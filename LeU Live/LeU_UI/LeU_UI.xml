<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE MudletPackage>
<MudletPackage version="1.001">
	<TriggerPackage>
		<TriggerGroup isActive="yes" isFolder="yes" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
			<name>Communications</name>
			<script></script>
			<triggerType>0</triggerType>
			<conditonLineDelta>99</conditonLineDelta>
			<mStayOpen>0</mStayOpen>
			<mCommand></mCommand>
			<packageName></packageName>
			<mFgColor>#ff0000</mFgColor>
			<mBgColor>#ffff00</mBgColor>
			<mSoundFile></mSoundFile>
			<colorTriggerFgColor>#000000</colorTriggerFgColor>
			<colorTriggerBgColor>#000000</colorTriggerBgColor>
			<regexCodeList />
			<regexCodePropertyList />
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>Personal communications</name>
				<script>ui.fDebug("[trig] Personal communications")
--
local from = copy2decho(matches[2])
local to = copy2decho(matches[3])
local message = copy2decho(matches[4])
local m
--
if (matches[2] == "["..ui.player.name.."]") then
  from = string.gsub(from, ui.player.name, "Tu")
  from = string.gsub(from, "]\&lt;r\&gt;", "]")
  from = from.." a "..matches[3].."\&lt;r\&gt;"
elseif (matches[2] == "Mandi") or (matches[2] == "Tu") then
  local color = string.gsub(from, matches[2].."\&lt;r\&gt;", "")
  from = color.."[\&lt;255,255,255:0,0,0\&gt;Tu"..color.."]".." a \&lt;255,255,255:0,0,0\&gt;"..matches[3].."\&lt;r\&gt;"
else
  --
  -- Save who Reply
  ui.reply = matches[2];
  ui.reply = string.gsub(ui.reply, "%[", "")
  ui.reply = string.gsub(ui.reply, "%]", "")
  ui.reply = string.gsub(ui.reply, ",", "")
  ui.reply = ui.fRemoveArticle(ui.reply)
  ui.reply = string.sub(ui.reply, 1, string.find(ui.reply, " "))
end
--
-- Private Chat
if (ui.previous.fromPrivate) and (ui.previous.fromPrivate == from) then
  m = "  "..message.."\n"
else
  m = "\n"..from.." &lt;128,128,128:"..ui.colors.wBackground.."&gt;"..os.date("%H:%M:%S").."\n  "..message.."\n"
  ui.previous.fromPrivate = from
end
--
m = string.gsub(m, ":0,0,0&gt;", ":"..ui.colors.wBackground.."&gt;")
m = string.gsub(m, "&lt;0,0,255:", "&lt;128,128,255:")
--
GUI.Chat.Main.Private:decho(m)
--
-- "All" Chat
if (ui.previous.fromAll) and (ui.previous.fromAll == from) then
  m = "  "..message.."\n"
else
  m = "\n"..from.." &lt;128,128,128:"..ui.colors.wBackground.."&gt;"..os.date("%H:%M:%S").."\n  "..message.."\n"
  ui.previous.fromAll = from
end
--
m = string.gsub(m, ":0,0,0&gt;", ":"..ui.colors.wBackground.."&gt;")
m = string.gsub(m, "&lt;0,0,255:", "&lt;128,128,255:")
--
GUI.Chat.Main.All:decho(m)
--
-- Sound
playSoundFile(ui.files.sounds.path..[[message.wav]], 10)</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>^(Mandi) a (.*) il (?:pensiero|messaggio) (\'.*\')$</string>
					<string>^(Tu) (?:chiedi|dici|sussurri) (?:a|ai|al|alla|alle|agli) (.*) (\'.*\')$</string>
					<string>^(\[.*\]) (ti) (?:manda il messaggio|manda il pensiero|chiede|dice|sussurra) (\'.*\')$</string>
					<string>^(\[.*\]) dice (?:a |ai |al |all'|alla |alle |agli )(.*) (\'.*\')$</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>1</integer>
					<integer>1</integer>
					<integer>1</integer>
					<integer>1</integer>
				</regexCodePropertyList>
			</Trigger>
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>Public  communication</name>
				<script>ui.fDebug("[trig] Public communication")
--
local str = copy2decho(matches[1])
local color = copy2decho(matches[2])
local from = copy2decho(matches[3])
local message = copy2decho(matches[4])
local m
-- Color
color = string.gsub(color, 'Tu&lt;r&gt;', '')
color = string.gsub(color, '%[&lt;r&gt;', '')
--
from = ui.fRemoveArticle(from)
--
-- Public Chat
if (ui.previous.fromPublic) and (ui.previous.fromPublic == from) then
  m = "  "..message.."\n"
  m = string.gsub(m, ":0,0,0&gt;",    ":"..ui.colors.wBackground.."&gt;")
else
  m = str
  m = string.gsub(m, "&gt;Tu",      "&gt;[Tu]")
  m = string.gsub(m, "] grida ",   "]")
  m = string.gsub(m, "] esclama ", "]")
  m = string.gsub(m, "] mormora ", "]")
  m = string.gsub(m, "] vi dice ", "]")
  m = string.gsub(m, "] dice ",    "]")
  m = string.gsub(m, "] dici ",    "]")
  m = string.gsub(m, "] risuona ", "]")
  --
  m = string.gsub(m, "]",          "] &lt;128,128,128:"..ui.colors.wBackground.."&gt;"..os.date("%H:%M:%S").."\n  "..color)
  m = string.gsub(m, ":0,0,0&gt;",    ":"..ui.colors.wBackground.."&gt;")
  m = "\n"..m.."\n"
  ui.previous.fromPublic = from
end
--
GUI.Chat.Main.Public:decho(m)
--
-- "All" Chat
if (ui.previous.fromAll) and (ui.previous.fromAll == from) then
  m = "  "..message.."\n"
  m = string.gsub(m, ":0,0,0&gt;",    ":"..ui.colors.wBackground.."&gt;")
else
  m = str
  m = string.gsub(m, "&gt;Tu",      "&gt;[Tu]")
  m = string.gsub(m, "] grida ",   "]")
  m = string.gsub(m, "] esclama ", "]")
  m = string.gsub(m, "] mormora ", "]")
  m = string.gsub(m, "] vi dice ", "]")
  m = string.gsub(m, "] dice ",    "]")
  m = string.gsub(m, "] dici ",    "]")
  m = string.gsub(m, "] risuona ", "]")
  --
  m = string.gsub(m, "]",          "] &lt;128,128,128:"..ui.colors.wBackground.."&gt;"..os.date("%H:%M:%S").."\n  "..color)
  m = string.gsub(m, ":0,0,0&gt;",    ":"..ui.colors.wBackground.."&gt;")
  m = "\n"..m.."\n"
  ui.previous.fromAll = from
end
--
GUI.Chat.Main.All:decho(m)</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>(^\[)(.*)\] (?:grida|esclama|mormora|vi dice|dice|risuona) (\'.*\')$</string>
					<string>(^(Tu)) (?:gridi|dici) (\'.*\')$</string>
					<string>(^\[)(.*)\] (\'.*\')$</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>1</integer>
					<integer>1</integer>
					<integer>1</integer>
				</regexCodePropertyList>
			</Trigger>
		</TriggerGroup>
		<TriggerGroup isActive="yes" isFolder="yes" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
			<name>Exits</name>
			<script></script>
			<triggerType>0</triggerType>
			<conditonLineDelta>0</conditonLineDelta>
			<mStayOpen>0</mStayOpen>
			<mCommand></mCommand>
			<packageName></packageName>
			<mFgColor>#ff0000</mFgColor>
			<mBgColor>#ffff00</mBgColor>
			<mSoundFile></mSoundFile>
			<colorTriggerFgColor>#000000</colorTriggerFgColor>
			<colorTriggerBgColor>#000000</colorTriggerBgColor>
			<regexCodeList />
			<regexCodePropertyList />
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>Exits</name>
				<script>ui.fDebug("[trig] Exits")
ui.room = ui.room or {}
ui.room.exitCaptured = matches[2]
ui.fUpdateRoom()</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>^Uscite: (.*)</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>1</integer>
				</regexCodePropertyList>
			</Trigger>
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>Room name</name>
				<script>ui.fDebug("[trig] Room name")
ui.room = ui.room or {}
ui.room.name = matches[2]
ui.room.type = matches[3]</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>^(.*) - (Foresta|Al chiuso|Citta'|Deserto|Pianura|Strada|Collina|Montagna|Acque Basse|Acque Profonde|Sott'acqua|A mezz'aria|Tra gli Alberi|Citta' oscura|Sottosuolo|Dungeon|Caverna|Cripta|Castello|Maniero|Tempio|Prigione|Negozio|Giungla|Costa|Spiaggia|Palude|Tundra|Taiga|Ghiacci|Steppa|Savana|Piano Astrale|Piano Esterno|Sigil|Vuoto cosmico|Sconosciuto|Teletrasporto|Prato)</string>
					<string>^(.*) (\[Zona di Guerra\])</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>1</integer>
					<integer>1</integer>
				</regexCodePropertyList>
			</Trigger>
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>Specchi di Astral</name>
				<script>ui.fDebug("[trig] Specchi di Astral")
ui.room = ui.room or {}
ui.room.exitCaptured = ui.room.exitCaptured or ""
ui.room.exitCaptured = ui.room.exitCaptured.." "..string.gsub(matches[2], " ", "-")
ui.fUpdateRoom()</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>^Nell'avvicinarti vedi uno specchio d'acqua color (.*).</string>
					<string>^Nell'avvicinarti vedi uno specchio d'acqua di colore (.*).</string>
					<string>^Nell'avvicinarti vedi uno specchio d'acqua appiccicosa color (.*).</string>
					<string>^Nell'avvicinarti vedi uno specchio d'acqua (.*).</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>1</integer>
					<integer>1</integer>
					<integer>1</integer>
					<integer>1</integer>
				</regexCodePropertyList>
			</Trigger>
		</TriggerGroup>
		<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
			<name>Affects</name>
			<script>ui.fDebug("[trig] Affect start")
ui.affects = {}
enableTrigger("affects_invalid")
enableTrigger("affects_valid")
enableTrigger("affects_end")</script>
			<triggerType>0</triggerType>
			<conditonLineDelta>0</conditonLineDelta>
			<mStayOpen>1</mStayOpen>
			<mCommand></mCommand>
			<packageName></packageName>
			<mFgColor>#ff0000</mFgColor>
			<mBgColor>#ffff00</mBgColor>
			<mSoundFile></mSoundFile>
			<colorTriggerFgColor>#000000</colorTriggerFgColor>
			<colorTriggerBgColor>#000000</colorTriggerBgColor>
			<regexCodeList>
				<string>+- Effetti Attivi -------------------------------------------------------------+</string>
			</regexCodeList>
			<regexCodePropertyList>
				<integer>3</integer>
			</regexCodePropertyList>
			<Trigger isActive="no" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>affects_invalid</name>
				<script>ui.fDebug("[trig] Affect_invalid")
setTriggerStayOpen("Affects", 1)</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>1</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>| Non hai effetti attivi al momento...                                         |</string>
					<string>+- Effetti Permanenti ---------------------------------------------------------+</string>
					<string>| Non hai effetti permanenti attivi...                                         |</string>
					<string>+- Altri Effetti --------------------------------------------------------------+</string>
					<string>| Non hai altri effetti attivi...                                              |</string>
					<string>+- Cooldown -------------------------------------------------------------------+</string>
					<string>| Non hai cooldown attivi al momento...                                        |</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>3</integer>
					<integer>3</integer>
					<integer>3</integer>
					<integer>3</integer>
					<integer>3</integer>
					<integer>3</integer>
					<integer>3</integer>
				</regexCodePropertyList>
			</Trigger>
			<Trigger isActive="no" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>affects_valid</name>
				<script>ui.fDebug("[trig] Affect_valid")
local name = string.trim(matches[2])
local duration = tonumber(string.trim(matches[3]))

ui.affects[name] = {}
ui.affects[name].duration = duration
ui.affects[name].isRound = (matches[4] == "round") 
--
-- not yet used
ui.affects[name].category         = ""
ui.affects[name].isNegative       = ""
ui.affects[name].type             = 0

setTriggerStayOpen("Affects", 1)
</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>1</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>^\|(.*)\| (.*) (ore|round)\s+\|</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>1</integer>
				</regexCodePropertyList>
			</Trigger>
			<Trigger isActive="no" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>affects_end</name>
				<script>ui.fDebug("[trig] Affect_end")
disableTrigger("affects_invalid")
disableTrigger("affects_valid")
disableTrigger("affects_end")
ui.fUpdateAffects()</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>+------------------------------------------------------------------------------+</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>3</integer>
				</regexCodePropertyList>
			</Trigger>
		</Trigger>
		<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
			<name>Equipment</name>
			<script>ui.fDebug("[trig] Equipment start")
--
local preDefinitedEquipment = {
  ["come luce"]         = { slot = "Luce",      short = "LUC", used = false },
  ["dito 1"]            = { slot = "Dito",      short = "DIT", used = false },
  ["dito 2"]            = { slot = "Dito",      short = "DIT", used = false },
  ["al collo 1"]        = { slot = "Collo",     short = "COL", used = false },
  ["al collo 2"]        = { slot = "Collo",     short = "COL", used = false },
  ["sul corpo"]         = { slot = "Corpo",     short = "COR", used = false },
  ["in testa"]          = { slot = "Testa",     short = "TES", used = false },
  ["sulle gambe"]       = { slot = "Gambe",     short = "GAM", used = false },
  ["ai piedi"]          = { slot = "Piedi",     short = "PIE", used = false },
  ["sulle mani"]        = { slot = "Mani",      short = "MAN", used = false },
  ["sulle braccia"]     = { slot = "Braccia",   short = "BRA", used = false },
  ["come scudo"]        = { slot = "Scudo",     short = "SCU", used = false },
  ["intorno al corpo"]  = { slot = "Intorno al corpo",   short = "INT", used = false },
  ["intorno alla vita"] = { slot = "Vita",      short = "VIT", used = false },
  ["polso 1"]           = { slot = "Polso",     short = "POL", used = false },
  ["polso 2"]           = { slot = "Polso",     short = "POL", used = false },
  ["impugnato"]         = { slot = "Arma",      short = "IMP", used = false },
  ["tenuto"]            = { slot = "Tenuto", short = "TEN", used = false },
  ["sulla schiena"]     = { slot = "Schiena",   short = "SCH", used = false },
  ["all'orecchio destro"]   = { slot = "Orecchio",  short = "ORE", used = false },
  ["all'orecchio sinistro"] = { slot = "Orecchio",  short = "ORE", used = false },
  ["davanti agli occhi"]    = { slot = "Occhi",      short = "OCC", used = false },
  ["incoccato"]         = { slot = "Incoccato", short = "INC", used = false },
  ["come aura"]         = { slot = "Aura",      short = "AUR", used = false },}
--
ui.equipment = ui.equipment or {}
ui.equipment = table.update(ui.equipment, preDefinitedEquipment)
--
enableTrigger("equipment_valid")
enableTrigger("equipment_end")
</script>
			<triggerType>0</triggerType>
			<conditonLineDelta>0</conditonLineDelta>
			<mStayOpen>1</mStayOpen>
			<mCommand></mCommand>
			<packageName></packageName>
			<mFgColor>#ff0000</mFgColor>
			<mBgColor>#ffff00</mBgColor>
			<mSoundFile></mSoundFile>
			<colorTriggerFgColor>#000000</colorTriggerFgColor>
			<colorTriggerBgColor>#000000</colorTriggerBgColor>
			<regexCodeList>
				<string>^Stai usando:$</string>
			</regexCodeList>
			<regexCodePropertyList>
				<integer>1</integer>
			</regexCodePropertyList>
			<Trigger isActive="no" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>equipment_valid</name>
				<script>-- (?:\[(.*)\] )?\&lt;(.*)\&gt;.*\[(.*)\] (?:\|(.*)\| )?(.*)
-- match[1] = [2:numero] &lt;3:locazione&gt; [4:livello] |5:tipo| 6:descrizione
ui.fDebug("[trig] Equipment_valid")
--
local location  = string.trim(matches[3])
--
if (location == "su di un dito") then
  if (not ui.equipment["dito 1"].used) then
    location = "dito 1"
  else
    location = "dito 2"
  end
elseif (location == "intorno al collo") then
  if (not ui.equipment["al collo 1"].used) then
    location = "al collo 1"
  else
    location = "al collo 2"
  end
elseif (location == "al polso") then
  if (not ui.equipment["polso 1"].used) then
    location = "polso 1"
  else
    location = "polso 2"
  end
end
--
if (ui.equipment[location]) then
  --
  local number   = tonumber(string.trim(matches[2]))
  --
  -- Con il comando "eq manc" il numero e "X"
  if (number) then
    ui.equipment[location].number = number  
    ui.equipment[location].level    = tonumber(string.trim(matches[4]))
    ui.equipment[location].type     = string.gsub(copy2decho(matches[5]), ":0,0,0&gt;", ":"..ui.colors.wBackground.."&gt;")
    ui.equipment[location].name,
    ui.equipment[location].status,
    ui.equipment[location].good,
    ui.equipment[location].evil,
    ui.equipment[location].bright,
    ui.equipment[location].noisy,
    ui.equipment[location].brittle  = ui.fParsingItem(copy2decho(matches[6]))
    ui.equipment[location].name = string.gsub(ui.equipment[location].name, ":0,0,0&gt;", ":"..ui.colors.wBackground.."&gt;");
    ui.equipment[location].used = true;
  end
end
--
setTriggerStayOpen("Equipment", 1)
</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>(?:\[(.*)\] )?\&lt;(.*)\&gt;.*\[(.*)\] (?:\|(.*)\| )?(.*)</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>1</integer>
				</regexCodePropertyList>
			</Trigger>
			<Trigger isActive="no" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>equipment_end</name>
				<script>ui.fDebug("[trig] Equipment_end")
disableTrigger("equipment_valid")
disableTrigger("equipment_end")
ui.parameters.widgets.endowment.type = "equip"
ui.fUpdateEndowment()
</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>^Il livello di potenza medio del tuo equipaggiamento e' .*$</string>
					<string>^    Nulla.$</string>
					<string>^$</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>1</integer>
					<integer>1</integer>
					<integer>1</integer>
				</regexCodePropertyList>
			</Trigger>
		</Trigger>
		<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
			<name>Group</name>
			<script>ui.fDebug("[trig] Group start")
ui.group = {}
enableTrigger("group_valid")
enableTrigger("group_end")</script>
			<triggerType>0</triggerType>
			<conditonLineDelta>0</conditonLineDelta>
			<mStayOpen>1</mStayOpen>
			<mCommand></mCommand>
			<packageName></packageName>
			<mFgColor>#ff0000</mFgColor>
			<mBgColor>#ffff00</mBgColor>
			<mSoundFile></mSoundFile>
			<colorTriggerFgColor>#000000</colorTriggerFgColor>
			<colorTriggerBgColor>#000000</colorTriggerBgColor>
			<regexCodeList>
				<string>^Ma non sei il membro di un gruppo!$</string>
				<string>^I membri del tuo gruppo(.*)sono\:(.*)$</string>
			</regexCodeList>
			<regexCodePropertyList>
				<integer>1</integer>
				<integer>1</integer>
			</regexCodePropertyList>
			<Trigger isActive="no" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>group_valid</name>
				<script>ui.fDebug("[trig] group_valid")
--
local member = {}
member.name     = matches[2];
member.isLeader = (matches[3] == "(Capo)");
member.hp       = tonumber(matches[4]);
member.maxhp    = 100;
member.mana     = tonumber(matches[5]);
member.maxmana  = 100;
member.mov      = tonumber(matches[6]);
--
ui.group[#ui.group+1] = member
--
setTriggerStayOpen("Group", 1)</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#00ff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>^\s+(\S+)\s+(.*) HP:\s+(\d+)\% MANA:\s+(\d+)\% MV:\s+(\d+)\%$</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>1</integer>
				</regexCodePropertyList>
			</Trigger>
			<Trigger isActive="no" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>group_end</name>
				<script>ui.fDebug("[trig] group_end")
disableTrigger("group_valid")
disableTrigger("group_end")
--
ui.fUpdateGroup()</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>1</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#00ffff</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>^$</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>1</integer>
				</regexCodePropertyList>
			</Trigger>
		</Trigger>
		<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
			<name>Tick</name>
			<script>ui.fIncrementTickTimer(10)</script>
			<triggerType>0</triggerType>
			<conditonLineDelta>0</conditonLineDelta>
			<mStayOpen>0</mStayOpen>
			<mCommand></mCommand>
			<packageName></packageName>
			<mFgColor>#ff0000</mFgColor>
			<mBgColor>#ffff00</mBgColor>
			<mSoundFile></mSoundFile>
			<colorTriggerFgColor>#000000</colorTriggerFgColor>
			<colorTriggerBgColor>#000000</colorTriggerBgColor>
			<regexCodeList>
				<string>^Un[']altra ora della giornata si accinge a trascorrere[.]</string>
			</regexCodeList>
			<regexCodePropertyList>
				<integer>1</integer>
			</regexCodePropertyList>
		</Trigger>
		<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
			<name>Track</name>
			<script>ui.fDebug("[trig] Track")
--
if (matches[2]) and (ui.validExit[string.lower(matches[2])])then
  ui.track = ui.validExit[string.lower(matches[2])].short
else
  ui.track = ""
end
--
ui.fUpdateRoom()</script>
			<triggerType>0</triggerType>
			<conditonLineDelta>0</conditonLineDelta>
			<mStayOpen>0</mStayOpen>
			<mCommand></mCommand>
			<packageName></packageName>
			<mFgColor>#ff0000</mFgColor>
			<mBgColor>#ffff00</mBgColor>
			<mSoundFile></mSoundFile>
			<colorTriggerFgColor>#000000</colorTriggerFgColor>
			<colorTriggerBgColor>#000000</colorTriggerBgColor>
			<regexCodeList>
				<string>^Vedi una traccia della tua preda che va verso (?:l'|il )?(.*).$</string>
				<string>^Vedi una debole traccia verso (?:l'|il )?(.*)$</string>
				<string>^Cio' che cerchi e' gia' qui!$</string>
				<string>^Non riesci a trovare tracce.$</string>
				<string>^Hai trovato la tua preda!$</string>
				<string>^Hai perso la traccia.$</string>
			</regexCodeList>
			<regexCodePropertyList>
				<integer>1</integer>
				<integer>1</integer>
				<integer>1</integer>
				<integer>1</integer>
				<integer>1</integer>
				<integer>1</integer>
			</regexCodePropertyList>
		</Trigger>
		<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
			<name>Position</name>
			<script>local pos2number = {
["sud-ovest"] = 1,
["sud"] = 2,
["sud-est"] = 3,
["ovest"] = 4,
["centro"] = 5,
["est"] = 6,
["nord-ovest"] = 7,
["nord"] = 8,
["nord-est"] = 9,
}
ui.room = ui.room or {}
ui.room.position = pos2number[matches[2]] or matches[2] or ""
ui.fUpdateRoom()</script>
			<triggerType>0</triggerType>
			<conditonLineDelta>0</conditonLineDelta>
			<mStayOpen>0</mStayOpen>
			<mCommand></mCommand>
			<packageName></packageName>
			<mFgColor>#ff0000</mFgColor>
			<mBgColor>#ffff00</mBgColor>
			<mSoundFile></mSoundFile>
			<colorTriggerFgColor>#000000</colorTriggerFgColor>
			<colorTriggerBgColor>#000000</colorTriggerBgColor>
			<regexCodeList>
				<string>^Ti muovi rapidamente verso (?:il lato|l'angolo|il) (.*) della stanza.</string>
			</regexCodeList>
			<regexCodePropertyList>
				<integer>1</integer>
			</regexCodePropertyList>
		</Trigger>
	</TriggerPackage>
	<TimerPackage />
	<AliasPackage>
		<Alias isActive="yes" isFolder="no">
			<name>UI Aliases</name>
			<script>local alias = matches[2] or ""
local value = matches[3] or ""
--
-- Mostra tutti gli aliases
if (alias == "") then
  ui.fShowAllAliases()
--
-- Rimuove tutti gli aliases
elseif (alias == "remove_all") then
  ui.fRemoveAllAliases()
  ui.fEcho2n("Tutti gli alias sono stati rimossi.")
--
-- Mostra il singolo alias
elseif (value == "") then
  if (ui.aliases[alias]) then
    ui.fEcho2n(ui.fGetAliasFormattedText(alias))
  else
    ui.fError("L'alias "..ui.fGetAliasNameFormattedText(alias).." non esiste.")
  end
--
-- Rimuove il singolo alias
elseif value == "remove" then
  if (ui.fRemoveAlias(alias)) then
    ui.fEcho2n("L'alias "..ui.fGetAliasNameFormattedText(alias).." e' stato rimosso.")
  else
    ui.fError("L'alias "..ui.fGetAliasNameFormattedText(alias).." non esiste.")
  end
--
-- Crea o modifica l'alias
else
  local alreadyExist = ui.aliases[alias];
  local result, output = ui.fAddAlias(alias, value)
  if (result == -1) then
    ui.fError("L'alias "..ui.fGetAliasNameFormattedText(alias).." non è stato creato/modificato. La variabile "..ui.fGetVarNameFormattedText(output).." non esiste.")
  elseif (result == 1) then
    if (alreadyExist) then
      ui.fEcho2n("L'alias "..ui.fGetAliasNameFormattedText(alias).." è stato modificato: "..output..".")
    else
      ui.fEcho2n("L'alias "..ui.fGetAliasNameFormattedText(alias).." è stato creato: "..output..".")
    end
  else
    ui.fError("Errore non previsto.")
  end
end
--
ui.fSaveFileAliases()
ui.fUpdateAliasButton()
</script>
			<command></command>
			<packageName></packageName>
			<regex>^(?i)(?:uia(?:l(?:i(?:a(?:s(?:e(?:s)?)?)?)?)?)?)(?:\s+(\w*)\s*(.*))?$</regex>
		</Alias>
		<Alias isActive="yes" isFolder="no">
			<name>UI Buttons (configurazione)</name>
			<script>local button = matches[2] or ""
local alias = matches[3] or ""
--
-- Mostra tutti gli alias button
if (button == "") then
  ui.fShowAllAliasButtons()
--
-- Rimuove tutti gli alias buttons
elseif (button == "remove_all") then
  ui.fRemoveAllAliasButtons()
  ui.fEcho2n("Tutti i pulsanti alias sono stati rimossi.")
--
-- Mostra il singolo alias button
elseif (alias == "") then
  local type, number = ui.fExpandButton(button)
  if (type == "a") or (type == "b") or (type == "c") then
    button = type..number
    local alias = ui.fSearchAliasButton(button)
    if (alias) then
      ui.fEcho("")
      ui.fLinkAliasButton(button)
      echo("\n\n")
    else
      ui.fEcho2n("Nessun alias associato al pulsante "..ui.fGetAliasButtonFormattedText(button)..".")
    end
  else
    ui.fError(ui.fGetAliasButtonFormattedText(button).." non è un pulsante valido.")
  end
--
-- Rimuove il singolo alias button
elseif (alias == "remove") then
  local result = ui.fRemoveAliasButton(button)
  if (result == -2) then
    ui.fEcho2n("Nessun alias da rimuovere per il pulsante "..ui.fGetAliasButtonFormattedText(button)..".")
  elseif (result == -1) then
    ui.fError(ui.fGetAliasButtonFormattedText(button).." non è un pulsante valido.")
  elseif (result == 1) then
    ui.fEcho2n("L'alias associato al pulsante "..ui.fGetAliasButtonFormattedText(button).." è stato rimosso.")
  else
    ui.fError("Errore non previsto.")
  end
--
-- Crea o modifica l'alias button
else
  local result = ui.fAssignAliasButton(button, alias)
  if (result == -2) then
    ui.fError("L'alias "..ui.fGetAliasNameFormattedText(alias).." non esiste.")
  elseif (result == -1) then
    ui.fError(ui.fGetAliasButtonFormattedText(button).." non è un pulsante valido.")
  elseif (result == 1) then
    ui.fEcho2n("Il pulsante "..ui.fGetAliasButtonFormattedText(button).." è stato associato all'alias "..ui.fGetAliasNameFormattedText(alias)..".")
  else
    ui.fError("Errore non previsto.")
  end
end
--
ui.fSaveFileAliases()
ui.fUpdateAliasButton()</script>
			<command></command>
			<packageName></packageName>
			<regex>^(?i)(?:uib(?:u(?:t(?:t(?:o(?:n(?:s)?)?)?)?)?)?)(?:\s+(\w*)\s*(.*))?$</regex>
		</Alias>
		<Alias isActive="yes" isFolder="no">
			<name>UI Buttons (esecuzione)</name>
			<script>ui.fExecuteAliasButton(matches[2])</script>
			<command></command>
			<packageName></packageName>
			<regex>^(?i)([abc]\d)$</regex>
		</Alias>
		<Alias isActive="yes" isFolder="no">
			<name>UI Colors</name>
			<script>cecho(ui.fTitle("Colori disponibili:"))
ui.fDisplayColors({justText = false, removeDupes = true})</script>
			<command></command>
			<packageName></packageName>
			<regex>^(?i)(?:uic(?:o(?:l(?:o(?:r(?:s)?)?)?)?)?)$</regex>
		</Alias>
		<Alias isActive="yes" isFolder="no">
			<name>UI Font size</name>
			<script>local windows = string.lower(matches[2] or "")
local fontsize = tonumber(matches[3] or -1)
--
if (matches[3]) then
  if (fontsize &gt;= 1) and (fontsize &lt;= 30) then
    if (windows == "all") then
      -- Chat
      GUI.Chat.Main.All:setFontSize(fontsize)
      GUI.Chat.Main.Public:setFontSize(fontsize)
      GUI.Chat.Main.Private:setFontSize(fontsize)
      ui.parameters.widgets.chat.fontSize = fontsize
      -- Help
      GUI.Help.Main.Console:setFontSize(fontsize)
      ui.parameters.widgets.help.fontSize = fontsize
      -- Room
      GUI.Room.Main.Console:setFontSize(fontsize)
      ui.parameters.widgets.room.fontSize = fontsize
      --
    elseif (windows == "chat") then
      GUI.Chat.Main.All:setFontSize(fontsize)
      GUI.Chat.Main.Public:setFontSize(fontsize)
      GUI.Chat.Main.Private:setFontSize(fontsize)
      ui.parameters.widgets.chat.fontSize = fontsize
    elseif (windows == "help") then
      GUI.Help.Main.Console:setFontSize(fontsize)
      ui.parameters.widgets.help.fontSize = fontsize
    elseif (windows == "room") then
      GUI.Room.Main.Console:setFontSize(fontsize)
      ui.parameters.widgets.room.fontSize = fontsize
    else
      ui.fError("Nome widget errato: Usare "..ui.fGetCommandFormattedText("All")..", "
                                            ..ui.fGetCommandFormattedText("Chat")..", "
                                            ..ui.fGetCommandFormattedText("Help")..", "
                                            ..ui.fGetCommandFormattedText("Room")..".")
      fontsize = 0
    end
    --
    if (fontsize &gt; 0) then
      if (windows == "all") then
        ui.fEcho2n("La dimensione del font di tutti i widget e' stata impostata a "..ui.fGetCommandFormattedText(fontsize)..".")
      else
        ui.fEcho2n("La dimensione del font del widget "..ui.fGetCommandFormattedText(windows).." e' stata impostata a "..ui.fGetCommandFormattedText(fontsize)..".")
      end 
      ui.fSaveFileParameters()
    end
  else
    ui.fError("La dimensione del font e' errata: Usare un valore compreso tra "..ui.fGetCommandFormattedText("1").." e "..ui.fGetCommandFormattedText("30")..".")
  end
else
  cecho(ui.fTitle("Dimensioni font"))
  cecho(ui.fGetNumberFormattedText(1)..ui.fGetCommandFormattedText(" Chat")..ui.fGetOperatorFormattedText(" = ")..ui.fGetVarValueFormattedText(ui.parameters.widgets.chat.fontSize).."\n");
  cecho(ui.fGetNumberFormattedText(2)..ui.fGetCommandFormattedText(" Help")..ui.fGetOperatorFormattedText(" = ")..ui.fGetVarValueFormattedText(ui.parameters.widgets.help.fontSize).."\n");
  cecho(ui.fGetNumberFormattedText(3)..ui.fGetCommandFormattedText(" Room")..ui.fGetOperatorFormattedText(" = ")..ui.fGetVarValueFormattedText(ui.parameters.widgets.room.fontSize).."\n\n");
  ui.fEcho2n("Usare "..ui.fGetCommandFormattedText("uisetf[ontsize] &lt;nome_finestra&gt; ")..ui.fGetVarValueFormattedText("&lt;dimensione_font&gt;"))
end</script>
			<command></command>
			<packageName></packageName>
			<regex>^(?i)(?:uif(?:o(?:n(?:t(?:s(?:i(?:z(?:e)?)?)?)?)?)?)?)(?:\s*(\w+)?|$)(?:\s*(\w+)?|$)</regex>
		</Alias>
		<Alias isActive="yes" isFolder="no">
			<name>UI Help</name>
			<script>local helpselect = string.lower(matches[2] or "")
--
if (helpselect == "") then
  ui.fHelp()
elseif (rex.match(helpselect, [[(?i)(?:^(?:ui)?a(?:l(?:i(?:a(?:s(?:e(?:s)?)?)?)?)?)?)$]])) then
  ui.fHelp("alias")
elseif (rex.match(helpselect, [[(?i)(?:^(?:ui)?b(?:u(?:t(?:t(?:o(?:n(?:s)?)?)?)?)?)?)$]])) then
  ui.fHelp("button")
elseif (rex.match(helpselect, [[(?i)(?:^(?:ui)?c(?:o(?:l(?:o(?:r(?:s?)?)?)?)?)?)$]])) then
  ui.fHelp("color")
elseif (rex.match(helpselect, [[(?i)(?:^(?:ui)?f(?:o(?:n(?:t(?:s(?:i(?:z(?:e)?)?)?)?)?)?)?)$]])) then
  ui.fHelp("fontsize")
elseif (rex.match(helpselect, [[(?i)(?:^(?:ui)?hi(?:g(?:h(?:l(?:i(?:g(?:h(?:t(?:s)?)?)?)?)?)?)?)?)$]])) then
  ui.fHelp("highlight")
elseif (rex.match(helpselect, [[(?i)(?:^(?:ui)?k(?:e(?:y(?:b(?:i(?:n(?:d)?)?)?)?)?)?)$]])) then
  ui.fHelp("keybind")
elseif (rex.match(helpselect, [[(?i)(?:^(?:ui)?t(?:a(?:r(?:g(?:e(?:t(?:s)?)?)?)?)?)?)$]])) then
  ui.fHelp("target")
elseif (rex.match(helpselect, [[(?i)(?:^(?:ui)?s(?:e(?:t(?:t(?:i(?:n(?:g)?)?)?)?)?)?)$]])) then
  ui.fHelp("setting")
elseif (rex.match(helpselect, [[(?i)(?:^(?:ui)?v(?:a(?:r(?:i(?:a(?:b(?:l(?:e)?)?)?)?)?)?)?|]]..ui.varID..[[)$]])) then
  ui.fHelp("variable")
elseif (rex.match(helpselect, [[^\.(?:\.)?$]])) then
  ui.fHelp("walk")
elseif (rex.match(helpselect, [[(?i)(?:(?:ui)?w(?:i(?:d(?:g(?:e(?:t?)?)?)?)?)?)$]])) then
  ui.fHelp("widget")
else
  ui.fHelp(helpselect)
end</script>
			<command></command>
			<packageName></packageName>
			<regex>^(?i)(?:uih(?:e(?:l(?:p)?)?)?)(?:\s+(.*))?$</regex>
		</Alias>
		<Alias isActive="yes" isFolder="no">
			<name>UI Reply</name>
			<script>if (ui.reply) then
  local msg = matches[2] or ""
  expandAlias("telep "..ui.reply.." "..msg)
end</script>
			<command></command>
			<packageName></packageName>
			<regex>^(?i)(?:uir(?:e(?:p(?:l(?:y)?)?)?)?)(?:\s+(.*))?$</regex>
		</Alias>
		<Alias isActive="yes" isFolder="no">
			<name>UI Highlights</name>
			<script>--
local text = string.trim(matches[2] or "")
local color = string.trim(matches[3] or "")
--
if (color ~= "") and (color ~= "remove") then
  if (text == "") and (color == "remove_all") then
    text = "remove_all"
    color = ""
  elseif (text == "") and (color ~= "") then
    text = color
    color = ""
  elseif (text ~= "") and (not ui.fColorCheck(color)) then
    text = text.." "..color
    color = ""
  end
end
-- Mostra tutti gli highlights
if (text == "") and (color == "") then
  ui.fShowAllHighlights()
-- Rimuove tutti gli highlights
elseif (text == "remove_all") then
  ui.fRemoveAllHighlights()
  ui.fEcho2n("Tutti gli highlight sono stati eliminati.")
-- Rimuove il singolo highlight
elseif (color == "remove") then
  if (ui.fRemoveHighlight(text)) then
    ui.fEcho2n("L'highlight e' stato rimosso.")
  else
    ui.fError("L'highlight '"..text.."' non esiste.")
  end
-- Mostra il singolo highlight
elseif (color == "") then
  if (ui.highlights[text]) then
    ui.fEcho2n(ui.fGetHighlightFormattedText(text))
  else
    ui.fError("L'highlight '"..text.."' non esiste.")
  end
-- Crea o modifica l'Highlight
else
  local alreadyExist = ui.highlights[text];
  local result = ui.fAddHighlight(text, color)
  if (result == -2) then
    ui.fError("L'highlight '"..text.."' non è stato creato/modificato. Il colore '"..color.."' non è valido. Usare il comando "..ui.fGetCommandFormattedText("uicolor").." per l'elenco dei colori disponibili.")
  elseif (result == -1) then
    ui.fError("L'highlight '"..text.."' non è stato creato/modificato. Specificare un testo valido.")
  elseif (result == 1) then
    if (alreadyExist) then
      ui.fEcho2n("L'highlight &lt;"..color.."&gt;"..text.."&lt;r&gt; è stato modificato.")
    else
      ui.fEcho2n("L'highlight &lt;"..color.."&gt;"..text.."&lt;r&gt; è stato creato.")
    end
  else
    ui.fError("Errore non previsto.")
  end
end
--
ui.fSaveFileHighlights()</script>
			<command></command>
			<packageName></packageName>
			<regex>^(?i)(?:uihi(?:g(?:h(?:l(?:i(?:g(?:h(?:t(?:s)?)?)?)?)?)?)?)?)(?:\s?(.*)\s?( \w+))?$</regex>
		</Alias>
		<Alias isActive="yes" isFolder="no">
			<name>UI Keybind</name>
			<script>local element = matches[2] or ""
local key1 = matches[3] or ""
local key2 = matches[4] or ""
local key3 = matches[5] or ""
local isValid, mod1, mod2, key, keybind = ui.fGetKeyb(key1, key2, key3)
-- Mostra tutti i keybind associati a targetselement e aliases
if (element == "") then
  ui.fShowAllKeyb()
-- Rimuove tutti i keybind associati a argets e aliases
elseif (element == "remove_all") then
  ui.fRemoveAllKeyb()
  ui.fEcho2n("Tutti i tasti rapidi sono stati rimossi.")
-- Mostra il singolo keybind
elseif (key1 == "") then
  -- Target
  if (ui.targets[element]) then
    if (ui.targets[element].keybId) then
      ui.fEcho2n(ui.fGetTargetFormattedText(element))
    else
      ui.fEcho2n("Nessun tasto rapido è assegnato al target "..ui.fGetTargetFormattedText(element)..".")
    end
  -- Alias
  elseif (ui.aliases[element]) then
    if (ui.aliases[element].keybId) then
      ui.fEcho2n(ui.fGetAliasFormattedText(element))
    else
      ui.fEcho2n("Nessun tasto rapido è assegnato all'alias "..ui.fGetAliasNameFormattedText(element)..".")
    end
  else
    ui.fError("L'alias "..ui.fGetAliasNameFormattedText(element).." non esiste.")
  end
-- Rimuove il singolo keybind
elseif key1 == "remove" then
  local result
  -- Target
  if (ui.targets[element]) then
    keybind = ui.targets[element].keybind
    result = ui.fRemoveKeyb(ui.targets[element])
    if (result == -2) then
      ui.fError("Il target non esiste.")
    elseif (result == -1) then
      ui.fEcho2n("Nessun tasto rapido assegnato al target "..ui.fGetTargetFormattedText(element).." da rimuovere.")
    elseif (result == 1) then
      ui.fEcho2n("Il tasto rapido "..ui.fGetKeybFormattedText(keybind)..", associato al target "..ui.fGetTargetFormattedText(element)..", e' stato rimosso.")
    else
      ui.fError("Errore non previsto.")
    end
  -- Alias
  elseif (ui.aliases[element]) then
    keybind = ui.aliases[element].keybind
    result = ui.fRemoveKeyb(ui.aliases[element])
    if (result == -2) then
      ui.fError("L'alias non esiste.")
    elseif (result == -1) then
      ui.fEcho2n("Nessun tasto rapido assegnato all'alias "..ui.fGetAliasNameFormattedText(element).." da rimuovere.")
    elseif (result == 1) then
      ui.fEcho2n("Il tasto rapido "..ui.fGetKeybFormattedText(keybind)..", associato all'alias "..ui.fGetAliasNameFormattedText(element)..", e' stato rimosso.")
    else
      ui.fError("Errore non previsto.")
    end
  else
    ui.fError("L'alias "..ui.fGetAliasNameFormattedText(element).." non esiste o non è associato a nessun tasto rapido.")
  end
-- Crea o modifica il keybind
else
  local result, keybind, isTarget
  if (ui.targets[element]) then
    isTarget = true
    result, keybind = ui.fSetKeyb(ui.targets, element, [[ui.fExecuteTargetButton("]]..element..[[")]], key1, key2, key3)
  else
    isTarget = false
    result, keybind = ui.fSetKeyb(ui.aliases, element, ui.aliases[element].code, key1, key2, key3)
  end
  --
  if (result == -4) then
    ui.fError("Il tasto rapido non è stato assegnato. La combinazione di tasti "..ui.fGetKeybFormattedText(keybind).." è già utilizzata in un alias.")
  elseif (result == -3) then
    ui.fError("Il tasto rapido non è stato assegnato. La combinazione di tasti "..ui.fGetKeybFormattedText(keybind).." è già utilizzata in un target.")
  elseif (result == -2) then
    ui.fError("Il tasto rapido non è stato assegnato. La combinazione di tasti "..ui.fGetKeybFormattedText(keybind).." non è valida.")
  elseif (result == -1) then
    ui.fError("Il tasto rapido non è stato assegnato. L'alias "..ui.fGetAliasNameFormattedText(element).." non esiste.")
  elseif (result == 1) and (isTarget) then
    ui.fEcho2n("Il tasto rapido è stato assegnato al target "..ui.fGetTargetFormattedText(element)..".")
  elseif (result == 1) and (not isTarget) then
    ui.fEcho2n("Il tasto rapido è stato assegnato all'alias "..ui.fGetAliasNameFormattedText(element)..".")
  elseif (result == 2) and (isTarget) then
    ui.fEcho2n("Il tasto rapido associato al target "..ui.fGetTargetFormattedText(element).." è stato rimosso.")
  elseif (result == 2) and (not isTarget) then
    ui.fEcho2n("Il tasto rapido associato all'alias "..ui.fGetAliasNameFormattedText(element).." è stato rimosso.")
  end
end
--
ui.fSaveFileAliases()
ui.fUpdateAliasButton()
--
ui.fUpdateAllTargetButtons()</script>
			<command></command>
			<packageName></packageName>
			<regex>^(?i)(?:uik(?:e(?:y(?:b(?:i(?:n(?:d)?)?)?)?)?)?)(?:\s*(\w+)?|$)(?:\s*(\w+)?|$)(?:\s*(\w+)?|$)(?:\s*(\w+)?|$)</regex>
		</Alias>
		<Alias isActive="yes" isFolder="no">
			<name>UI Setting</name>
			<script>local setting = matches[2] or ""
local subCommand = matches[3] or ""
-- Mostra tutti i profiles
if (subCommand == "") then
  ui.fShowAllSettings()
-- Carica setting
--elseif (subCommand == "load") then
--  if (ui.fLoadLocalSetting(setting)) then
--    ui.fEcho2n("Il setting "..ui.fGetSettingNameFormattedText(setting).." e' stato caricato.")
--  else
--    ui.fError("Il setting "..ui.fGetSettingNameFormattedText(setting).." non e' stato caricato.")
--  end
elseif (subCommand == "import") then
  if (ui.fImportSetting(setting)) then
    ui.fEcho2n("Il setting "..ui.fGetSettingNameFormattedText(setting).." e' stato importato.")
  else
    ui.fError("Il setting "..ui.fGetSettingNameFormattedText(setting).." non e' stato importato.")
  end
--
-- Rimuove il singolo setting
elseif (subCommand == "remove") then
  if (ui.fRemoveSetting(setting)) then
    ui.fEcho2n("Il setting "..ui.fGetSettingNameFormattedText(setting).." e' stato rimosso.")
  else
    ui.fError("Il setting "..ui.fGetSettingNameFormattedText(setting).." non e' stato rimosso.")
  end
else
  ui.fError("Parametro non previsto ("..subCommand..").")
end</script>
			<command></command>
			<packageName></packageName>
			<regex>^(?i)(?:uis(?:e(?:t(?:t(?:i(?:n(?:g)?)?)?)?)?)?)(?:\s+(\w*)\s*(.*))?$</regex>
		</Alias>
		<Alias isActive="yes" isFolder="no">
			<name>UI Speedwalk (./..)</name>
			<script>ui.fDebug("[alias] UI Speedwalk")
--
local in_path = string.lower(matches[3] or "")
local out_path = ""
local backwards = (matches[2] == ".")
--
local function ui_fGetNextNumber(text, index)
  ui.fDebug("[&lt;cyan&gt;call&lt;r&gt;] ui_fGetNextNumber("..(text or "nil")..", "..(index or "nil")..")")
  --
  local number = ""
  --
  index = tonumber(index or 1)
  while (index&lt;=text:len()) and (string.match(string.lower(text:sub(index, index)), "[0123456789]")) do
    number = number..string.lower(text:sub(index, index))
    index = index + 1
  end
  if (number == "") then
    number = "1"
  end
  number = tonumber(number)
  --
  return number, index
end
--
if (in_path == "") then
  ui.fEcho2n("Specificare un percorso.")
else
  -- Speedwalk
  local number
  local idx = 1
  while (idx&lt;=in_path:len()) do
    number, idx = ui_fGetNextNumber(in_path, idx)
    if (idx&lt;=in_path:len()) then
      local char = string.lower(in_path:sub(idx, idx))
      for j=1, number do
        if (backwards) then
          out_path = ui.dirReverse[char]..out_path
        else
          out_path = out_path..char
        end
      end
      idx = idx + 1
    end
  end
end
--
if (backwards) then
  ui.fDebug("[alias] UI Speedwalk (Back) - in: "..in_path.." - out: "..out_path)
else
  ui.fDebug("[alias] UI Speedwalk (Forward) - in: "..in_path.." - out: "..out_path)
end
-- Execute out path
for j=1, out_path:len() do
  -- Execute Ui Direction alias
  expandAlias(out_path:sub(j, j), false); 
end</script>
			<command></command>
			<packageName></packageName>
			<regex>^\.(\.)?(?i)([nsewdu\d]+)?$</regex>
		</Alias>
		<Alias isActive="yes" isFolder="no">
			<name>UI Target</name>
			<script>local button_type = string.upper(matches[2])
local button_number = tonumber(matches[3])
local value = matches[4] or ""
local button = button_type..button_number
--
-- G buttons
if (button_type == "G") then
  if (button_number&lt;0) or (button_number&gt;9) then
    ui.fError(ui.fGetTargetFormattedText(button).." non valido. Usare un target compreso tra "..ui.fGetTargetFormattedText("G0").." e "..ui.fGetTargetFormattedText("G9"))
  elseif (value ~= "") then
    ui.fError(ui.fGetTargetFormattedText(button).." non è possibile assegnare o rimuovere un valore al target avversario "..ui.fGetTargetFormattedText(button))
  else
    ui.fExecuteTargetButton(button)
  end
--
-- O button
elseif (button_type == "O") then
  if (button_number~=0)  then
    ui.fError(ui.fGetTargetFormattedText(button).." non valido. Usare "..ui.fGetTargetFormattedText("T0"))
  elseif (value ~= "") then
    ui.fError(ui.fGetTargetFormattedText(button).." non è possibile assegnare o rimuovere un valore al target di gruppo "..ui.fGetTargetFormattedText(button))
  else
    ui.fExecuteTargetButton(button)
  end
--
-- T buttons
elseif (button_type == "T") then
  if (button_number&lt;1) or (button_number&gt;4) then
    ui.fError(ui.fGetTargetFormattedText(button).." non valido. Usare "..ui.fGetTargetFormattedText("T1")..", "..ui.fGetTargetFormattedText("T2")..", "..ui.fGetTargetFormattedText("T3").." oppure "..ui.fGetTargetFormattedText("T4"))
  elseif (value == "") then
    ui.fExecuteTargetButton(button)
  elseif (value == "remove") then
    if (ui.fAssignTargetButton(button, nil)) then
      ui.fUpdateAllTargetButtons()
      --
      ui.fEcho2n(ui.fGetTargetFormattedText(button).." valore rimosso.")
    else
      ui.fError(ui.fGetTargetFormattedText(button).." errore durante la rimozione del valore.")
    end
  else
    if (ui.fAssignTargetButton(button, value)) then
      ui.fEcho2n(ui.fGetTargetFormattedText(button).." valore impostato "..ui.fGetVarValueFormattedText(value)..".")
    else
      ui.fUpdateAllTargetButtons()
      --
      ui.fError(ui.fGetTargetFormattedText(button).." errore durante il cambio di valore.")
    end
  end
end</script>
			<command></command>
			<packageName></packageName>
			<regex>^(?i)([got])(\d)(?:\s+(.*))?$</regex>
		</Alias>
		<Alias isActive="yes" isFolder="no">
			<name>UI Variables</name>
			<script>local variable = matches[2]
local value = matches[3]
-- Mostra tutte le variabili
if variable == nil or variable == "" then
  ui.fShowAllVar()
-- Rimuove tutte le variabili
elseif variable == "remove_all" then
  ui.fRemoveAllVariables();
  ui.fEcho2n("Tutte le variabili sono state eliminate.")
-- Mostra la singola variabile
elseif value == nil or value == "" then
  if ui.variables[variable] then
    ui.fEcho2n(ui.fGetVarFormattedText(variable))
  else
    ui.fEcho2n("La variabile "..ui.fGetVarNameFormattedText(variable).." non esiste.")
  end
-- Rimuove la singola variabile
elseif value == "remove" then
  if not ui.variables[variable] then
    ui.fEcho2n("La variabile "..ui.fGetVarNameFormattedText(variable).." non esiste.")
  elseif table.contains(ui.fGetPreDefinitedVariables(), variable) then
    ui.variables[variable] = ""
    ui.fEcho2n("La variabile predefinita "..ui.fGetVarNameFormattedText(variable).." è stata pulita.")
  else
    ui.variables[variable] = nil
    ui.fEcho2n("La variabile "..ui.fGetVarNameFormattedText(variable).." e' stata rimossa.")
  end
-- Crea o modifica la variabile
else
  if (ui.variables[variable])then
    ui.variables[variable] = value
    ui.fEcho2n('La variabile è stata aggiornata: '..ui.fGetVarFormattedText(variable))
  else
    ui.variables[variable] = value
    ui.fEcho2n('La variabile è stata creata: '..ui.fGetVarFormattedText(variable))
  end
end
--
if (variable and variable == "target") then
  ui.fUpdateAllTargetButtons()
end
--
ui.fSaveFileVariables()</script>
			<command></command>
			<packageName></packageName>
			<regex>^(?i)(?:uiv(?:a(?:r(?:i(?:a(?:b(?:l(?:e)?)?)?)?)?)?)?|&amp;)(?:\s*&amp;?(\w+)(?:\s*)?(.*))?$</regex>
		</Alias>
		<Alias isActive="yes" isFolder="no">
			<name>UI Widget</name>
			<script>local widgets = {
  ["affects"]       = GUI.Affects,
  ["buttons"]       = GUI.AliasButtons,
  ["chat"]          = GUI.Chat,
  ["endowment"]     = GUI.Endowment,
  ["group"]         = GUI.Group,
  ["help"]          = GUI.Help,
  ["room"]          = GUI.Room,
  ["opponent"]      = GUI.Opponent,
  ["player"]        = GUI.Player,
  ["target"]        = GUI.TargetButtons
}
local widget = string.lower(matches[2] or "")
--
if (widget == "") then
  ui.fEcho("Usare ")
  cechoLink(ui.cLink("all"), [[expandAlias("uiw all")]], "uiwidget all", true);
  for k, _ in pairs(widgets) do
    cecho(", ")
    cechoLink(ui.cLink(k), [[expandAlias("uiw ]]..k..[[")]], "uiwidget "..k, true);
  end
  cecho("\n")
--
elseif (widget == "all") then
  for _, w in pairs(widgets) do
    w:restore();
    w:show();
  end
  ui.fEcho2n("Tutti i widget sono stati ripristinati.")
--
elseif (widgets[widget]) then
  widgets[widget]:restore();
  widgets[widget]:show();
  ui.fEcho2n("Il widget "..ui.fGetCommandFormattedText(widget).." e' stato ripristinato.")
--
else
  ui.fEcho("Nome widget errato. Usare: ")
  cechoLink(ui.cLink("all"), [[expandAlias("uiw all")]], "uiwidget all", true);
  for k, _ in pairs(widgets) do
    cecho(", ")
    cechoLink(ui.cLink(k), [[expandAlias("uiw ]]..k..[[")]], "uiwidget "..k, true);
  end
  cecho("\n")  
end
</script>
			<command></command>
			<packageName></packageName>
			<regex>^(?i)(?:uiw(?:i(?:d(?:g(?:e(?:t)?)?)?)?)?)(?:\s+(.*))?$</regex>
		</Alias>
	</AliasPackage>
	<ActionPackage />
	<ScriptPackage>
		<ScriptGroup isActive="yes" isFolder="yes">
			<name>Functions</name>
			<packageName></packageName>
			<script>ui = ui or {}
ui.enDebug = 0 -- 0 = Off, 1 = Text only, 2 = simulate values</script>
			<eventHandlerList />
			<Script isActive="yes" isFolder="no">
				<name>Affects</name>
				<packageName></packageName>
				<script>--
function ui.fUpdateAffects()
  ui.fDebug("[&lt;cyan&gt;call&lt;r&gt;] ui.fUpdateAffects()")
  --
  local distance = 2; 
  local min_w = 100;
  local max_w = 150;
  local w_h = GUI.Affects.Main:get_height() - distance;
  local w_w = GUI.Affects.Main:get_width() -  distance;
  local h = distance + 28;
  local w = distance + min_w;
  local x = 0
  local y = 0
  local r = 1
  local c = 1
  local tot_r, tot_c, total
  local orderTable = {}
  --
  -- Pre defined affect 
  local pre_defined_affects = {
    ["velocita` della luce"]        = {                        BGcolor = "cyan" },
  --  ["[CD] Nuovo Dungeon"]        = {icon = "skill_115.png", color = "blue", shortName = "CD Dung" },
  --  ["[CD] Nuova Missione"]       = {icon = "skill_115.png", color = "blue", shortName = "CD Miss" },  
  --  ["avvelena"]                  = {icon = nil,             color = "YellowGreen", shortName = "Vel" },
  --  ["chiaroveggenza"]            = {icon = nil,             color = "magenta", shortName = "Chiaro" },  
  --  ["colpo psichico"]            = {icon = nil,             color = "magenta", shortName = "Colpo PSI" },  
  --  ["forza psichica"]            = {icon = "skill_9.png",   color = "OrangeRed", shortName = "PSI Str" },
  --  ["individua il magico"]       = {icon = 'Skill_322.png', color = "DarkOrchid", shortName = "Ind. mag." },
  --  ["individua il male"]         = {icon = 'skill_72.png',  color = "DarkOrchid", shortName = "Ind. mal." },
  --  ["individua invisibile"]      = {icon = "Skill_312.png", color = "DarkOrchid", shortName = "Ind. inv." },
  --  ["levitazione"]               = {icon = "skill_156.png", color = "blue", shortName = "Lev" },
  --  ["nuotare (cooldown)"]        = {icon = "skill_110.png", color = "blue", shortName = "Swim" },
  --  ["percepisci vita"]           = {icon = "skill_44.png",  color = "DarkOrchid", shortName = "True Live" },
  --  ["primo soccorso"]            = {icon = nil,             color = "green", shortName = "First AID" },  
  --  ["santuario"]                 = {icon = "Skill_243.png", color = "white", shortName = "Sanc" },
  --  ["scarica di adrenalina"]     = {icon = "Skill_472.png", color = "yellow", shortName = "PSI Dro" },
  --  ["scopri le trappole"]        = {icon = "skill_166.png", color = "brown", shortName = "Det. trap" },
  --  ["mantello di fiamme"]        = {icon = "fireshield.png", BGcolor = "firebrick", FGcolor = "yellow", shortName = "PSI Fire" },
  --  ["scudo psichico"]            = {icon = "skill_168.png", color = "cyan", shortName = "PSI Shield" },
  --  ["vera vista"]                = {icon = "Skill_264.png", color = "DarkOrchid", shortName = "Vera Vista" },
  }
  --
  -- Simulation (for debug)
  if (ui.enDebug &gt;= 2) then
    for i=1, math.random(1, 30) do
      local name = "Affect "..i 
      --
      ui.affects[name] = {} 
      ui.affects[name].category   = math.random(0, 100)
      if (i&lt;10)then
        ui.affects[name].color    = "$c000"..(i)
      else
        ui.affects[name].color    = "$c00"..(i)
      end
      ui.affects[name].duration         = math.random(0, 15) - 10
      ui.affects[name].isNegative       = math.random(0, 100)
      if (math.random(0, 1) == 0) then ui.affects[name].isRound = true else ui.affects[name].isRound = false end;
      ui.affects[name].type             = math.random(0, 100)
      --
      orderTable[#orderTable+1] = name
    end
  else
    for affect in pairs(ui.affects) do
      if (ui.affects[affect].duration &gt; 0) then
        orderTable[#orderTable+1] = affect
      end
    end
  end
  --
  -- Order Affects
  table.sort(orderTable, function (affect1, affect2)
                           if (ui.affects[affect1].duration &lt; 0) then
                             return false
                           elseif(ui.affects[affect2].duration &lt; 0) then
                             return true
                           elseif (ui.affects[affect1].isRound) and (not ui.affects[affect2].isRound) then
                             return true
                           elseif (not ui.affects[affect1].isRound) and (ui.affects[affect2].isRound) then
                             return false
                           else 
                             return ui.affects[affect1].duration &lt; ui.affects[affect2].duration
                           end
                         end )
  --
  total = math.min(#orderTable, 20);
  tot_r = math.max(1, math.min(math.floor(w_h / h), total));
  tot_c = math.max(1, math.min(math.floor(w_w / w), total));
  --
  -- Recalc w
  w = math.min(w_w / tot_c, distance + max_w)
  --
  for i = 1, 20 do
    --
    -- Show if inside box
    if (r &gt; tot_r) or (i &gt; total) then
      GUI.Affects.Main["Affect"..i]:hide();
    else
      local duration = ""
      local affect = orderTable[i]
      local durationColor = "green"
      --
      -- Permanent
      if (ui.affects[affect].duration &lt; 0) then
        durationColor = "white"
        ui.affects[affect].strDuration = "&lt;b&gt;P&lt;/b&gt;"
        duration = "Permanente"
      else
        --
        if (ui.affects[affect].duration &lt; 1) then
          durationColor = "red"
        elseif (ui.affects[affect].duration &lt; 3) then
          durationColor = "orange"
        elseif  (ui.affects[affect].duration &lt; 5) then
          durationColor = "yellow"
        end
        --
        -- In round or  tick
        if (ui.affects[affect].isRound) then
          duration = ui.affects[affect].duration.." round"
          ui.affects[affect].strDuration = ui.affects[affect].duration.."r"
        else
          duration = ui.affects[affect].duration.." tick"
          ui.affects[affect].strDuration = ui.affects[affect].duration.."T"
        end
      end
      --
      -- Normal Affects
      local icon = nil
      local BGColor = nil
      local FGColor = "black";
      local shortName = nil
      local CCS = GUI.CSS.ItemText
      --
      -- Pre-load icon, BG volor and short name form predefinited table (if exists)
      if table.contains(pre_defined_affects, affect) then
        --
        -- Pre-ShortName
        if (pre_defined_affects[affect].shortName) then
          shortName = pre_defined_affects[affect].shortName
        end
        --
        -- Pre-FG Color
        if (pre_defined_affects[affect].FGcolor) then
          FGColor = pre_defined_affects[affect].FGcolor
        end
        --
        -- Pre-Icon
        if (pre_defined_affects[affect].icon) and (io.exists(ui.files.icons.path..pre_defined_affects[affect].icon)) then
          icon = ui.files.icons.path..pre_defined_affects[affect].icon;
        end
        --
        -- Pre-BG Color
        if (pre_defined_affects[affect].BGcolor) then
          BGColor = pre_defined_affects[affect].BGcolor
        end
      end
      --
      -- Short Name
      if (not shortName) then
        shortName = ui.fRemoveArticle(affect);
      end
      GUI.Affects.Main["Affect"..i].text:setFgColor(FGColor)
      GUI.Affects.Main["Affect"..i].text:echo("&lt;center&gt;"..string.gsub(shortName, "(%a)([%w_']*)", ui.fTitleCase))
      --
      -- Icon
      if (icon) then
        CCS = CCS..[[
                border-image: url("]]..icon..[[") 0px stretch;
              ]]
      end
      --
      -- BG color
      if (not BGColor) then
        if (ui.affects[affect].color) then
          BGColor = ui.fGetColor(ui.affects[affect].color)
        else
		      local R = 9 * ((string.byte(shortName, 1) or 0x0) - 0x61) -- Primo carattere o 0 se la frase è vuota
		      local G = 9 * ((string.byte(shortName, 2) or 0x0) - 0x61) -- Secondo carattere o 0 se la frase ha meno di 2 caratteri
		      local B = 9 * ((string.byte(shortName, 3) or 0x0) - 0x61) -- Terzo carattere o 0 se la frase ha meno di 3 caratteri
		      --
          BGColor = string.format("#%02X%02X%02X", R, G, B)
        end
      end
      --
      CCS = CCS..[[
              background-color: ]]..BGColor..[[;
            ]]
      GUI.Affects.Main["Affect"..i].text:setStyleSheet(CCS)
      --
      GUI.Affects.Main["Affect"..i]:setStyleSheet([[QLabel{
        ]]..GUI.CSS.Item..[[
        background-color: ]]..BGColor..[[;
      }]])
      --
      GUI.Affects.Main["Affect"..i].duration:setFgColor(durationColor)
      GUI.Affects.Main["Affect"..i].duration:echo("&lt;center&gt;"..ui.affects[affect].strDuration)
      --
      -- ToolTip
      local toolTip = '&lt;p style="text-align: center;"&gt;&lt;b&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;'..string.upper(affect)..'&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/b&gt;&lt;br&gt;'..
                      '&lt;i&gt;'..duration..'&lt;/i&gt;&lt;/p&gt;'
      GUI.Affects.Main["Affect"..i]:setToolTip(toolTip, 10)
      --
      --
      GUI.Affects.Main["Affect"..i]:move(distance + (c-1)*w, distance + (r-1)*h)
      GUI.Affects.Main["Affect"..i]:resize(w - distance, h - distance)
      GUI.Affects.Main["Affect"..i]:show();
      --
      c = c + 1
      if (c &gt; tot_c) then
        c = 1;
        r = r + 1
      end
    end
  end
end
--
--
function ui.fTickUpdateAffects()
  ui.fDebug("ui.fTickUpdateAffects()");
  for affect in pairs(ui.affects) do
    ui.affects[affect].duration = ui.affects[affect].duration - 1
  end
  ui.fUpdateAffects()
end</script>
				<eventHandlerList />
			</Script>
			<Script isActive="yes" isFolder="no">
				<name>Alias buttons</name>
				<packageName></packageName>
				<script>local bgColor = {
  ["a"] = "75,0,0",
  ["b"] = "0,75,0",
  ["c"] = "0,0,75",
}
--
local bgColorHover = {
  ["a"] = "150,0,0",
  ["b"] = "0,200,0",
  ["c"] = "0,0,150",
}
--
-- Expand button name. Es. ui.fExpandButton("T5") -&gt; "t", 5
function ui.fExpandButton(button)
  local val = 0
  --
  button = string.lower(button or "")
  if (string.find(button, "^[abcgot]%d$")) then
    return string.sub(button, 1, 1), tonumber(string.sub(button, 2, 2))
  end
  --
  return nil, nil
end
--
function ui.fGetAliasButtonFormattedText(button)
  local cColor = {
    ["a"] = "&lt;red&gt;",
    ["b"] = "&lt;green&gt;",
    ["c"] = "&lt;blue&gt;",
  }
  local b, n = ui.fExpandButton(button)
  if (cColor[b]) then
    return ui.cLink(cColor[b]..button)
  else
    return ui.colors.aliasButton.."["..button.."]".."&lt;r&gt;"
  end
end
--
function ui.fSearchAliasButton(button)
  local type, number = ui.fExpandButton(button)
  --
  if (type == "a") or (type == "b") or (type == "c") then
    button = type..number
    for alias in pairs(ui.aliases) do
      if (ui.aliases[alias].button) and (ui.aliases[alias].button==button) then
        return alias
      end
    end
  end
  --
  return nil
end
--
-- Cecho Alias with link
function ui.fLinkAliasButton(button)
  local alias = ui.fSearchAliasButton(button)
  cechoLink(ui.fGetAliasButtonFormattedText(button), [[expandAlias("]]..button..[[")]], "Esegui '"..button.."'", true)
  cecho(" "..ui.fGetOperatorFormattedText("»").." ")
  if (alias) then
    ui.fLinkAlias(alias)
  else
    cecho("&lt;r&gt;non configurato")
  end
end
--
-- List all alias buttons
function ui.fShowAllAliasButtons()
  ui.fDebug("[&lt;cyan&gt;call&lt;r&gt;] ui.fShowAllAliasButtons()")
  --
  local i = 0
  --
  cecho(ui.fTitle("Pulsanti alias"))
  local button = {"a", "b", "c"}
  for b=1, 3 do
    for i=0, 9 do
      cecho(ui.fGetNumberFormattedText((b-1)*10 + i +1).." ")
      cechoLink(ui.cLink("X"), [[expandAlias("uibuttons ]]..button[b]..i..[[ remove")]], "Rimuovi l'alias associato a '"..button[b]..i.."'", true)
      cecho(" ")
      ui.fLinkAliasButton(button[b]..i)
      cecho("\n")
    end
  end
end
--
-- Remove alias button
function ui.fRemoveAliasButton(button)
  ui.fDebug("[&lt;cyan&gt;call&lt;r&gt;] ui.fRemoveAliasButton("..(button or "nil")..")")
  --
  local ret = 0;
  local type, number = ui.fExpandButton(button)
  --
  if (type == "a") or (type == "b") or (type == "c") then
    button = type..number 
    local alias = ui.fSearchAliasButton(button)
    --
    if (alias) then
      ui.aliases[alias].button = nil
      --
      return 1
    end
    --
    return -2 -- Not alias assigned
  end
  --
  return -1 -- Invaid button
end
--
-- Remove all alias button
function ui.fRemoveAllAliasButtons()
  ui.fDebug("[&lt;cyan&gt;call&lt;r&gt;] ui.fRemoveAllAliasButtons()")
  --
  for alias in pairs(ui.aliases) do
    if (ui.aliases[alias].button) then
      ui.aliases[alias].button = nil
    end
  end
end
--
-- Assign alias button
function ui.fAssignAliasButton(button, alias)
  ui.fDebug("[&lt;cyan&gt;call&lt;r&gt;] ui.fAssignAliasButton("..(button or "nil")..", "..(alias or "nil")..")")
  --
  local ret = 0;
  local type, number = ui.fExpandButton(button)
  --
  if (type == "a") or (type == "b") or (type == "c") then
    button = type..number
    if (ui.aliases[alias]) then
      ui.fRemoveAliasButton(button)
      ui.aliases[alias].button = button
      --
      return 1
    end
    --
    return -2 -- Alias not exist
  end
  --
  return -1 -- Invaid button
end
--
function ui.fExecuteAliasButton(button)
  ui.fDebug("[&lt;cyan&gt;call&lt;r&gt;] ui.fExecuteAliasButton("..(button or "nil")..")")
  --
  local alias = nil;
  local type, number = ui.fExpandButton(button)
  --
  if (type == "a") or (type == "b") or (type == "c") then
    button = type..number
    alias = ui.fSearchAliasButton(button)
    if (alias) then
      expandAlias(alias, false)
    else
      ui.fEcho2n(ui.fGetAliasButtonFormattedText(button).." non configurato. Usare il comanto "..ui.fGetCommandFormattedText(button.." &lt;alias&gt;").." per configurare.")
    end
  end
  --
  return alias
end
--
function ui.fUpdateAliasButton()
  ui.fDebug("[&lt;cyan&gt;call&lt;r&gt;] ui.fUpdateAliasButton()")
  --
  local distance = 3; 
  local w_h = GUI.AliasButtons.Main:get_height() - distance;
  local w_w = GUI.AliasButtons.Main:get_width() -  distance;
  local h = distance + 25
  local w = distance + 80;
  local x = 0
  local y = 0
  local r = 1
  local c = 1
  local tot_r, tot_c
  local total = 10
  --
  tot_c = math.max(1, math.min(math.floor(w_w / w), total));
  -- When working with negative numbers math.floor() returns the closest integer less than or equal to a given value
  tot_r = -math.floor(-total/tot_c);
  --
  -- Recalc w if possible
  w = w_w / tot_c
  --
  -- Recalc h if possible
  h = w_h / tot_r
  --
  for i = 0, 9 do
    if (r &gt; tot_r) then
      GUI.AliasButtons.Main["Button"..i]:hide();
    else
      local title = ""
      local keybind = ""
      local button = ui.parameters.page..i
      --
      for alias in pairs(ui.aliases) do
        if (ui.aliases[alias].button) and (ui.aliases[alias].button==button) then
          title = alias
          keybind = ui.aliases[alias].keybind or ""
          break
        end
      end
      --
      GUI.AliasButtons.Main["Button"..i].index:echo("&lt;center&gt;"..ui.parameters.page..i)
      --
      GUI.AliasButtons.Main["Button"..i].icon:setStyleSheet(GUI.CSS.ButtonsIcon)
      GUI.AliasButtons.Main["Button"..i].icon:echo("&lt;center&gt;"..title)
      --
      GUI.AliasButtons.Main["Button"..i].keybind:echo("&lt;p align=right&gt;"..keybind.."&lt;/p&gt;")
      --
      GUI.AliasButtons.Main["Button"..i]:setStyleSheet([[
        QLabel{
          ]]..GUI.CSS.Button..[[
          background-color: rgb(]]..bgColor[ui.parameters.page]..[[);
        }
        QLabel::hover{
          background-color: rgb(]]..bgColorHover[ui.parameters.page]..[[);
        }
      ]])
      --
      GUI.AliasButtons.Main["Button"..i]:resize(w - distance, h - distance)
      GUI.AliasButtons.Main["Button"..i]:move(distance + (c-1)*w, distance + (r-1)*h)
      GUI.AliasButtons.Main["Button"..i]:show();
      --
      c = c + 1
      if (c &gt; tot_c) then
        c = 1;
        r = r + 1
      end
    end
  end
end
--
function ui.fClickAliasButton(number)
  ui.fDebug("[&lt;cyan&gt;call&lt;r&gt;] ui.fClickAliasButton("..(number or "nil")..")")
  --
  local button = ui.parameters.page..number
  --
  ui.fExecuteAliasButton(button)
end
--
function ui.fOptionButton(buttonName)
  ui.fDebug("[&lt;cyan&gt;call&lt;r&gt;] ui.fOptionButton("..(buttonName or "nil")..")")
  --
  -- Aliases Buttons
  ui.parameters.page = buttonName;
  ui.fUpdateAliasButton()
end
--
-- Debug simulation
if (ui.enDebug) and (ui.enDebug &gt;= 2) then
  ui.fUpdateAliasButton()
end</script>
				<eventHandlerList />
			</Script>
			<Script isActive="yes" isFolder="no">
				<name>Aliases</name>
				<packageName></packageName>
				<script>--
function ui.fExpandVariables(value, toAlias)
  if (toAlias) then
    value = string.gsub(value, "#", '"..__mtchs2__.."')
    value = string.gsub(value, "["..ui.varID.."@](%w+)", '"..ui.variables.%1.."')
  else
    value = string.gsub(value, "["..ui.varID.."@](%w+)", "ui.variables.%1")
  end
  --
  for varName in string.gfind(value, "ui.variables%.(%w+)") do
    if (not ui.variables[varName]) then
      return nil, varName
    elseif (not toAlias) then
      value = string.gsub(value, "ui.variables%.(%w+)", ui.variables[varName])
    end
  end
  --
  return value, nil
end
--
function ui.fGetAliasNameFormattedText(alias)
  return ui.colors.aliasName..alias.."&lt;r&gt;"
end
--
function ui.fGetAliasOutputFormattedText(command, input)
  if (command) then
    input = input or ""
    --
    -- Add same spaces between commands
    command = string.gsub(command, "(%s*/%s*)", " / ")
    command = string.gsub(command, "(%s*;%s*)", "; ")
    --
    -- Format Aliases
    command = string.gsub(command, "^(%w+)", function(str)
                                               if ui.aliases[str] then
                                                 return ui.fGetAliasNameFormattedText(str)..ui.colors.aliasOutput
                                               end
                                             end)
    command = string.gsub(command, "/ (%w+)", function(str)
                                                if ui.aliases[str] then
                                                  return "/ "..ui.fGetAliasNameFormattedText(str)..ui.colors.aliasOutput
                                                end
                                              end)
    command = string.gsub(command, "; (%w+)", function(str)
                                                if ui.aliases[str] then
                                                  return "; "..ui.fGetAliasNameFormattedText(str)..ui.colors.aliasOutput
                                                end
                                              end)
    --
    -- Format Variables
    command = string.gsub(command, "["..ui.varID.."@](%w+)", function(str)
                                                        if not ui.variables[str] then
                                                          return ui.fGetVarNameFormattedText(str)..ui.fGetOperatorFormattedText("(")..ui.colors.error.."Variabile non trovata!"..ui.fGetOperatorFormattedText(")")..ui.colors.aliasOutput
                                                        else
                                                          return ui.fGetVarFormattedText(str)..ui.colors.aliasOutput
                                                        end
                                                      end)
    --
    -- Format commands separator
    command = string.gsub(command, ";", ui.colors.separator..";"..ui.colors.aliasOutput)
    command = string.gsub(command, "/", ui.colors.separator.."/"..ui.colors.aliasOutput)
    --
    -- Format input command
    command = string.gsub(command, "#", ui.fGetInputFormattedText("#"..input)..ui.colors.aliasOutput)
    --
    return ui.colors.aliasOutput..command.."&lt;r&gt;"
  end
  --
  return ""
end
--
function ui.fGetAliasFormattedText(alias)
  local ret = ""
  --
  if (ui.aliases[alias]) then
    ret = ui.fGetAliasNameFormattedText(alias)
    --
    if (ui.aliases[alias].keybId) then
      ret = ret.." "..ui.fGetOperatorFormattedText("or").." "..ui.fGetKeybFormattedText(ui.aliases[alias].keybind)
    end
    --
    if (ui.aliases[alias].button) then
      ret = ret.." "..ui.fGetOperatorFormattedText("or").." "..ui.fGetAliasButtonFormattedText(ui.aliases[alias].button)
    end
    --
    ret = ret.." "..ui.fGetOperatorFormattedText("»").." "..ui.fGetAliasOutputFormattedText(ui.aliases[alias].text)
  end
  --
  return ret
end
--
-- Cecho Alias with link
function ui.fLinkAlias(alias)
  if (ui.aliases[alias]) then
    cechoLink(ui.cLink(ui.fGetAliasNameFormattedText(alias)), [[expandAlias("]]..alias..[[")]], "Esegui l'alias '"..alias.."'", true)
    cecho(" "..ui.fGetOperatorFormattedText("»").." "..ui.fGetAliasOutputFormattedText(ui.aliases[alias].text))
  end
end
--
-- List all aliases
function ui.fShowAllAliases()
  ui.fDebug("[&lt;cyan&gt;call&lt;r&gt;] ui.fShowAllAliases()")
  --
  cecho(ui.fTitle("Aliases"))
  --
  if (table.is_empty(ui.aliases)) then
    cecho("Non ci sono alias.\n\n")
  else
    local idx = 0
    for alias in ui.fOrderedPairs(ui.aliases) do
      idx = idx + 1
      cecho(ui.fGetNumberFormattedText(idx).." ")
      cechoLink(ui.cLink("X"), [[expandAlias("uialias ]]..alias..[[ remove")]], "Cancella l'alias '"..alias.."'", true)
      cecho(" ")
      ui.fLinkAlias(alias)
      echo("\n")
    end
    echo("\n")
  end
end
--
function ui.fRemoveAlias(alias)
  ui.fDebug("[&lt;cyan&gt;call&lt;r&gt;] ui.fRemoveAlias("..(alias or "nil")..")")
  --
  if (ui.aliases[alias]) then
    ui.fRemoveKeyb(ui.aliases[alias]);
    if (ui.aliases[alias]["id"]) then
      killAlias(ui.aliases[alias]["id"])
    end
    ui.aliases[alias] = nil
    --
    return true
  end
  --
  return false
end
--
function ui.fRemoveAllAliases()
  ui.fDebug("[&lt;cyan&gt;call&lt;r&gt;] ui.fRemoveAllAliases()")
  --
  for alias in pairs(ui.aliases) do
    ui.fRemoveAlias(alias)
  end
  ui.aliases = {}
end
--
function ui.fExpandAlias(alias, value, mtchs, command)
  if (ui.echoed == "") then
    ui.echoed = ui.fGetAliasNameFormattedText(alias).." "..ui.fGetOperatorFormattedText("»").." "..ui.fGetAliasOutputFormattedText(value, mtchs);
    ui.fEcho(ui.echoed);
  else
    cecho(" "..ui.fGetOperatorFormattedText("»").." "..ui.fGetAliasOutputFormattedText(value, mtchs));
    ui.echoed = ui.echoed.." "..ui.fGetOperatorFormattedText("»").." "..ui.fGetAliasOutputFormattedText(value, mtchs)
  end
  expandAlias(command, false);
end
--
function ui.fExpandMultiAlias(idx, alias, value, mtchs, command)
  if (ui.echoed == "") then
    ui.echoed = ui.fGetAliasNameFormattedText(alias)..ui.fGetNumberFormattedText(idx).." "..ui.fGetOperatorFormattedText("»").." "..ui.fGetAliasOutputFormattedText(value, mtchs);
    if (idx &gt; 1) then echo("\n") end
    ui.fEcho(ui.echoed);
  elseif (idx == 1) then
    cecho(ui.fGetNumberFormattedText(idx).." "..ui.fGetOperatorFormattedText("»").." "..ui.fGetAliasOutputFormattedText(value, mtchs));
    ui.echoed = ui.echoed..ui.fGetNumberFormattedText(idx).." "..ui.fGetOperatorFormattedText("»").." "..ui.fGetAliasOutputFormattedText(value, mtchs);
  else
    local s = ui.echoed
    s = string.gsub(s, "\&lt;%w+\&gt;", "")
    s = string.gsub(s, "»", "x");
    s = string.gsub(s, "%S", " ");
    ui.echoed = s..ui.fGetNumberFormattedText(idx).." "..ui.fGetOperatorFormattedText("»").." "..ui.fGetAliasOutputFormattedText(value, mtchs);
    echo("\n")
    ui.fEcho(ui.echoed);
  end
  expandAlias(command, false);
end
--
function ui.fAddAlias(alias, value)
  ui.fDebug("[&lt;cyan&gt;call&lt;r&gt;] ui.fAddAlias("..(alias or "nil")..", "..(value or "nil")..")")
  --
  local command
  local commands, varNameError = ui.fExpandVariables(value, true)
  --
  if (not varNameError) then
    --
    -- Init alias (if no exist)
    ui.aliases[alias] = ui.aliases[alias] or {}
    --
    -- Remove old alias
    if (ui.aliases[alias].id) then
      killAlias(ui.aliases[alias].id)
    end
    --
    -- Save value in text format
    ui.aliases[alias].text = value
    --
    -- Generate alias code
    local code = [[
--
-- Recursion leval
ui.levelCode = ui.levelCode or 0
if (ui.levelCode &gt;= 20) then
  ui.fError("Recursion protection.")
  ui.levelCode = ui.levelCode - 1
  return
end
ui.levelCode = ui.levelCode + 1
--
-- Init
matches = matches or {}
local __mtchs2__ = matches[2] or ""
ui.echoed = ui.echoed or ""
local lstEchoed = ui.echoed
]]
    commands = ui.fExpandCommand(value)
    if (#commands == 1) then
      --
      -- Single command
      command = ui.fExpandVariables(value, true)
      if (string.match(command, "__mtchs2__")) then
        code = code..[[
--
-- Single command with #
ui.fExpandAlias("]]..alias..[[", 
                "]]..value..[[", 
                __mtchs2__, 
                "]]..command..[[");
]]
      else
        --
        -- Search for variables in command
        local last_variable = ""
        local last_expanded_variable = ""
        for variable in string.gfind(command, "ui.variables%.%w+") do
          last_variable = string.gsub(variable, "ui.variables%.", ui.varID)
          last_expanded_variable = variable
        end
        if (last_variable == "") then
          --
          -- If not variables in comman, add matches[2]
          code = code..[[
--
-- Single command without # and without variables
if (__mtchs2__ == "") then
  ui.fExpandAlias("]]..alias..[[", 
                  "]]..value..[[", 
                  __mtchs2__, 
                  "]]..command..[[");
else
  ui.fExpandAlias("]]..alias..[[", 
                  "]]..value..[[ #", 
                  __mtchs2__, 
                  "]]..command..[[".." "..__mtchs2__);
end
]]
        else
          --
          -- If variables in command, replace last variable with matches[2]
          local command_matches = string.gsub(command, last_expanded_variable, "__mtchs2__")
          code = code..[[
--
-- Single command without # but with variables
if (__mtchs2__ == "") then
  ui.fExpandAlias("]]..alias..[[", 
                  "]]..value..[[", 
                  __mtchs2__, 
                  "]]..command..[[");
else
  ui.fExpandAlias("]]..alias..[[", 
                  "]]..string.gsub(value, last_variable, "#")..[[", 
                  __mtchs2__, 
                  "]]..command_matches..[[");
end
]]
        end
      end
      code = code..[[
--
ui.echoed = lstEchoed;
]]

    else
      --
      -- Multiple commands
      code = code..[[
--
-- Multiple commands
]]
      for idx, cmd in ipairs(commands) do
        command = ui.fExpandVariables(cmd, true)
        code = code..[[
ui.fExpandMultiAlias(]]..idx..[[,
                     "]]..alias..[[",
                     "]]..cmd..[[",
                     __mtchs2__, 
                     "]]..command..[[")
--
ui.echoed = lstEchoed;
]]
      end
    end
    code = code..[[
--
if (ui.levelCode == 1) then echo("\n") end;
ui.levelCode = math.max(0, ui.levelCode - 1)
]]
    --
    -- Save alias code (for debug only)
    ui.aliases[alias].code = code
    --
    -- Assign keybind
    local mod1 = ui.aliases[alias].mod1 or "";
    local mod2 = ui.aliases[alias].mod2 or "";
    local key = ui.aliases[alias].key or "";
    local result, keybind
    --
    if (mod2 ~= "") then
      result, keybind = ui.fSetKeyb(ui.aliases, alias, ui.aliases[alias].code, mod2, mod1, key)
    elseif (mod1 ~= "") then
      result, keybind = ui.fSetKeyb(ui.aliases, alias, ui.aliases[alias].code, mod1, key)
    elseif (key ~= "") then
      result, keybind = ui.fSetKeyb(ui.aliases, alias, ui.aliases[alias].code, key)
    else
      result, keybind = ui.fSetKeyb(ui.aliases, alias, ui.aliases[alias].code)
    end
    --
    -- Remove keybind if not valid (or already used)
    if (result &lt;= 0) then
      ui.fRemoveKeyb(ui.aliases[alias])
    end
    --
    -- Create alias
    ui.aliases[alias].id = tempAlias([[^]]..alias..[[(?: (.*))?$]], code)
    --
    return 1, ui.fGetAliasFormattedText(alias)
  end
  --
  return -1, varNameError  -- Variable not exist
end
--
-- Save aliases data from file
function ui.fSaveFileAliases()
  ui.fDebug("[&lt;cyan&gt;call&lt;r&gt;] ui.fSaveFileAliases()")
  --
  if (ui.setting) then
    local file = ui.files.aliases.path..ui.setting.."/"..ui.files.aliases.name
    local aliasesDataToSave = {}
    --
    for alias in pairs(ui.aliases) do
      aliasesDataToSave[alias] = {}
      aliasesDataToSave[alias].text = ui.aliases[alias].text
      aliasesDataToSave[alias].mod1 = ui.aliases[alias].mod1
      aliasesDataToSave[alias].mod2 = ui.aliases[alias].mod2
      aliasesDataToSave[alias].key = ui.aliases[alias].key
      aliasesDataToSave[alias].button = ui.aliases[alias].button
    end
    table.save(file, aliasesDataToSave)
  end
end
--
-- Read Aliases data from file
function ui.fReadFileAliases()
  ui.fDebug("[&lt;cyan&gt;call&lt;r&gt;] ui.fReadFileAliases()")
  --
  local file = ui.files.aliases.path..ui.setting.."/"..ui.files.aliases.name
  --
  -- Remove actual Aliases
  ui.aliases = ui.aliases or {}
  ui.fRemoveAllAliases()
  --
  -- Load Aliases
  if (io.exists(file)) then
    table.load(file, ui.aliases)
  end
  --
  -- Create Aliases
  for alias in pairs(ui.aliases) do
    ui.fAddAlias(alias, ui.aliases[alias].text)
  end
end</script>
				<eventHandlerList />
			</Script>
			<Script isActive="yes" isFolder="no">
				<name>Chat</name>
				<packageName></packageName>
				<script>--
function ui.fUpdateChat()
  ui.fDebug("[&lt;cyan&gt;call&lt;r&gt;] ui.fUpdateChat()")
  --
  if (ui.parameters.widgets.chat.type == "all") then
    GUI.Chat.Button_split:show();
    --
    if (ui.parameters.widgets.chat.split == "horizontal") then
      GUI.Chat.Main.All:hide()
      --
      GUI.Chat.Main.Private:move(0, 0);
      GUI.Chat.Main.Private:resize("100%", "50%-4")
      GUI.Chat.Main.Private:show()
      --
      GUI.Chat.Split_line:move(0, "50%-2");
      GUI.Chat.Split_line:resize("100%", 4)
      GUI.Chat.Split_line:show()
      --
      GUI.Chat.Main.Public:move(0, "50%+4");
      GUI.Chat.Main.Public:resize("100%", "50%-4")
      GUI.Chat.Main.Public:show()
      --
      GUI.Chat:setTitle("Chat [private - pubblic]")
    --
    elseif (ui.parameters.widgets.chat.split == "vertical") then
      GUI.Chat.Main.All:hide()
      --
      GUI.Chat.Main.Private:move(0, 0);
      GUI.Chat.Main.Private:resize("50%-4", "100%")
      GUI.Chat.Main.Private:show()
      --
      GUI.Chat.Split_line:move("50%-2", 0);
      GUI.Chat.Split_line:resize(4, "100%")
      GUI.Chat.Split_line:show()
      --
      GUI.Chat.Main.Public:move("50%+4", 0);
      GUI.Chat.Main.Public:resize("50%-4", "100%")
      GUI.Chat.Main.Public:show()
      --
      GUI.Chat:setTitle("Chat [private | pubblic]")
    --
    else
      GUI.Chat.Main.All:move(0, 0);
      GUI.Chat.Main.All:resize("100%", "100%")
      GUI.Chat.Main.All:show()
      --
      GUI.Chat.Main.Public:hide()
      --
      GUI.Chat.Split_line:hide()
      --
      GUI.Chat.Main.Private:hide()
      --
      GUI.Chat:setTitle("Chat [private + pubblic]")
    end
  --
  elseif (ui.parameters.widgets.chat.type == "public") then
    GUI.Chat.Button_split:hide();
    --
    GUI.Chat.Main.All:hide()
    --
    GUI.Chat.Main.Public:move(0, 0);
    GUI.Chat.Main.Public:resize("100%", "100%")
    GUI.Chat.Main.Public:show()
    --
    GUI.Chat.Split_line:hide()
    --
    GUI.Chat.Main.Private:hide()
    --
    GUI.Chat:setTitle("Chat [pubblic]")
  else
    GUI.Chat.Button_split:hide();
    --
    GUI.Chat.Main.All:hide()
    --
    GUI.Chat.Main.Public:hide()
    --
    GUI.Chat.Split_line:hide()
    --
    GUI.Chat.Main.Private:move(0, 0);
    GUI.Chat.Main.Private:resize("100%", "100%")
    GUI.Chat.Main.Private:show()
    --
    GUI.Chat:setTitle("Chat [private]")
  end
  --
  GUI.Chat.Button_type:echo("&lt;center&gt;"..ui.parameters.widgets.chat.type);
end
--
function ui.fChatTypeClicked()
  ui.fDebug("[&lt;cyan&gt;call&lt;r&gt;] ui.fChatTypeClicked()")
  --
  if (ui.parameters.widgets.chat.type == "all") then
    ui.parameters.widgets.chat.type = "public"
  elseif (ui.parameters.widgets.chat.type == "public") then
    ui.parameters.widgets.chat.type = "private"
  else
    ui.parameters.widgets.chat.type = "all"
  end
  --
  ui.fUpdateChat()
  --
  ui.fSaveFileParameters()
end
--
function ui.fChatSplitClicked()
  ui.fDebug("[&lt;cyan&gt;call&lt;r&gt;] ui.fChatSplitClicked()")
  --
  if (ui.parameters.widgets.chat.split == "no") then
    ui.parameters.widgets.chat.split = "vertical";
  elseif (ui.parameters.widgets.chat.split == "vertical") then
    ui.parameters.widgets.chat.split = "horizontal";
  else
    ui.parameters.widgets.chat.split = "no"
  end
  --
  ui.fUpdateChat()
  --
  ui.fSaveFileParameters()
end</script>
				<eventHandlerList />
			</Script>
			<Script isActive="yes" isFolder="no">
				<name>Colors</name>
				<packageName></packageName>
				<script>--
-- Coded by Mudlet community developer demonnic
-- internal sorting function, sorts first by hue, then luminosity, then value
local sortColorsByHue = function(lhs, rhs)
  local lh, ll, lv = unpack(lhs.sort)
  local rh, rl, rv = unpack(rhs.sort)
  --
  if lh &lt; rh then
    return true
  elseif lh &gt; rh then
    return false
  elseif ll &lt; rl then
    return true
  elseif ll &gt; rl then
    return false
  else
    return lv &lt; rv
  end
end
--
-- Internal sorting function, removes _ from snake_case and compares to camelCase
local sortColorsByName = function(a, b)
  local aname = string.gsub(string.lower(a.name), "_", "")
  local bname = string.gsub(string.lower(b.name), "_", "")
  --
  return aname &lt; bname
end
--
-- Internal function used to turn sorted colors table into columns
local chunkify = function(tbl, num_chunks)
  local pop =
    function(t)
      return table.remove(t, 1)
    end
  local tbl = table.deepcopy(tbl)
  local tblsize = #tbl
  local base_chunk_size = tblsize / num_chunks
  local chunky_chunks = tblsize % num_chunks
  local chunks = {}
  --
  for i = 1, num_chunks do
    local chunk_size = base_chunk_size
    if i &lt;= chunky_chunks then
      chunk_size = chunk_size + 1
    end
    local chunk = {}
    for j = 1, chunk_size do
      chunk[j] = pop(tbl)
    end
    chunks[i] = chunk
  end
  --
  return chunks
end
--
-- internal function, converts rgb to hsv
-- found at https://github.com/EmmanuelOga/columns/blob/master/utils/color.lua#L89
local rgbToHsv = function(r, g, b)
  r, g, b = r / 255, g / 255, b / 255
  local max, min = math.max(r, g, b), math.min(r, g, b)
  local h, s, v
  v = max
  local d = max - min
  if max == 0 then
    s = 0
  else
    s = d / max
  end
  if max == min then
    h = 0
    -- achromatic
  else
    if max == r then
      h = (g - b) / d
      if g &lt; b then
        h = h + 6
      end
    elseif max == g then
      h = (b - r) / d + 2
    elseif max == b then
      h = (r - g) / d + 4
    end
    h = h / 6
  end
  --
  return h, s, v
end
--
-- internal stepping function, removes some of the noise for a more pleasing sort
-- cribbed from the python on https://www.alanzucconi.com/2015/09/30/colour-sorting/
local step = function(r, g, b)
  local lum = math.sqrt(.241 * r + .691 * g + .068 * b)
  local reps = 8
  local h, s, v = rgbToHsv(r, g, b)
  local h2 = math.floor(h * reps)
  local lum2 = math.floor(lum * reps)
  local v2 = math.floor(v * reps)
  --
  if h2 % 2 == 1 then
    v2 = reps - v2
    lum2 = reps - lum2
  end
  --
  return h2, lum2, v2
end
--
local function calc_luminosity(r, g, b)
  r = r &lt; 11 and r / (255 * 12.92) or ((0.055 + r / 255) / 1.055) ^ 2.4
  g = g &lt; 11 and g / (255 * 12.92) or ((0.055 + g / 255) / 1.055) ^ 2.4
  b = b &lt; 11 and b / (255 * 12.92) or ((0.055 + b / 255) / 1.055) ^ 2.4
  --
  return (0.2126 * r) + (0.7152 * g) + (0.0722 * b)
end
--
local function include(color, options)
  if options.removeDupes then
    if string.find(color, "_") or string.find(color:lower(), 'gray') then
      return false
    else
      return true
    end
  else
    if string.find(color, "ansi_%d%d%d") then
      return false
    else
      return true
    end
  end
end
--
local function echoColor(color, options)
  local rgb = color.rgb
  local fgc = "white"
  --
  if calc_luminosity(unpack(rgb)) &gt; 0.5 then
    fgc = "black"
  end
  local colorString
  if options.justText then
    colorString = string.format('&lt;%s:%s&gt; %-23s&lt;r&gt; ', color.name, 'black', color.name, spacer)
  else
    colorString = string.format('&lt;%s:%s&gt; %-23s&lt;r&gt; ', fgc, color.name, color.name)
  end
  if options.window == "main" then
    if options.echoOnly then
      cecho(colorString)
    else
      cechoLink(
        colorString, [[appendCmdLine("]]..color.name..[[")]], table.concat(rgb, ", "), true
      )
    end
  else
    if options.echoOnly then
      cecho(options.window, colorString)
    else
      cechoLink(
        options.window,
        colorString,
        [[appendCmdLine("]]..color.name..[[")]],
        table.concat(rgb, ", "),
        true
      )
    end
  end
end
--
function ui.fDisplayColors(options)
  local options = options or {}
  local optionsType = type(options)
  --
  assert(
    optionsType == "table",
    "ui.fDisplayColors(options) argument error: options as table expects, got "..optionsType
  )
  options.cols = options.cols or 4
  options.search = options.search or ""
  options.sort = options.sort or false
  if options.removeDupes == nil then
    options.removeDupes = true
  end
  if options.columnSort == nil then
    options.columnSort = true
  end
  if type(options.window) == "table" then
    options.window = options.window.name
  end
  options.window = options.window or "main"
  local color_table = options.color_table or color_table
  local cols, search, sort = options.cols, options.search, options.sort
  local colors = {}
  for k, v in pairs(color_table) do
    local color = {}
    color.rgb = v
    color.name = k
    color.sort = {step(unpack(v))}
    if include(k, options) and k:lower():find(search) then
      table.insert(colors, color)
    end
  end
  if sort then
    table.sort(colors, sortColorsByName)
  else
    table.sort(colors, sortColorsByHue)
  end
  if options.columnSort then
    local columns_table = chunkify(colors, cols)
    local lines = #columns_table[1]
    for i = 1, lines do
      for j = 1, cols do
        local color = columns_table[j][i]
        if color then
          echoColor(color, options)
        end
      end
      echo(options.window, "\n")
    end
  else
    local i = 1
    for _, k in ipairs(colors) do
      echoColor(k, options)
      if i == cols then
        echo(options.window, "\n")
        i = 1
      else
        i = i + 1
      end
    end
    if i ~= 1 then
      echo(options.window, "\n")
    end
  end
end
--
-- Check color
function ui.fColorCheck(color)
  local color = color:lower()
  --
  color = color:gsub("_", "")
  for color_name, _ in pairs(color_table) do
    if color_name:lower() == color then
      return color_name
    end
  end
  --
  return false
end
</script>
				<eventHandlerList />
			</Script>
			<Script isActive="yes" isFolder="no">
				<name>CSS (init)</name>
				<packageName></packageName>
				<script>function ui.initCSS()
  ui.fDebug("[&lt;white&gt;init&lt;r&gt;] CSS")
  --
  GUI = {}
  GUI.CSS = {}
  --
  -- Item
  GUI.CSS.Item = [[
    border: 2px outset rgb(]]..ui.colors.wBorder..[[);
    border-top-left-radius: 12px;
    border-top-right-radius:12px;
    border-bottom-left-radius: 12px;
    border-bottom-right-radius:12px;
  ]]
  --
  -- Item Left
  GUI.CSS.ItemLeft = [[
    border: 2px inset rgb(]]..ui.colors.wBorder..[[);
    border-top-left-radius: 10px;
    border-top-right-radius: 5px;
    border-bottom-left-radius: 10px;
    border-bottom-right-radius: 5px;
    background-color: rgb(]]..ui.colors.wBackground..[[);
  ]]
  --
  -- Item Top Left
  GUI.CSS.ItemTopLeft = [[
    border: 2px inset rgb(]]..ui.colors.wBorder..[[);
    border-bottom: none;
    border-top-left-radius: 10px;
    border-top-right-radius: 5px;
    background-color: rgb(]]..ui.colors.wBackground..[[);
  ]]
  --
  -- Item Bottom Left
  GUI.CSS.ItemBottomLeft = [[
    border: 2px inset rgb(]]..ui.colors.wBorder..[[);
    border-top: none;
    border-bottom-left-radius: 10px;
    border-bottom-right-radius: 5px;
    background-color: rgb(]]..ui.colors.wBackground..[[);
  ]]
  --
  -- Item Text
  GUI.CSS.ItemText = [[
    border: none;
    border-radius: 0px;
    qproperty-wordWrap: true;
  ]]
  --
  -- Item Top Right
  GUI.CSS.ItemTopRight = [[
    border: 2px inset rgb(]]..ui.colors.wBorder..[[);
    border-bottom: none;
    border-top-left-radius: 5px;
    border-top-right-radius: 10px;
    background-color: rgb(]]..ui.colors.wBackground..[[);
  ]]
  --
  -- Item Bottom Right
  GUI.CSS.ItemBottomRight = [[
    border: 2px inset rgb(]]..ui.colors.wBorder..[[);
    border-top: none;
    border-bottom-left-radius: 5px;
    border-bottom-right-radius: 10px;
    background-color: rgb(]]..ui.colors.wBackground..[[);
  ]]
  --
  -- Border
  GUI.CSS.Border = [[
    border: 2px inset rgb(]]..ui.colors.wBorder..[[); 
    border-radius: 4px;
    background-color: rgb(]]..ui.colors.wBackground..[[);
  ]]
  --
  -- Border transparent
  GUI.CSS.BorderTransparent = [[
    border: none;
    padding: 2px;
    background: transparent;
  ]]
  --
  -- Target buttons
  GUI.CSS.Button = [[
    border: 2px outset #aa8822;
    border-radius: 5px 10px;
    qproperty-wordWrap: true;
  ]]
  --
  -- Buttons Icon
  GUI.CSS.ButtonsIcon = [[
    background: transparent;
    qproperty-wordWrap: true;
  ]]
  --
  -- Gauge back
  GUI.CSS.GaugeBack = [[
    border: none;
    border-radius: 5px;
    margin: 0px;
  ]]
  --
  -- Gauge front
  GUI.CSS.GaugeFront = [[
    border-radius: 3px;
    margin:  2px;
  ]]
  --
  -- Keybind
  GUI.CSS.Keybind = [[
    background: transparent;
  ]]
  --
  -- Level
  GUI.CSS.Level = [[
    border-image: url("]]..ui.files.images.path..[[borderRound.png") 0px stretch;
    background-color: rgb(]]..ui.colors.wBackground..[[);
    background: transparent;
  ]]
  --
  -- Widget Body
  
  GUI.CSS.Main = [[
    background: transparent;
  ]]
  --
  --
  GUI.CSS.Widget = [[
    border: 2px outset rgb(]]..ui.colors.wBorder..[[); 
    border-top-left-radius: 10px;
    border-top-right-radius: 10px;
    border-bottom-left-radius: 4px;
    border-bottom-right-radius: 4px;
    background-color: rgb(]]..ui.colors.widget..[[);
  ]]
  --
  GUI.CSS.WidgetButton = [[
    QLabel{
      border-radius: 6px;
      background-color: rgb(]]..ui.colors.wButton..[[);
    }
    QLabel::hover{
      background-color: rgb(]]..ui.colors.wButtonHover..[[);
    }
  ]]
  --
  --
  GUI.CSS.WidgetTransparent = [[
    QWidget{
      border: none;
      border-top-left-radius: 10px;
      border-top-right-radius: 10px;
      border-bottom-left-radius: 4px;
      border-bottom-right-radius: 4px;
      padding: 2px;
      background: transparent;
    }
    QWidget::hover{
      border: 2px outset rgba(]]..ui.colors.wBorder..[[, 0.7); 
      background-color: rgba(]]..ui.colors.wBackground..[[, 0.7);
    }
  ]]
end</script>
				<eventHandlerList />
			</Script>
			<Script isActive="yes" isFolder="no">
				<name>Endowment</name>
				<packageName></packageName>
				<script>local replacements = {
	["DAc"] = "Danno Acido",
	["DCh"] = "Danno Caos",
	["DEl"] = "Danno Elettricita'",
	["DEn"] = "Danno Energia",
	["DFr"] = "Danno Freddo",
	["DFu"] = "Danno Fuoco",
	["DIm"] = "Danno Impatto",
	["DLu"] = "Danno Lumen",
	["DNa"] = "Danno Natura",
	["DPe"] = "Danno Perforazione",
	["DPs"] = "Danno Psichico",
	["DTa"] = "Danno Taglio",
	["DTr"] = "Danno Trauma",
	["DUm"] = "Danno Umbra",
	["Dmg"] = "Danno Fisico",

	["EEl"] = "Efficacia Elettricita'",
	["EFr"] = "Efficacia Freddo",
	["EFu"] = "Efficacia Fuoco",

	["RAc"] = "Resistenza Acido",
	["RCh"] = "Resistenza Caos",
	["RDi"] = "Resistenza danni Divini",
	["REl"] = "Resistenza Elettricita'",
	["REm"] = "Resistenza danni Elementali",
	["REn"] = "Resistenza Energia",
	["RFr"] = "Resistenza Freddo",
	["RFs"] = "Resistenza al Fisico",
	["RFu"] = "Resistenza Fuoco",
	["RIm"] = "Resistenza Impatto",
	["RLu"] = "Resistenza Lumen",
	["RMg"] = "Resistenza Magici",
	["RNa"] = "Resistenza Natura",
	["RPe"] = "Resistenza Perforazione",
	["RPs"] = "Resistenza danno Psichico",
	["RTT"] = "Resistenza Tutto",
	["RTa"] = "Resistenza Taglio",
	["RTr"] = "Resistenza Trauma",
	["RUm"] = "Resistenza Umbra",

	["For"] = "Forza",
	["Des"] = "Destrezza",
	["Cos"] = "Costituzione",
	["Int"] = "Intelligenza",
	["Sag"] = "Saggezza",
	["Car"] = "Carisma",

	["Let"] = "Letalita'",
	["Ast"] = "Astuzia",
	["Vit"] = "Vitalità",
	["Per"] = "Percezione",
	["Prc"] = "Precisione",
	["Pen"] = "Penetrazione",

	["Arm"] = "Classe Armatura",
	["Crt"] = "Colpo Critico",
	["CCF"] = "Corpo a Corpo Fisico",
	["CCM"] = "Corpo a Corpo Magico",
	["IsA"] = "Incantesimo su Arma",
	["PdG"] = "Pittura di Guerra",
	["Mag"] = "Potere Magico",
	["Spc"] = "Potere Speciale",
	["BSc"] = "Bloccare con lo Scudo",
	["Nms"] = "Nemesi",

	["PfR"] = "Recupero Punti Ferita",
	["MnR"] = "Recupero Mana",
	["MvR"] = "Recupero Movimento",

	["PF"]	= "Punti Ferita",
	["Mn"]	= "Mana", 
	["Mv"]	= "Movimento", 
}
--
function ui.fIsStatistics(s)
  s = ansi2string(decho2ansi(s))
  --
  for k, i in pairs(replacements) do
    s = string.gsub(s, k, "")       -- statistics
  end
  --
  s = string.gsub(s, "%d+d%d+", "") -- dices
  --
  s = string.gsub(s, "-?%d+", "")   -- values
  --
  s = string.gsub(s, " ", "")       -- white space
  --
  return (string.len(s) == 0)
end
--
function ui.fUpdateEndowment()
  ui.fDebug("[&lt;cyan&gt;call&lt;r&gt;] ui.fUpdateEndowment()")
  --
  local distance = 2; 
  local min_w = 100;
  local max_w = 150;
  local w_h = GUI.Endowment.Main:get_height() - distance;
  local w_w = GUI.Endowment.Main:get_width() -  distance;
  local h = distance + 28;
  local w = distance + min_w;
  local x = 0
  local y = 0
  local r = 1
  local c = 1
  local tot_r, tot_c, total
  local orderTable = {}
  --
  -- Order Items
  for item in pairs(ui.equipment) do
    if (ui.equipment[item].used) then
      orderTable[#orderTable+1] = item
    end
  end
  --
  table.sort(orderTable, function (item1, item2)
                           return (ui.equipment[item1].number &lt; ui.equipment[item2].number)
                         end )
  --
  total = math.min(#orderTable, 25);
  tot_r = math.max(1, math.min(math.floor(w_h / h), total));
  tot_c = math.max(1, math.min(math.floor(w_w / w), total));
  --
  -- Recalc w 
  w = math.min(w_w / tot_c, distance + max_w)
  --
  for i = 1, 25 do
    --
    -- Show if inside box
    if (r &gt; tot_r) or (i &gt; total) then
      GUI.Endowment.Main["Item"..i]:hide();
    else
      local item = orderTable[i]
      --
      -- Number
      GUI.Endowment.Main["Item"..i].Index:echo("&lt;center&gt;"..ui.equipment[item].number)
      --
      -- Status
      GUI.Endowment.Main["Item"..i].Status:echo("&lt;center&gt;"..ui.equipment[item].status)
      --
      -- Name
      GUI.Endowment.Main["Item"..i].Text:echo("&lt;center&gt;"..string.gsub(ui.fRemoveArticle(ui.equipment[item].name), "(%a)([%w_']*)", ui.fTitleCase));
      --
      -- Level
      GUI.Endowment.Main["Item"..i].Level:echo("&lt;center&gt;"..ui.equipment[item].level);
      --
      -- Slot
      GUI.Endowment.Main["Item"..i].Slot:echo("&lt;center&gt;"..ui.equipment[item].short);
      --
      -- Type (determinate color)
      local BGColor = "grey"
      local t = ansi2string(decho2ansi(ui.equipment[item].type))
      --
      -- T = Trash, C = common, U = Uncommon, R = Rare, E = Epic, L = Leggend
      if (t == "C") then
        t = "&lt;color=white&gt;Comune&lt;/color&gt;"
        BGColor = "white"
      elseif (t == "U") then
        t = "Non comune"
        BGColor = "lime"
      elseif (t == "R") then
        t = "Raro"
        BGColor = "rgb(58,120,242)"
      elseif (t == "E") then
        t = "Epico"
        BGColor = "blue"
      elseif (t == "L") then
        t = "Leggendario"
        BGColor = "orange"
      elseif (t == "S") then
        t = "Set astrale"
        BGColor = "yellow"        
      elseif (t == "A") then
        t = "Astrale"
        BGColor = "cyan"        
      else
        t = "Spazzatura"
        BGColor = "grey"
      end
      --
      -- BorderColor
      local borderColor 
      local status = string.gsub(ui.equipment[item].status, "%%", "")
      --
      status = tonumber(status)
      if (status &lt;= 0) then
        borderColor = "brown"
      elseif (status &lt;= 2) then
        borderColor = "red"
      elseif (status &lt;= 4) then
        borderColor = "orange"
      elseif (status &lt;= 6) then
        borderColor = "yellow"
      elseif (status &lt;= 7) then
        borderColor = "green"
      else
        borderColor = "rgb("..ui.colors.wBorder..")"
      end
      --
      -- CSS
      GUI.Endowment.Main["Item"..i].Text:setStyleSheet(GUI.CSS.ItemText..[[
              background-color: ]]..BGColor..[[;
            ]])
      --
      GUI.Endowment.Main["Item"..i]:setStyleSheet([[QLabel{
        ]]..GUI.CSS.Item..[[
        background-color: ]]..BGColor..[[;
        border: 2px outset ]]..borderColor..[[;
      }]])        
      --
      -- Stat for ToolTip
      local stat = "&lt;lu&gt;"
      if (ui.equipment[item].status == 9) then stat = stat.."&lt;li&gt;▷ Indistruttibile&lt;/li&gt;" end
      if (ui.equipment[item].good)        then stat = stat.."&lt;li&gt;▷ Buono (good)&lt;/li&gt;" end
      if (ui.equipment[item].evil)        then stat = stat.."&lt;li&gt;▷ Malvagio (evil)&lt;/li&gt;" end
      if (ui.equipment[item].bright)      then stat = stat.."&lt;li&gt;▷ Luminoso (bright)&lt;/li&gt;" end
      if (ui.equipment[item].noisy)       then stat = stat.."&lt;li&gt;▷ Rumoroso (noisy)&lt;/li&gt;" end
      if (ui.equipment[item].brittle)     then stat = stat.."&lt;li&gt;▷ Fragile (brittle)&lt;/li&gt;" end
      stat = stat.."&lt;/lu&gt;"
      --
      -- ToolTip
      local toolTip = '&lt;p style="text-align: center;"&gt;&lt;b&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;'..string.upper(ansi2string(decho2ansi(ui.equipment[item].name)))..'&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/b&gt;&lt;br&gt;'..
                      '&lt;i&gt;&amp;lt;'..ui.equipment[item].slot..'&amp;gt;&lt;/i&gt;&lt;/p&gt;'..
                      stat..
                      '&lt;p style="text-align: right;"&gt;&lt;i&gt;'..t..'&lt;/i&gt; [Liv. '..ui.equipment[item].level..']&lt;/p&gt;'
      --
      GUI.Endowment.Main["Item"..i]:setToolTip(toolTip, 10);
      --
      GUI.Endowment.Main["Item"..i]:resize(w - distance, h - distance)
      GUI.Endowment.Main["Item"..i]:move(distance + (c-1)*w, distance + (r-1)*h)
      GUI.Endowment.Main["Item"..i]:show();
      --
      c = c + 1
      if (c &gt; tot_c) then
        c = 1;
        r = r + 1
      end
    end
  end
end</script>
				<eventHandlerList />
			</Script>
			<Script isActive="yes" isFolder="no">
				<name>Generic</name>
				<packageName></packageName>
				<script>function ui.fInitDataDirectory()
  ui.fDebug("[&lt;cyan&gt;call&lt;r&gt;] ui.fInitDataDirectory()")
  --
  local lfs = require("lfs")
  --
  if (lfs.chdir(ui.files.data.path)) then
    ui.fEchon("&lt;orange&gt; - Cartella &lt;white&gt;dati&lt;orange&gt; inizializzata correttamente.")
    return true
  elseif (lfs.mkdir(ui.files.data.path)) then
    ui.fEchon("&lt;orange&gt; - Cartella &lt;white&gt;dati&lt;orange&gt; creata correttamente.")
    return true
  else
    ui.fEchon("&lt;red&gt; - Impossibile caricare la cartella &lt;white&gt;dati&lt;red&gt;.")
  end
  return false
end
--
function ui.fGenOrderedIndex( t )
  local orderedIndex = {}
  --
  for key in pairs(t) do
    table.insert(orderedIndex, key)
  end
  --
  table.sort(orderedIndex)
  --
  return orderedIndex
end
--
function ui.fOrderedNext(t, state)
  -- Equivalent of the next function, but returns the keys in the alphabetic
  -- order. We use a temporary ordered key table that is stored in the
  -- table being iterated.
  local key = nil
  --
  if (state == nil) then
    --
    -- First time, generate the index
    t.__orderedIndex = ui.fGenOrderedIndex(t)
    key = t.__orderedIndex[1]
  else
    --
    -- Fetch the next value
    for i = 1,table.getn(t.__orderedIndex) do
      if t.__orderedIndex[i] == state then
        key = t.__orderedIndex[i+1]
      end
    end
  end
  --
  if (key) then
    return key, t[key]
  end
  --
  -- No more value to return, cleanup
  t.__orderedIndex = nil
  --
  return
end
--
function ui.fOrderedPairs(t, state)
  -- Equivalent of the pairs() function on tables. Allows to iterate in order
  return ui.fOrderedNext, t, state
end
--
function ui.fFormatEcho(text, level)
  local tab = ""
  --
  if (level) and (level &gt; 0) then 
    for i=2, level do
      tab = tab.."    "
    end
    tab = tab..ui.fGetOperatorFormattedText("  » ")
  end
  --
  return ui.echo..tab..ui.colors.text..text.."&lt;r&gt;"
end
--
function ui.fEcho(text, level)
  cecho(ui.fFormatEcho(text, level))
end
--
function ui.fEchon(text, level)
  cecho(ui.fFormatEcho(text, level).."\n")
end
--
function ui.fEcho2n(text, level)
  cecho(ui.fFormatEcho(text, level).."\n\n")
end
--
function ui.fDecho(text)
  text = copy2decho(ui.echo..ui.colors.text)..text..copy2decho("&lt;r&gt;").."\n\n"
  decho(text)
end
--
function ui.fDebug(text, level)
  level = level or 1
  --
  if (ui.enDebug &gt;= level) then
    ui.fEchon("&lt;orange&gt;[DEBUG ] &lt;white&gt;("..getTime(true, "hh:mm:ss.zzz")..") "..ui.colors.text..text.."&lt;r&gt;")
  end
end
--
function ui.fLog(text)
  text = "\n&lt;128,128,128:"..ui.colors.wBackground.."&gt;"..os.date("%H:%M:%S").." - &lt;255,255,255:"..ui.colors.wBackground.."&gt;"..text.."\n"
  --
  GUI.Chat.Main.All:decho(text)
  GUI.Chat.Main.Private:decho(text)
  --GUI.Chat.Main.Public:decho(text)
end
--
function ui.fError(text)
  text = ui.echo..ui.colors.error.."[ERRORE] "..ui.colors.text..text.."&lt;r&gt;\n\n"
  --
  cecho(text)
end
--
function ui.fTitle(text)
  local title = "\n"..ui.echo..ui.colors.title..text.."\n"
  --
  text = string.gsub(ui.echo..text, "\&lt;%a+\&gt;", "")
  for i=1, text:len() do
    title = title.."-"
  end
  title = title.."\n"
  --uih
  return title
end
--
function ui.fdigitNumber(number, digit)
  number = ""..(number or "")
  digit = tonumber(digit or 2) or 2;
  --
  for i = string.len(number), digit-1 do
    number = " "..number
  end
  --
  return number
end
--
function ui.fGetNumberFormattedText(number, digit)
  return "&lt;ansiMagenta&gt;[&lt;white&gt;"..ui.fdigitNumber(number, digit).."&lt;ansiMagenta&gt;]".."&lt;r&gt;"
end
--
function ui.fRemoveArticle(text)
  text = " "..text.." "
  text = string.gsub(text, "&gt;", "&gt; ")
  text = string.gsub(text, " [aA] ", " ")
  text = string.gsub(text, " [aA][dD] ", " ")
  text = string.gsub(text, " [aA][lL] ", " ")
  text = string.gsub(text, " [cC][oO][nN] ", " ")
  text = string.gsub(text, " [dD]'", " ")
  text = string.gsub(text, " [dD][aA] ", " ")
  text = string.gsub(text, " [dD][iI] ", " ")
  text = string.gsub(text, " [dD][eE][iI] ", " ")
  text = string.gsub(text, " [dD][eE][lL] ", " ")
  text = string.gsub(text, " [dD][eE][lL][lL]'", " ")
  text = string.gsub(text, " [dD][eE][gG][lL][iI] ", " ")
  text = string.gsub(text, " [dD][eE][lL][lL][aA] ", " ")
  text = string.gsub(text, " [dD][eE][lL][lL][eE] ", " ")
  text = string.gsub(text, " [dD][eE][lL][lL][oO] ", " ")
  text = string.gsub(text, " [eE] ", " ")
  text = string.gsub(text, " [gG][lL][iI] ", " ")
  text = string.gsub(text, " [iI] ", " ")
  text = string.gsub(text, " [iI][lL] ", " ")
  text = string.gsub(text, " [iI][nN] ", " ")
  text = string.gsub(text, " [lL]'", " ")
  text = string.gsub(text, " [lL][aA] ", " ")
  text = string.gsub(text, " [lL][eE] ", " ")
  text = string.gsub(text, " [lL][oO] ", " ")
  text = string.gsub(text, " [pP][aA][iA][oOaA] ", " ")
  text = string.gsub(text, " [uU][nN] ", " ")
  text = string.gsub(text, " [uU][nN]'", " ")
  text = string.gsub(text, " [uU][nN][aA] ", " ")
  text = string.gsub(text, " [uU][nN][oO] ", " ")
  text = string.gsub(text, "&gt; ", "&gt;")
  text = string.trim(text)
  --
  return text
end
--
function ui.fParsingItem(text)
  --local status = 8
  --
  text = string.gsub(text, "%.%.%.", "")
  --
  if (string.find(text, "indistruttibil")) then
    text = string.gsub(text, "E` indistruttibile!", "")
    text = string.gsub(text, "Sono indistruttibili!", "")
    status = 9
  elseif (string.find(text, "in condizioni eccellenti")) then
    text = string.gsub(text, "E` in condizioni eccellenti", "")
    text = string.gsub(text, "Sono in condizioni eccellenti", "")
    status = 8
  elseif (string.find(text, "in ottime condizioni")) then
    text = string.gsub(text, "E` in ottime condizioni", "")
    text = string.gsub(text, "Sono in ottime condizioni", "")
    status = 7
  elseif (string.find(text, "danni superficiali")) then
    text = string.gsub(text, "Presenta danni superficiali", "")
    text = string.gsub(text, "Presentano danni superficiali", "")
    status = 6
  elseif (string.find(text, "danneggiat")) then
    text = string.gsub(text, "E` danneggiato ed usurato", "")
    text = string.gsub(text, "Sono danneggiati ed usurati", "")
    status = 5
  elseif (string.find(text, "in pessime condizioni")) then
    text = string.gsub(text, "E` in pessime condizioni", "")
    text = string.gsub(text, "Sono in pessime condizioni", "")
    status = 4
  elseif (string.find(text, "bisogno di essere riparat")) then
    text = string.gsub(text, "Ha bisogno di essere riparato", "")
    text = string.gsub(text, "Hanno bisogno di essere riparati", "")
    status = 3
  elseif (string.find(text, "per cadere in pezzi")) then
    text = string.gsub(text, "Sta per cadere in pezzi", "")
    text = string.gsub(text, "Stanno per cadere in pezzi", "")
    status = 2
  elseif (string.find(text, "rompersi da un momento all'altro")) then
    text = string.gsub(text, "Potrebbe rompersi da un momento all'altro!", "")
    text = string.gsub(text, "Potrebbero rompersi da un momento all'altro!", "")
    status = 1
  elseif (string.find(text, "in frantumi. Inutilizzabil")) then
    text = string.gsub(text, "E` in frantumi. Inutilizzabile!", "")
    text = string.gsub(text, "Sono in frantumi. Inutilizzabili!", "")
    status = 0
  end
  --
  local good = false;
  if (string.find(text, "luce blu")) then
    text = string.gsub(text, "Ha un alone di &lt;r&gt;&lt;[%d,:]+&gt;luce blu", "")
    text = string.gsub(text, "Hanno un alone di &lt;r&gt;&lt;[%d,:]+&gt;luce blu", "")
    good = true;
  end
  --
  local evil = false;
  if (string.find(text, "luce rossa")) then
    text = string.gsub(text, "Ha un alone di &lt;r&gt;&lt;[%d,:]+&gt;luce rossa", "")
    text = string.gsub(text, "Hanno un alone di &lt;r&gt;&lt;[%d,:]+&gt;luce rossa", "")
    evil = true
  end
  --
  local bright = false
  if (string.find(text, "alone luminoso")) then
    text = string.gsub(text, "Ha un &lt;r&gt;&lt;[%d,:]+&gt;alone luminoso", "")
    text = string.gsub(text, "Hanno un &lt;r&gt;&lt;[%d,:]+&gt;alone luminoso", "")
    bright = true
  end
  --
  local noisy = false
  if (string.find(text, "forte ronzio")) then
    text = string.gsub(text, "Emette un &lt;r&gt;&lt;[%d,:]+&gt;forte ronzio", "")
    text = string.gsub(text, "Emettono un &lt;r&gt;&lt;[%d,:]+&gt;forte ronzio", "")
    noisy = true
  end
  --
  local brittle = false
  if (string.find(text, "molto fragil")) then
    text = string.gsub(text, "Sembra molto fragile", "")
    text = string.gsub(text, "Sembrano molto fragili", "")
    brittle = true
  end
  --
  text = string.gsub(text, "&lt;[%d,:]+&gt;&lt;r&gt;", "")
  text = ui.fRemoveArticle(text)
  --
  return text, status, good, evil, bright, noisy, brittle
end
--
function ui.fGetCommandFormattedText(command)
  return ui.colors.command..command.."&lt;r&gt;"
end
--
function ui.fGetOperatorFormattedText(operator)
  return ui.colors.operator..operator.."&lt;r&gt;"
end
--
function ui.fGetInputFormattedText(input)
  return ui.colors.input..input.."&lt;r&gt;"
end
--
function ui.fExpandCommand(value)
  if string.match(value, "/") then
    return string.split(value, "%s*/%s*")
  end
  --
  return string.split(value, "%s*;%s*")
end
--
function ui.fTitleCase(first, rest)
   return first:upper()..rest:lower()
end
--
function ui.fExecutePath(table, option)
  if (not option) then
    --
    -- execute all
    for i = 1, #table do
      expandAlias(table[i])
    end
  else
    local itemNumber = tonumber(option)
    if (itemNumber) then
      if (itemNumber == 0) then
        --
        -- Show all
        for i = 1, #table do
          cecho(ui.fGetNumberFormattedText(i).." "..ui.fGetAliasOutputFormattedText(table[i]).."\n")
        end
      elseif (itemNumber &gt;= 1) and (itemNumber &lt;= #table) then
        expandAlias(table[itemNumber])
      else
        ui.fError("Indice non valido.")
      end
    else
      --
      -- execute command for all (es. tell Pippo)
      for i = 1, #table do
        send(option.." "..i..") "..table[i]:gsub("(%s*;%s*)", " | "))
      end    
    end
  end
end
--
function ui.fDeleteDirectory(dir)
  local lfs = require('lfs')
  --
  local function deletedir(dir)
    for file in lfs.dir(dir) do
      local file_path = dir..'/'..file
      --
      if (file ~= ".") and (file ~= "..") then
        if (lfs.attributes(file_path, 'mode') == 'file') then
          os.remove(file_path)
        elseif (lfs.attributes(file_path, 'mode') == 'directory') then
          deletedir(file_path)
        end
      end
    end
    lfs.rmdir(dir)
  end
  --
  deletedir(dir)
end
--
function ui.fCopyFile(old_path, new_path)
  local old_file = io.open(old_path, "rb")
  local new_file = io.open(new_path, "wb")
  local old_file_sz, new_file_sz = 0, 0
  --
  if (not old_file) or (not new_file) then
    return false
  end
  --
  local block = old_file:read(2^13)
  while block do
    new_file:write(block)
    block = old_file:read(2^13)
  end
  --
  old_file_sz = old_file:seek("end")
  old_file:close()
  --
  new_file_sz = new_file:seek("end")
  new_file:close()
  --
  return new_file_sz == old_file_sz
end
--
-- Return true if t1 == t2
function ui.fTableCompare(o1, o2, ignore_mt)
  local o1Type = type(o1)
  local o2Type = type(o2)
  --
  -- Same object
  if (o1 == o2) then
    return true
  end
  --
  -- Different type
  if (o1Type ~= o2Type) then 
    return false 
  end
  --
  -- Same type but not table, already compared above
  if (o1Type ~= 'table') then 
    return false 
  end
  --
  -- Use metatable method
  if (not ignore_mt) then
    local mt1 = getmetatable(o1)
    --
    if mt1 and mt1.__eq then
      -- Compare using built in method
      return o1 == o2
    end
  end
  --
  -- Iterate over o1
  for key1, value1 in pairs(o1) do
    local value2 = o2[key1]
    --
    if (value2 == nil) or (ui.fTableCompare(value1, value2, ignore_mt) == false) then
      return false
    end
  end
  --
  -- check keys in o2 but missing from o1
  for key2, _ in pairs(o2) do
    if (o1[key2] == nil) then 
      return false 
    end
  end
  --
  return true
end
--
function ui.fHasbit(x, p)
  x = tonumber(x)
  p = tonumber(p)
  --
  p = 2 ^ (p - 1)
  --
  return (x % (p + p) &gt;= p)
  --return (math.mod(x, p+p) &gt;= p)       
end
--
function ui.fGetColor(color)
  local tabColor = {
    ["$c0000"] = "#080808", -- Nero 
    ["$c0001"] = "#870000", -- Rosso scuro 
    ["$c0002"] = "#008700", -- Verde scuro 
    ["$c0003"] = "#878700", -- Marrone 
    ["$c0004"] = "#000087", -- Blu 
    ["$c0005"] = "#870087", -- Viola 
    ["$c0006"] = "#008787", -- Cyan 
    ["$c0007"] = "#a8a8a8", -- Grigio (default)        
    ["$c0008"] = "#767676", -- Grigio scuro
    ["$c0009"] = "#ff0000", -- Rosso chiaro
    ["$c0010"] = "#00ff00", -- Verde chiaro
    ["$c0011"] = "#ffff00", -- Giallo
    ["$c0012"] = "#0000ff", -- Blu chiaro
    ["$c0013"] = "#ff00ff", -- Viola chiaro
    ["$c0014"] = "#00ffff", -- Celeste chiaro
    ["$c0015"] = "#ffffff", -- Bianco
  }
  --
  -- $chfRRGGBB
  if (string.find(color, "$chf")) then
    color = string.gsub(color, "$chf", "#")
  --
  -- $cXXXX
  elseif (string.find(color, "$c")) then
    color = tabColor[color] or tabColor["$c0007"]
  end
  --
  return color
end
--
function ui.fConvertColorString(s)
  local tabColor = {
    ["$c0000"] = "&lt;black&gt;", -- Nero 
    ["$c0001"] = "&lt;ansiRed&gt;", -- Rosso scuro 
    ["$c0002"] = "&lt;DarkGreen&gt;", -- Verde scuro 
    ["$c0003"] = "&lt;brown&gt;", -- Marrone 
    ["$c0004"] = "&lt;ansiBlue&gt;", -- Blu 
    ["$c0005"] = "&lt;purple&gt;", -- Viola 
    ["$c0006"] = "&lt;ansiCyan&gt;", -- Cyan 
    ["$c0007"] = "&lt;r&gt;", -- Grigio (default)        
    ["$c0008"] = "&lt;DimGrey&gt;", -- Grigio scuro
    ["$c0009"] = "&lt;red&gt;", -- Rosso chiaro
    ["$c0010"] = "&lt;green&gt;", -- Verde chiaro
    ["$c0011"] = "&lt;yellow&gt;", -- Giallo
    ["$c0012"] = "&lt;blue&gt;", -- Blu chiaro
    ["$c0013"] = "&lt;violet&gt;", -- Viola chiaro
    ["$c0014"] = "&lt;cyan&gt;", -- Celeste chiaro
    ["$c0015"] = "&lt;white&gt;", -- Bianco
  }
  local codes = s:gmatch("$c%d%d%d%d")
  --
  for code in codes do
    local val = tabColor[code] or tabColor["$c0007"]
    --
    s = s:gsub(code, val)
  end
  s = s:gsub("$crk%d%d%d%d%d%d%d%d", "")
  --
  return s
end
--
function ui.fAddMain(sender, CSS_Border, CSS_Main)
  if (sender) then
    sender.Border = Geyser.Label:new2({
      name = sender.name..".Border",
      x = 4,
      y = 24,
      width = "100%-8",
      height = "100%-28",
    }, sender)
    sender.Border:enableClickthrough()
    sender.Border:setStyleSheet(CSS_Border);
    
    sender.Main = Geyser.Label:new2({
      name = sender.name..".Main",
      x = 5,
      y = 5,
      width = "100%-10",
      height = "100%-10",
    }, sender.Border)
    sender.Main:enableClickthrough()
    sender.Main:setStyleSheet(CSS_Main);
  end
end
--
function ui.fAddSpace(s, l, mode)
  s = s or ""
  local ansiString = ansi2string(decho2ansi(s));
  local ansiStringLen = ansiString:len()
  local spaceL = ""
  local spaceR = ""
  --
  mode = mode or "c"
  if (ansiStringLen &lt; l) then
    for i = ansiStringLen, l do
      if (mode == "l") then
        spaceL = spaceL.." "
      elseif (mode == "r") then
        spaceR = spaceR.." "
      elseif (i%2==0) then
        spaceL = spaceL.." "
      else
        spaceR = spaceL.." "        
      end
    end
  end
  --
  return spaceL..s..spaceR
end
--
function ui.fWindowResize(eventName, containerName)
  ui.fUpdateAffects()
  ui.fUpdateAliasButton()
  ui.fUpdateEndowment()
  ui.fUpdateGroup()
  ui.fRefreshTargetButtonsWidget()
end
--
function ui.fSetBorderMode(sender, mode)
  --
  -- Transparent (Mode = true)
  if (mode) then
    --
    -- Widget
    sender.adjLabelstyle = GUI.CSS.WidgetTransparent
    sender.adjLabel:setStyleSheet(sender.adjLabelstyle) 
    --
    -- Internal border
    sender.Border:setStyleSheet(GUI.CSS.BorderTransparent);
  --
  -- Solid (Mode = false)
  else
    --
    -- Widget
    sender.adjLabelstyle = GUI.CSS.Widget
    sender.adjLabel:setStyleSheet(sender.adjLabelstyle) 
    --
    -- Internal border
    sender.Border:setStyleSheet(GUI.CSS.Border);
  end
end
--
function ui.cLink(s)
  s = s or ""
  return "&lt;gold&gt;[&lt;LightYellow&gt;"..s.."&lt;gold&gt;]&lt;r&gt;"
end
--
-- Connection Event
function ui.fConnection()
  ui.fDebug("[&lt;cyan&gt;call&lt;r&gt;] ui.fConnection()")
  --
  ui.fRemoveAllHighlights()
  ui.fRemoveAllAliasButtons()
  ui.fRemoveAllKeyb()
  ui.fRemoveAllAliases()
  ui.fRemoveAllVariables()
  --
  ui.initStructures()
  --
  ui.fEcho("&lt;orange&gt; - Caricamento 'Lumen et Umbra UI' (rel. "..ui.release..") completato.&lt;r&gt;\n")
  ui.fEcho("&lt;orange&gt; - Digitare ");
  cechoLink(ui.cLink("uihelp"), [[expandAlias("uihelp")]], "Esegui i comando 'uihelp'", true) 
  cecho("&lt;orange&gt; per iniziare...&lt;r&gt;\n")
end
--
function ui.fLevelColor(opponentLevel, playerLevel)
  --
  -- Level color
  local levelDif = tonumber(opponentLevel) - tonumber(playerLevel or 0)
  local color = "grey"
  --
  if (levelDif &lt; -5) then
    color = "grey"
  elseif (levelDif &lt; 0) then
    color = "green"
  elseif (levelDif == 0) then
    color = "white"
  elseif (levelDif &lt; 10) then
    color = "yellow"
  else
    color = "red"
  end
  --
  return color
end
</script>
				<eventHandlerList />
			</Script>
			<Script isActive="yes" isFolder="no">
				<name>GMCP</name>
				<packageName></packageName>
				<script>--
function ui.fUpdateGMCP(event, ...)
  ui.fDebug("[&lt;cyan&gt;call&lt;r&gt;] ui.fUpdateGMCP(&lt;white&gt;"..event.."&lt;r&gt;)", 3)
  --
  if (gmcp) then
    --
    -- Wait for first gmcp pack to load setting from cheracter name
    if (ui.setting == nil) and (gmcp.MSDP) and (gmcp.MSDP.CHARACTER_NAME) then
      ui.setting = string.lower(gmcp.MSDP.CHARACTER_NAME)
      --
      if (ui.fLoadLocalSetting()) then
        ui.fEcho2n("Il setting "..ui.fGetSettingNameFormattedText(ui.setting).." e' stato caricato correttamente.")
      elseif (ui.fSaveSetting()) then
        ui.fEcho2n("Il setting "..ui.fGetSettingNameFormattedText(ui.setting).." e' stato creato correttamente.")
      else
        ui.fError("Impossibile caricare/creare il setting "..ui.fGetSettingNameFormattedText(ui.setting)..".")
      end
    end
    --
    -- Player
    ui.fUpdatePlayer();
    --
    -- Opponent
    ui.fUpdateOpponent();
    --
  end
end</script>
				<eventHandlerList />
			</Script>
			<Script isActive="yes" isFolder="no">
				<name>Group</name>
				<packageName></packageName>
				<script>--
function ui.fUpdateGroup()
  ui.fDebug("[&lt;cyan&gt;call&lt;r&gt;] ui.fUpdateGroup()")
  --
  local distance = 2;
  local min_w = 150;
  local max_w = 250;
  local w_h = GUI.Group.Main:get_height() - distance;
  local w_w = GUI.Group.Main:get_width() -  distance;
  local h = distance + 50;
  local w = distance + min_w;
  local x = 0
  local y = 0
  local r = 1
  local c = 1
  local tot_r, tot_c, total
  --
  if (ui.enDebug &gt;= 2) then
    total = math.random(1, 10)
    local leader = math.random(0, total)
    for member=1, total do
      ui.group[member] = {
        name     = "Player "..member,
        isLeader = (member == leader),
        hp       = math.random(0, 100),
        maxhp    = 100,
        mana     = math.random(0, 100),
        maxmana  = 100,
        mov      = math.random(0, 100),
        maxmov   = 100,
        pov      = math.random(0, 100),
        maxpov   = 100,
        roomPos  = math.random(1, 9),
      }  
    end
  end
  --
  total = math.min(#ui.group, 10);
  tot_r = math.max(1, math.min(math.floor(w_h / h), total));
  tot_c = math.max(1, math.min(math.floor(w_w / w), total));
  --
  -- Recalc w if possible
  w = math.min(w_w / tot_c, distance + max_w)
  --
  for i = 1, 10 do
    mod = i % 10
    if (r &gt; tot_r) or (i &gt; total) then
      GUI.Group.Main["g"..mod]:hide()
      ui.fAssignTargetButton("g"..mod, nil)
    else
      --
      GUI.Group.Main["g"..mod]:resize(w - distance, h - distance)
      GUI.Group.Main["g"..mod]:move(distance + (c-1)*w, distance + (r-1)*h)
      --
      if (ui.group[i].isLeader) then
        GUI.Group.Main["g"..mod].Member:echo("&lt;center&gt;".."👑 "..ansi2string(ui.group[i].name.." 👑"))
      else
        GUI.Group.Main["g"..mod].Member:echo("&lt;center&gt;"..ansi2string(ui.group[i].name))
      end
      --
      GUI.Group.Main["g"..mod].Health:setValue(math.max(0, ui.group[i].hp), ui.group[i].maxhp, "&lt;p align=right&gt;"..ui.group[i].hp.."/"..ui.group[i].maxhp.."&lt;/p&gt;")
      GUI.Group.Main["g"..mod].Mana:setValue(math.max(0, ui.group[i].mana), ui.group[i].maxmana)
      GUI.Group.Main["g"..mod].Stamina:setValue(math.max(0, ui.group[i].mov), ui.group[i].maxmov)
      --
      GUI.Group.Main["g"..mod]:show();
      ui.fAssignTargetButton("g"..mod, ui.group[i].name)
      --
      c = c + 1
      if (c &gt; tot_c) then
        c = 1;
        r = r + 1
      end
    end
  end
  --
  ui.fUpdateAllTargetButtons()
  --
  GUI.Group:setTitle("Gruppo ["..total.."]")
end
--
-- Debug simulation
if (ui.enDebug) and (ui.enDebug &gt;= 2) then
  ui.fUpdateGroup()
end</script>
				<eventHandlerList />
			</Script>
			<Script isActive="yes" isFolder="no">
				<name>Help (init)</name>
				<packageName></packageName>
				<script>function ui.initHelp()
ui.fDebug("[&lt;white&gt;init&lt;r&gt;] Help")
--
ui.help = {}
--
ui.help.error = [[
Non esiste aiuto per questa parola

Ritorna alla pagina principale dell'&lt;link help&gt;help&lt;/link&gt;.
]]
--
ui.help.help = [[
&lt;title&gt;Lumen et Umbra UI Help&lt;/title&gt; Lumen et Umbra UI comprende un insieme di finestre (widget), script, trigger, etc, creati per personalizzare l'esperienza di gioco con il MUD Lumen et Umbra su client Mudlet. Usare il comando &lt;command&gt;uih[elp] &lt;comando&gt;&lt;/command&gt; o clicca sui link tra parentesi quadre per avere informazioni sugli argomenti disponibili.

&lt;yellow&gt;Witgets&lt;r&gt; &lt;link widgets&gt;Panoramica&lt;/link&gt;                
  &lt;link affects&gt;Affects&lt;/link&gt;   ▷ Widget effetti attivi                   &lt;link opponent&gt;Opponent&lt;/link&gt; ▷ Widget dati avversatrio 
  &lt;link buttons&gt;Buttons&lt;/link&gt;   ▷ Widget bottoni per alias                &lt;link player&gt;Player&lt;/link&gt;   ▷ Widget dati giocatore
  &lt;link chat&gt;Chat&lt;/link&gt;      ▷ Widget chat                             &lt;link room&gt;Room&lt;/link&gt;     ▷ Widget stanza 
  &lt;link endowment&gt;Endowment&lt;/link&gt; ▷ Widget equipaggiamento                  &lt;link targets&gt;Target&lt;/link&gt;   ▷ Widget bottoni per target 
  &lt;link group&gt;Group&lt;/link&gt;     ▷ Widget gruppo
  

&lt;yellow&gt;Comandi (principali):&lt;r&gt;
  &lt;link alias&gt;uia[liases]&lt;/link&gt;    ▷ Comando per gestire gli aliases
  &lt;link help&gt;uih[elp]&lt;/link&gt;       ▷ Questo help
  &lt;link highlight&gt;uihi[ghlights]&lt;/link&gt; ▷ Comando per gestione gli highlights
  &lt;link variable&gt;uiv[ariables]&lt;/link&gt;  ▷ Comando per gestione le variabili

&lt;yellow&gt;Altri comandi:&lt;r&gt;
  &lt;link walk&gt;.&lt;/link&gt; oppure
  &lt;link walk&gt;..&lt;/link&gt;           ▷ Comandi di walk e speedwalk
  &lt;link target&gt;g0..g9&lt;/link&gt; oppure
  &lt;link target&gt;o0&lt;/link&gt; oppure
  &lt;link target&gt;t1..t4&lt;/link&gt;       ▷ Comandi per la gestione della variabile &lt;var&gt;target&lt;/var&gt;
  &lt;link button&gt;uib[uttons]&lt;/link&gt;  ▷ Comando per la gestione dei pulsanti del widget Button
  &lt;link color&gt;uic[olors]&lt;/link&gt;   ▷ Comando per la visualizzazione dei colori disponibili per gli highlights
  &lt;link fontsize&gt;uif[ontsize]&lt;/link&gt; ▷ Comando per la gestione della dimensione dei font di aluni widget
  &lt;link keybind&gt;uik[eibind]&lt;/link&gt;  ▷ Comando per la gestione dei tasti rapidi per aliases e targets
  &lt;link profile&gt;uip[rofiles]&lt;/link&gt; ▷ Comando per la gestione dei profili
  &lt;link widget&gt;uiw[idget]&lt;/link&gt;   ▷ Comando per il ripristino dei widget chiusi
]]
--
ui.help.affects = [[
&lt;title&gt;Widget Affects&lt;/title&gt;Il widget Affects visualizza automaticamente (via trigger) i dati relativi agli effetti attivi sul personaggio, visualizzabili con il comando "effetti". Ogni elemento del widget rappresenta un effetto attivo ed è composto dal suo nome (al centro) e il tempo di permanenza (a sinistra, r=round, t=tick, P=permanente).

Rimanendo con il cursore del mouse su un effetto è possibile visualizzare in un tooltip le caratteristiche dell'effetto selezionato.

Ritorna alla pagina principale dell'&lt;link help&gt;help&lt;/link&gt;.
]]
--
ui.help.alias = [[
&lt;title&gt;Aliases&lt;/title&gt;Gli aliases permettono di associare un testo semplice a uno o più comandi complessi. I comandi di un alias possono contenere variabili create con il comando &lt;link variable&gt;uiv[ariables]&lt;/link&gt; o altri alias creati precedenemente con il comando &lt;link alias&gt;uia[liases]&lt;/link&gt;. 
Per associare più comandi ad un alias utilizzare uno degli appositi separatori di comando (]]..ui.colors.separator..[[;&lt;r&gt; o ]]..ui.colors.separator..[[/&lt;r&gt;). Richiamando l'alias i comandi verranno eseguiti sequenzialmente dal primo all'ultimo.

&lt;yellow&gt;Configurazione:&lt;r&gt;
  &lt;command&gt;uia[liases]&lt;/command&gt;                   Per visualizzare l'elenco degli aliases
  &lt;command&gt;uia[liases]&lt;/command&gt; &lt;aliasName&gt;&lt;alias&gt;&lt;/aliasName&gt;           Per visualizzare il singolo alias
  &lt;command&gt;uia[liases]&lt;/command&gt; &lt;aliasName&gt;&lt;alias&gt;&lt;/aliasName&gt; &lt;comandi&gt; Per creare o modificare un alias
  &lt;command&gt;uia[liases]&lt;/command&gt; &lt;aliasName&gt;&lt;alias&gt;&lt;/aliasName&gt; &lt;command&gt;remove&lt;/command&gt;    Per eliminare un alias
  &lt;command&gt;uia[liases] remove_all&lt;/command&gt;        Per eliminare tutti gli aliases

&lt;yellow&gt;Utilizzo:&lt;r&gt;
  &lt;aliasName&gt;&lt;alias&gt;&lt;/aliasName&gt; &lt;input&gt;[argomento]&lt;/input&gt;           Per eseguire l'alias

&lt;yellow&gt;Carattere speciale&lt;r&gt; &lt;input&gt;#&lt;/input&gt;
Normalmente, durante l'esecuzione di un alias, l'input passato come parametro ad un alias viene appeso al comando o sostituito all'ultima variabile del comando (se presente). Il carattere speciale &lt;input&gt;#&lt;/input&gt; permette di specificare il punto esatto all'interno del comando dove inserire il testo di input.

&lt;yellow&gt;Carattere speciale&lt;r&gt; ]]..ui.colors.varID..ui.varID..[[&lt;r&gt;
Per utilizzare una variabile precedentemente dichiarata con il comando &lt;link variable&gt;uiv[ariables]&lt;/link&gt; all'interno di un alias usare il carattere speciale ]]..ui.colors.varID..ui.varID..[[&lt;r&gt; prima delnome della variabile.

&lt;yellow&gt;Caratteri speciali&lt;r&gt; ]]..ui.colors.separator..[[;&lt;r&gt; o ]]..ui.colors.separator..[[/&lt;r&gt;
Utilizzare uno dei seguenti carattere speciali per dividere più comandi all'interno dello stesso alias

&lt;yellow&gt;Esempio 1: Comando semplice&lt;r&gt;
  Dichiarazione:
    ▷ &lt;command&gt;uia&lt;/command&gt; &lt;aliasName&gt;hl&lt;/aliasName&gt; &lt;aliasOutput&gt;cast 'heal'&lt;/aliasOutput&gt;

  Esecuzione:
    ▷ &lt;aliasName&gt;hl&lt;/aliasName&gt;
    ◁ &lt;aliasOutput&gt;cast 'heal'&lt;/aliasOutput&gt;       

  Esecuzione con parametri:
    ▷ &lt;aliasName&gt;hl&lt;/aliasName&gt; Pippo
    ◁ &lt;aliasOutput&gt;cast 'heal'&lt;/aliasOutput&gt; Pippo 
    
  L'input viene appeso al comando.

&lt;yellow&gt;Esempio 2: Comando con variabile&lt;r&gt;
  Dichiarazione:
    ▷ &lt;command&gt;uia&lt;/command&gt; &lt;aliasName&gt;bt&lt;/aliasName&gt; bash &lt;varName&gt;target&lt;/varName&gt;   
   
  Con &lt;varName&gt;target&lt;/varName&gt; precedentemente inizializzato a &lt;varValue&gt;Pluto&lt;/varValue&gt;

  Esecuzione:
    ▷ &lt;aliasName&gt;bt&lt;/aliasName&gt;
    ◁ bash &lt;varValue&gt;Pluto&lt;/varValue&gt;

  Esecuzione con parameri:
    ▷ &lt;aliasName&gt;bt&lt;/aliasName&gt; Pippo
    ◁ bash Pippo
  
L'ultima variabile viene sostituita dall'input. Il valore della variabile, in questo caso &lt;varName&gt;target&lt;/varName&gt;, non cambierà

&lt;yellow&gt;Esempio 3: Comando con più variabili&lt;r&gt;
  Dichiarazione:
    ▷ &lt;command&gt;uia&lt;/command&gt; &lt;aliasName&gt;aa&lt;/aliasName&gt; &lt;varName&gt;action&lt;/varName&gt; &lt;varName&gt;target&lt;/varName&gt;
  
  Con &lt;varName&gt;action&lt;/varName&gt; precedentemente inizializzata a &lt;varValue&gt;kick&lt;/varValue&gt; e &lt;varName&gt;target&lt;/varName&gt; a &lt;varValue&gt;Pluto&lt;/varValue&gt;
   
  Esecuzione:
    ▷ &lt;aliasName&gt;aa&lt;/aliasName&gt;
    ◁ &lt;varValue&gt;kick&lt;/varValue&gt; &lt;varValue&gt;Pluto&lt;/varValue&gt;

  Esecuzione con parameri:
    ▷ &lt;aliasName&gt;aa&lt;/aliasName&gt; Pippo
    ◁ &lt;varValue&gt;kick&lt;/varValue&gt; Pippo 
  
  L'ultima variabile viene sostituita dall'input. Il valore della variabile, in questo caso &lt;varName&gt;target&lt;/varName&gt;, non cambierà

&lt;yellow&gt;Esempio 4: Comandi multipli con input a posizione definita
  Dichiarazione:
    ▷ &lt;command&gt;uia&lt;/command&gt; &lt;aliasName&gt;dd&lt;/aliasName&gt; &lt;aliasOutput&gt;get&lt;/aliasOutput&gt; &lt;input&gt;#&lt;/input&gt; &lt;varName&gt;bag&lt;/varName&gt; ]]..ui.colors.separator..[[/&lt;r&gt; &lt;aliasOutput&gt;drink&lt;/aliasOutput&gt; &lt;input&gt;#&lt;/input&gt; ]]..ui.colors.separator..[[/&lt;r&gt; &lt;aliasOutput&gt;put&lt;/aliasOutput&gt; &lt;input&gt;#&lt;/input&gt; &lt;varName&gt;bag&lt;/varName&gt;
  
  Con &lt;varName&gt;bag&lt;/varName&gt; precedentemente inizializzata a &lt;varValue&gt;moltetasche&lt;/varValue&gt;

  Esecuzione con parameri:
    ▷ &lt;aliasName&gt;dd&lt;/aliasName&gt; limonata
    ◁ [1] &lt;aliasOutput&gt;get&lt;/aliasOutput&gt; &lt;input&gt;limonata&lt;/input&gt; &lt;varValue&gt;moltetasche&lt;/varValue&gt;
    ◁ [2] &lt;aliasOutput&gt;drink&lt;/aliasOutput&gt; &lt;input&gt;limonata&lt;/input&gt;
    ◁ [3] &lt;aliasOutput&gt;put&lt;/aliasOutput&gt; &lt;input&gt;limonata&lt;/input&gt; &lt;varValue&gt;moltetasche&lt;/varValue&gt;
  
  Il carattere speciale &lt;input&gt;#&lt;/input&gt; verrà sostituito dall'imput. Si noti che in caso di mancanza di input, il carattere speciale &lt;input&gt;#&lt;/input&gt; verrà sostituito da uno spazio vuoto

&lt;yellow&gt;Esempio 5: Comandi multipli complessi con alias, variabili e input a posizione definita
  Dichiarazione (si faccia riferimento agli esempi precedenti):
    ▷ &lt;command&gt;uia&lt;/command&gt; &lt;aliasName&gt;gg&lt;/aliasName&gt; &lt;aliasOutput&gt;get&lt;/aliasOutput&gt; &lt;input&gt;#&lt;/input&gt; &lt;varName&gt;bag&lt;/varName&gt;
    ▷ &lt;command&gt;uia&lt;/command&gt; &lt;aliasName&gt;pp&lt;/aliasName&gt; &lt;aliasOutput&gt;put&lt;/aliasOutput&gt; &lt;input&gt;#&lt;/input&gt; &lt;varName&gt;bag&lt;/varName&gt;
    ▷ &lt;command&gt;uia&lt;/command&gt; &lt;aliasName&gt;dd&lt;/aliasName&gt; &lt;aliasName&gt;gg&lt;/aliasName&gt; &lt;input&gt;#&lt;/input&gt; ]]..ui.colors.separator..[[/&lt;r&gt; &lt;aliasOutput&gt;drink&lt;/aliasOutput&gt; &lt;input&gt;#&lt;/input&gt; ]]..ui.colors.separator..[[/&lt;r&gt; &lt;aliasName&gt;pp&lt;/aliasName&gt; &lt;input&gt;#&lt;/input&gt;
  
  Con &lt;varName&gt;bag&lt;/varName&gt; precedentemente inizializzata a &lt;varValue&gt;moltetasche&lt;/varValue&gt;

  Esecuzione con parameri:
    ▷ &lt;aliasName&gt;dd&lt;/aliasName&gt; limonata
    ◁ [1] &lt;aliasName&gt;gg&lt;/aliasName&gt; limonata
      ◁ &lt;aliasOutput&gt;get&lt;/aliasOutput&gt; &lt;input&gt;limonata&lt;/input&gt; &lt;varValue&gt;moltetasche&lt;/varValue&gt;
    ◁ [2] &lt;aliasOutput&gt;drink&lt;/aliasOutput&gt; &lt;input&gt;limonata&lt;/input&gt;
    ◁ [3] &lt;aliasName&gt;pp&lt;/aliasName&gt; limonata
      ◁ &lt;aliasOutput&gt;put&lt;/aliasOutput&gt; &lt;input&gt;limonata&lt;/input&gt; &lt;varValue&gt;moltetasche&lt;/varValue&gt;
  
&lt;yellow&gt;Per maggiori informazioni:&lt;r&gt;
  &lt;link keybind&gt;uik[eibind]&lt;/link&gt; ▷ Comando per la gestione dei tasti rapidi per aliases e targets
 
Ritorna alla pagina principale dell'&lt;link help&gt;help&lt;/link&gt;.
]]
--
ui.help.buttons = [[
&lt;title&gt;Widget Button&lt;/title&gt;Il widget Button contiene dei pulsanti che posso essere assonciati ad un alias creato precedentemente. I pulsanti sono identificati da una lettera (&lt;red&gt;a&lt;r&gt;, &lt;green&gt;b&lt;r&gt; oppure &lt;blue&gt;c&lt;r&gt;) e un numero (da 0 a 9) per un totale di 30 pulsanti configurabili (da &lt;red&gt;a0&lt;r&gt; a &lt;red&gt;a9&lt;r&gt;, da &lt;green&gt;b0&lt;r&gt; a &lt;green&gt;b9&lt;r&gt; e da &lt;blue&gt;c0&lt;r&gt; a &lt;blue&gt;c9&lt;r&gt;).

I pulsanti sono ragruppati per lettera ed è possibile passare da un gruppo all'altro cliccando sui pulsanti a, b e c sulla barra del titolo del widget.

Tramite il comando &lt;link button&gt;uib[uttons]&lt;/link&gt; è possibile configurare i pusanti del widget.

Cliccare su un pulsante o richiamarlo per nome da console equivale a eseguire l'alias a cui è stato associato.

&lt;yellow&gt;Per maggiori informazioni:&lt;r&gt;
  &lt;link button&gt;uib[uttons]&lt;/link&gt;  ▷ Comando per la gestione dei pulsanti del widget Button

Ritorna alla pagina principale dell'&lt;link help&gt;help&lt;/link&gt;.
]]
--
ui.help.button = [[
&lt;title&gt;Gestione dei pulsanti del widget Button&lt;/title&gt;Tramite il comando &lt;command&gt;uib[uttons]&lt;/command&gt; è possibile associare, cambiare o rimuovere un alias a uno dei 30 pulsanti del widget Button.

Una volta associato ad un alias, sul pulsante appariranno le informazioni relative al suo nome (in alto a sinistra), all'alias associato (al centro) e al tasto di scelta rapida associato all'alias (in basso a destra, se presente). Si noti che il tasto di scelta rapida va associato all'alias (tramite il comando &lt;link keybind&gt;uik[eibind]&lt;/link&gt;) e non al pulsante.

&lt;yellow&gt;Configurazione:&lt;r&gt;
  &lt;command&gt;uib[uttons]&lt;/command&gt;                   Per visualizzare l'elenco dei pulsanti configurati
  &lt;command&gt;uib[uttons]&lt;/command&gt; &lt;button&gt;&lt;button&gt;&lt;/button&gt;          Per visualizzare il singolo pulsante
  &lt;command&gt;uib[uttons]&lt;/command&gt; &lt;button&gt;&lt;button&gt;&lt;/button&gt; &lt;aliasName&gt;&lt;alias&gt;&lt;/aliasName&gt;  Per associare un alias al pusante
  &lt;command&gt;uib[uttons]&lt;/command&gt; &lt;button&gt;&lt;button&gt;&lt;/button&gt; &lt;command&gt;remove&lt;/command&gt;   Per eliminare l'alias associato al pulsante
  &lt;command&gt;uib[uttons] remove_all&lt;/command&gt;        Per eliminare gli aliases associati a tutti i pulsanti

&lt;yellow&gt;Utilizzo:&lt;r&gt;
  &lt;button&gt;&lt;button&gt;&lt;/button&gt; o click             Per eseguire l'alias associato al pulsante

&lt;button&gt;&lt;button&gt;&lt;/button&gt; deve essere compreso tra uno dei 30 pulsanti disponibili (da &lt;red&gt;a0&lt;r&gt; a &lt;red&gt;a9&lt;r&gt;, da &lt;green&gt;b0&lt;r&gt; a &lt;green&gt;b9&lt;r&gt; e da &lt;blue&gt;c0&lt;r&gt; a &lt;blue&gt;c9&lt;r&gt;).

&lt;yellow&gt;Per maggiori informazioni:&lt;r&gt;
  &lt;link buttons&gt;Buttons&lt;/link&gt;     ▷ Widget bottoni per alias
  &lt;link alias&gt;uia[liases]&lt;/link&gt; ▷ Comando per gestire gli aliases

Ritorna alla pagina principale dell'&lt;link help&gt;help&lt;/link&gt;.
]]
--
ui.help.chat = [[
&lt;title&gt;Widget Chat&lt;/title&gt;Il widget Chat cattura e visualizza in modo automatico (via trigger) i testi di comunicazione privati (tel, send, etc) e pubblici (gossip, ot, etc).

Tramite il tasto nella barra del titolo è possibile scegliere se visualizzare solo i messaggi privati (private), solo i messagi pubblici (public) oppure tutti i messaggi (all). Nel caso in cui sia attiva la visualizzazione di tutti i messaggi, tramite il tasto "split" è possibile suddividere la visualizzazione dei messaggi privati\pubblici in orizzontale, verticale o ragruppati in un unica finestra.

Ritorna alla pagina principale dell'&lt;link help&gt;help&lt;/link&gt;.
]]
--
ui.help.color = [[
&lt;title&gt;Colori&lt;/title&gt;Tramite il comando &lt;command&gt;uiColors&lt;/command&gt; è possibile visualizzare l'elenco dei colori che si possono utilizzare negli &lt;link highlight&gt;highlight&lt;/link&gt;.  

&lt;yellow&gt;Utilizzo:&lt;r&gt;
  &lt;command&gt;uic[olors]&lt;/command&gt;    Per visualizzare l'elenco dei colori

Ritorna alla pagina principale dell'&lt;link help&gt;help&lt;/link&gt;.
]]
--
ui.help.endowment = [[&lt;title&gt;Widget Endowment&lt;/title&gt;Il widget Endowment visualizza i dati relativi all'equipaggiamento e si aggiorna manualmente con il comando &lt;command&gt;equipment&lt;/command&gt;. Ogni elemento del widget rappresenta un pezzo dell'equipaggiamento indossato ed è composto dal suo nome (al centro), il numero dello slot che occupa (in alto a sinistra), il nome dello slot che occupa (i basso a sinistra, abbreviato a 3 lettere), il suo livello di potenza (in alto a destra) e la sua percentuale di usura (in basso a destra). La percentuale di usura determina anche il colore del bordo dell'elemento (100%=grigio poi &lt;green&gt;verde&lt;r&gt;, &lt;yellow&gt;giallo&lt;r&gt;, &lt;orange&gt;arancione&lt;r&gt;, &lt;red&gt;rosso&lt;r&gt;, &lt;brown&gt;marrone&lt;r&gt;).

Rimanendo con il cursore del mouse su un elemento è possibile visualizzare un tooltip con le caratteristiche principali del pezzo selezionato. Queste informazioni vengono ricaricate automaticamente con il comando &lt;command&gt;equipment statistic&lt;/command&gt;. Inoltre il tooltip visualizzarà nella parte inferiore anche le statistiche dell'ultimo oggetto identificato, per permettere un paragone veloce e diretto.

Ritorna alla pagina principale dell'&lt;link help&gt;help&lt;/link&gt;.
]]
--
ui.help.fontsize = [[
&lt;title&gt;Impostare la dimensione del font dei widget&lt;/title&gt;Tramite il comando &lt;command&gt;uif[ontsize]&lt;/command&gt; è possibile cambiare la dimensione del font di alcuni widget dell'UI.

&lt;yellow&gt;Utilizzo:&lt;r&gt;
  &lt;command&gt;uif[ontsize]&lt;/command&gt; &lt;input&gt;&lt;widget&gt;&lt;/input&gt; &lt;input&gt;&lt;dimensione&gt;&lt;/input&gt;

I &lt;input&gt;&lt;widget&gt;&lt;/input&gt; a cui è possibile cambiare la dimensione del font sono: &lt;input&gt;all&lt;/input&gt; (per tutti contemporaneamente), &lt;input&gt;chat&lt;/input&gt;, &lt;input&gt;help&lt;/input&gt; o &lt;input&gt;room&lt;/input&gt;.

Le &lt;input&gt;&lt;dimensione&gt;&lt;/input&gt; del font devono essere un valore compreso tra &lt;varValue&gt;1&lt;/varValue&gt; e &lt;varValue&gt;30&lt;/varValue&gt;.

Ritorna alla pagina principale dell'&lt;link help&gt;help&lt;/link&gt;.
]]
--
ui.help.group = [[
&lt;title&gt;Widget Group&lt;/title&gt;Il widget Group visualizza automaticamente (via trigger) i dati relativi ai componenti del gruppo a cui si partecipa, visualizzabili con il comando "gruppo". Il leader del gruppo viene evidenziato col simbolo 👑 a fianco al nome.

Cliccando su un elemento del gruppo, la variabile &lt;varName&gt;target&lt;/varName&gt; viene autimaticamente aggiornata con il nome del componente del gruppo cliccato.

Lo stesso effetto lo si ottiene digitanto il nome dell'elemento del gruppo (da &lt;button&gt;g0&lt;/button&gt; a &lt;button&gt;g9&lt;/button&gt;) oppure con la combinazione di tasti rapidi associata all'elemento del gruppo (visualizzata in basso a destra).

Questa funzionalità, combinata con gli alias, permette di eseguire comandi specifici sull'avversario.

&lt;yellow&gt;Per maggiori informazioni:&lt;r&gt;
  &lt;link target&gt;g0..g9&lt;/link&gt;,
  &lt;link target&gt;o0&lt;/link&gt;,
  &lt;link target&gt;t1..t4&lt;/link&gt;       ▷ Comandi per la gestione della variabile &lt;var&gt;target&lt;/var&gt;
  &lt;link keybind&gt;uik[eibind]&lt;/link&gt;  ▷ Comando per la gestione dei tasti rapidi per aliases e targets

Ritorna alla pagina principale dell'&lt;link help&gt;help&lt;/link&gt;.
]]        
--
ui.help.highlight = [[
&lt;title&gt;Highlights&lt;/title&gt;Gli Highlights permettono di evidenziare parole o frasi del mud cambiandone il colore. Questo può semplificare la visualizzazione di elementi importanti all'interno del testo come, ad esempio, evidenziare la presenza di una &lt;red&gt;cassa&lt;r&gt; o di una &lt;cyan&gt;chiave&lt;r&gt; nella descrizione di una stanza.

&lt;yellow&gt;Configurazione:&lt;r&gt;
  &lt;command&gt;uihi[lights]&lt;/command&gt;                   Per visualizzare l'elenco degli highlights
  &lt;command&gt;uihi[lights]&lt;/command&gt; &lt;testo&gt;           Per visualizzare il colore del testo
  &lt;command&gt;uihi[lights]&lt;/command&gt; &lt;testo&gt; &lt;colore&gt;  Per associare un colore a un testo
  &lt;command&gt;uihi[lights]&lt;/command&gt; &lt;testo&gt; &lt;command&gt;remove&lt;/command&gt;    Per eliminare highlights associato al testo
  &lt;command&gt;uihi[lights] remove_all&lt;/command&gt;        Per eliminare gli aliases associati a tutti i pulsanti

E' possibile visualizzare un elenco dei colori disponibili per gli highlights utilizzando il comando &lt;link color&gt;uic[olors]&lt;/link&gt;.

Ritorna alla pagina principale dell'&lt;link help&gt;help&lt;/link&gt;.
]]
ui.help.keybind = [[
&lt;title&gt;Tasti rapidi per aliases e target&lt;/title&gt;Tramite il comando &lt;command&gt;uik[eybind]&lt;/command&gt; è possibile associare una combinazione di tasti rapidi a un &lt;link alias&gt;alias&lt;/link&gt; o a un &lt;link target&gt;target&lt;/link&gt;.

&lt;yellow&gt;Configurazione:&lt;r&gt;
  &lt;command&gt;uik[eybind]&lt;/command&gt;                           Per visualizzare l'elenco dei tasti rapidi
  &lt;command&gt;uik[eybind]&lt;/command&gt; &lt;aliasName&gt;&lt;alias&gt;&lt;/aliasName&gt;|&lt;button&gt;&lt;target&gt;&lt;/button&gt;          Per visualizzare i tasti dell'alias\del target
  &lt;command&gt;uik[eybind]&lt;/command&gt; &lt;aliasName&gt;&lt;alias&gt;&lt;/aliasName&gt;|&lt;button&gt;&lt;target&gt;&lt;/button&gt; &lt;keybind&gt;&lt;tasti&gt;&lt;/keybind&gt;  Per associare uun tasto all'alias\al target
  &lt;command&gt;uik[eybind]&lt;/command&gt; &lt;aliasName&gt;&lt;alias&gt;&lt;/aliasName&gt;|&lt;button&gt;&lt;target&gt;&lt;/button&gt; &lt;command&gt;remove&lt;/command&gt;   Per eliminare i tasti dell'alias\del target
  &lt;command&gt;uik[eybind] remove_all&lt;/command&gt;                Per eliminare tutti i tasti rapidi

I tasti utillizzabili possono essere o i tasti funzione (&lt;keybind&gt;f1&lt;/keybind&gt;, &lt;keybind&gt;f2&lt;/keybind&gt;, &lt;keybind&gt;f3&lt;/keybind&gt;, etc) o i caratteri dell'alfabeto (&lt;keybind&gt;a&lt;/keybind&gt;, &lt;keybind&gt;b&lt;/keybind&gt;, &lt;keybind&gt;c&lt;/keybind&gt;, etc) o i numeri (&lt;keybind&gt;0&lt;/keybind&gt;, &lt;keybind&gt;1&lt;/keybind&gt;, &lt;keybind&gt;2&lt;/keybind&gt;, etc), presi singolarmente oppure preceduti da &lt;keybind&gt;CTRL&lt;/keybind&gt; o &lt;keybind&gt;ALT&lt;/keybind&gt; (o entrambi).

&lt;yellow&gt;Per maggiori informazioni:&lt;r&gt;
  &lt;link target&gt;g0..g9&lt;/link&gt;,
  &lt;link target&gt;o0&lt;/link&gt;,
  &lt;link target&gt;t1..t4&lt;/link&gt;      ▷ Comandi per la gestione della variabile &lt;var&gt;target&lt;/var&gt;
  &lt;link alias&gt;uia[liases]&lt;/link&gt; ▷ Comando per gestire gli aliases
 
Ritorna alla pagina principale dell'&lt;link help&gt;help&lt;/link&gt;.
]]
--
ui.help.opponent = [[
&lt;title&gt;Widget Opponent&lt;/title&gt;Il widget Opponent visualizza automaticamente (via GMCP) i dati dell'avversario contro cui si sta combattendo relativi a nome, livello e HP (barra rossa).

Cliccando sulla barra degli HP, la variabile &lt;varName&gt;target&lt;/varName&gt; viene autimaticamente aggiornata con il nome dell'avversario.

Lo stesso effetto lo si ottiene digitanto il nome del widget (&lt;button&gt;o0&lt;/button&gt;) oppure con la combinazione di tasti rapidi associata all'avversario (visualizzata in basso a destra).

Questa funzionalità, combinata con gli alias, permette di eseguire comandi specifici sull'avversario.

&lt;yellow&gt;Per maggiori informazioni:&lt;r&gt;
  &lt;link target&gt;g0..g9&lt;/link&gt;,
  &lt;link target&gt;o0&lt;/link&gt;,
  &lt;link target&gt;t1..t4&lt;/link&gt;       ▷ Comandi per la gestione della variabile &lt;var&gt;target&lt;/var&gt;
  &lt;link keybind&gt;uik[eibind]&lt;/link&gt;  ▷ Comando per la gestione dei tasti rapidi per aliases e targets

Ritorna alla pagina principale dell'&lt;link help&gt;help&lt;/link&gt;.
]]
--
ui.help.player = [[
&lt;title&gt;Widget Player&lt;/title&gt;Il widget Player visualizza automaticamente (via GMCP) i dati del personaggio in gioco relativi a nome, razza, classe, livello, HP (barra rossa), mana (barra blu) e movimanto (barra verde). Inoltre è possibile tenere sotto controlo il tick counter (barra sopra la barra HP) e l'esperienza (barra sotto la barra del movimento).

Ritorna alla pagina principale dell'&lt;link help&gt;help&lt;/link&gt;.
]]
--
ui.help.setting = [[
&lt;title&gt;Setting&lt;/title&gt;Tramite l'utilizzo dei setting è possibile importare &lt;link alias&gt;alias&lt;/link&gt;, &lt;link highlight&gt;highlights&lt;/link&gt;, &lt;link targets&gt;target&lt;/link&gt; e &lt;link variable&gt;variables&lt;/link&gt; da un qualsiasi profilo di muddlet precedentemente salvato al profilo attuale.
Il nome del personaggio con cui è stato effetuaro il login viene usato come nome del suo personale setting. I settings vengono creati automaticamente in ogni profilo Mudlet, per ogni personaggio. 
Dall'elenco dei settings è possibile visualizzare il nome del profilo Mudlet e il personaggio a cui fa riferimento.

&lt;yellow&gt;Configurazione:&lt;r&gt;
  &lt;command&gt;uis[etting]&lt;/command&gt;                           Per visualizzare l'elenco di tutti i setting disponibili
  &lt;command&gt;uis[etting]&lt;/command&gt; &lt;profile&gt;&lt;numero profilo&gt;&lt;/profile&gt; &lt;command&gt;import&lt;/command&gt;   Per importare un setting
  &lt;command&gt;uis[etting]&lt;/command&gt; &lt;profile&gt;&lt;numero profilo&gt;&lt;/profile&gt; &lt;command&gt;remove&lt;/command&gt;   Per rimuovere un setting

Il &lt;profile&gt;&lt;numero profilo&gt;&lt;/profile&gt; da uilizzare è il numero visibile nell'elenco dei setting.
Non è possibile importare o eliminare i setting attualmente in uso, anche se vengono visualizzati nell'elenco.

Ritorna alla pagina principale dell'&lt;link help&gt;help&lt;/link&gt;.
]]
--
ui.help.room = [[
&lt;title&gt;Widget Room&lt;/title&gt;Il widget Room visualizza i dati relativi alla stanza in cui si trova attualmete il personaggio e si aggiorna automaticamente (via trigger) ad ogni spostamento o "look" della stanza.

Il widget è composto da un quadrato in formato ASCII che rappresenta la stanza in cui ci si trova sul quale è possibile visualizzare le uscite disponibili (con frecce che indicano le direzioni nord, est, sud, ovest, su e giu) e la posizione del personaggio all'interno della stanza (con un cerchio crociato, vedere il comando &lt;command&gt;sposta&lt;/command&gt;).

A fianco al quadrato vengono riportate eventuali altre uscite speciali o portali (se presenti).

Ritorna alla pagina principale dell'&lt;link help&gt;help&lt;/link&gt;.
]]
--
ui.help.target = [[
&lt;title&gt;Target (g0..g9, o0, t1..t4)&lt;/title&gt;La variable &lt;varName&gt;target&lt;/varName&gt; è una variabile predefinita utilizzabile negli &lt;link alias&gt;uia[liases]&lt;/link&gt; e che è possibile impostare in modi differenti.

Oltre ad essere getibile come semplice variabile tramite il comando &lt;link variable&gt;uiv[ariables]&lt;/link&gt; è possibile impostarla utilizzando o i 4 tasti del widget Target (&lt;button&gt;t1&lt;/button&gt;, &lt;button&gt;t2&lt;/button&gt;, &lt;button&gt;t3&lt;/button&gt; e &lt;button&gt;t4&lt;/button&gt;), o cliccando sull'avversario ingaggiato dal widget Opponent (&lt;button&gt;o0&lt;/button&gt;) o ancora cliccando su uno dei componenti del gruppo dal widget Gruppo.
di gioco (da &lt;button&gt;g0&lt;/button&gt; a &lt;button&gt;g9&lt;/button&gt;).

I tasti del widget Target &lt;button&gt;t1&lt;/button&gt;, &lt;button&gt;t2&lt;/button&gt;, &lt;button&gt;t3&lt;/button&gt; e &lt;button&gt;t4&lt;/button&gt; sono configurabili, mentre &lt;button&gt;o0&lt;/button&gt; e da &lt;button&gt;g0&lt;/button&gt; a &lt;button&gt;g9&lt;/button&gt; sono preimpostati in base all'avversario ingaggiato o alla composizione attuale del gruppo.

&lt;yellow&gt;Configurazione:&lt;r&gt;
  &lt;command&gt;t1&lt;/command&gt;|&lt;command&gt;t2&lt;/command&gt;|&lt;command&gt;t3&lt;/command&gt;|&lt;command&gt;t4&lt;/command&gt; &lt;valore&gt;        Per assegnare un valore a &lt;button&gt;t1&lt;/button&gt;, &lt;button&gt;t2&lt;/button&gt;, &lt;button&gt;t3&lt;/button&gt; o &lt;button&gt;t4&lt;/button&gt;
  &lt;command&gt;t1&lt;/command&gt;|&lt;command&gt;t2&lt;/command&gt;|&lt;command&gt;t3&lt;/command&gt;|&lt;command&gt;t4 remove&lt;/command&gt;          Per rimuovere il valore assegnato a &lt;command&gt;t1&lt;/command&gt;, &lt;command&gt;t2&lt;/command&gt;, &lt;command&gt;t3&lt;/command&gt; o &lt;command&gt;t4&lt;/command&gt;

&lt;yellow&gt;Utilizzo:&lt;r&gt;
  &lt;command&gt;g0&lt;/command&gt;| .. | &lt;command&gt;g9&lt;/command&gt; o click sul widget Group      Per assegnare a &lt;varName&gt;target&lt;/varName&gt; il nome del relativo componente del gruppo
  &lt;command&gt;o0&lt;/command&gt;          o click sul widget Opponent   Per assegnare a &lt;varName&gt;target&lt;/varName&gt; il nome dell'avversario ingaggiato
  &lt;command&gt;t1&lt;/command&gt;|&lt;command&gt;t2&lt;/command&gt;|&lt;command&gt;t3&lt;/command&gt;|&lt;command&gt;t4&lt;/command&gt; o click sug widget Targets    Per assegnare a &lt;varName&gt;target&lt;/varName&gt; il valore assegnato a &lt;button&gt;t1&lt;/button&gt;, &lt;button&gt;t2&lt;/button&gt;, &lt;button&gt;t3&lt;/button&gt; o &lt;button&gt;t4&lt;/button&gt;

&lt;yellow&gt;Per maggiori informazioni:&lt;r&gt;
  &lt;link group&gt;Group&lt;/link&gt;       ▷ Widget gruppo
  &lt;link opponent&gt;Opponent&lt;/link&gt;    ▷ Widget dati avversatrio 
  &lt;link targets&gt;Target&lt;/link&gt;      ▷ Widget bottoni per target 
  &lt;link keybind&gt;uik[eibind]&lt;/link&gt; ▷ Comando per la gestione dei tasti rapidi per aliases e targets

Ritorna alla pagina principale dell'&lt;link help&gt;help&lt;/link&gt;.
]]
--
ui.help.targets= [[
&lt;title&gt;Widget Targets&lt;/title&gt;Il widget Target è coposto da 4 pulsanti personalizzabili sui quali è possibile memorizzare 4 target differenti. Clickando su uno dei pulsanti la variabile &lt;varName&gt;Target&lt;/varName&gt; viene aggiornata con il valore che è stato assegnato al pulsante.

Lo stesso effetto lo si ottiene digitanto il nome del pulsante (&lt;button&gt;t1&lt;/button&gt;, &lt;button&gt;t2&lt;/button&gt;, &lt;button&gt;t3&lt;/button&gt; e &lt;button&gt;t4&lt;/button&gt;) oppure con la combinazione di tasti rapidi associata al pulsante (visualizzata su ogni tasto, in basso a destra).

Questa funzionalità, combinata con gli alias, permette di passare velcemente da un target all'altro.

&lt;yellow&gt;Per maggiori informazioni:&lt;r&gt;
  &lt;link target&gt;g0..g9&lt;/link&gt;,
  &lt;link target&gt;o0&lt;/link&gt;,
  &lt;link target&gt;t1..t4&lt;/link&gt;       ▷ Comandi per la gestione della variabile &lt;var&gt;target&lt;/var&gt;
  &lt;link keybind&gt;uik[eibind]&lt;/link&gt;  ▷ Comando per la gestione dei tasti rapidi per aliases e targets

Ritorna alla pagina principale dell'&lt;link help&gt;help&lt;/link&gt;.
]]
--
ui.help.variable = [[
&lt;title&gt;Variabili&lt;/title&gt;E' possibile definire delle variabili (retentive) da riutilizzare negli alias.
E' possibile richiamare una variabile all'interno di un alias facendo precedere al nome della variabile il carattere speciale &lt;command&gt;]]..ui.varID..[[&lt;/command&gt;.
Alcune delle variabili sono già dichiarate (variabili predefinite), e vengno utilizzate per gli elementi l'interfaccia.
Le variabili sono utilizzabili nel codice dei vostri script facendo accesso alla tabella LUA ui.variables[nomevariabile].

&lt;yellow&gt;Configurazione:&lt;r&gt;
  &lt;command&gt;uiv[ariable]&lt;/command&gt;|&lt;command&gt;]]..ui.varID..[[&lt;/command&gt;                       Per visualizzare l'elenco delle variabili
  &lt;command&gt;uiv[ariable]&lt;/command&gt;|&lt;command&gt;]]..ui.varID..[[&lt;/command&gt; &lt;varName&gt;&lt;nome&gt;&lt;/varName&gt;               Per visualizzare il valore di una variabile
  &lt;command&gt;uiv[ariable]&lt;/command&gt;|&lt;command&gt;]]..ui.varID..[[&lt;/command&gt; &lt;varName&gt;&lt;nome&gt;&lt;/varName&gt; &lt;varValue&gt;&lt;valore&gt;&lt;/varValue&gt;      Per creare o modificare una variabile
  &lt;command&gt;uiv[ariable]&lt;/command&gt;|&lt;command&gt;]]..ui.varID..[[&lt;/command&gt; &lt;varName&gt;&lt;nome&gt;&lt;/varName&gt; &lt;command&gt;remove&lt;/command&gt;        Per rimuovere una variabile
  &lt;command&gt;uiv[ariable]&lt;/command&gt;|&lt;command&gt;]]..ui.varID..[[&lt;/command&gt; &lt;command&gt;remove_all&lt;/command&gt;            Per rimuovere tutte le variabili

Ritorna alla pagina principale dell'&lt;link help&gt;help&lt;/link&gt;.
]]
--
ui.help.walk = [[
&lt;title&gt;Walk, Speedwalk e Backwalk&lt;/title&gt;Tramite il comandi "&lt;command&gt;.&lt;/command&gt;" è possibile percorrere un &lt;percorso&gt; espressi nel formato "ee2w4suuu9n".

Tramite il comando "&lt;command&gt;..&lt;/command&gt;" oltre che ripercorrere un &lt;percorso&gt; all'indietro. 

&lt;yellow&gt;Utilizzo:&lt;r&gt;
  &lt;command&gt;.&lt;/command&gt;&lt;percorso&gt;   Per eseguire il percorso specificato
  &lt;command&gt;..&lt;/command&gt;&lt;percorso&gt;  Per eseguire il percorso specificato all'indietro

Ritorna alla pagina principale dell'&lt;link help&gt;help&lt;/link&gt;.
]]
--
ui.help.widget = [[
&lt;title&gt;Ripristino dei widget chiusi&lt;/title&gt;E' possibile ripristinare i widget dell'UI che sono stati minimizzati o chiusi.

&lt;yellow&gt;Utilizzo:&lt;r&gt;
  &lt;command&gt;uiw[idget] &lt;nome_widget&gt;&lt;/command&gt;

I &lt;command&gt;&lt;nome_widget&gt;&lt;/command&gt; disponibili sono: &lt;exec uiwidget all&gt;all&lt;/exec&gt; (ripristina tutti i widgets), &lt;exec uiwidget affects&gt;affects&lt;/exec&gt;, &lt;exec uiwidget buttons&gt;buttons&lt;/exec&gt;, &lt;exec uiwidget chat&gt;chat&lt;/exec&gt;, &lt;exec uiwidget endowment&gt;endowment&lt;/exec&gt;, &lt;exec uiwidget group&gt;group&lt;/exec&gt;, &lt;exec uiwidget help&gt;help&lt;/exec&gt;, &lt;exec uiwidget opponent&gt;opponent&lt;/exec&gt;, &lt;exec uiwidget player&gt;player&lt;/exec&gt;, &lt;exec uiwidget room&gt;room&lt;/exec&gt; o &lt;exec uiwidget target&gt;target&lt;/exec&gt; per i relativi widgets.

Ritorna alla pagina principale dell'&lt;link help&gt;help&lt;/link&gt;.
]]
--
ui.help.widgets = [[
&lt;title&gt;Widgets&lt;/title&gt;I widget sono gli elementi a finestra che compongono l'interfaccia e permettono di interagire con il gioco per avere una visuale più completa delle informazioni che il gioco stesso mette a disposizione.

Tutti i widget hanno la possibilità di essere spostati, ridimensionato, chiusi (tasto &lt;cyan&gt;&lt;x&gt;&lt;r&gt; nella barra del titolo), nascosti (tasto &lt;cyan&gt;&lt;_&gt;&lt;r&gt; nella barra del titolo) o ripristinati (con il comando &lt;link widget&gt;uiw[idget]&lt;/link&gt;). Alcuni widget possono essere resi trasparenti (tasto &lt;cyan&gt;&lt;...&gt;&lt;r&gt; nella barra del titolo) per personalizare il più possibile la disposizione dei widget all'interno dell'area di gioco.

I widget sono creati utilizzando il componeti &lt;cyan&gt;Geyser Adjustable Container&lt;r&gt; di Mudlet (fare riferimento all'help on line di Mudlet) che integrano delle funzionalità comuni accessibili dal menù che appare cliccando con il tasto destro sulla barra del titolo.
Tra queste funzionalità merita di essere menzionata la possibilità di agganciare il widget a un bordo della finestra principale di gioco. Per fare questo è sufficente spostare il widget contro il bordo al quale lo si vuole agganciare, cliccare con tasto destro sulla barra del titolo e selezionare &lt;cyan&gt;&lt;Aggancia a:&gt;&lt;r&gt;. Apparirà un sottomenù con i nomi dei bordi della finestra principale (es: basso, destra, etc) ai quali sarà possibie agganciare il widget. Per sganciare il widget dal bordo è sufficiente spostare il widget lontano dal bordo al quale è stato agganciato.

Ritorna alla pagina principale dell'&lt;link help&gt;help&lt;/link&gt;.
]]
end</script>
				<eventHandlerList />
			</Script>
			<Script isActive="yes" isFolder="no">
				<name>Help</name>
				<packageName></packageName>
				<script>--
function ui.fHelp(cmd)
  ui.fDebug("[&lt;cyan&gt;call&lt;r&gt;] ui.fHelp("..(cmd or "nil")..")")
  --
  local line
  --
  -- Restore widget
  clearWindow("GUI.Help.Main.Console")
  --
  -- Command
  if cmd and cmd ~= "" then
    cmd = cmd:lower():gsub(" ","_")
    if not ui.help[cmd] then
      cmd = "error"
    end
  else
    cmd = "help"
  end
  --
  -- Pharse lines
  for line in ui.help[cmd]:gmatch("([^\n]*)\n") do
    local str_match, end_match = rex.find(line, [[\&lt;(?&lt;tag&gt;[^&gt;\s]+)(?&lt;argument&gt;\s*[^&gt;]*)\&gt;(?&lt;inside&gt;.*?)\&lt;\/\k&lt;tag&gt;\&gt;]])
    while (str_match) do
      local before = ""
      local match  = string.sub(line, str_match, end_match);
      local after  = ""
      local tag, argument, inside = rex.match(match, [[\&lt;(?&lt;tag&gt;[^&gt;\s]+)(?&lt;argument&gt;\s*[^&gt;]*)\&gt;(?&lt;inside&gt;.*?)\&lt;\/\k&lt;tag&gt;\&gt;]])
      --
      if (str_match &gt; 1) then
        before = string.sub(line, 1, str_match-1);
      end
      --
      if (end_match &lt; string.len(line)) then
        after = string.sub(line, end_match+1, string.len(line));
      end
      --
      -- Before
      GUI.Help.Main.Console:cecho(before)
      --
      -- Match
      tag = tag:lower()
      --
      if (tag == "alias") then
        inside = ui.fGetAliasFormattedText(inside)          
        GUI.Help.Main.Console:cecho(inside)
      --
      elseif (tag == "aliasname") then
        inside = ui.fGetAliasNameFormattedText(inside)
        GUI.Help.Main.Console:cecho(inside)
      --
      elseif (tag == "aliasoutput") then
        inside = ui.fGetAliasOutputFormattedText(inside)
        GUI.Help.Main.Console:cecho(inside)
      --
      elseif (tag == "button") then
        inside = ui.colors.aliasButton..inside.."&lt;r&gt;"          
        GUI.Help.Main.Console:cecho(inside)
      --
      elseif (tag == "command") then
        inside = ui.fGetCommandFormattedText(inside)
        GUI.Help.Main.Console:cecho(inside)
      --
      elseif (tag == "exec") then
        local fgColor = string.gsub(ui.colors.link, "[\&lt;\&gt;]", "");
        argument = string.trim(argument);
        GUI.Help.Main.Console:cechoLink(ui.cLink(inside), [[expandAlias("]]..argument..[[")]], argument, true)
      --
      elseif (tag == "input") then
        inside = ui.fGetInputFormattedText(inside)          
        GUI.Help.Main.Console:cecho(inside)
      --
      elseif (tag == "keybind") then
        inside = ui.colors.keybind..inside.."&lt;r&gt;"          
        GUI.Help.Main.Console:cecho(inside)        
      --
      elseif (tag == "link") then
        local fgColor = string.gsub(ui.colors.link, "[\&lt;\&gt;]", "");
        argument = string.trim(argument);
        GUI.Help.Main.Console:cechoLink(ui.cLink(inside), [[ui.fHelp("]]..argument..[[")]], argument, true)
      --
      elseif (tag == "profile") then
        inside = ui.fGetSettingNameFormattedText(inside)
        GUI.Help.Main.Console:cecho(inside)
      --
      elseif (tag == "title") then
        inside = ui.fTitle(inside)
        GUI.Help.Main.Console:cecho(inside)
      --
      elseif (tag == "var") then
        inside = ui.fGetVarFormattedText(inside)
        GUI.Help.Main.Console:cecho(inside)
      --
      elseif (tag == "varname") then
        inside = ui.colors.varID..ui.varID..ui.colors.varName..inside.."&lt;r&gt;"
        GUI.Help.Main.Console:cecho(inside)
      --
      elseif (tag == "varvalue") then
        inside = ui.fGetVarValueFormattedText(inside)          
        GUI.Help.Main.Console:cecho(inside)
      else
        -- Match non riconosciuto
        GUI.Help.Main.Console:cecho(match)
      end
      --
      line = after
      str_match, end_match = rex.find(line, [[\&lt;(?&lt;tag&gt;[^&gt;\s]+)(?&lt;argument&gt;\s*[^&gt;]*)\&gt;(?&lt;inside&gt;.*?)\&lt;\/\k&lt;tag&gt;\&gt;]])
    end
    --
    -- line\after
    GUI.Help.Main.Console:cecho(line.."\n")
  end
  GUI.Help:show()
  GUI.Help.Main.Console:enableScrolling ()
  GUI.Help.Main.Console:scrollTo(1)
end
--
function ui.fHelp_links(htext, hlinktext, hurl, hcaption)
  ui.fDebug("[&lt;cyan&gt;call&lt;r&gt;] ui.fHelp_links(...)")
  --
  --
  if (htext ~= nil) and (hlinktext ~= nil) and (hurl ~= nil) and (hcaption ~= nil) then
    --
    GUI.Help:cecho(ui.colors.text..htext.." ")
    --
    GUI.Help:cechoLink(ui.colors.link..hlinktext..ui.colors.text.."\n",
                       [[openWebPage("https://]]..hurl..[[")]],
                       hcaption,
                       true)
  end
end</script>
				<eventHandlerList />
			</Script>
			<Script isActive="yes" isFolder="no">
				<name>Highlights</name>
				<packageName></packageName>
				<script>--
function ui.fGetHighlightFormattedText(highlight)
  if (ui.highlights[highlight]) then
    return "&lt;"..ui.highlights[highlight].color.."&gt;"..highlight.."&lt;r&gt;"
  end
  --
  return ""
end
--
function ui.fShowAllHighlights()
  ui.fDebug("[&lt;cyan&gt;call&lt;r&gt;] ui.fShowAllHighlights()")
  --
  local i = 0
  local num
  --
  cecho(ui.fTitle("Highlights"))
  for highlight in pairs(ui.highlights) do
    i = i + 1
    cecho(ui.fGetNumberFormattedText(i).." "..ui.fGetHighlightFormattedText(highlight).."\n")
  end
  if (i&gt;0) then
    echo("\n")
  else
    cecho("Non ci sono highlights.\n\n")
  end
end
--
function ui.fRemoveHighlight(highlight)
  ui.fDebug("[&lt;cyan&gt;call&lt;r&gt;] ui.fRemoveHighlight("..(highlight.."nil")..")")
  --
  if (ui.highlights[highlight]) then
    if (ui.highlights[highlight].id) then
      killTrigger(ui.highlights[highlight].id)
    end
    ui.highlights[highlight] = nil
    --
    return true
  end
  --
  return false
end
--
function ui.fRemoveAllHighlights()
  ui.fDebug("[&lt;cyan&gt;call&lt;r&gt;] ui.fRemoveAllHighlights()")
  --
  for highlight in pairs(ui.highlights) do
    ui.fRemoveHighlight(highlight)
  end
  ui.highlights = {}
end
--
function ui.fAddHighlight(highlight, color)
  ui.fDebug("[&lt;cyan&gt;call&lt;r&gt;] ui.fRemoveHighlight("..(highlight.."nil")..", "..(color.."nil")..")")
  --
  if ui.fColorCheck(color) then
    highlight = highlight or "" 
    if (highlight ~= "") then
      --
      -- Init highlight (if not exist)
      ui.highlights[highlight] = ui.highlights[highlight] or {}
      --
      -- Remove old highlight
      if (ui.highlights[highlight].id) then
        killTrigger(ui.highlights[highlight].id)
      end
      --
      -- Create trigger
      ui.highlights[highlight].id = tempRegexTrigger([[(?i)(?:^|\W|\s)(]]..highlight..[[)(?:\W|$|\s)]], function()
                                                                                                          selectString(matches[2], 1)
                                                                                                          fg(color)
                                                                                                          resetFormat()
                                                                                                        end)
      ui.highlights[highlight].color = color
      --
      return 1
    end
    --
    return -1 -- Invaid text
  end
  --
  return -2 -- Invalid color
end
--
-- Save Highlights data from file
function ui.fSaveFileHighlights()
  ui.fDebug("[&lt;cyan&gt;call&lt;r&gt;] ui.fSaveFileHighlights()")
  --
  if (ui.setting) then
    local file = ui.files.highlights.path..ui.setting.."/"..ui.files.highlights.name
    local highlightsDataToSave = {}
    --
    for highlight in pairs(ui.highlights) do
      highlightsDataToSave[highlight] = {}
      highlightsDataToSave[highlight].color = ui.highlights[highlight].color
    end
    table.save(file, highlightsDataToSave)
  end
end
--
-- Read Highlights data from file
function ui.fReadFileHighlights()
  ui.fDebug("[&lt;cyan&gt;call&lt;r&gt;] ui.fReadFileHighlights()")
  --
  local file = ui.files.highlights.path..ui.setting.."/"..ui.files.highlights.name
  --
  -- Remove actual Highlights
  ui.highlights = ui.highlights or {}
  ui.fRemoveAllHighlights()
  --
  -- Load Highlights
  if (io.exists(file)) then
    table.load(file, ui.highlights)
  end
  --
  -- Create Highlights
  for highlight in pairs(ui.highlights) do
    ui.fAddHighlight(highlight, ui.highlights[highlight].color)
  end
end</script>
				<eventHandlerList />
			</Script>
			<Script isActive="yes" isFolder="no">
				<name>Keybind</name>
				<packageName></packageName>
				<script>--
function ui.fGetKeybFormattedText(keybind)
  if (keybind) then
    return ui.colors.keybind.."&lt;"..keybind.."&gt;".."&lt;r&gt;"
  end
  return ""
end
--
-- Validate 3 keys for keybind (order: mod1 mod2 key)
function ui.fGetKeyb(key1, key2, key3)
  local isValid = false;
  local mod1 = "";
  local mod2 = "";
  local key = "";
  local keybind = ""
  --
  key1 = string.upper(key1 or "")
  key2 = string.upper(key2 or "")
  key3 = string.upper(key3 or "")
  if (key3 ~= "") then  -- es: key1=CTRL key2=ALT key3=F1
    if (key1 ~= key2) and
       (table.contains(ui.keyb_modifier, key1)) and
       (table.contains(ui.keyb_modifier, key2)) and
       (table.contains(ui.keyb_single,   key3)) then
      local idx1 = table.index_of(table.keys(ui.keyb_modifier), key1)
      local idx2 = table.index_of(table.keys(ui.keyb_modifier), key2)
      mod1 = idx1 &lt; idx2 and key2 or key1
      mod2 = idx1 &lt; idx2 and key1 or key2
      key = key3
      isValid = true
    end
  elseif (key2 ~= "") then  -- es: key1=CTRL key2=F1
    if (table.contains(ui.keyb_modifier, key1) and table.contains(ui.keyb_single, key2))then
      mod1 = key1
      mod2 = ""
      key = key2
      isValid = true
    end
  elseif (key1~= "") then -- es: key1=F1
    if (table.contains(ui.keyb_single, key1)) then
      mod1 = ""
      mod2 = ""
      key = key1
      isValid = true
    end
  else
    mod1 = ""
    mod2 = ""
    key = ""
    isValid = true
  end
  --
  if (mod2 ~= "") then
    keybind = string.gsub(mod1 or "", "(%a)([%w_']*)", ui.fTitleCase).."+"..
              string.gsub(mod2 or "", "(%a)([%w_']*)", ui.fTitleCase).."+"..
              string.gsub( key or "", "(%a)([%w_']*)", ui.fTitleCase)
  elseif (mod1 ~= "") then
    keybind = string.gsub(mod1 or "", "(%a)([%w_']*)", ui.fTitleCase).."+"..
              string.gsub( key or "", "(%a)([%w_']*)", ui.fTitleCase)
  elseif (key ~= "") then
    keybind = string.gsub( key or "", "(%a)([%w_']*)", ui.fTitleCase)
  end
  --
  return isValid, mod1, mod2, key, keybind
end
--
function ui.fSearchKeyb(table, keybind, excludeKey)
  keybind = keybind or ""
  excludeKey = excludeKey or ""
  if (keybind ~= "") and (table) then
    for key in pairs(table) do
      if (key ~= excludeKey) and (table[key].keybind == keybind) then
        return key
      end
    end
  end
  --
  return nil
end
--
function ui.fShowAllKeyb()
  ui.fDebug("[&lt;cyan&gt;call&lt;r&gt;] ui.fShowAllKeyb()")
  --
  local orderTable = {}
  --
  -- Order Target keybind
  for target in pairs(ui.targets) do
    orderTable[#orderTable+1] = target
  end
  table.sort(orderTable, function (target1, target2) 
                           keybind1 = ui.targets[target1].keybind or ""
                           keybind2 = ui.targets[target2].keybind or ""                  
                           if (rex.match(keybind1, [[F\d$]])) then
                             keybind1 = keybind1:gsub("F%w", "F0%1")                             
                           end
                           if (rex.match(keybind2, [[F\d$]])) then
                             keybind2 = keybind2:gsub("F%w", "F0%1")                             
                           end
                           return keybind1 &lt; keybind2
                         end )
  --
  -- Show Target keybind
  cecho(ui.fTitle("Keybind associati ai Target"))
  for i,target in ipairs(orderTable) do
    if (ui.targets[target].keybId) then
      cecho(ui.fGetNumberFormattedText(i).." ")
      cechoLink(ui.cLink("X"), [[expandAlias("uikeybind ]]..target..[[ remove")]], "Rimuovi il keybind associato al target '"..target.."'", true)
      cecho(" "..ui.fGetTargetFormattedText(target, true)..ui.fGetOperatorFormattedText(" » "))
      if (ui.targets[target].target) then
        cecho(ui.fGetVarNameFormattedText("target")..ui.fGetOperatorFormattedText(" = ")..ui.fGetVarValueFormattedText(ui.targets[target].target))
      else
        cecho("&lt;r&gt;non configurato")
      end
      cecho("\n")
    end
  end
  --
  -- Order Aliases keybind
  orderTable = {}
  for alias in pairs(ui.aliases) do
    if (ui.aliases[alias].keybId) then
      orderTable[#orderTable+1] = alias
    end
  end
  table.sort(orderTable, function (alias1, alias2) 
                           keybind1 = ui.aliases[alias1].keybind
                           keybind2 = ui.aliases[alias2].keybind                           
                           if (rex.match(keybind1, [[F\d$]])) then
                             keybind1 = keybind1:gsub("F%w", "F0%1")                             
                           end
                           if (rex.match(keybind2, [[F\d$]])) then
                             keybind2 = keybind2:gsub("F%w", "F0%1")                             
                           end
                           return keybind1 &lt; keybind2
                         end )
  --
  -- Show Aliases keybind
  cecho(ui.fTitle("Keybind associati agli Aliases"))
  for i,alias in ipairs(orderTable) do
      cecho(ui.fGetNumberFormattedText(i).." ")
      cechoLink(ui.cLink("X"), [[expandAlias("uikeybind ]]..alias..[[ remove")]], "Rimuovi il keybind associato all'alias '"..alias.."'", true)
      cecho(" "..ui.fGetKeybFormattedText(ui.aliases[alias].keybind)..ui.fGetOperatorFormattedText(" » "))
    ui.fLinkAlias(alias)
    cecho("\n")
  end
  if (#orderTable==0) then
    cecho("Non ci sono keybind.\n\n")
  else
    echo("\n")
  end
end
--
-- Delete keybind from a table
function ui.fRemoveKeyb(element)
  if (element) then
    if (element.mod1) then
      element.mod1 = nil
    end
    if (element.mod2) then
      element.mod2 = nil
    end
    if (element.key) then
      element.key = nil
    end
    if (element.keybind) then
      element.keybind = nil
    end
    if (element.keybId) then
      killKey(element.keybId)
      element.keybId = nil
      --
      return 1 -- keyb removed
    end
    --
    return -1 -- Not keyb to remove
  end
  --
  return -2 -- Invalid element
end
--
function ui.fRemoveAllKeyb()
  ui.fDebug("[&lt;cyan&gt;call&lt;r&gt;] ui.fRemoveAllKeyb()")
  --
  for element in pairs(ui.aliases) do
    ui.fRemoveKeyb(ui.aliases[element])
  end
  --
  for element in pairs(ui.targets) do
    ui.fRemoveKeyb(ui.targets[element])
  end
end
--
-- Set, modify or delete a keybind
function ui.fSetKeyb(table, tKey, code, key1, key2, key3)
  local isValid, mod1, mod2, key, keybind = ui.fGetKeyb(key1, key2, key3)
  --
  if (table[tKey]) then
    if (isValid) then
      if (ui.fSearchKeyb(ui.targets, keybind, tKey) == nil) then
        if (ui.fSearchKeyb(ui.aliases, keybind, tKey) == nil) then
          --
          -- Remove old keybind
          ui.fRemoveKeyb(table[tKey]);
          --
          -- Create new keybind
          if (mod2 ~= "") then
            table[tKey].keybId = tempKey(ui.keyb_modifier[mod1] + ui.keyb_modifier[mod2], ui.keyb_single[key], code)
          elseif (mod1 ~= "") then
            table[tKey].keybId = tempKey(ui.keyb_modifier[mod1], ui.keyb_single[key], code)
          elseif (key ~= "") then
            table[tKey].keybId = tempKey(ui.keyb_single[key], code)
          else
            return 2, keybind -- keybind removed
          end
          --
          -- Save data
          table[tKey].mod1 = mod1
          table[tKey].mod2 = mod2
          table[tKey].key = key
          table[tKey].keybind = keybind
          --
          return 1, keybind -- keybind changed or created
        end
        --
        return -4, keybind -- keybind already used in an alias
      end
      --
      return -3, keybind -- keybind already used in a target
    end
    --
    return -2, keybind -- Not valid keys
  end
  --
  return -1, keybind -- Alias not exist
end
</script>
				<eventHandlerList />
			</Script>
			<Script isActive="yes" isFolder="no">
				<name>Opponent</name>
				<packageName></packageName>
				<script>--
function ui.fDifTimerOpponent(time_left)
  ui.fDebug("[&lt;cyan&gt;call&lt;r&gt;] ui.fDifTimerOpponent(&lt;white&gt;"..(time_left or "nil").."&lt;r&gt;)", 3)
  --
  if (ui.handlers.fDifTimerOpponent) then
    killTimer(ui.handlers.fDifTimerOpponent)
    ui.handlers.fDifTimerOpponent = nil;
  end
  --
  if (time_left &gt; 0) then
    ui.handlers.fDifTimerOpponent = tempTimer(time_left, function() ui.fDifTimerOpponent(0.0) end)
    GUI.Opponent.Main.Health.dif:show()
  else
    GUI.Opponent.Main.Health.dif:hide()
  end
end
--
function ui.fUpdateOpponent()
  ui.fDebug("[&lt;cyan&gt;call&lt;r&gt;] ui.fUpdateOpponent()")
  --
  local title
  local hpGaugeWidthDif = GUI.Opponent.Main.Health.front:get_width()
  --
  -- init
  ui.opponent       = {}
  ui.opponent.hp    = 0
  ui.opponent.hpmax = 100
  ui.opponent.level = 0
  ui.opponent.name  = ""
  --
  if (ui.enDebug &gt;= 2) then
    ui.opponent.hp         = math.random(0, 100)
    ui.opponent.hpmax      = 100
    ui.opponent.level      = math.random(1, 60)
    ui.opponent.name       = "C4tt1v0ne di d3bug"
  elseif (gmcp.MSDP) then
    ui.opponent.hp         = gmcp.MSDP.OPPONENT_HEALTH or ui.opponent.hp
    ui.opponent.hpmax      = gmcp.MSDP.OPPONENT_HEALTH_MAX
    ui.opponent.level      = gmcp.MSDP.OPPONENT_LEVEL or ui.opponent.level
    ui.opponent.name       = gmcp.MSDP.OPPONENT_NAME or ui.opponent.name
  end
  --
  if (hpGaugeWidthDif == 0) and (ui.opponent.hp &gt; 0) then
    -- Engage
    hpGaugeWidthDif = GUI.Opponent.Main.Health.back:get_width()
  end
  --
  ui.opponent.hp = tonumber(ui.opponent.hp) or 0
  --
  if (ui.opponent.name ~= "") then
    --
    -- Showed name
    title = ui.opponent.name;
    --
    -- Name
    ui.opponent.name = string.gsub(ui.opponent.name, "(\$c%d+)", "")
    ui.opponent.name = ui.fRemoveArticle(ui.opponent.name)
    ui.opponent.name = string.gsub(ui.opponent.name, " ", "-")
    --
    GUI.Opponent.Main.Health.front:echo(ui.opponent.name)
    --
    -- Level
    GUI.Opponent.Level:setFgColor(ui.fLevelColor(ui.opponent.level, ui.player.level))
    GUI.Opponent.Level:echo("&lt;center&gt;"..ui.opponent.level)
    GUI.Opponent.Level:show()
    --
    -- HP
    GUI.Opponent.Main.Health:setValue(math.max(0, ui.opponent.hp), ui.opponent.hpmax, "&lt;p align=right&gt;"..ui.opponent.hp.."%  &lt;/p&gt;")
    --
    -- Keybind
    ui.fAssignTargetButton("o0", ui.opponent.name)    
  else
    --
    -- reset showed name
    title = "* nessuno *"    --
    --
    -- Remove name
    GUI.Opponent.Main.Health.front:echo("")
    --
    -- Hide level
    GUI.Opponent.Level:hide()
    --
    -- Reset HP
    GUI.Opponent.Main.Health:setValue(0, 100, "")
    --
    -- Remove Keybind
    ui.fAssignTargetButton("o0", nil)
  end
  --
  ui.fUpdateAllTargetButtons()
  --
  -- Diff. hp
  hpGaugeWidthDif = GUI.Opponent.Main.Health.front:get_width() - hpGaugeWidthDif
  --
  if (hpGaugeWidthDif ~= 0) then
    local x, y, w, h, txt, CSS
    --
    if (hpGaugeWidthDif &lt; 0) then
      x = GUI.Opponent.Main.Health.front:get_x() - GUI.Opponent.Main:get_x() + GUI.Opponent.Main.Health.front:get_width() - 3
      y = GUI.Opponent.Main.Health.front:get_y() - GUI.Opponent.Main:get_y()
      w = -hpGaugeWidthDif
      h = GUI.Opponent.Main.Health.front:get_height()
      txt = "- -"
      CSS = GUI.CSS.GaugeFront..[[
        qproperty-alignment: 'AlignRight';
        border: 1px solid rgba(255, 0, 0, 0.8);
        background-color: rgba(255, 0, 0, 0.4);
      ]]
    else
      x = GUI.Opponent.Main.Health.front:get_x() - GUI.Opponent.Main:get_x() + GUI.Opponent.Main.Health.front:get_width() - hpGaugeWidthDif
      y = GUI.Opponent.Main.Health.front:get_y() - GUI.Opponent.Main:get_y()
      w = hpGaugeWidthDif
      h = GUI.Opponent.Main.Health.front:get_height()
      txt = "++"
      CSS = GUI.CSS.GaugeFront..[[
        qproperty-alignment: 'AlignRight';
        border: 1px solid rgba(0, 255, 0, 0.8);
        background-color: rgba(0, 255, 0, 0.4);
      ]]
    end
    --
    x = math.max(0, x);
    --
    GUI.Opponent.Main.Health.dif:move(x, y);
    GUI.Opponent.Main.Health.dif:resize(w, h)
    GUI.Opponent.Main.Health.dif:echo(txt)
    GUI.Opponent.Main.Health.dif:setStyleSheet(CSS)
    --
    ui.fDifTimerOpponent(1.5)
  end
  --
  -- Target on title
  if (ui.variables.target) and (ui.variables.target ~= "") then
    title = title.." (T:"..ui.variables.target..")"
  end
  GUI.Opponent:setTitle(title)
end</script>
				<eventHandlerList />
			</Script>
			<Script isActive="yes" isFolder="no">
				<name>Parameters</name>
				<packageName></packageName>
				<script>--
function ui.fGetPreDefinitedParameters()
  return {
    widgets = {
      affects = {
        transparent = false,
      },
      aliasButton ={
        transparent = false,
      },
      chat = {
        type = "all",
        split = "horizontal",    
        fontSize = 10,
      },
      endowment = {
        transparent = false,
      },
      group = {
        transparent = false,
      },
      help = {
        fontSize = 10,
      },
      keybind = {
        fontSize = 6,
      },
      opponent = {
        transparent = false,
      },
      player = {
        transparent = false,
      },
      room = {
        fontSize = 10,
        transparent = false,
      },
      targets = {
        transparent = false,
      },
    },
    page = "a",
  }
end
--
-- Save Parameters data to file
function ui.fSaveFileParameters()
  ui.fDebug("[&lt;cyan&gt;call&lt;r&gt;] ui.fSaveFileParameters()")
  --
  if (ui.setting) then
    local file = ui.files.parameters.path..ui.files.parameters.name
    --
    table.save(file, ui.parameters)
  end
end
--
-- Read Parameters data from file
function ui.fReadFileParameters()
  ui.fDebug("[&lt;cyan&gt;call&lt;r&gt;] ui.fReadFileParameters()")
  --
  local file = ui.files.parameters.path..ui.files.parameters.name
  --
  -- Load parameters
  ui.parameters = ui.parameters or {}
  if (io.exists(file)) then
    table.load(file, ui.parameters)
  end
  ui.parameters = table.update(ui.fGetPreDefinitedParameters(), ui.parameters)
  --
  ui.fSaveFileParameters()
end</script>
				<eventHandlerList />
			</Script>
			<Script isActive="yes" isFolder="no">
				<name>Player</name>
				<packageName></packageName>
				<script>--
function ui.fDifTimerPlayer(time_left)
  ui.fDebug("[&lt;cyan&gt;call&lt;r&gt;] ui.fDifTimerPlayer(&lt;white&gt;"..(time_left or "nil").."&lt;r&gt;)", 3)
  --
  if (ui.handlers.fDifTimerPlayer) then
    killTimer(ui.handlers.fDifTimerPlayer)
    ui.handlers.fDifTimerPlayer = nil;
  end
  --
  if (time_left &gt; 0) then
    ui.handlers.fDifTimerPlayer = tempTimer(time_left, function() ui.fDifTimerPlayer(0.0) end)
    GUI.Player.Main.Health.dif:show()
  else
    GUI.Player.Main.Health.dif:hide()
  end
end
--
function ui.fUpdatePlayer()
  ui.fDebug("[&lt;cyan&gt;call&lt;r&gt;] ui.fUpdatePlayer()")
  --
  local hpGaugeWidthDif = GUI.Player.Main.Health.front:get_width()
  --
  -- init vars
  ui.player = {
    ac             = 0,
    alignment      = 0,
    experience     = 1,
    gold           = 0,
    name           = "",
    hp             = 1,
    maxhp          = 1,
    level          = 0,
    mana           = 1,
    maxmana        = 1,
    mov            = 1,
    maxmov         = 1,
  }
  --
  ui.previous.player = ui.previous.player or ui.player;
  --
  -- for debug
  if (ui.enDebug &gt;= 2) then
    ui.player.ac             = math.random(-100, 100)
    ui.player.alignment      = math.random(-1000, 1000)
    ui.player.experience     = math.random(1, 100000000)
    ui.player.gold           = math.random(1, 100000000)
    ui.player.hp             = math.random(0, 100)
    ui.player.maxhp          = 100
    ui.player.level          = math.random(1, 50)
    ui.player.mana           = math.random(0, 100)
    ui.player.maxmana        = 100
    ui.player.mov            = math.random(0, 100)
    ui.player.maxmov         = 100
    ui.player.name           = "D3Bu4 M0D3"
    
  elseif (gmcp) and (gmcp.MSDP) then
    ui.player.ac             = gmcp.MSDP.AC or ui.player.ac
    ui.player.alignment      = gmcp.MSDP.ALIGNMENT or ui.player.alignment
    ui.player.experience     = gmcp.MSDP.EXPERIENCE or ui.player.experience
    ui.player.gold           = gmcp.MSDP.MONEY or ui.player.gold
    ui.player.hp             = gmcp.MSDP.HEALTH or ui.player.hp
    ui.player.maxhp          = gmcp.MSDP.HEALTH_MAX or ui.player.maxhp
    ui.player.level          = gmcp.MSDP.LEVEL or ui.player.level
    ui.player.mana           = gmcp.MSDP.MANA or ui.player.mana
    ui.player.maxmana        = gmcp.MSDP.MANA_MAX or ui.player.maxmana
    ui.player.mov            = gmcp.MSDP.MOVEMENT or ui.player.mov
    ui.player.maxmov         = gmcp.MSDP.MOVEMENT_MAX or ui.player.maxmov
    ui.player.name           = gmcp.MSDP.CHARACTER_NAME or ui.player.name
  end 
  --
  -- Tittle
  GUI.Player:setTitle(ui.player.name);
  --
  -- Level
  GUI.Player.Level:echo("&lt;center&gt;"..ui.player.level);
  --
  -- HP
  ui.player.hp = tonumber(ui.player.hp)
  ui.player.maxhp = tonumber(ui.player.maxhp)
  local hpPerc = math.floor(100 * ui.player.hp / ui.player.maxhp); 
  --
  if (hpPerc &lt;= 40) then
    playSoundFile(ui.files.sounds.path..[[hurt.wav]], 10)
  end
  --
  GUI.Player.Main.Health:setValue(math.min(math.max(0, ui.player.hp), ui.player.maxhp), ui.player.maxhp,"&lt;p align=right&gt;"..ui.player.hp.."/"..ui.player.maxhp.." - "..hpPerc.."% &lt;/p&gt;")
  --
  -- Mana
  ui.player.mana = tonumber(ui.player.mana)
  ui.player.maxmana = tonumber(ui.player.maxmana)
  local manaPerc = math.floor(100 * ui.player.mana / ui.player.maxmana); 
  --
  if (ui.player.mana &lt; ui.previous.player.mana) then
    playSoundFile(ui.files.sounds.path..[[cast.wav]], 10)
  end
  --
  GUI.Player.Main.Mana:setValue(math.min(math.max(0, ui.player.mana), ui.player.maxmana), ui.player.maxmana, "&lt;p align=right&gt;"..ui.player.mana.."/"..ui.player.maxmana.." - "..manaPerc.."% &lt;/p&gt;")
  --
  -- Stamina
  ui.player.mov = tonumber(ui.player.mov)
  ui.player.maxmov = tonumber(ui.player.maxmov)
  local staminaPerc = math.floor(100 * ui.player.mov / ui.player.maxmov); 
  --
  GUI.Player.Main.Stamina:setValue(math.min(math.max(0, ui.player.mov), ui.player.maxmov), ui.player.maxmov, "&lt;p align=right&gt;"..ui.player.mov.."/"..ui.player.maxmov.." - "..staminaPerc.."% &lt;/p&gt;")
  --
  -- Experience
  ui.player.experience = tonumber(ui.player.experience)
  GUI.Player.Main.Experience:setValue(math.min(math.max(0, ui.player.experience), 300000000), 300000000, "")
  --
  hpGaugeWidthDif = GUI.Player.Main.Health.front:get_width() - hpGaugeWidthDif
  if (hpGaugeWidthDif ~= 0) then
    local x, y, w, h, txt, CSS
    --
    if (hpGaugeWidthDif &lt; 0) then
      x = GUI.Player.Main.Health.front:get_x() - GUI.Player.Main:get_x() + GUI.Player.Main.Health.front:get_width() - 3
      y = GUI.Player.Main.Health.front:get_y() - GUI.Player.Main:get_y()
      w = -hpGaugeWidthDif
      h = GUI.Player.Main.Health.front:get_height()
      txt = "- -"
      CSS = GUI.CSS.GaugeFront..[[
        qproperty-alignment: 'AlignRight';
        border: 1px solid rgba(255, 0, 0, 0.8);
        background-color: rgba(255, 0, 0, 0.4);
      ]]
    else
      x = GUI.Player.Main.Health.front:get_x() - GUI.Player.Main:get_x() + GUI.Player.Main.Health.front:get_width() - hpGaugeWidthDif
      y = GUI.Player.Main.Health.front:get_y() - GUI.Player.Main:get_y()
      w = hpGaugeWidthDif
      h = GUI.Player.Main.Health.front:get_height()
      txt = "++"
      CSS = GUI.CSS.GaugeFront..[[
        qproperty-alignment: 'AlignRight';
        border: 1px solid rgba(0, 255, 0, 0.8);
        background-color: rgba(0, 255, 0, 0.4);
      ]]
    end
    --
    GUI.Player.Main.Health.dif:move(x, y);
    GUI.Player.Main.Health.dif:resize(w, h)
    GUI.Player.Main.Health.dif:echo(txt)
    GUI.Player.Main.Health.dif:setStyleSheet(CSS)
    --
    ui.fDifTimerPlayer(1.5)
  end
  --
  ui.previous.player = ui.player;
end</script>
				<eventHandlerList />
			</Script>
			<Script isActive="yes" isFolder="no">
				<name>Room</name>
				<packageName></packageName>
				<script>function ui.fDrawRoomPosition(position)
  local isPlayerPos = (ui.room.position == position)
  --
  --      
  if (isPlayerPos) then
    return "&lt;white&gt;⨂&lt;r&gt;"
  else
    return "&lt;DimGrey&gt;"..position.."&lt;r&gt;"
  end
end
--
function ui.fDrawRoomLine(line)
  local position = ""
  local icon = ""
  --
  -- Player icon or track direction
  if (ui.track == nil) or (ui.track == "") then
    icon = "&lt;white&gt;⨂&lt;r&gt;"
  else
    icon = ui.validExit[ui.track].color..ui.validExit[ui.track].tokenOpen.."&lt;r&gt;"
  end
  --
  -- Line 1
  if (line == 1) then
    position = ui.fDrawRoomPosition(7).."  "..ui.fDrawRoomPosition(8).."  "..ui.fDrawRoomPosition(9)
  --
  -- Line 2
  elseif (line == 2) then
    position = ui.fDrawRoomPosition(4).."  "..ui.fDrawRoomPosition(5).."  "..ui.fDrawRoomPosition(6)
  --
  -- Line 3
  elseif (line == 3) then
    position = ui.fDrawRoomPosition(1).."  "..ui.fDrawRoomPosition(2).."  "..ui.fDrawRoomPosition(3)
  --
  else
    position = "X  X  X"
  end
  --
  return position
end
--
function ui.fGetToken(exits, dir)
  local token = ""
  --
  if (exits[dir]) then
    -- Close exit
    if (exits[dir].close) then
      token = "&lt;red&gt;"..ui.validExit[dir].tokenClose.."&lt;r&gt;"
    -- Secret exit
    elseif (exits[dir].secret) then
      token = "&lt;red&gt;"..ui.validExit[dir].tokenSecret.."&lt;r&gt;"
    -- Normal exit
    else
      token = ui.validExit[dir].color..ui.validExit[dir].tokenOpen.."&lt;r&gt;"
    end
  -- No exit
  elseif (ui.validExit[dir].tokenAbsent) then
    token = ui.validExit[dir].tokenAbsent
  --
  else
    token = dir;
  end
  --
  return token
end
--
function ui.fUpdateRoom()
  local fw, fh = calcFontSize("GUI.Room.Main.Console")
  local maxChar = math.floor(GUI.Room.Main.Console:get_width() / fw)
  local lastDir = nil;
  --
  ui.room = ui.room or {}
  ui.room.exitCaptured = ui.room.exitCaptured or ""
  ui.room.name = ui.room.name or ""
  ui.room.position = ui.room.position or 5 -- centro
  ui.room.type = ui.room.type or ""
  ui.room.exits = {}
  ui.room.otherExits = {}
  --
  -- Generate directiones table
  for dir in string.gmatch(ui.room.exitCaptured, "[^%s]+") do
    dir = string.lower(dir)
    if (ui.validExit[dir]) then
      lastDir = ui.validExit[dir].short;
      ui.room.exits[lastDir] = {};
    elseif (dir == "(chiuso)") then
      if (lastDir) then
        ui.room.exits[lastDir].close = true;
      end
    elseif (dir == "(segreto)") then
      if (lastDir) then
        ui.room.exits[lastDir].secret = true;
      end
    else
      table.insert(ui.room.otherExits, "▷ "..dir)      
    end
  end
  --
  clearWindow("GUI.Room.Main.Console")
  --
  -- Room name
  GUI.Room:setTitle(ui.room.name.." - "..ui.room.type)
  --
  -- Exits and Position
  GUI.Room.Main.Console:cecho("  ┌───"..ui.fGetToken(ui.room.exits, "n").."───"..ui.fGetToken(ui.room.exits, "u").."    &lt;cyan&gt;"..(ui.room.otherExits[1] or "").."&lt;r&gt;\n")
  GUI.Room.Main.Console:cecho("  │"..ui.fDrawRoomLine(1).."│    &lt;cyan&gt;"..(ui.room.otherExits[2] or "").."&lt;r&gt;\n")
  GUI.Room.Main.Console:cecho("  "..ui.fGetToken(ui.room.exits, "w")..ui.fDrawRoomLine(2)..ui.fGetToken(ui.room.exits, "e").."    &lt;cyan&gt;"..(ui.room.otherExits[3] or "").."&lt;r&gt;\n")
  GUI.Room.Main.Console:cecho("  │"..ui.fDrawRoomLine(3).."│    &lt;cyan&gt;"..(ui.room.otherExits[4] or "").."&lt;r&gt;\n")
  GUI.Room.Main.Console:cecho("  "..ui.fGetToken(ui.room.exits, "d").."───"..ui.fGetToken(ui.room.exits, "s").."───┘    &lt;cyan&gt;"..(ui.room.otherExits[5] or "").."&lt;r&gt;\n")
  --
  -- Other exits
  local idx = 6;
  while (ui.room.otherExits[idx]) do
     GUI.Room.Main.Console:cecho("               &lt;cyan&gt;"..(ui.room.otherExits[idx]).."&lt;r&gt;\n")
     idx = idx + 1
  end
end
--</script>
				<eventHandlerList />
			</Script>
			<Script isActive="yes" isFolder="no">
				<name>Settings</name>
				<packageName></packageName>
				<script>--
function ui.fGetSettingNameFormattedText(setting)
  return ui.colors.settingName..setting.."&lt;r&gt;"
end
--
--
function ui.fInitSettings()
  ui.fDebug("[&lt;cyan&gt;call&lt;r&gt;] ui.fInitSettings()")
  --
  local lfs = require("lfs")
  --
  if (lfs.chdir(ui.files.settings.path)) then
    ui.fEchon("&lt;orange&gt; - Cartella "..ui.colors.settingName.."Settings&lt;orange&gt; inizializzata correttamente.&lt;r&gt;")
    return true
  elseif (lfs.mkdir(ui.files.settings.path)) then
    ui.fEchon("&lt;orange&gt; - Cartella "..ui.colors.settingName.."Settings&lt;orange&gt; creata correttamente.&lt;r&gt;")
    return true
  else
    ui.fEchon("&lt;red&gt; - Impossibile caricare la cartella "..ui.colors.settingName.."Settings&lt;red&gt;.&lt;r&gt;")
  end
  return false
end
--
-- Get saved settings  list
function ui.fGetSettingsList()
  ui.fDebug("[&lt;cyan&gt;call&lt;r&gt;] ui.fGetSettingsList()")
  --
  local lfs = require("lfs")
  local settings = {}
  ui.setting = ui.setting or ""
  --
  -- Overcome saved settings version (for compatibility)
  local settingsDir = getMudletHomeDir().."/../../profilesLeu/"
  if (lfs.chdir(settingsDir)) then
    for s in lfs.dir(settingsDir) do
      if (s ~= ".") and (s ~= "..") and (lfs.chdir(settingsDir..s)) then
        local index = #settings+1 
        settings[index] = {}
        settings[index].setting = s
        settings[index].profile = "profilesLeu"
        settings[index].path = settingsDir..s.."/"
        settings[index].overcome = true          
      end
    end
  end 
  --
  local mudletProfileDir = getMudletHomeDir().."/../"
  if (lfs.chdir(mudletProfileDir)) then
    for p in lfs.dir(mudletProfileDir) do
      if (p ~= ".") and (p ~= "..") and (lfs.chdir(mudletProfileDir..p)) then
        --
        -- Actual overcome settings version (for compatibility)
        settingsDir = mudletProfileDir..p.."/Lumen et Umbra UI/"
        if (lfs.chdir(settingsDir)) then
          local index = #settings+1 
          settings[index] = {}
          settings[index].setting = "&lt;senza nome&gt;"
          settings[index].profile = p
          settings[index].path = settingsDir
          settings[index].overcome = true          
        end
        --
        -- Actual settings version
        settingsDir = mudletProfileDir..p.."/LeU_UI.data/settings/"
        if (lfs.chdir(settingsDir)) then
          for s in lfs.dir(settingsDir) do
            if (s ~= ".") and (s ~= "..") and (lfs.chdir(settingsDir..s)) then
              local index = #settings+1 
              settings[index] = {}
              settings[index].setting = s
              settings[index].profile = p
              settings[index].path = settingsDir..s.."/"
              if (p == getProfileName()) and (s == ui.setting) then
                settings[index].actual = true
              end
            end
          end
        end
        --
      end
    end
  end
  --
  return settings
end
--
-- List all aliases
function ui.fShowAllSettings()
  ui.fDebug("[&lt;cyan&gt;call&lt;r&gt;] ui.fShowAllSettings()")
  --
  local settings = ui.fGetSettingsList()
  local n = 0
  --
  cecho(ui.fTitle("Settings"))
  for s in ui.fOrderedPairs(settings) do
    n = n + 1
    cecho(ui.fGetNumberFormattedText(n).." "..ui.fGetSettingNameFormattedText(settings[s].setting).." in &lt;yellow&gt;"..settings[s].profile.."&lt;r&gt;")
    if (settings[s].overcome) then
      cecho(" &lt;orange&gt;(overcame)&lt;r&gt;")
    end
    if (settings[s].actual) then
      cecho(" &lt;cyan&gt;(attuale)&lt;r&gt;")
    end
    cecho("\n")
  end
  --
  if (n&gt;0) then
    echo("\n")
  else
    cecho("Non ci sono settings.\n\n")
  end
end
--
function ui.fContainSetting(settings, profile, setting)
  for _, s in pairs(settings) do
    if (s.profile == profile) and (s.setting == setting) then
      return s.path
    end
  end
  --
  return nil;
end
--
function ui.fLoadLocalSetting()
  ui.fDebug("[&lt;cyan&gt;call&lt;r&gt;] ui.fLoadLocalSetting()")
  --
  local path = ui.fContainSetting(ui.fGetSettingsList(), getProfileName(), ui.setting)
  --
  if (path) then
    --
    -- Load variables
    ui.fReadFileVariables()
    --
    -- Load targets
    ui.fReadFileTargets()
    --
    -- Load Aliases
    ui.fReadFileAliases()
    --
    -- Load Highlights
    ui.fReadFileHighlights()
    --
    -- Update Target Buttons
    ui.fRefreshTargetButtonsWidget()
    --
    --  Opponent and Groups are also targets. Widgets needed before updating
    ui.fUpdateAllTargetButtons()
    ui.fUpdateOpponent()
    ui.fUpdateGroup()
    --
    -- Update Chat
    ui.fUpdateChat()
    --
    -- Update Player
    ui.fUpdatePlayer()
    --
    -- Update Alias Button
    ui.fUpdateAliasButton()
    --
    -- Update Affects
    ui.fUpdateAffects()
    --
    -- Update Room
    ui.fUpdateRoom()
    --
    -- Update Endowment
    ui.fUpdateEndowment()
    --
    return true
  end
  --
  return nil
end
--
function ui.fRemoveSetting(number)
  ui.fDebug("[&lt;cyan&gt;call&lt;r&gt;] ui.fRemoveSetting("..(number or "nil")..")")
  --
  local settings = ui.fGetSettingsList()
  number = tonumber(number or 0)
  --
  if (number &gt; 0) and (number &lt;= #settings) and (settings[number]) and (not settings[number].actual) then
    ui.fDeleteDirectory(settings[number].path)
    --
    return true
  end
  --
  return nil
end
--
function ui.fImportSetting(number)
  ui.fDebug("[&lt;cyan&gt;call&lt;r&gt;] ui.fImportSetting("..(number or "nil")..")")
  --
  local settings = ui.fGetSettingsList()
  number = tonumber(number or 0)
  --
  if (number &gt; 0) and (number &lt;= #settings) and (settings[number]) and (not settings[number].actual) then
    ui.fCopyFile(settings[number].path..ui.files.aliases.name,    ui.files.settings.path..ui.setting.."/"..ui.files.aliases.name)
    ui.fCopyFile(settings[number].path..ui.files.highlights.name, ui.files.settings.path..ui.setting.."/"..ui.files.highlights.name)
    ui.fCopyFile(settings[number].path..ui.files.targets.name,    ui.files.settings.path..ui.setting.."/"..ui.files.targets.name)
    ui.fCopyFile(settings[number].path..ui.files.variables.name,  ui.files.settings.path..ui.setting.."/"..ui.files.variables.name)
    --
    ui.fRemoveAllHighlights()
    ui.fRemoveAllAliasButtons()
    ui.fRemoveAllKeyb()
    ui.fRemoveAllAliases()
    ui.fRemoveAllVariables()
    --
    ui.fLoadLocalSetting()
    --
    return true
  end
  --
  return nil
end
--
function ui.fSaveSetting()
  ui.fDebug("[&lt;cyan&gt;call&lt;r&gt;] ui.fSaveSetting()")
  --
  local lfs = require("lfs")
  local path = ui.fContainSetting(ui.fGetSettingsList(), getProfileName(), ui.setting)
  --
  if (path ~= nil) then
    ui.fDeleteDirectory(path)
  end
  --
  if (lfs.mkdir(ui.files.settings.path..ui.setting)) then
    return true
  end
  --
  return nil
end</script>
				<eventHandlerList />
			</Script>
			<Script isActive="yes" isFolder="no">
				<name>Structures (init)</name>
				<packageName></packageName>
				<script>function ui.initStructures()
  ui.release = getPackageInfo("LeU_UI", "version")
  ui.echo = "&lt;blue&gt;[  &lt;DodgerBlue&gt;UI  &lt;blue&gt;] "
  ui.transparentID = '&lt;center&gt;⋯'
  ui.varID = "&amp;"
  --
  -- Colors
  ui.colors = {
    aliasButton  = "&lt;orange&gt;",
    aliasName    = "&lt;violet&gt;",
    aliasOutput  = "&lt;r&gt;",  -- "&lt;PaleGoldenrod&gt;"
    command      = "&lt;steel_blue&gt;",
    error        = "&lt;DarkOrange&gt;",
    input        = "&lt;bisque&gt;", -- #
    keybind      = "&lt;cyan&gt;",
    link         = "&lt;gold&gt;",
    operator     = "&lt;gold&gt;",         -- » or «
    settingName  = "&lt;green&gt;",
    separator    = "&lt;orange_red&gt;",     -- ; or /
    target       = "&lt;orange&gt;",
    text         = "&lt;r&gt;",
    title        = "&lt;white&gt;",
    varID        = "&lt;steel_blue&gt;",
    varName      = "&lt;LightBlue&gt;",
    varCont      = "&lt;MediumSeaGreen&gt;",
    widget       = "25,20,20",
    wBackground  = "30,24,24",
    wBorder      = "90,72,72",
    wButton      = "90,72,72",
    wButtonHover = "180,144,144",
    wText        = "69,69,69",
  }
  --
  local mudletHomeDir = getMudletHomeDir()
  --
  ui.files = {
    aliases = {
      path = mudletHomeDir.."/LeU_UI.data/settings/",
      name = "aliases.lua",
    },
    data = {
      path = mudletHomeDir.."/LeU_UI.data/",
    },
    highlights = {
      path = mudletHomeDir.."/LeU_UI.data/settings/",
      name = "highlights.lua",
    },
    icons = {
      path = mudletHomeDir.."/LeU_UI/icons/",
    },
    images = {
      path = mudletHomeDir.."/LeU_UI/images/",
    },
    parameters = {
      path = mudletHomeDir.."/LeU_UI.data/",
      name = "parameters.lua",
    },
    settings = {
      path = mudletHomeDir.."/LeU_UI.data/settings/",
    },
    sounds = {
      path = mudletHomeDir.."/LeU_UI/sounds/",
    },
    targets    = {
      path = mudletHomeDir.."/LeU_UI.data/settings/",
      name = "targets.lua",
    },
    variables  = {
      path = mudletHomeDir.."/LeU_UI.data/settings/",
      name = "variables.lua",
    },
  }
  --
  -- Modifier for keybind
  ui.keyb_modifier = {
    CTRL = mudlet.keymodifier.Control,
    ALT  = mudlet.keymodifier.Alt,
  }
  --
  -- Keys for keybind
  ui.keyb_single = {
    ["0"] = mudlet.key["0"],
    ["1"] = mudlet.key["1"],
    ["2"] = mudlet.key["2"],
    ["3"] = mudlet.key["3"],
    ["4"] = mudlet.key["4"],
    ["5"] = mudlet.key["5"],
    ["6"] = mudlet.key["6"],
    ["7"] = mudlet.key["7"],
    ["8"] = mudlet.key["8"],
    ["9"] = mudlet.key["9"],
    --
    A = mudlet.key.A,
    B = mudlet.key.B,
    C = mudlet.key.C,
    D = mudlet.key.D,
    E = mudlet.key.E,
    F = mudlet.key.F,
    G = mudlet.key.G,
    H = mudlet.key.H,
    I = mudlet.key.I,
    J = mudlet.key.J,
    K = mudlet.key.k,
    L = mudlet.key.L,
    M = mudlet.key.M,
    N = mudlet.key.N,
    O = mudlet.key.O,
    P = mudlet.key.P,
    Q = mudlet.key.Q,
    R = mudlet.key.R,
    S = mudlet.key.S,
    T = mudlet.key.T,
    U = mudlet.key.U,
    V = mudlet.key.V,
    W = mudlet.key.W,
    X = mudlet.key.X,
    Y = mudlet.key.Y,
    Z = mudlet.key.Z,
    --
    F1  = mudlet.key.F1,
    F2  = mudlet.key.F2,
    F3  = mudlet.key.F3,
    F4  = mudlet.key.F4,
    F5  = mudlet.key.F5,
    F6  = mudlet.key.F6,
    F7  = mudlet.key.F7,
    F8  = mudlet.key.F8,
    F9  = mudlet.key.F9,
    F10 = mudlet.key.F10,
    F11 = mudlet.key.F11,
    F12 = mudlet.key.F12,
  }
  --
  ui.validExit = {
    down  = {short = "d", long = "down",  reverse = "u", tokenOpen = "⤦", tokenClose = "□", tokenAbsent = "└", tokenFrom = "◆", tokenSecret = "S", color = "&lt;white&gt;", dColor = "&lt;255,255,255:30,24,24&gt;",},
    east  = {short = "e", long = "east",  reverse = "w", tokenOpen = "▷", tokenClose = "□", tokenAbsent = "│", tokenFrom = "◆", tokenSecret = "S", color = "&lt;yellow&gt;", dColor = "&lt;255,255,0:30,24,24&gt;",},
    north = {short = "n", long = "north", reverse = "s", tokenOpen = "△", tokenClose = "□", tokenAbsent = "─", tokenFrom = "◆", tokenSecret = "S", color = "&lt;green&gt;", dColor = "&lt;0,255,0:30,24,24&gt;",},
    south = {short = "s", long = "south", reverse = "n", tokenOpen = "▽", tokenClose = "□", tokenAbsent = "─", tokenFrom = "◆", tokenSecret = "S", color = "&lt;blue&gt;", dColor = "&lt;0,0,255:30,24,24&gt;",},
    up    = {short = "u", long = "up",    reverse = "d", tokenOpen = "⤤", tokenClose = "□", tokenAbsent = "┐", tokenFrom = "◆", tokenSecret = "S", color = "&lt;cyan&gt;", dColor = "&lt;0,255,255:30,24,24&gt;",},
    west  = {short = "w", long = "west",  reverse = "e", tokenOpen = "◁", tokenClose = "□", tokenAbsent = "│", tokenFrom = "◆", tokenSecret = "S", color = "&lt;magenta&gt;", dColor = "&lt;255,0,255:30,24,24&gt;",},
  }
  --
  ui.validExit["basso"] = ui.validExit.down
  ui.validExit["d"]     = ui.validExit.down
  --
  ui.validExit["est"]   = ui.validExit.east
  ui.validExit["e"]     = ui.validExit.east
  --
  ui.validExit["nord"]  = ui.validExit.north
  ui.validExit["n"]     = ui.validExit.north
  --
  ui.validExit["sud"]   = ui.validExit.south
  ui.validExit["s"]     = ui.validExit.south
  --
  ui.validExit["alto"]  = ui.validExit.up
  ui.validExit["u"]     = ui.validExit.up
  --
  ui.validExit["w"]     = ui.validExit.west
  ui.validExit["ovest"] = ui.validExit.west
  ui.validExit["o"]     = ui.validExit.west
  --
  -- Affects
  ui.affects = {}
  --
  -- Aliases
  ui.aliases = {}
  --
  -- Equipment
  ui.equipment = {}
  --
  -- Group
  ui.group = {}
  --
  -- Handlers
  ui.handlers = {}
  --
  -- Highlights
  ui.highlights = {}
  --
  -- Opponent
  ui.opponent = {}
  --
  -- Player
  ui.player = {}
  --
  -- Previous
  ui.previous = {}
  --
  -- Setting
  ui.setting = nil
  -- 
  -- Targets
  ui.targets = {
    g0 = { mod1 = "CTRL", mod2 = "", key = "F10" },
    g1 = { mod1 = "CTRL", mod2 = "", key = "F1" },
    g2 = { mod1 = "CTRL", mod2 = "", key = "F2" },
    g3 = { mod1 = "CTRL", mod2 = "", key = "F3" },
    g4 = { mod1 = "CTRL", mod2 = "", key = "F4" },
    g5 = { mod1 = "CTRL", mod2 = "", key = "F5" },
    g6 = { mod1 = "CTRL", mod2 = "", key = "F6" },
    g7 = { mod1 = "CTRL", mod2 = "", key = "F7" },
    g8 = { mod1 = "CTRL", mod2 = "", key = "F8" },
    g9 = { mod1 = "CTRL", mod2 = "", key = "F9" },
    --
    o0 = { mod1 = "CTRL", mod2 = "", key = "0" },
    --
    t1 = { mod1 = "CTRL", mod2 = "", key = "1" },
    t2 = { mod1 = "CTRL", mod2 = "", key = "2" },
    t3 = { mod1 = "CTRL", mod2 = "", key = "3" },
    t4 = { mod1 = "CTRL", mod2 = "", key = "4" },
  }
  --
  -- Variables
  ui.variables = {}
  --
  -- GMCP
  gmcp = {}
  --
  --
  ui.fDebug("[&lt;white&gt;init&lt;r&gt;] Structures") 
end</script>
				<eventHandlerList />
			</Script>
			<Script isActive="yes" isFolder="no">
				<name>Targets</name>
				<packageName></packageName>
				<script>--
function ui.fClickTarget(sender)
  ui.fDebug("[&lt;cyan&gt;call&lt;r&gt;] ui.fClickTarget("..(sender or "nil")..")")
  --
  if (sender) then
    local type, number = ui.fExpandButton(sender)
    --
    if (type == "g") or (type == "o") then
      ui.fExecuteTargetButton(sender)
    end
  end
end
--
function ui.fGetTargetChild(type, number)
  if (type == "g") then
    return GUI.Group.Main[type..number];
  elseif (type == "o") then
    return GUI.Opponent.Main
  elseif (type == "t") then
    return GUI.TargetButtons.Main[type..number]
  else
    return nil
  end
end
--
function ui.fGetTargetFormattedText(target, keybind)
  local str = ui.colors.target..target
  keybind = keybind or false
  --
  if (keybind) and (ui.targets[target]) and (ui.targets[target].keybId) then
    str = ui.fGetKeybFormattedText(ui.targets[target].keybind)..ui.fGetOperatorFormattedText(" » ")..str
  end
  --
  return str.."&lt;r&gt;"
end
--
function ui.fRefreshTargetButtonsWidget()
  ui.fDebug("[&lt;cyan&gt;call&lt;r&gt;] ui.fRefreshTargetButtonsWidget()")
  --
  local distance = 3; 
  local w_h = GUI.TargetButtons.Main:get_height() - distance;
  local w_w = GUI.TargetButtons.Main:get_width() -  distance;
  local h = distance + 25;
  local w = distance + 120;
  local x = 0
  local y = 0
  local r = 1
  local c = 1
  local tot_r, tot_c
  local total = 4
  --
  tot_c = math.max(1, math.min(math.floor(w_w / w), total));
  -- When working with negative numbers math.floor() returns the closest integer less than or equal to a given value
  tot_r = -math.floor(-total/tot_c);
  --
  -- Recalc w if possible
  w = w_w / tot_c
  --
  -- Recalc h if possible
  h = w_h / tot_r
  --
  for i = 1, 4 do
    if (r &gt; tot_r) then
      GUI.TargetButtons.Main["t"..i]:hide();
    else
      GUI.TargetButtons.Main["t"..i]:resize(w - distance, h - distance)
      GUI.TargetButtons.Main["t"..i]:move(distance + (c-1)*w, distance + (r-1)*h)
      GUI.TargetButtons.Main["t"..i]:show();
      --
      c = c + 1
      if (c &gt; tot_c) then
        c = 1;
        r = r + 1
      end
    end
  end
end
--
-- Refresh target button
function ui.fUpdateSingleTargetButton(button)
  ui.fDebug("[&lt;cyan&gt;call&lt;r&gt;] ui.fUpdateSingleTargetButton("..(button or "nil")..")")
  --
  local type, number = ui.fExpandButton(button)
  local child = ui.fGetTargetChild(type, number)
  --
  if (child ~= nil) then
    button = type..number 
    if (ui.targets[button]) then
      local mod1 = ui.targets[button].mod1 or "";
      local mod2 = ui.targets[button].mod2 or "";
      local key = ui.targets[button].key or "";
      local result, keybind
      local target
      local CCS, bgColor, bgColorHover
      --
      -- Target
      if (ui.targets[button].target) and (ui.targets[button].target ~= "") then
        target = ui.targets[button].target
      else
        target = "'"..button.."'";
      end
      --
      -- Keybind
      if (mod2 ~= "") then
        result, keybind = ui.fSetKeyb(ui.targets, button, [[ui.fExecuteTargetButton("]]..button..[[")]], mod2, mod1, key)
      elseif (mod1 ~= "") then
        result, keybind = ui.fSetKeyb(ui.targets, button, [[ui.fExecuteTargetButton("]]..button..[[")]], mod1, key)
      elseif (key ~= "") then
        result, keybind = ui.fSetKeyb(ui.targets, button, [[ui.fExecuteTargetButton("]]..button..[[")]], key)
      else
        result, keybind = ui.fSetKeyb(ui.targets, button, [[ui.fExecuteTargetButton("]]..button..[[")]])
      end
      --
      if (result &lt;= 0) then
        ui.fRemoveKeyb(ui.targets[button])
      end
      --
      -- Echo
      child.keybind:echo("&lt;p align=right&gt;"..keybind.."&lt;/p&gt;")
      --
      -- CCS
      if (type == "g") or (type == "o") then
        --CCS = GUI.CSS.BorderPlayer;
        CCS = [[
          border-radius: 4px; 
        ]]
        bgColor      = "150, 0, 0, 0.4"
        bgColorHover = "150, 0, 0, 1"
      --
      elseif (type == "t") then
        GUI.TargetButtons.Main[button]:echo("&lt;center&gt;"..target)
        CCS = GUI.CSS.Button;
        bgColor      = "75, 0, 0, 1"
        bgColorHover = "150, 0, 0, 1"
      end
      --
      if (target == ui.variables["target"]) then
        child:setStyleSheet([[
          QLabel{
            ]]..CCS..[[
            background-color: rgba(]]..bgColorHover..[[);
          }
        ]])
      else
        child:setStyleSheet([[
          QLabel{
            ]]..CCS..[[
            background-color: rgba(]]..bgColor..[[);
          }
          QLabel::hover{
            ]]..CCS..[[
            background-color: rgba(]]..bgColorHover..[[);
          }
        ]])
      end
      --
      return true
    end
  end
  --
  return false
end
-- 
-- Refresh all target button
function ui.fUpdateAllTargetButtons()
  ui.fDebug("[&lt;cyan&gt;call&lt;r&gt;] ui.fUpdateAllTargetButtons()")
  --
  for i=0, 9 do
    if (i &gt;= 1) and (i &lt;= 4) then
      ui.fUpdateSingleTargetButton("t"..i)
    end
    ui.fUpdateSingleTargetButton("g"..i)
  end
  ui.fUpdateSingleTargetButton("o0")
  --
  ui.fRefreshTargetButtonsWidget()
  ui.fSaveFileTarges()
end
--
-- Refresh Target
function ui.fUpdateTargetButtonsTitle()
  ui.fDebug("[&lt;cyan&gt;call&lt;r&gt;] ui.fUpdateTargetButtonsTitle()")
  --
  if (not ui.variables.target) or (ui.variables.target == "") then
    GUI.TargetButtons:setTitle("Target")
  else
    GUI.TargetButtons:setTitle("Target: "..ui.variables["target"])
  end
end
--
-- Assign Target button
function ui.fAssignTargetButton(button, value)
  ui.fDebug("[&lt;cyan&gt;call&lt;r&gt;] ui.fAssignTargetButton("..(button or "nil")..", "..(value or "nil")..")")
  --
  local ret = 0;
  local type, number = ui.fExpandButton(button)
  --
  if (type == "g") or (type == "o") or (type == "t") then
    button = type..number
    ui.targets[button] = ui.targets[button] or {}
    ui.targets[button].target = value
    --
    return 1 -- Value assigned (can be nil)
  end
  --
  return -1 -- Invaid button
end
--
-- Execute Target button
function ui.fExecuteTargetButton(button)
  ui.fDebug("[&lt;cyan&gt;call&lt;r&gt;] ui.fExecuteTargetButton("..(button or "nil")..")")
  --
  local type, number = ui.fExpandButton(button)
  --
  if (type == "g") or (type == "o") or (type == "t") then
    button = type..number
    if (ui.targets[button]) and (ui.targets[button].target) then
      if (ui.variables["target"] == ui.targets[button].target) then
        ui.variables["target"] = ""
        ui.fEcho2n(ui.fGetTargetFormattedText(button)..ui.fGetOperatorFormattedText(" » ").."nessun "..ui.fGetVarNameFormattedText("target").." selezionato")
      else
        ui.variables["target"] = ui.targets[button].target
        ui.fEcho2n(ui.fGetTargetFormattedText(button)..ui.fGetOperatorFormattedText(" » ")..ui.fGetVarNameFormattedText("target").." impostato su "..ui.fGetVarValueFormattedText(ui.variables.target).."&lt;r&gt;.")
      end
      ui.fUpdateTargetButtonsTitle()
    elseif (type == "g") then
      ui.fEcho2n("Nessun componente del gruppo da associare a "..ui.fGetTargetFormattedText(button)..".")
    elseif (type == "o") then
      ui.fEcho2n("Nessun avversario ingaggiato da associare a "..ui.fGetTargetFormattedText(button)..".")
    elseif (type == "t") then
      ui.fEcho2n(ui.fGetTargetFormattedText(button).." non configurato. Usare il comanto "..ui.fGetCommandFormattedText(button.." &lt;testo&gt;").." per configurare.")
    end
    -- Save target
    ui.fUpdateAllTargetButtons()
    ui.fSaveFileVariables()
    -- ui.fUpdateOpponent()
  else
    ui.fEcho2n(ui.fGetTargetFormattedText(button).." pulsante non valido.")
  end
end
--
-- Save buttons data from file
function ui.fSaveFileTarges()
  ui.fDebug("[&lt;cyan&gt;call&lt;r&gt;] ui.fSaveFileTarges()")
  --
  if (ui.setting) then
    local file = ui.files.targets.path..ui.setting.."/"..ui.files.targets.name
    local targetsDataToSave = {}
    --
    for button in pairs(ui.targets) do
      targetsDataToSave[button] = {}
      targetsDataToSave[button].target = ui.targets[button].target
      targetsDataToSave[button].mod1 = ui.targets[button].mod1
      targetsDataToSave[button].mod2 = ui.targets[button].mod2
      targetsDataToSave[button].key = ui.targets[button].key
    end
    table.save(file, targetsDataToSave)
  end
end
--
-- Read Targets data from file
function ui.fReadFileTargets()
  ui.fDebug("[&lt;cyan&gt;call&lt;r&gt;] ui.fReadFileTargets()")
  --
  local file = ui.files.targets.path..ui.setting.."/"..ui.files.targets.name
  --
  -- Pre defined target buttons
  local pre_defined_target_buttons = {
    g0 = { mod1 = "CTRL", mod2 = "", key = "F10" },
    g1 = { mod1 = "CTRL", mod2 = "", key = "F1" },
    g2 = { mod1 = "CTRL", mod2 = "", key = "F2" },
    g3 = { mod1 = "CTRL", mod2 = "", key = "F3" },
    g4 = { mod1 = "CTRL", mod2 = "", key = "F4" },
    g5 = { mod1 = "CTRL", mod2 = "", key = "F5" },
    g6 = { mod1 = "CTRL", mod2 = "", key = "F6" },
    g7 = { mod1 = "CTRL", mod2 = "", key = "F7" },
    g8 = { mod1 = "CTRL", mod2 = "", key = "F8" },
    g9 = { mod1 = "CTRL", mod2 = "", key = "F9" },
    --
    o0 = { mod1 = "CTRL", mod2 = "", key = "0" },
    --
    t1 = { mod1 = "CTRL", mod2 = "", key = "1" },
    t2 = { mod1 = "CTRL", mod2 = "", key = "2" },
    t3 = { mod1 = "CTRL", mod2 = "", key = "3" },
    t4 = { mod1 = "CTRL", mod2 = "", key = "4" },
  }
  --
  -- Remove actual Targets
  ui.targets = {}
  --
  -- Load Targets
  if (io.exists(file)) then
    table.load(file, ui.targets)
  else
    -- Update only if file targets not exist otherwise it would reassign any removed keys
    ui.targets = table.update(pre_defined_target_buttons, ui.targets)
  end
  --
  -- Save
  table.save(file, ui.targets)
end</script>
				<eventHandlerList />
			</Script>
			<Script isActive="yes" isFolder="no">
				<name>Tick</name>
				<packageName></packageName>
				<script>function ui.fIncrementTickTimer(time_left)
  if time_left &lt; 0 then
    ui.fTickUpdateAffects()
    time_left = 75;
  end
  --
  if (ui.handlers.ticktimer) then
    killTimer(ui.handlers.ticktimer)
    ui.handlers.ticktimer = nil
  end
  ui.handlers.ticktimer = tempTimer(1, function() ui.fIncrementTickTimer(time_left - 1) end)
  --
  GUI.Player.Main.Tick:setValue(time_left, 75)
end
</script>
				<eventHandlerList />
			</Script>
			<Script isActive="yes" isFolder="no">
				<name>Variables</name>
				<packageName></packageName>
				<script>--
function ui.fGetVarNameFormattedText(varName)
  return ui.colors.varID..ui.varID..ui.colors.varName..varName.."&lt;r&gt;"
end
--
function ui.fGetVarValueFormattedText(varValue)
  return ui.colors.varCont..tostring(varValue)
end
--
function ui.fGetVarFormattedText(variable)
  if (ui.variables[variable]) then
    if (ui.variables[variable] == "") then
      return ui.fGetVarNameFormattedText(variable)
    end
    --
    return ui.fGetVarNameFormattedText(variable)..ui.fGetOperatorFormattedText("=")..ui.fGetVarValueFormattedText(ui.variables[variable])
  end
  --
  return ""
end
--
function ui.fRemoveAllVariables()
  ui.fDebug("[&lt;cyan&gt;call&lt;r&gt;] ui.fRemoveAllVariables()")
  --
  ui.variables = {}
  ui.variables = table.deepcopy(ui.fGetPreDefinitedVariables())
end
--
function ui.fShowAllVar()
  ui.fDebug("[&lt;cyan&gt;call&lt;r&gt;] ui.fShowAllVar()")
  --
  local app = {}
  local idx = 0
  --
  cecho(ui.fTitle("Variabili predefinite"))
  for variable in pairs(ui.variables) do
    if (ui.variables[variable]) and (ui.fGetPreDefinitedVariables()[variable]) then
      idx = idx + 1
      cecho(ui.fGetNumberFormattedText(idx).." "..ui.fGetVarNameFormattedText(variable))
      if (ui.variables[variable]  ~= "") then
        cecho(ui.fGetOperatorFormattedText(" = ")..ui.fGetVarValueFormattedText(ui.variables[variable]))
      end
      cecho("\n")
    end
  end
  --
  cecho(ui.fTitle("Variabili"))
  idx = 0
  for variable in pairs(ui.variables) do
    if (ui.variables[variable]) and (ui.fGetPreDefinitedVariables()[variable] == nil) then
      idx = idx + 1
      cecho(ui.fGetNumberFormattedText(idx).." ")
      cechoLink(ui.cLink("X"), [[expandAlias("uiv ]]..variable..[[ remove]]..getCommandSeparator()..[[uiv")]], "Rimuovi la variabile '"..variable.."'", true)
      checho(" "..ui.fGetVarNameFormattedText(variable))
      if (ui.variables[variable]  ~= "") then
        cecho(ui.fGetOperatorFormattedText(" = ")..ui.fGetVarValueFormattedText(ui.variables[variable]))
      end
      cecho("\n")
    end
  end
  --
  if (idx &gt; 0) then
    echo("\n")
  else
    cecho("Non ci sono variabili.\n\n")
  end
end
--
function ui.fGetPreDefinitedVariables()
  return {
    target = "",
  }
end
--
-- Save Variables data to file
function ui.fSaveFileVariables()
  ui.fDebug("[&lt;cyan&gt;call&lt;r&gt;] ui.fSaveFileVariables()")
  --
  if (ui.setting) then
    local file = ui.files.variables.path..ui.setting.."/"..ui.files.variables.name
    -- Save
    table.save(file, ui.variables)
  end
end
--
-- Read Variables data from file
function ui.fReadFileVariables()
  ui.fDebug("[&lt;cyan&gt;call&lt;r&gt;] ui.fReadFileVariables()")
  --
  local file = ui.files.variables.path..ui.setting.."/"..ui.files.variables.name
  --
  -- Remove actual Variables
  ui.variables = {}
  --
  -- Load Variables
  if (io.exists(file)) then
    table.load(file, ui.variables)
  end
  --
  -- Merge pre defined variables
  ui.variables = table.update(ui.fGetPreDefinitedVariables(), ui.variables)
  --
  -- Save
  table.save(file, ui.variables)
end</script>
				<eventHandlerList />
			</Script>
		</ScriptGroup>
		<ScriptGroup isActive="yes" isFolder="yes">
			<name>Graphic elements</name>
			<packageName></packageName>
			<script></script>
			<eventHandlerList />
			<Script isActive="yes" isFolder="no">
				<name>Affects Widget</name>
				<packageName></packageName>
				<script>function ui.fInitAffectsWidget()
  ui.fDebug("[&lt;cyan&gt;call&lt;r&gt;] ui.fInitAffectsWidget()")
  --
  -- Affects
  GUI.Affects = Adjustable.Container:new2({
    name = "GUI.Affects",
    attached = "right",
    x = -500,
    y = "15%",
    width = 300,
    height = "35%",
    titleText ="Effetti",
    titleTxtColor = "orange",
    buttonsize = 12,
    buttonFontSize = 5,
    adjLabelstyle = GUI.CSS.Widget, 
    buttonstyle = GUI.CSS.WidgetButton,
  })
  GUI.Affects:changeMenuStyle("dark")
  --
  -- Add Border and Main
  ui.fAddMain(GUI.Affects, GUI.CSS.Border, GUI.CSS.Main)
  --
  -- Set transparent
  ui.fSetBorderMode(GUI.Affects, ui.parameters.widgets.affects.transparent)
  --
  -- Button "Hide"
  GUI.Affects.Button_hide = Geyser.Label:new2({
    name = "GUI.Affects.Button_hide",
    x = -46, 
    y = 4,
    width = 12,
    height = 12,
  },GUI.Affects)
  GUI.Affects.Button_hide:setStyleSheet(GUI.CSS.WidgetButton);
  GUI.Affects.Button_hide:setFontSize(5)
  GUI.Affects.Button_hide:echo(ui.transparentID);
  GUI.Affects.Button_hide:setClickCallback(function() 
                                                   local mode = ui.parameters.widgets.affects.transparent or false;
                                                   ui.fSetBorderMode(GUI.Affects, not mode)
                                                   ui.parameters.widgets.affects.transparent = not mode;
                                                   ui.fSaveFileParameters()
                                                end)
  GUI.Affects.Button_hide:setToolTip("Transparent", 10)
  --
  -- 20x Affects
  local i
  for i=1, 20 do
    local col = (i-1) % 10;
    local row = (i&lt;=10)and(0)or(1)
    --
    GUI.Affects.Main["Affect"..i] = Geyser.Label:new2({
      name = "GUI.Affects.Main.Affect"..i,
      x = 30*col,
      y = 30*row,
      width = 100,
      height = 26,
    }, GUI.Affects.Main)
    GUI.Affects.Main["Affect"..i]:setStyleSheet(GUI.CSS.Item);
    --
    -- Duration
    GUI.Affects.Main["Affect"..i].duration = Geyser.Label:new2({
      name = "GUI.Affects.Main.Affect"..i..".duration",
      x = 2, y = 2,
      width = 26,
      height = -2,
    }, GUI.Affects.Main["Affect"..i])
    GUI.Affects.Main["Affect"..i].duration:enableClickthrough() -- for tooltip
    GUI.Affects.Main["Affect"..i].duration:setStyleSheet(GUI.CSS.ItemLeft)
    GUI.Affects.Main["Affect"..i].duration:setFontSize(7);
    --
    -- Text
    GUI.Affects.Main["Affect"..i].text = Geyser.Label:new2({
      name = "GUI.Affects.Main.Affect"..i..".text",
      x = 28,
      y = 2,
      width = -28,
      height = -2,
    }, GUI.Affects.Main["Affect"..i])
    GUI.Affects.Main["Affect"..i].text:enableClickthrough() -- for tooltip
    GUI.Affects.Main["Affect"..i].text:setStyleSheet(GUI.CSS.ItemText)
    GUI.Affects.Main["Affect"..i].text:setFontSize(7);
    --
    GUI.Affects.Main["Affect"..i]:hide()
  end
  --
  -- Wrapping function
  local Minimize = GUI.Affects.minimize
  local Restore = GUI.Affects.restore
  local Resize = GUI.Affects.resize
  --
  function GUI.Affects:minimize(...)
    GUI.Affects.Main:hide()
    return Minimize(GUI.Affects)
  end
  --
  function GUI.Affects:restore(...)
    GUI.Affects.Main:show()
    return Restore(GUI.Affects)
  end
  --
  function GUI.Affects:resize(...)
    ui.fUpdateAffects()
    return Resize(GUI.Affects, ...)
  end
  --
end</script>
				<eventHandlerList />
			</Script>
			<Script isActive="yes" isFolder="no">
				<name>Alias Buttons Widget</name>
				<packageName></packageName>
				<script>function ui.fInitAliasButtonsWidget()
  ui.fDebug("[&lt;cyan&gt;call&lt;r&gt;] ui.fInitAliasButtonsWidget()")
  --
  -- Alias buttons 
  GUI.AliasButtons = Adjustable.Container:new2({
    name = "GUI.AliasButtons",
    attached = "right",
    x = -500,
    y = 0,
    width = 500,
    height = "15%",
    titleText ="Pulsanti alias",
    titleTxtColor = "orange",
    buttonsize = 12,
    buttonFontSize = 5,
    adjLabelstyle = GUI.CSS.Widget, 
    buttonstyle = GUI.CSS.WidgetButton,
  })
  GUI.AliasButtons:changeMenuStyle("dark")
  --
  -- Add Border and Main
  ui.fAddMain(GUI.AliasButtons, GUI.CSS.Border, GUI.CSS.Main)
  GUI.AliasButtons.Main:setColor(30, 24, 24)
  GUI.AliasButtons.Main:setBgColor(30, 24, 24)
  --
  -- Set transparent
  ui.fSetBorderMode(GUI.AliasButtons, ui.parameters.widgets.aliasButton.transparent)
  --
  -- Button "Hide"
  GUI.AliasButtons.Button_hide = Geyser.Label:new2({
    name = "GUI.AliasButtons.Button_hide",
    x = -46, 
    y = 4,
    width = 12,
    height = 12,
  },GUI.AliasButtons)
  GUI.AliasButtons.Button_hide:setStyleSheet(GUI.CSS.WidgetButton);
  GUI.AliasButtons.Button_hide:setFontSize(5)
  GUI.AliasButtons.Button_hide:echo(ui.transparentID);
  GUI.AliasButtons.Button_hide:setClickCallback(function() 
                                                   local mode = ui.parameters.widgets.aliasButton.transparent or false;
                                                   ui.fSetBorderMode(GUI.AliasButtons, not mode)
                                                   ui.parameters.widgets.aliasButton.transparent = not mode;
                                                   ui.fSaveFileParameters()
                                                end)
  GUI.AliasButtons.Button_hide:setToolTip("Transparent", 10)
  --
  -- Button "A"
  GUI.AliasButtons.Button_a = Geyser.Label:new2({
    name = "GUI.AliasButtons.Button_a",
    x = -106, 
    y = 4,
    width = 12,
    height = 12,
  },GUI.AliasButtons)
  GUI.AliasButtons.Button_a:setStyleSheet(GUI.CSS.WidgetButton);
  GUI.AliasButtons.Button_a:setFontSize(6)
  GUI.AliasButtons.Button_a:echo("&lt;center&gt;a");
  GUI.AliasButtons.Button_a:setClickCallback("ui.fOptionButton", "a")
  --
  -- Button "B"
  GUI.AliasButtons.Button_b = Geyser.Label:new2({
    name = "GUI.AliasButtons.Button_b",
    x = -91, 
    y = 4,
    width = 12,
    height = 12,
  },GUI.AliasButtons)
  GUI.AliasButtons.Button_b:setStyleSheet(GUI.CSS.WidgetButton);
  GUI.AliasButtons.Button_b:setFontSize(6)
  GUI.AliasButtons.Button_b:echo("&lt;center&gt;b");
  GUI.AliasButtons.Button_b:setClickCallback("ui.fOptionButton", "b")
  --
  -- Button "C"
  GUI.AliasButtons.Button_c = Geyser.Label:new2({
    name = "GUI.AliasButtons.Button_c",
    x = -76, 
    y = 4,
    width = 12,
    height = 12,
  },GUI.AliasButtons)
  GUI.AliasButtons.Button_c:setStyleSheet(GUI.CSS.WidgetButton);
  GUI.AliasButtons.Button_c:setFontSize(6)
  GUI.AliasButtons.Button_c:echo("&lt;center&gt;c");
  GUI.AliasButtons.Button_c:setClickCallback("ui.fOptionButton", "c")
  --
  -- Buttons
  for order=1,10 do
    local i = order % 10
    --
    -- Name
    GUI.AliasButtons.Main["Button"..i] = Geyser.Label:new2({
      name = "GUI.AliasButtons.Main.Button"..i,
      x = (10*i).."%", 
      y = 0,
      width = "10%",
      height = "100%",
    },GUI.AliasButtons.Main)
    GUI.AliasButtons.Main["Button"..i]:setClickCallback("ui.fClickAliasButton", i, nil)
    --
    -- Icon
    GUI.AliasButtons.Main["Button"..i].icon = Geyser.Label:new2({
      name = "GUI.AliasButtons.Main.Button"..i..".icon",
      x = 5, y = 5,
      width = -5,
      height = -5,
    }, GUI.AliasButtons.Main["Button"..i])
    GUI.AliasButtons.Main["Button"..i].icon:enableClickthrough()
    GUI.AliasButtons.Main["Button"..i].icon:setFgColor("violet")
    GUI.AliasButtons.Main["Button"..i].icon:setFontSize(9)
    --
    -- Index
    GUI.AliasButtons.Main["Button"..i].index = Geyser.Label:new2({
      name = "GUI.AliasButtons.Main.Button"..i..".index",
      x = 5, 
      y = 1,
      width = "15",
      height = "15",
    }, GUI.AliasButtons.Main["Button"..i])
    GUI.AliasButtons.Main["Button"..i].index:enableClickthrough()
    GUI.AliasButtons.Main["Button"..i].index:setFontSize(ui.parameters.widgets.keybind.fontSize)
    GUI.AliasButtons.Main["Button"..i].index:setStyleSheet(GUI.CSS.Keybind);
    GUI.AliasButtons.Main["Button"..i].index:echo("")
    --
    -- Keybid
    GUI.AliasButtons.Main["Button"..i].keybind = Geyser.Label:new2({
      name = "GUI.AliasButtons.Main.Button"..i..".keybind",
      x = 5, 
      y = -15,
      width = -10,
      height = 15,
    }, GUI.AliasButtons.Main["Button"..i])
    GUI.AliasButtons.Main["Button"..i].keybind:enableClickthrough()
    GUI.AliasButtons.Main["Button"..i].keybind:setStyleSheet(GUI.CSS.Keybind);
    GUI.AliasButtons.Main["Button"..i].keybind:setFontSize(ui.parameters.widgets.keybind.fontSize);
  end
  --
  -- Wrapping function
  local Minimize = GUI.AliasButtons.minimize
  local Restore = GUI.AliasButtons.restore
  local Resize = GUI.AliasButtons.resize
  --
  function GUI.AliasButtons:minimize(...)
    GUI.AliasButtons.Main:hide()
    return Minimize(GUI.AliasButtons)
  end
  --
  function GUI.AliasButtons:restore(...)
    GUI.AliasButtons.Main:show()
    return Restore(GUI.AliasButtons)
  end
  --
  function GUI.AliasButtons:resize(...)
    ui.fUpdateAliasButton()
    return Resize(GUI.AliasButtons, ...)
  end
end</script>
				<eventHandlerList />
			</Script>
			<Script isActive="yes" isFolder="no">
				<name>Chat Widget</name>
				<packageName></packageName>
				<script>function ui.fInitChatWidget()
  ui.fDebug("[&lt;cyan&gt;call&lt;r&gt;] ui.fInitChatWidget()")
  --
  -- Private messages
  GUI.Chat = Adjustable.Container:new2({
    name = "GUI.Chat",
    attached = "left",
    x = 0,
    y = 0,
    width = 300,
    height = "55%",
    titleText ="Canale privato",
    titleTxtColor = "orange",
    buttonsize = 12,
    buttonFontSize = 5,
    adjLabelstyle = GUI.CSS.Widget, 
    buttonstyle = GUI.CSS.WidgetButton,
  })
  GUI.Chat:changeMenuStyle("dark")
  --
  -- Add Border and Main
  ui.fAddMain(GUI.Chat, GUI.CSS.Border, GUI.CSS.Main)
  --
  -- Button "Split"
  GUI.Chat.Button_split = Geyser.Label:new2({
    name = "GUI.Chat.Button_split",
    x = -133, 
    y = 4,
    width = 40,
    height = 12,
  },GUI.Chat)
  GUI.Chat.Button_split:setStyleSheet(GUI.CSS.WidgetButton);
  GUI.Chat.Button_split:setFontSize(6)
  GUI.Chat.Button_split:echo("&lt;center&gt;split");
  GUI.Chat.Button_split:setClickCallback("ui.fChatSplitClicked")
  --
  -- Button "Type"
  GUI.Chat.Button_type = Geyser.Label:new2({
    name = "GUI.Chat.Button_type",
    x = -89, 
    y = 4,
    width = 40,
    height = 12,
  },GUI.Chat)
  GUI.Chat.Button_type:setStyleSheet(GUI.CSS.WidgetButton);
  GUI.Chat.Button_type:setFontSize(6)
  GUI.Chat.Button_type:echo("&lt;center&gt;"..ui.parameters.widgets.chat.type);
  GUI.Chat.Button_type:setClickCallback("ui.fChatTypeClicked")
  --
  -- Button "Type"
  GUI.Chat.Split_line = Geyser.Label:new2({
    name = "GUI.Chat.Split_line",
    x = 0, 
    y = "50%-2",
    width = "100%",
    height = 4,
  },GUI.Chat.Border)
  GUI.Chat.Split_line:setStyleSheet(GUI.CSS.Border);
  --
  -- Console "All"
  GUI.Chat.Main.All = Geyser.MiniConsole:new2({
    name = 'GUI.Chat.Main.All',
    x=0,
    y=0,
    width = "100%", 
    height = "100%",
    autoWrap = true,
    scrollBar = true,
  }, GUI.Chat.Main)
  GUI.Chat.Main.All:setColor(30, 24, 24)
  GUI.Chat.Main.All:setBgColor(30, 24, 24)
  GUI.Chat.Main.All:setFontSize(ui.parameters.widgets.chat.fontSize)
  --
  -- Console "Public"
  GUI.Chat.Main.Public = Geyser.MiniConsole:new2({
    name = 'GUI.Chat.Main.Public',
    x=0,
    y=0,
    width = "100%", 
    height = "100%",
    autoWrap = true,
    scrollBar = true,
  }, GUI.Chat.Main)
  GUI.Chat.Main.Public:setColor(30, 24, 24)
  GUI.Chat.Main.Public:setBgColor(30, 24, 24)
  GUI.Chat.Main.Public:setFontSize(ui.parameters.widgets.chat.fontSize)
  --
  -- Console "Private"
  GUI.Chat.Main.Private = Geyser.MiniConsole:new2({
    name = 'GUI.Chat.Main.Private',
    x=0,
    y=0,
    width = "100%", 
    height = "100%",
    autoWrap = true,
    scrollBar = true,
  }, GUI.Chat.Main)
  GUI.Chat.Main.Private:setColor(30, 24, 24)
  GUI.Chat.Main.Private:setBgColor(30, 24, 24)
  GUI.Chat.Main.Private:setFontSize(ui.parameters.widgets.chat.fontSize)
  --
  -- Wrapping function
  local Minimize = GUI.Chat.minimize
  local Restore = GUI.Chat.restore
  --
  function GUI.Chat:minimize(...)
    GUI.Chat.Main:hide()
    return Minimize(GUI.Chat)
  end
  --
  function GUI.Chat:restore(...)
    GUI.Chat.Main:show()
    return Restore(GUI.Chat)
  end
end</script>
				<eventHandlerList />
			</Script>
			<Script isActive="yes" isFolder="no">
				<name>Endowment Widget</name>
				<packageName></packageName>
				<script>function ui.fInitEndowmentWidget()
  ui.fDebug("[&lt;cyan&gt;call&lt;r&gt;] ui.fInitEndowmentWidget()")
  --
  -- Equip
  GUI.Endowment = Adjustable.Container:new2({
    name = "GUI.Endowment",
    attached = "right",
    x = -200,
    y = "15%",
    width = 200,
    height = "85%",
    titleText ="Equipaggiamento",
    titleTxtColor = "orange",
    buttonsize = 12,
    buttonFontSize = 5,
    adjLabelstyle = GUI.CSS.Widget, 
    buttonstyle = GUI.CSS.WidgetButton,
  })
  GUI.Endowment:changeMenuStyle("dark")
  --
  -- Add Border and Main
  ui.fAddMain(GUI.Endowment, GUI.CSS.Border, GUI.CSS.Main)
  --
  -- Set transparent
  ui.fSetBorderMode(GUI.Endowment, ui.parameters.widgets.endowment.transparent)
  --
  -- Button "Hide"
  GUI.Endowment.Button_hide = Geyser.Label:new2({
    name = "GUI.Endowment.Button_hide",
    x = -46, 
    y = 4,
    width = 12,
    height = 12,
  },GUI.Endowment)
  GUI.Endowment.Button_hide:setStyleSheet(GUI.CSS.WidgetButton);
  GUI.Endowment.Button_hide:setFontSize(5)
  GUI.Endowment.Button_hide:echo(ui.transparentID);
  GUI.Endowment.Button_hide:setClickCallback(function() 
                                            local mode = ui.parameters.widgets.endowment.transparent or false;
                                            ui.fSetBorderMode(GUI.Endowment, not mode)
                                            ui.parameters.widgets.endowment.transparent = not mode;
                                            ui.fSaveFileParameters()
                                          end)
  GUI.Endowment.Button_hide:setToolTip("Transparent", 10)
  --
  -- 25x Slot
  for i=1, 25 do
    --
    GUI.Endowment.Main["Item"..i] = Geyser.Label:new2({
      name = "GUI.Endowment.Main.Item"..i,
      width = 100,
      height = 26,
    }, GUI.Endowment.Main)
    GUI.Endowment.Main["Item"..i]:setStyleSheet(GUI.CSS.Item);
    --
    -- Index
    GUI.Endowment.Main["Item"..i].Index = Geyser.Label:new2({
      name = "GUI.Endowment.Main.Item"..i..".Index",
      x = 2,
      y = 2,
      width = 30,
      height = "50%-2",
    }, GUI.Endowment.Main["Item"..i])
    GUI.Endowment.Main["Item"..i].Index:enableClickthrough() -- for tooltip
    GUI.Endowment.Main["Item"..i].Index:setStyleSheet(GUI.CSS.ItemTopLeft)
    GUI.Endowment.Main["Item"..i].Index:setFgColor("white")
    GUI.Endowment.Main["Item"..i].Index:setFontSize(7);
    --
    -- Status
    GUI.Endowment.Main["Item"..i].Slot = Geyser.Label:new2({
      name = "GUI.Endowment.Main.Item"..i..".Slot",
      x = 2,
      y = "50%",
      width = 30,
      height = "50%-2",
    }, GUI.Endowment.Main["Item"..i])
    GUI.Endowment.Main["Item"..i].Slot:enableClickthrough() -- for tooltip
    GUI.Endowment.Main["Item"..i].Slot:setStyleSheet(GUI.CSS.ItemBottomLeft)
    GUI.Endowment.Main["Item"..i].Slot:setFgColor("orange")
    GUI.Endowment.Main["Item"..i].Slot:setFontSize(7);
    --
    -- Text
    GUI.Endowment.Main["Item"..i].Text = Geyser.Label:new2({
      name = "GUI.Endowment.Main.Item"..i..".Text",
      x = 32,
      y = 2,
      width = -32,
      height = -2,
    }, GUI.Endowment.Main["Item"..i])
    GUI.Endowment.Main["Item"..i].Text:enableClickthrough() -- for tooltip
    GUI.Endowment.Main["Item"..i].Text:setStyleSheet(GUI.CSS.ItemText)
    GUI.Endowment.Main["Item"..i].Text:setFontSize(7);
    GUI.Endowment.Main["Item"..i].Text:setFgColor("black")    --
    -- Level
    GUI.Endowment.Main["Item"..i].Level = Geyser.Label:new2({
      name = "GUI.Endowment.Main.Item"..i..".Level",
      x = -32,
      y = 2,
      width = 30,
      height = "50%-2",
    }, GUI.Endowment.Main["Item"..i])
    GUI.Endowment.Main["Item"..i].Level:enableClickthrough() -- for tooltip
    GUI.Endowment.Main["Item"..i].Level:setStyleSheet(GUI.CSS.ItemTopRight)
    GUI.Endowment.Main["Item"..i].Level:setFgColor("green")
    GUI.Endowment.Main["Item"..i].Level:setFontSize(7);
    --
    -- Slot
    GUI.Endowment.Main["Item"..i].Status = Geyser.Label:new2({
      name = "GUI.Endowment.Main.Item"..i..".Status",
      x = -32,
      y = "50%",
      width = 30,
      height = "50%-2",
    }, GUI.Endowment.Main["Item"..i])
    GUI.Endowment.Main["Item"..i].Status:enableClickthrough() -- for tooltip
    GUI.Endowment.Main["Item"..i].Status:setStyleSheet(GUI.CSS.ItemBottomRight)
    GUI.Endowment.Main["Item"..i].Status:setFgColor("orange")
    GUI.Endowment.Main["Item"..i].Status:setFontSize(7);
    --
    GUI.Endowment.Main["Item"..i]:hide()
  end
  --
  -- Wrapping function
  local Minimize = GUI.Endowment.minimize
  local Restore = GUI.Endowment.restore
  local Resize = GUI.Endowment.resize
  --
  function GUI.Endowment:minimize(...)
    GUI.Endowment.Main:hide()
    return Minimize(GUI.Endowment)
  end
  --
  function GUI.Endowment:restore(...)
    GUI.Endowment.Main:show()
    return Restore(GUI.Endowment)
  end
  --
  function GUI.Endowment:resize(...)
    ui.fUpdateEndowment()
    return Resize(GUI.Endowment, ...)
  end
end</script>
				<eventHandlerList />
			</Script>
			<Script isActive="yes" isFolder="no">
				<name>Group Widget</name>
				<packageName></packageName>
				<script>function ui.fInitGroupWidget()
  ui.fDebug("[&lt;cyan&gt;call&lt;r&gt;] ui.fInitGroupWidget()")
  --
  -- Group Members
  GUI.Group = Adjustable.Container:new2({
    name = "GUI.Group",
    attached = "right",
    x = -500,
    y = "50%",
    width = 300,
    height = "35%",
    titleText ="Gruppo",
    titleTxtColor = "orange",
    buttonsize = 12,
    buttonFontSize = 5,
    adjLabelstyle = GUI.CSS.Widget, 
    buttonstyle = GUI.CSS.WidgetButton,
  })
  GUI.Group:changeMenuStyle("dark")
  --
  -- Add Border and Main
  ui.fAddMain(GUI.Group, GUI.CSS.Border, GUI.CSS.Main)
  --
  -- Set transparent
  ui.fSetBorderMode(GUI.Group, ui.parameters.widgets.group.transparent)
  --
  -- Button "Hide"
  GUI.Group.Button_hide = Geyser.Label:new2({
    name = "GUI.Group.Button_hide",
    x = -46, 
    y = 4,
    width = 12,
    height = 12,
  },GUI.Group)
  GUI.Group.Button_hide:setStyleSheet(GUI.CSS.WidgetButton);
  GUI.Group.Button_hide:setFontSize(5)
  GUI.Group.Button_hide:echo(ui.transparentID);
  GUI.Group.Button_hide:setClickCallback(function() 
                                                   local mode = ui.parameters.widgets.group.transparent or false;
                                                   ui.fSetBorderMode(GUI.Group, not mode)
                                                   ui.parameters.widgets.group.transparent = not mode;
                                                   ui.fSaveFileParameters()
                                                end)
  GUI.Group.Button_hide:setToolTip("Transparent", 10)
  --
  -- Members
  for i=1, 10 do
    local mod = i % 10
    --
    -- Member
    GUI.Group.Main["g"..mod] = Geyser.Label:new2({
      name = "GUI.Group.Main.g"..mod
    }, GUI.Group.Main)
    GUI.Group.Main["g"..mod]:setClickCallback("ui.fClickTarget", "g"..mod)
    GUI.Group.Main["g"..mod]:hide();
    --
    -- Index
    GUI.Group.Main["g"..mod].index = Geyser.Label:new2({
      name = "GUI.Group.Main.g"..mod..".index",
      x = 2, 
      y = 0,
      width = 20,
      height = 10,
    }, GUI.Group.Main["g"..mod])
    GUI.Group.Main["g"..mod].index:enableClickthrough()
    GUI.Group.Main["g"..mod].index:setStyleSheet(GUI.CSS.Keybind);
    GUI.Group.Main["g"..mod].index:setFontSize(ui.parameters.widgets.keybind.fontSize)
    GUI.Group.Main["g"..mod].index:echo("g"..mod.."")
    --
    -- Index
    GUI.Group.Main["g"..mod].Member = Geyser.Label:new2({
      name = "GUI.Group.Main.g"..mod..".Member",
      x = 22, 
      y = 0,
      width = "100%-44",
      height = 10,
    }, GUI.Group.Main["g"..mod])
    GUI.Group.Main["g"..mod].Member:enableClickthrough()
    GUI.Group.Main["g"..mod].Member:setStyleSheet(GUI.CSS.Keybind);
    GUI.Group.Main["g"..mod].Member:setFontSize(ui.parameters.widgets.keybind.fontSize)
    GUI.Group.Main["g"..mod].Member:echo("")
    --
    -- Member Health Gauges
    GUI.Group.Main["g"..mod].Health = Geyser.Gauge:new2({
      name = "GUI.Group.Main.g"..mod..".Health",
      x = 2,
      y = 11,
      width = -2,
      height = 15,
    }, GUI.Group.Main["g"..mod])
    GUI.Group.Main["g"..mod].Health:setValue(0, 100)
    GUI.Group.Main["g"..mod].Health:enableClickthrough()
    --
    GUI.Group.Main["g"..mod].Health.back:setStyleSheet(GUI.CSS.GaugeBack..[[
      background-color: rgba(0, 0, 0, 0.3);
    ]])
    GUI.Group.Main["g"..mod].Health.back:enableClickthrough()
    --
    GUI.Group.Main["g"..mod].Health.front:setStyleSheet(GUI.CSS.GaugeFront..[[
      background-color: QLinearGradient( x1: 0, y1: 0, x2: 0, y2: 1, stop: 0 #ee0000, stop: 0.65 #990000, stop: 1 #bb0000);
    ]])
    GUI.Group.Main["g"..mod].Health.front:enableClickthrough()
    --
    -- Member Mana Gauges
    GUI.Group.Main["g"..mod].Mana = Geyser.Gauge:new2({
      name = "GUI.Group.Main.g"..mod..".Mana",
      x = 2,
      y = 27,
      width = -2,
      height = 6,
    }, GUI.Group.Main["g"..mod])
    GUI.Group.Main["g"..mod].Mana:setValue(0, 100)
    GUI.Group.Main["g"..mod].Mana:enableClickthrough()
    --
    GUI.Group.Main["g"..mod].Mana.back:setStyleSheet(GUI.CSS.GaugeBack..[[
      background-color: rgba(0, 0, 250, .3);
    ]])
    GUI.Group.Main["g"..mod].Mana.back:enableClickthrough()
    --
    GUI.Group.Main["g"..mod].Mana.front:setStyleSheet(GUI.CSS.GaugeFront..[[
      background-color: QLinearGradient( x1: 0, y1: 0, x2: 0, y2: 1, stop: 0 #0000ee, stop: 0.65 #000099, stop: 1 #0000bb);
    ]])
    GUI.Group.Main["g"..mod].Mana.front:enableClickthrough()
    --
    -- Member Stamina Gauges
    GUI.Group.Main["g"..mod].Stamina = Geyser.Gauge:new2({
      name = "GUI.g"..mod..".Stamina",
      x = 2,
      y = 34,
      width = -2,
      height = 6,
    }, GUI.Group.Main["g"..mod])
    GUI.Group.Main["g"..mod].Stamina:setValue(0, 100)
    GUI.Group.Main["g"..mod].Stamina:enableClickthrough()
    --
    GUI.Group.Main["g"..mod].Stamina.back:setStyleSheet(GUI.CSS.GaugeBack..[[
      background-color: rgba(0, 250, 0, .2);
    ]])
    GUI.Group.Main["g"..mod].Stamina.back:enableClickthrough()
    --
    GUI.Group.Main["g"..mod].Stamina.front:setStyleSheet(GUI.CSS.GaugeFront..[[
      background-color: QLinearGradient( x1: 0, y1: 0, x2: 0, y2: 1, stop: 0 #00aa00, stop: 0.65 #006600, stop: 1 #008800);
    ]])
    GUI.Group.Main["g"..mod].Stamina.front:enableClickthrough()
    --
    -- Keybid
    GUI.Group.Main["g"..mod].keybind = Geyser.Label:new2({
      name = "GUI.Group.Main.g"..mod..".keybind",
      x = 30,
      y = -10,
      width = -10,
      height = 10,
    }, GUI.Group.Main["g"..mod])
    GUI.Group.Main["g"..mod].keybind:enableClickthrough()
    GUI.Group.Main["g"..mod].keybind:setStyleSheet(GUI.CSS.Keybind);
    GUI.Group.Main["g"..mod].keybind:setFontSize(ui.parameters.widgets.keybind.fontSize);
    GUI.Group.Main["g"..mod].keybind:echo("keybind")
  end
  --
  -- Wrapping function
  local Minimize = GUI.Group.minimize
  local Restore = GUI.Group.restore
  local Resize = GUI.Group.resize
  --
  function GUI.Group:minimize(...)
    GUI.Group.Main:hide()
    return Minimize(GUI.Group)
  end
  --
  function GUI.Group:restore(...)
    GUI.Group.Main:show()
    return Restore(GUI.Group)
  end
  --
  function GUI.Group:resize(...)
    ui.fUpdateGroup()
    return Resize(GUI.Group, ...)
  end
end</script>
				<eventHandlerList />
			</Script>
			<Script isActive="yes" isFolder="no">
				<name>Help Widget</name>
				<packageName></packageName>
				<script>function ui.fInitHelpWidget()
  ui.fDebug("[&lt;cyan&gt;call&lt;r&gt;] ui.fInitHelpWidget()")
  --
  -- Public messages
  GUI.Help = Adjustable.Container:new2({
    name = "GUI.Help",
    x = 100,
    y = 100,
    width = -100,
    height = -100,
    titleText ="Lumen et Umbra UI rel. "..ui.release.." - Help",
    titleTxtColor = "orange",
    buttonsize = 12,
    buttonFontSize = 5,
    adjLabelstyle = GUI.CSS.Widget, 
    buttonstyle = GUI.CSS.WidgetButton,
  })
  GUI.Help:changeMenuStyle("dark")
  GUI.Help:hide()
  --
  -- Add Border and Main
  ui.fAddMain(GUI.Help, GUI.CSS.Border, GUI.CSS.Main)
  --
  -- Console
  GUI.Help.Main.Console = Geyser.MiniConsole:new2({
    name = 'GUI.Help.Main.Console',
    x=0,
    y=0,
    width = "100%", 
    height = "100%",
    autoWrap = true,
    scrollBar = true,
  }, GUI.Help.Main)
  GUI.Help.Main.Console:setColor(30, 24, 24)
  GUI.Help.Main.Console:setBgColor(30, 24, 24)
  GUI.Help.Main.Console:setFontSize(ui.parameters.widgets.help.fontSize)
  --
  -- Wrapping function
  local Minimize = GUI.Help.minimize
  local Restore = GUI.Help.restore
  --
  function GUI.Help:minimize(...)
    GUI.Help.Main:hide()
    return Minimize(GUI.Help)
  end
  --
  function GUI.Help:restore(...)
    GUI.Help.Main:show()
    return Restore(GUI.Help)
  end
end</script>
				<eventHandlerList />
			</Script>
			<Script isActive="yes" isFolder="no">
				<name>Opponent Widget</name>
				<packageName></packageName>
				<script>function ui.fInitOpponentWidget()
  ui.fDebug("[&lt;cyan&gt;call&lt;r&gt;] ui.fInitOpponentWidget()")
  --
  -- Opponent
  GUI.Opponent = Adjustable.Container:new2({
    name = "GUI.Opponent",
    attached = "left",
    x = 0,
    y = "70%",
    width = 300,
    height = "10%",
    titleText = "Avversario",
    titleTxtColor = "orange",
    buttonsize = 12,
    buttonFontSize = 5,
    adjLabelstyle = GUI.CSS.Widget, 
    buttonstyle = GUI.CSS.WidgetButton,
  });
  GUI.Opponent:changeMenuStyle("dark")
  --
  -- Add Border and Main
  ui.fAddMain(GUI.Opponent, GUI.CSS.Border, GUI.CSS.Main)
  GUI.Opponent.Main:disableClickthrough()
  GUI.Opponent.Main:setClickCallback("ui.fExecuteTargetButton", "o0", nil)
  --
  -- Set transparent
  ui.fSetBorderMode(GUI.Opponent, ui.parameters.widgets.opponent.transparent)
  --
  -- Button "Hide"
  GUI.Opponent.Button_hide = Geyser.Label:new2({
    name = "GUI.Opponent.Button_hide",
    x = -46, 
    y = 4,
    width = 12,
    height = 12,
  },GUI.Opponent)
  GUI.Opponent.Button_hide:setStyleSheet(GUI.CSS.WidgetButton);
  GUI.Opponent.Button_hide:setFontSize(5)
  GUI.Opponent.Button_hide:echo(ui.transparentID);
  GUI.Opponent.Button_hide:setClickCallback(function() 
                                                   local mode = ui.parameters.widgets.opponent.transparent or false;
                                                   ui.fSetBorderMode(GUI.Opponent, not mode)
                                                   ui.parameters.widgets.opponent.transparent = not mode;
                                                   ui.fSaveFileParameters()
                                                end)
  GUI.Opponent.Button_hide:setToolTip("Transparent", 10)
  --
  -- Opponent Level
  GUI.Opponent.Level = Geyser.Label:new2({
    name = "GUI.Opponent.Level",
    x = -74,
    y = "0%-3",
    width = 25,
    height = 25,
    fontSize = 8,
  }, GUI.Opponent)
  GUI.Opponent.Level:setStyleSheet(GUI.CSS.Level);
  GUI.Opponent.Level:enableClickthrough()
  --
  -- Opponent Health Gauges
  GUI.Opponent.Main.Health = Geyser.Gauge:new2({
    name = "GUI.Opponent.Main.Health",
    x = 2,
    y = 2,
    width = -2,
    height = -10,
  },GUI.Opponent.Main)
  GUI.Opponent.Main.Health:setValue(0, 100)
  GUI.Opponent.Main.Health:enableClickthrough()
  --
  GUI.Opponent.Main.Health.back:setStyleSheet(GUI.CSS.GaugeBack..[[
    background-color: rgba(0, 0, 0, 0.3);
  ]]);
  GUI.Opponent.Main.Health.back:enableClickthrough()
  --
  GUI.Opponent.Main.Health.front:setStyleSheet(GUI.CSS.GaugeFront..[[
    background-color: QLinearGradient( x1: 0, y1: 0, x2: 0, y2: 1, stop: 0 #ee0000, stop: 0.65 #990000, stop: 1 #bb0000);
  ]])
  GUI.Opponent.Main.Health.front:enableClickthrough()
  --
  --
  GUI.Opponent.Main.Health.dif = Geyser.Label:new2({
    name = "GUI.Opponent.Main.Health.dif",
    x = 0,
    y = 0,
    width = "10",
    height = "10",
  }, GUI.Opponent.Main)
  GUI.Opponent.Main.Health.dif:enableClickthrough()
  GUI.Opponent.Main.Health.dif:setFontSize(5)
  GUI.Opponent.Main.Health.dif:hide()
  --
  -- Keybid
  GUI.Opponent.Main.keybind = Geyser.Label:new2({
    name = "GUI.Opponent.Main.keybind",
    x = 5, y = -10,
    width = -5,
    height = 10,
  }, GUI.Opponent.Main)
  GUI.Opponent.Main.keybind:enableClickthrough()
  GUI.Opponent.Main.keybind:setStyleSheet(GUI.CSS.Keybind);
  GUI.Opponent.Main.keybind:setFontSize(ui.parameters.widgets.keybind.fontSize);
  --
  -- Wrapping function
  local Minimize = GUI.Opponent.minimize
  local Restore = GUI.Opponent.restore
  --
  function GUI.Opponent:minimize(...)
    GUI.Opponent.Main:hide()
    return Minimize(GUI.Opponent)
  end
  --
  function GUI.Opponent:restore(...)
    GUI.Opponent.Main:show()
    return Restore(GUI.Opponent)
  end
end</script>
				<eventHandlerList />
			</Script>
			<Script isActive="yes" isFolder="no">
				<name>Player Widget</name>
				<packageName></packageName>
				<script>function ui.fInitPlayerWidget()
  ui.fDebug("[&lt;cyan&gt;call&lt;r&gt;] ui.fInitPlayerWidget()")
  --
  -- Player 
  GUI.Player = Adjustable.Container:new2({
    name = "GUI.Player",
    attached = "left",
    x = 0,
    y = "80%",
    width = 300,
    height = "20%",
    titleText ="Player",
    titleTxtColor = "orange",
    buttonsize = 12,
    buttonFontSize = 5,
    adjLabelstyle = GUI.CSS.Widget, 
    buttonstyle = GUI.CSS.WidgetButton,
  })
  GUI.Player:changeMenuStyle("dark")
  --
  -- Border and Main
  ui.fAddMain(GUI.Player, GUI.CSS.Border, GUI.CSS.Main)
  --
  -- Set transparent
  ui.fSetBorderMode(GUI.Player, ui.parameters.widgets.player.transparent)
  --
  -- Level
  GUI.Player.Level = Geyser.Label:new2({
    name = "GUI.Player.Level",
    x = -74,
    y = "0%-3",
    width = 25,
    height = 25,
    fontSize = 8,
  }, GUI.Player)
  GUI.Player.Level:setStyleSheet(GUI.CSS.Level);
  GUI.Player.Level:enableClickthrough()
  --
  -- Button "Hide"
  GUI.Player.Button_hide = Geyser.Label:new2({
    name = "GUI.Player.Button_hide",
    x = -46, 
    y = 4,
    width = 12,
    height = 12,
  },GUI.Player)
  GUI.Player.Button_hide:setStyleSheet(GUI.CSS.WidgetButton);
  GUI.Player.Button_hide:setFontSize(5)
  GUI.Player.Button_hide:echo(ui.transparentID);
  GUI.Player.Button_hide:setClickCallback(function() 
                                            local mode = ui.parameters.widgets.player.transparent or false;
                                            ui.fSetBorderMode(GUI.Player, not mode)
                                            ui.parameters.widgets.player.transparent = not mode;
                                            ui.fSaveFileParameters()
                                          end)
  GUI.Player.Button_hide:setToolTip("Transparent", 10)
  --
  -- Tick 
  GUI.Player.Main.Tick = Geyser.Gauge:new2({
    name = "GUI.Player.Main.Tick",
    x = 2, 
    y = 0,
    width = -2,
    height = 5,
  },GUI.Player.Main)
  GUI.Player.Main.Tick:setValue(0, 74)
  --
  GUI.Player.Main.Tick.front:echo("")
  --
  GUI.Player.Main.Tick.back:setStyleSheet(GUI.CSS.GaugeBack..[[
    background-color: rgba(255, 255, 255, 0.1);
    border-radius: 2px;
  ]])
  --
  GUI.Player.Main.Tick.front:setStyleSheet(GUI.CSS.GaugeFront..[[
    background-color: grey;
    border-radius: 1px;
  ]])
  --
  -- Health
  GUI.Player.Main.Health = Geyser.Gauge:new2({
    name = "GUI.Player.Main.Health",
    x = 2,
    y = 7,
    width = -2,
    height = "50%-8",
  },GUI.Player.Main)
  GUI.Player.Main.Health:setValue(0, 100)
  --
  GUI.Player.Main.Health.back:setStyleSheet(GUI.CSS.GaugeBack..[[
    background-color: rgba(150, 0, 0, 0.3);
  ]])
  --
  GUI.Player.Main.Health.front:setStyleSheet(GUI.CSS.GaugeFront..[[
    background-color: QLinearGradient( x1: 0, y1: 0, x2: 0, y2: 1, stop: 0 #ee0000, stop: 0.65 #990000, stop: 1 #bb0000);
  ]])
  GUI.Player.Main.Health.front:echo("Vita")
  --
  --
  GUI.Player.Main.Health.dif = Geyser.Label:new2({
    name = "GUI.Player.Main.Health.dif",
    x = 0,
    y = 0,
    width = "10",
    height = "10",
  }, GUI.Player.Main)
  GUI.Player.Main.Health.dif:setFontSize(5)
  GUI.Player.Main.Health.dif:hide();
  --
  -- Mana
  GUI.Player.Main.Mana = Geyser.Gauge:new2({
    name = "GUI.Player.Main.Mana",
    x = 2,
    y = "50%+1",
    width = -2,
    height = "25%-5",
  },GUI.Player.Main)
  GUI.Player.Main.Mana:setValue(0, 100)
  --
  GUI.Player.Main.Mana.back:setStyleSheet(GUI.CSS.GaugeBack..[[
    background-color: rgba(0, 100, 250, .3);
  ]])
  --
  GUI.Player.Main.Mana.front:setStyleSheet(GUI.CSS.GaugeFront..[[
    background-color: QLinearGradient( x1: 0, y1: 0, x2: 0, y2: 1, stop: 0 #0000ee, stop: 0.65 #000099, stop: 1 #0000bb);
  ]])
  GUI.Player.Main.Mana.front:echo("Mana")
  --
  -- Stamina (used for moviment)
  GUI.Player.Main.Stamina = Geyser.Gauge:new2({
    name = "GUI.Player.Main.Stamina",
    x = 2,
    y = "75%-2",
    width = -2,
    height = "25%-5",
  },GUI.Player.Main)
  GUI.Player.Main.Stamina:setValue(0, 100)
  --
  GUI.Player.Main.Stamina.back:setStyleSheet(GUI.CSS.GaugeBack..[[
    background-color: rgba(0, 250, 0, .2);
  ]])
  --
  GUI.Player.Main.Stamina.front:setStyleSheet(GUI.CSS.GaugeFront..[[
    background-color: QLinearGradient( x1: 0, y1: 0, x2: 0, y2: 1, stop: 0 #00aa00, stop: 0.65 #006600, stop: 1 #008800);
  ]])
  GUI.Player.Main.Stamina.front:echo("Movimento")
  --
  -- Experience 
  GUI.Player.Main.Experience = Geyser.Gauge:new2({
    name = "GUI.Player.Main.Experience",
    x = 2, 
    y = -6,
    width = -2,
    height = 5,
  },GUI.Player.Main)
  GUI.Player.Main.Experience:setValue(0, 100)
  --
  GUI.Player.Main.Experience.front:echo("")
  --
  GUI.Player.Main.Experience.back:setStyleSheet(GUI.CSS.GaugeBack..[[
    background-color: rgba(255, 255, 255, 0.1);
    border-radius: 2px;
  ]])
  --
  GUI.Player.Main.Experience.front:setStyleSheet(GUI.CSS.GaugeFront..[[
    background-color: purple;
    border-radius: 1px;
  ]])
  --
  -- Wrapping function
  local Minimize = GUI.Player.minimize
  local Restore = GUI.Player.restore
  --
  function GUI.Player:minimize(...)
    GUI.Player.Main:hide()
    return Minimize(GUI.Player)
  end
  --
  function GUI.Player:restore(...)
    GUI.Player.Main:show()
    return Restore(GUI.Player)
  end
end</script>
				<eventHandlerList />
			</Script>
			<Script isActive="yes" isFolder="no">
				<name>Room Widget</name>
				<packageName></packageName>
				<script>function ui.fInitRoomWidget()
  ui.fDebug("[&lt;cyan&gt;call&lt;r&gt;] ui.fInitRoomWidget()")
  --
  -- Room
  GUI.Room = Adjustable.Container:new2({
    name = "GUI.Room",
    attached = "left",
    x = 0,
    y = "55%",
    width = 300,
    height = "15%",
    titleText ="Stanza",
    titleTxtColor = "orange",
    buttonsize = 12,
    buttonFontSize = 5,
    adjLabelstyle = GUI.CSS.Widget, 
    buttonstyle = GUI.CSS.WidgetButton,
  })
  GUI.Room:changeMenuStyle("dark")
  --
  -- Add Border and Main
  ui.fAddMain(GUI.Room, GUI.CSS.Border, GUI.CSS.Main)
  --
  -- Exits
  GUI.Room.Main.Console = Geyser.MiniConsole:new2({ 
    name = 'GUI.Room.Main.Console',
    x=0,
    y=0,
    width = "100%", 
    height = "100%", 
    autoWrap = false,
    scrollBar = false,
  }, GUI.Room.Main)
  GUI.Room.Main.Console:setColor(30, 24, 24)
  GUI.Room.Main.Console:setBgColor(30, 24, 24)
  GUI.Room.Main.Console:setFontSize(ui.parameters.widgets.room.fontSize)
  --
  -- Wrapping function
  local Minimize = GUI.Room.minimize
  local Restore = GUI.Room.restore
  --
  function GUI.Room:minimize(...)
    GUI.Room.Main:hide()
    return Minimize(GUI.Room)
  end
  --
  function GUI.Room:restore(...)
    GUI.Room.Main:show()
    return Restore(GUI.Room)
  end
end</script>
				<eventHandlerList />
			</Script>
			<Script isActive="yes" isFolder="no">
				<name>Target Buttons Widget</name>
				<packageName></packageName>
				<script>function ui.fInitTargetButtonsWidget()
  ui.fDebug("[&lt;cyan&gt;call&lt;r&gt;] ui.fInitTargetButtonsWidget()")
  --
  -- Target
  GUI.TargetButtons = Adjustable.Container:new2({
    name = "GUI.TargetButtons",
    attached = "right",
    x = -500,
    y = "85%",
    width = 300,
    height = "15%",
    titleText ="Target",
    titleTxtColor = "orange",
    buttonsize = 12,
    buttonFontSize = 5,
    adjLabelstyle = GUI.CSS.Widget, 
    buttonstyle = GUI.CSS.WidgetButton,
  })
  GUI.TargetButtons:changeMenuStyle("dark")
  --
  -- Add Border and Main
  ui.fAddMain(GUI.TargetButtons, GUI.CSS.Border, GUI.CSS.Main)
  --
  -- Set transparent
  ui.fSetBorderMode(GUI.TargetButtons, ui.parameters.widgets.targets.transparent)
  --
  -- Button "Hide"
  GUI.TargetButtons.Button_hide = Geyser.Label:new2({
    name = "GUI.TargetButtons.Button_hide",
    x = -46, 
    y = 4,
    width = 12,
    height = 12,
  },GUI.TargetButtons)
  GUI.TargetButtons.Button_hide:setStyleSheet(GUI.CSS.WidgetButton);
  GUI.TargetButtons.Button_hide:setFontSize(5)
  GUI.TargetButtons.Button_hide:echo(ui.transparentID)
  GUI.TargetButtons.Button_hide:setClickCallback(function() 
                                                   local mode = ui.parameters.widgets.targets.transparent or false;
                                                   ui.fSetBorderMode(GUI.TargetButtons, not mode)
                                                   ui.parameters.widgets.targets.transparent = not mode;
                                                   ui.fSaveFileParameters()
                                                end)
  GUI.TargetButtons.Button_hide:setToolTip("Transparent", 10)
  --
  -- Target buttons
  for i=1,4 do
    GUI.TargetButtons.Main["t"..i] = Geyser.Label:new2({
      name = "GUI.TargetButtons.Main.t"..i,
      x = 0,
      y = 0,
      width = "10",
      height = "10",
    },GUI.TargetButtons.Main)
    GUI.TargetButtons.Main["t"..i]:setClickCallback("ui.fExecuteTargetButton", "t"..i, nil)
    GUI.TargetButtons.Main["t"..i]:setFontSize(9)
    GUI.TargetButtons.Main["t"..i]:setFgColor("LightGoldenrod")
    --
    -- Index
    GUI.TargetButtons.Main["t"..i].index = Geyser.Label:new2({
      name = "GUI.TargetButtons.Main.t"..i..".index",
      x = 5, 
      y = 1,
      width = "15",
      height = "15",
    }, GUI.TargetButtons.Main["t"..i])
    GUI.TargetButtons.Main["t"..i].index:enableClickthrough()
    GUI.TargetButtons.Main["t"..i].index:setFontSize(ui.parameters.widgets.keybind.fontSize)
    GUI.TargetButtons.Main["t"..i].index:setStyleSheet(GUI.CSS.Keybind);
    GUI.TargetButtons.Main["t"..i].index:echo("t"..i.."")
    --
    -- Keybid
    GUI.TargetButtons.Main["t"..i].keybind = Geyser.Label:new2({
      name = "GUI.TargetButtons.Main.t"..i..".keybind",
      x = 5, 
      y = -15,
      width = "100%-10",
      height = 15,
    }, GUI.TargetButtons.Main["t"..i])
    GUI.TargetButtons.Main["t"..i].keybind:enableClickthrough()
    GUI.TargetButtons.Main["t"..i].keybind:setStyleSheet(GUI.CSS.Keybind);
    GUI.TargetButtons.Main["t"..i].keybind:setFontSize(ui.parameters.widgets.keybind.fontSize)
  end
  --
  -- Wrapping function
  local Minimize = GUI.TargetButtons.minimize
  local Restore = GUI.TargetButtons.restore
  local Resize = GUI.TargetButtons.resize
  --
  function GUI.TargetButtons:minimize(...)
    GUI.TargetButtons.Main:hide()
    return Minimize(GUI.TargetButtons)
  end
  --
  function GUI.TargetButtons:restore(...)
    GUI.TargetButtons.Main:show()
    return Restore(GUI.TargetButtons)
  end
  --
  function GUI.TargetButtons:resize(...)
    ui.fRefreshTargetButtonsWidget()
    return Resize(GUI.TargetButtons, ...)
  end
end</script>
				<eventHandlerList />
			</Script>
		</ScriptGroup>
		<Script isActive="yes" isFolder="no">
			<name>Init</name>
			<packageName></packageName>
			<script>--
-- Init structures
ui.initStructures()
--
-- init CSS
ui.initCSS()
--
-- init Help
ui.initHelp()
--
-- Init DATA directory
if (ui.fInitDataDirectory()) then
  --
  -- Init Settings directory
  if (ui.fInitSettings()) then
    --
    -- Load generic parameters
    ui.fReadFileParameters()
    --
    -- Init Opponent widget
    ui.fInitOpponentWidget()
    --
    -- Init Group widget
    ui.fInitGroupWidget()
    --
    -- Init Target Buttons widget
    ui.fInitTargetButtonsWidget()
    --
    -- Init Chat widget
    ui.fInitChatWidget()
    --
    -- Init Player widget
    ui.fInitPlayerWidget()
    --
    -- Init Alias Button widget
    ui.fInitAliasButtonsWidget()
    --
    -- Init Affects widget
    ui.fInitAffectsWidget()
    --
    -- Init Room widget
    ui.fInitRoomWidget()
    --
    -- Init Endowment widget
    ui.fInitEndowmentWidget()
    --
    -- Init Help widget
    ui.fInitHelpWidget()
    --
    -- For drawing all target buttons
    ui.fUpdateAllTargetButtons()
    ui.fUpdateAliasButton()
    ui.fUpdateChat()
    --
    -- Check if the generic_mapper package is installed and if so uninstall it
    if table.contains(getPackages(), "generic_mapper") then
      ui.fDebug("[&lt;white&gt;init&lt;r&gt;] Unistall 'generic_mapper package")
      uninstallPackage("generic_mapper")
    end
    --
    -- GMCP
    ui.fDebug("[&lt;white&gt;init&lt;r&gt;] setMergeTables()")
    setMergeTables("MSDP")
    --
    -- Events:
    -- gmcp (MSDP) event
    ui.fDebug("[&lt;white&gt;init&lt;r&gt;] Register events")
    if (ui.handlers.fUpdateGMCP) then
      killAnonymousEventHandler(ui.handlers.fUpdateGMCP)
      ui.handlers.fUpdateGMCP = nil
    end
    ui.handlers.fUpdateGMCP  = registerAnonymousEventHandler("gmcp.MSDP", "ui.fUpdateGMCP");
    --
    -- Resize main window event
    if (ui.handlers.fWindowResize) then
      killAnonymousEventHandler(ui.handlers.fWindowResize)
      ui.handlers.fWindowResize = nil
    end
    ui.handlers.fWindowResize = registerAnonymousEventHandler("sysWindowResizeEvent", ui.fWindowResize)
    --
    -- Connection event
    if (ui.handlers.fConnection) then
      killAnonymousEventHandler(ui.handlers.fConnection)
      ui.handlers.fConnection = nil
    end
    ui.handlers.fConnection = registerAnonymousEventHandler("sysConnectionEvent", "ui.fConnection")
    --
    ui.fDebug("[&lt;white&gt;init&lt;r&gt;] ... end UI init!")
  --
  else
    ui.fEcho("&lt;red&gt; - Errore caricamento cartella "..ui.fGetSettingNameFormattedText("setting").."&lt;red&gt;.&lt;r&gt;\n")
  end
--
else
  ui.fEcho("&lt;red&gt; - Errore caricamento cartella &lt;white&gt;dati&lt;red&gt;.&lt;r&gt;\n")
end</script>
			<eventHandlerList />
		</Script>
	</ScriptPackage>
	<KeyPackage>
		<KeyGroup isActive="yes" isFolder="yes">
			<name>Keypad</name>
			<packageName></packageName>
			<script></script>
			<command></command>
			<keyCode>-1</keyCode>
			<keyModifier>0</keyModifier>
			<KeyGroup isActive="yes" isFolder="yes">
				<name>Movement (keypad)</name>
				<packageName></packageName>
				<script></script>
				<command></command>
				<keyCode>-1</keyCode>
				<keyModifier>0</keyModifier>
				<Key isActive="yes" isFolder="no">
					<name>keypad + 1 (down)</name>
					<packageName></packageName>
					<script></script>
					<command>d</command>
					<keyCode>49</keyCode>
					<keyModifier>536870912</keyModifier>
				</Key>
				<Key isActive="yes" isFolder="no">
					<name>keypad + 2 (south)</name>
					<packageName></packageName>
					<script></script>
					<command>s</command>
					<keyCode>50</keyCode>
					<keyModifier>536870912</keyModifier>
				</Key>
				<Key isActive="yes" isFolder="no">
					<name>keypad + 4 (west)</name>
					<packageName></packageName>
					<script></script>
					<command>w</command>
					<keyCode>52</keyCode>
					<keyModifier>536870912</keyModifier>
				</Key>
				<Key isActive="yes" isFolder="no">
					<name>keypad + 6 (east)</name>
					<packageName></packageName>
					<script></script>
					<command>e</command>
					<keyCode>54</keyCode>
					<keyModifier>536870912</keyModifier>
				</Key>
				<Key isActive="yes" isFolder="no">
					<name>keypad + 8 (north)</name>
					<packageName></packageName>
					<script></script>
					<command>n</command>
					<keyCode>56</keyCode>
					<keyModifier>536870912</keyModifier>
				</Key>
				<Key isActive="yes" isFolder="no">
					<name>keypad + 9 (up)</name>
					<packageName></packageName>
					<script></script>
					<command>u</command>
					<keyCode>57</keyCode>
					<keyModifier>536870912</keyModifier>
				</Key>
			</KeyGroup>
		</KeyGroup>
	</KeyPackage>
	<VariablePackage>
		<HiddenVariables />
	</VariablePackage>
</MudletPackage>
