<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE MudletPackage>
<MudletPackage version="1.001">
	<HostPackage>
		<Host autoClearCommandLineAfterSend="no" HighlightHistory="yes" printCommand="yes" USE_IRE_DRIVER_BUGFIX="yes" mUSE_FORCE_LF_AFTER_PROMPT="no" mUSE_UNIX_EOL="no" mNoAntiAlias="no" mEchoLuaErrors="yes" runAllKeyMatches="no" AmbigousWidthGlyphsToBeWide="auto" mRawStreamDump="yes" mIsLoggingTimestamps="no" logDirectory="" logFileName="" logFileNameFormat="yyyy-MM-dd#HH-mm-ss" mAlertOnNewData="yes" mFORCE_NO_COMPRESSION="no" mFORCE_GA_OFF="no" mFORCE_SAVE_ON_EXIT="yes" mEnableGMCP="yes" mEnableMSSP="no" mEnableMSP="no" mEnableMSDP="no" mMapStrongHighlight="no" mEnableSpellCheck="yes" mEnableUserDictionary="yes" mUseSharedDictionary="no" mShowInfo="no" mAcceptServerGUI="yes" mAcceptServerMedia="yes" mMapperUseAntiAlias="yes" mMapperShowRoomBorders="yes" mFORCE_MXP_NEGOTIATION_OFF="no" mFORCE_CHARSET_NEGOTIATION_OFF="no" enableTextAnalyzer="no" mRoomSize="0.1" mLineSize="7.0" mBubbleMode="no" mMapViewOnly="no" mShowRoomIDs="no" mShowPanel="yes" mHaveMapperScript="yes" mEditorAutoComplete="no" mEditorShowBidi="yes" mEditorTheme="super" mEditorThemeFile="super.tmTheme" mThemePreviewItemID="4" mThemePreviewType="trigger" mSearchEngineName="Google" mTimerSupressionInterval="00:00:00.000" mUseProxy="no" mProxyAddress="" mProxyPort="0" mProxyUsername="" mProxyPassword="" mSslTsl="no" mSslIgnoreExpired="yes" mSslIgnoreSelfSigned="yes" mSslIgnoreAll="yes" mAskTlsAvailable="no" mDiscordAccessFlags="2495" mRequiredDiscordUserName="" mRequiredDiscordUserDiscriminator="" mSGRCodeHasColSpaceId="no" mServerMayRedefineColors="no" playerRoomPrimaryColor="#ffff0000" playerRoomSecondaryColor="#ffffffff" playerRoomStyle="0" playerRoomOuterDiameter="120" playerRoomInnerDiameter="70" CompactInputLine="no" mDoubleClickIgnore="'&quot;" EditorSearchOptions="0" DebugShowAllProblemCodepoints="no" announceIncomingText="yes" caretShortcut="None" blankLineBehaviour="Show" NetworkPacketTimeout="10">
			<name>LeU Live in progress...</name>
			<mInstalledPackages>
				<string>Lumen et Umbra UI</string>
				<string>Telegram Connector</string>
				<string>luogotenenti_aliases</string>
				<string>Luogotenenti_scripts</string>
				<string>Luogotenenti_triggers</string>
				<string>Invasioni</string>
				<string>generic_mapper</string>
			</mInstalledPackages>
			<url>mclmud.mclink.it</url>
			<serverPackageName>nothing</serverPackageName>
			<serverPackageVersion>-1</serverPackageVersion>
			<port>6000</port>
			<borderTopHeight>0</borderTopHeight>
			<borderBottomHeight>0</borderBottomHeight>
			<borderLeftWidth>305</borderLeftWidth>
			<borderRightWidth>515</borderRightWidth>
			<wrapAt>120</wrapAt>
			<wrapIndentCount>0</wrapIndentCount>
			<mFgColor>#c0c0c0</mFgColor>
			<mBgColor>#000000</mBgColor>
			<mCommandFgColor>#717100</mCommandFgColor>
			<mCommandBgColor>#000000</mCommandBgColor>
			<mCommandLineFgColor>#808080</mCommandLineFgColor>
			<mCommandLineBgColor>#000000</mCommandLineBgColor>
			<mBlack>#000000</mBlack>
			<mLightBlack>#808080</mLightBlack>
			<mRed>#800000</mRed>
			<mLightRed>#ff0000</mLightRed>
			<mBlue>#000080</mBlue>
			<mLightBlue>#0000ff</mLightBlue>
			<mGreen>#008000</mGreen>
			<mLightGreen>#00ff00</mLightGreen>
			<mYellow>#808000</mYellow>
			<mLightYellow>#ffff00</mLightYellow>
			<mCyan>#008080</mCyan>
			<mLightCyan>#00ffff</mLightCyan>
			<mMagenta>#800080</mMagenta>
			<mLightMagenta>#ff00ff</mLightMagenta>
			<mWhite>#c0c0c0</mWhite>
			<mLightWhite>#ffffff</mLightWhite>
			<mDisplayFont>Noto Mono,8,-1,5,50,0,0,0,1,0</mDisplayFont>
			<mCommandLineFont>Bitstream Vera Sans Mono,14,-1,5,50,0,0,0,0,0</mCommandLineFont>
			<mCommandSeparator>;</mCommandSeparator>
			<commandLineMinimumHeight>30</commandLineMinimumHeight>
			<mFgColor2>#c0c0c0</mFgColor2>
			<mBgColor2>#000000</mBgColor2>
			<mRoomBorderColor>#c0c0c0</mRoomBorderColor>
			<mMapInfoBg alpha="255">#969696</mMapInfoBg>
			<mBlack2>#000000</mBlack2>
			<mLightBlack2>#808080</mLightBlack2>
			<mRed2>#800000</mRed2>
			<mLightRed2>#ff0000</mLightRed2>
			<mBlue2>#000080</mBlue2>
			<mLightBlue2>#0000ff</mLightBlue2>
			<mGreen2>#008000</mGreen2>
			<mLightGreen2>#00ff00</mLightGreen2>
			<mYellow2>#808000</mYellow2>
			<mLightYellow2>#ffff00</mLightYellow2>
			<mCyan2>#008080</mCyan2>
			<mLightCyan2>#00ffff</mLightCyan2>
			<mMagenta2>#800080</mMagenta2>
			<mLightMagenta2>#ff00ff</mLightMagenta2>
			<mWhite2>#c0c0c0</mWhite2>
			<mLightWhite2>#ffffff</mLightWhite2>
			<mSpellDic>it_IT</mSpellDic>
			<mLineSize>7.0</mLineSize>
			<mRoomSize>0.1</mRoomSize>
			<profileShortcut key="Script editor">Alt+E</profileShortcut>
			<profileShortcut key="Show Map">Alt+M</profileShortcut>
			<profileShortcut key="Compact input line">Alt+L</profileShortcut>
			<profileShortcut key="Preferences">Alt+P</profileShortcut>
			<profileShortcut key="Notepad">Alt+N</profileShortcut>
			<profileShortcut key="Package manager">Alt+O</profileShortcut>
			<profileShortcut key="Module manager">Alt+I</profileShortcut>
			<profileShortcut key="MultiView">Alt+V</profileShortcut>
			<profileShortcut key="Play">Alt+C</profileShortcut>
			<profileShortcut key="Disconnect">Alt+D</profileShortcut>
			<profileShortcut key="Reconnect">Alt+R</profileShortcut>
			<profileShortcut key="Close profile">Alt+W</profileShortcut>
			<stopwatches />
		</Host>
	</HostPackage>
	<TriggerPackage>
		<TriggerGroup isActive="yes" isFolder="yes" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
			<name>Lumen et Umbra UI</name>
			<script></script>
			<triggerType>0</triggerType>
			<conditonLineDelta>0</conditonLineDelta>
			<mStayOpen>0</mStayOpen>
			<mCommand></mCommand>
			<packageName>Lumen et Umbra UI</packageName>
			<mFgColor>#ff0000</mFgColor>
			<mBgColor>#ffff00</mBgColor>
			<mSoundFile></mSoundFile>
			<colorTriggerFgColor>#000000</colorTriggerFgColor>
			<colorTriggerBgColor>#000000</colorTriggerBgColor>
			<regexCodeList />
			<regexCodePropertyList />
			<TriggerGroup isActive="yes" isFolder="yes" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>Communications</name>
				<script></script>
				<triggerType>0</triggerType>
				<conditonLineDelta>99</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList />
				<regexCodePropertyList />
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>Personal communications</name>
					<script>ui.fDebug("[trig] Personal communications")
--
local from = copy2decho(matches[2])
local to = copy2decho(matches[3])
local message = copy2decho(matches[4])
--
if (matches[2] == "["..ui.variables.character_name.."]") then
  from = string.gsub(from, ui.variables.character_name, "Tu")
  from = string.gsub(from, "]\&lt;r\&gt;", "]")
  from = from.." a "..matches[3].."\&lt;r\&gt;"
elseif (matches[2] == "Mandi") or (matches[2] == "Tu") then
  local color = string.gsub(from, matches[2].."\&lt;r\&gt;", "")
  from = color.."[\&lt;255,255,255:0,0,0\&gt;"..matches[2] ..color.."]".." a \&lt;255,255,255:0,0,0\&gt;"..matches[3].."\&lt;r\&gt;"
  from = string.gsub(from, "Mandi", "Tu")
else
  ui.reply = matches[2];
  ui.reply = string.gsub(ui.reply, "%[", "")
  ui.reply = string.gsub(ui.reply, "%]", "")
  ui.reply = string.gsub(ui.reply, ",", "")
  ui.reply = ui.fRemoveArticle(ui.reply)
  ui.reply = string.sub (ui.reply, 1, string.find(ui.reply, " "))
  --
  -- Reply
  GUI.PrivateChat:setTitle("Canale privato ["..ui.reply.."]")
end
--
if (ui.lastFromPrivate) and (ui.lastFromPrivate == from) then
  str = "  "..message.."\n"
else
  str = "\n"..from.." &lt;128,128,128:30,24,24&gt;"..os.date("%H:%M:%S").."\n  "..message.."\n"
  ui.lastFromPrivate = from
end
--
str = string.gsub(str, ":0,0,0&gt;", ":30,24,24&gt;")
str = string.gsub(str, "&lt;0,0,255:", "&lt;128,128,255:")
GUI.PrivateChat.Main.Body.Console:decho(str)
playSoundFile(ui.pathSnd..[[message.wav]], 10)</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>^(Mandi) a (.*) il (?:pensiero|messaggio) (\'.*\')$</string>
						<string>^(Tu) (?:chiedi|dici|sussurri) (?:a|ai|al|alla|alle|agli) (.*) (\'.*\')$</string>
						<string>^(\[.*\]) (ti) (?:manda il messaggio|manda il pensiero|chiede|dice|sussurra) (\'.*\')$</string>
						<string>^(\[.*\]) dice (?:a |ai |al |all'|alla |alle |agli )(.*) (\'.*\')$</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
						<integer>1</integer>
						<integer>1</integer>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>Public  communication</name>
					<script>ui.fDebug("[trig] Public communication")
--
local str = copy2decho(matches[1])
local color = copy2decho(matches[2])
local from = copy2decho(matches[3])
local message = copy2decho(matches[4])
-- Color
color = string.gsub(color, 'Tu&lt;r&gt;', '')
color = string.gsub(color, '%[&lt;r&gt;', '')
-- Text
if (ui.lastFromPubblic) and (ui.lastFromPubblic == from) then
  str = "  "..message.."\n"
  str = string.gsub(str, ":0,0,0&gt;",    ":30,24,24&gt;")
else
  str = string.gsub(str, "&gt;Tu",      "&gt;[Tu]")
  str = string.gsub(str, "] grida ",   "]")
  str = string.gsub(str, "] esclama ", "]")
  str = string.gsub(str, "] mormora ", "]")
  str = string.gsub(str, "] vi dice ", "]")
  str = string.gsub(str, "] dice ",    "]")
  str = string.gsub(str, "] dici ",    "]")
  str = string.gsub(str, "] risuona ", "]")
  str = string.gsub(str, "]",          "] &lt;128,128,128:30,24,24&gt;"..os.date("%H:%M:%S").."\n  "..color)
  str = string.gsub(str, ":0,0,0&gt;",    ":30,24,24&gt;")
  str = "\n"..str.."\n"
  ui.lastFromPubblic = from
end
from = ui.fRemoveArticle(from)
GUI.PublicChat:setTitle("Canale pubblico ["..from.."]")
GUI.PublicChat.Main.Body.Console:decho(str)</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>(^\[)(.*)\] (?:grida|esclama|mormora|vi dice|dice|risuona) (\'.*\')$</string>
						<string>(^(Tu)) (?:gridi|dici) (\'.*\')$</string>
						<string>(^\[)(.*)\] (\'.*\')$</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
						<integer>1</integer>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
			</TriggerGroup>
			<TriggerGroup isActive="yes" isFolder="yes" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>Exits</name>
				<script></script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList />
				<regexCodePropertyList />
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>Exits</name>
					<script>ui.fDebug("[trig] Exits")
ui.strExits = matches[2]
ui.fUpdateMap()</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>^Uscite: (.*)</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>Room name</name>
					<script>ui.fDebug("[trig] Room name")
ui.roomName = matches[2]
ui.roomType = matches[3]</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>^(.*) - (Foresta|Al chiuso|Citta'|Deserto|Pianura|Strada|Collina|Montagna|Acque Basse|Acque Profonde|Sott'acqua|A mezz'aria|Tra gli Alberi|Citta' oscura|Sottosuolo|Dungeon|Caverna|Cripta|Castello|Maniero|Tempio|Prigione|Negozio|Giungla|Costa|Spiaggia|Palude|Tundra|Taiga|Ghiacci|Steppa|Savana|Piano Astrale|Piano Esterno|Sigil|Vuoto cosmico|Sconosciuto|Teletrasporto|Prato)</string>
						<string>^(.*) (\[Zona di Guerra\])</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>Teleport</name>
					<script>ui.fDebug("[trig] Teleport")
--
ui.path = {}
ui.memPath = 0
ui.idxPath = 0
--
ui.nCad = 0</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>Chiudi gli occhi ed apri un passaggio nel quale entri velocemente.</string>
						<string>Cerchi di attraversare l'acqua, ma la superfice sembra respingerti.</string>
						<string>Cerchi di fuggire in tutta fretta.</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>3</integer>
						<integer>3</integer>
						<integer>3</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>Specchi di Astral</name>
					<script>ui.fDebug("[trig] Specchi di Astral")
ui.strExits = ui.strExits.." "..string.gsub(matches[2], " ", "-")
ui.fUpdateMap()</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>^Nell'avvicinarti vedi uno specchio d'acqua color (.*).</string>
						<string>^Nell'avvicinarti vedi uno specchio d'acqua di colore (.*).</string>
						<string>^Nell'avvicinarti vedi uno specchio d'acqua appiccicosa color (.*).</string>
						<string>^Nell'avvicinarti vedi uno specchio d'acqua (.*).</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
						<integer>1</integer>
						<integer>1</integer>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
			</TriggerGroup>
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>Equipment</name>
				<script>local m = matches[2]
ui.fDebug("[trig] Equipment start")
ui.equipment = {}
clearWindow("GUI.Equipment.Main.Body.Console")
enableTrigger("equipment_valid")
enableTrigger("equipment_end")

if (m) then
  GUI.Equipment:setTitle("Eq. ("..ui.fRemoveArticle(m)..") "..getTime(true, "[hh:mm]"))
else
  GUI.Equipment:setTitle("Equipaggiamento "..getTime(true, "[hh:mm]"))
end</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>1</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>^Stai usando:$</string>
					<string>^(.*) sta usando:$</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>1</integer>
					<integer>1</integer>
				</regexCodePropertyList>
				<Trigger isActive="no" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>equipment_valid</name>
					<script>-- match[1] = [2:numero] &lt;3:locazione&gt; [4:livello] |5:tipo| 6:descrizione
ui.fDebug("[trig] Equipment_valid")
if (matches[5] == "") then
  matches[5] = "-"
end
local equipment = {}
equipment.number   = matches[2]
equipment.location = string.gsub(copy2decho(matches[3]), ":0,0,0&gt;", ":30,24,24&gt;")
equipment.level    = string.gsub(copy2decho(matches[4]), ":0,0,0&gt;", ":30,24,24&gt;")
equipment.type     = string.gsub(copy2decho(matches[5]), ":0,0,0&gt;", ":30,24,24&gt;")
equipment.name, equipment.statusColor, equipment.good, equipment.evil, equipment.bring, equipment.noisy, equipment.brittle = ui.fParsingItem(copy2decho(matches[6]))
equipment.name = string.gsub(equipment.name, ":0,0,0&gt;", ":30,24,24&gt;")
if (equipment.good) then
  equipment.name = equipment.name.."&lt;0,0,255:30,24,24&gt;*"
end
if (equipment.evil) then
  equipment.name = equipment.name.."&lt;255,0,0:30,24,24&gt;*"
end
if (equipment.bright) then
  equipment.name = equipment.name.."&lt;255,255,255:30,24,24&gt;*"
end
if (equipment.noisy) then
  equipment.name = equipment.name.."&lt;128,128,128:30,24,24&gt;*"
end
if (equipment.brittle) then
  equipment.name = equipment.name.."&lt;0,128,128:30,24,24&gt;*"
end
GUI.Equipment.Main.Body.Console:decho(equipment.statusColor..equipment.number.."&lt;r&gt; "..equipment.level.." "..equipment.type.. " "..equipment.name.."\n")
table.insert(ui.equipment, equipment)
setTriggerStayOpen("Equipment", 1)
</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>(?:\[(.*)\] )?\&lt;(.*)\&gt;.*\[(.*)\] (?:\|(.*)\| )?(.*)</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="no" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>equipment_end</name>
					<script>ui.fDebug("[trig] Equipment_end")
disableTrigger("equipment_valid")
disableTrigger("equipment_invalid")
disableTrigger("equipment_end")</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>^Il livello di potenza medio del tuo equipaggiamento e' .*$</string>
						<string>^    Nulla.$</string>
						<string>^$</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
						<integer>1</integer>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
			</Trigger>
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>Loot</name>
				<script>local m = matches[2] or ""
ui.fDebug("[trig] Loot start")
clearWindow("GUI.Inventory.Main.Body.Console")
enableTrigger("loot_valid")
enableTrigger("loot_invalid")
enableTrigger("loot_end")

if (m == "Stai trasportando:") or (m == "Non stai trasportando nulla.") then
  GUI.Inventory:setTitle("Inventario "..getTime(true, "[hh:mm]"))
else
  GUI.Inventory:setTitle("Contenitore "..getTime(true, "[hh:mm]"))
end</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>1</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>^(Stai trasportando:)$</string>
					<string>^(Non stai trasportando nulla.)</string>
					<string>^(Quando ci guardi dentro, vedi:)</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>1</integer>
					<integer>1</integer>
					<integer>1</integer>
				</regexCodePropertyList>
				<Trigger isActive="no" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>loot_valid</name>
					<script>-- match[1] = [2:numero] &lt;3:locazione&gt; [4:livello] |5:tipo| 6:descrizione
ui.fDebug("[trig] Loot_valid")
if (matches[3]=="") then
  matches[3] = "-"
end
local number   = matches[2]
local eqtype   = string.gsub(copy2decho(matches[3]), ":0,0,0&gt;", ":30,24,24&gt;")
local name, statusColor, good, evil, bring, noisy, brittle = ui.fParsingItem(copy2decho(matches[4]))
name = string.gsub(name, ":0,0,0&gt;", ":30,24,24&gt;")
if (good) then
  name = name.."&lt;0,0,255:30,24,24&gt;*"
end
if (evil) then
  name = name.."&lt;255,0,0:30,24,24&gt;*"
end
if (bright) then
  name = name.."&lt;255,255,255:30,24,24&gt;*"
end
if (noisy) then
  name = name.."&lt;128,128,128:30,24,24&gt;*"
end
if (brittle) then
  name = name.."&lt;0,128,128:30,24,24&gt;*"
end
GUI.Inventory.Main.Body.Console:decho(statusColor..number.."&lt;r&gt; "..eqtype.. " "..name.."\n")
setTriggerStayOpen("Loot", 1)
</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>1</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>^\[(.*)\] (?:\|(.*)\| )?(.*)</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="no" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>loot_invalid</name>
					<script>ui.fDebug("[trig] Loot_invalid")
if (matches[2]) then
  GUI.Inventory:setTitle(matches[2].." "..getTime(true, "[hh:mm]"))
end
setTriggerStayOpen("Loot", 1)</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>1</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>^Oggetti in inventario : .* su .*</string>
						<string>^Peso trasportato\s+: .* su .* etti</string>
						<string>^(.*) \(.*\)'*</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
						<integer>1</integer>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="no" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>loot_end</name>
					<script>ui.fDebug("[trig] Loot_end")
disableTrigger("loot_valid")
disableTrigger("loot_invalid")
disableTrigger("loot_end")</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>^$</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
			</Trigger>
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>Affects Capture</name>
				<script>ui.fDebug("[trig] Affect start")
ui.actAffects = {}
enableTrigger("affects_invalid")
enableTrigger("affects_valid")
enableTrigger("affects_end")</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>1</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>+- Effetti Attivi -------------------------------------------------------------+</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>3</integer>
				</regexCodePropertyList>
				<Trigger isActive="no" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>affects_invalid</name>
					<script>ui.fDebug("[trig] Affect_invalid")
setTriggerStayOpen("Affects Capture", 1)</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>1</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>| Non hai effetti attivi al momento...                                         |</string>
						<string>+- Effetti Permanenti ---------------------------------------------------------+</string>
						<string>| Non hai effetti permanenti attivi...                                         |</string>
						<string>+- Altri Effetti --------------------------------------------------------------+</string>
						<string>| Non hai altri effetti attivi...                                              |</string>
						<string>+- Cooldown -------------------------------------------------------------------+</string>
						<string>| Non hai cooldown attivi al momento...                                        |</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>3</integer>
						<integer>3</integer>
						<integer>3</integer>
						<integer>3</integer>
						<integer>3</integer>
						<integer>3</integer>
						<integer>3</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="no" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>affects_valid</name>
					<script>ui.fDebug("[trig] Affect_valid")
local name = string.trim(matches[2])
local duration = tonumber(string.trim(matches[3]))
if (matches[4] == "round") then
  duration = duration / 10
end
ui.actAffects[name] = duration
setTriggerStayOpen("Affects Capture", 1)</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>1</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>^\|(.*)\| (.*) (ore|round)\s+\|</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="no" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>affects_end</name>
					<script>ui.fDebug("[trig] Affect_end")
disableTrigger("affects_invalid")
disableTrigger("affects_valid")
disableTrigger("affects_end")
ui.fUpdateAffects()</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>+------------------------------------------------------------------------------+</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>3</integer>
					</regexCodePropertyList>
				</Trigger>
			</Trigger>
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>Group</name>
				<script>ui.fDebug("[trig] Group start")
ui.group = {}
ui.totalMember = 0
enableTrigger("group_valid")
enableTrigger("group_end")</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>1</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>^Ma non sei il membro di un gruppo!$</string>
					<string>^I membri del tuo gruppo(.*)sono\:(.*)$</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>1</integer>
					<integer>1</integer>
				</regexCodePropertyList>
				<Trigger isActive="no" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>group_valid</name>
					<script>ui.fDebug("[trig] group_valid")
if (matches[2] ~= ui.variables.character_name) then
  local member = {matches[2], (matches[3] == "(Capo)"), tonumber(matches[4]), tonumber(matches[5]), tonumber(matches[6])}
  ui.totalMember = ui.totalMember + 1
  ui.group[ui.totalMember] = member
end
setTriggerStayOpen("Group", 1)</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#00ff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>^\s+(\S+)\s+(.*) HP:\s+(\d+)\% MANA:\s+(\d+)\% MV:\s+(\d+)\%$</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="no" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>group_end</name>
					<script>ui.fDebug("[trig] group_end")
disableTrigger("group_valid")
disableTrigger("group_end")
--
ui.fUpdateGroup()</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>1</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#00ffff</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>^$</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
			</Trigger>
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>Tick</name>
				<script>ui.fIncrementTickTimer(65)</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>^Un[']altra ora della giornata si accinge a trascorrere[.]</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>1</integer>
				</regexCodePropertyList>
			</Trigger>
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>Track</name>
				<script>ui.fDebug("[trig] Track")
if (matches[2]) then
  ui.track = ui.dirCompress[string.lower(matches[2])]
else
  ui.track = ""
end
ui.fUpdateMap()</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>^Vedi una traccia della tua preda che va verso (?:l'|il )?(.*).$</string>
					<string>^Vedi una debole traccia verso (?:l'|il )?(.*)$</string>
					<string>^Cio' che cerchi e' gia' qui!$</string>
					<string>^Non riesci a trovare tracce.$</string>
					<string>^Hai trovato la tua preda!$</string>
					<string>^Hai perso la traccia.$</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>1</integer>
					<integer>1</integer>
					<integer>1</integer>
					<integer>1</integer>
					<integer>1</integer>
					<integer>1</integer>
				</regexCodePropertyList>
			</Trigger>
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="yes" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>Position</name>
				<script>ui.position = matches[2] or ""
ui.fUpdateMap()</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>^Ti muovi rapidamente verso (?:il lato|l'angolo|il) (.*) della stanza.</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>1</integer>
				</regexCodePropertyList>
			</Trigger>
		</TriggerGroup>
		<TriggerGroup isActive="yes" isFolder="yes" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
			<name>Varie</name>
			<script></script>
			<triggerType>0</triggerType>
			<conditonLineDelta>0</conditonLineDelta>
			<mStayOpen>0</mStayOpen>
			<mCommand></mCommand>
			<packageName></packageName>
			<mFgColor>#ff0000</mFgColor>
			<mBgColor>#ffff00</mBgColor>
			<mSoundFile></mSoundFile>
			<colorTriggerFgColor>#000000</colorTriggerFgColor>
			<colorTriggerBgColor>#000000</colorTriggerBgColor>
			<regexCodeList />
			<regexCodePropertyList />
			<TriggerGroup isActive="yes" isFolder="yes" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>Luogotenenti</name>
				<script></script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList />
				<regexCodePropertyList />
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>Turbine</name>
					<script>--[[
Questo Luogotenente ha come special skill un turbine di energia che lancia ogni 4 round.
Basta semplicemente essere nella stessa location in cui lancia il turbine.
Dovete spostarvi perché tra il lancio del turbine e la special passa solo 1 round. 
Se al lancio del turbine non sarete nella giusta posizione perdete 1500 hp.
]]
local direzione = matches[2]
cecho("\n&lt;white:red&gt; * TURBINE * &lt;reset&gt; Muoversi a "..direzione.."\n")
sposta(getPosition(direzione))
</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>crea un turbine di energia presso l'angolo (.*) della stanza.</string>
						<string>crea un turbine di energia presso il lato (.*) della stanza</string>
						<string>crea un turbine di energia presso il (.*) della stanza.</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
						<integer>1</integer>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>Raggio</name>
					<script>--[[
Questo Luogotenente ha come special skill un raggio di energia pura che va evitato (toglie 2500 hp). 
Per evitarlo basta essere in un positioning diverso da quello dove indirizza il raggio. 
]]
local direction = getPosition(matches[2])
local actualPosition = getPosition(ui.position)
cecho("\n&lt;white:red&gt; * RAGGIO * &lt;reset&gt; Spostarsi da "..matches[2].." ("..direction..") (se uguale)\n")
if (actualPosition == direction) then
  if (actualPosition == 5) then
    sposta(1)
  else
    sposta(5)
  end
end</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>sembra guardare verso il lato (.*) della stanza.</string>
						<string>sembra guardare verso l'angolo (.*) della stanza.</string>
						<string>sembra guardare verso il (.*) della stanza.</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
						<integer>1</integer>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>Tremore</name>
					<script>--[[
Questo Luogotenente ha come special skill un doppio turbine di energia che lancia ogni 4 round. 
Il principio é lo stesso del turbine singolo, solo che essendo un turbine bidirezionale (va in due direzioni diverse), 
occorre coordinarsi col resto del gruppo in modo che un player vada sempre nel primo positioning. 
Il secondo player (o resto del gruppo) vada sempre nella seconda posizione in modo da evitare completamente i danni della special (1500 hp).
A differenza del turbine singolo, qui il Luogotenente vi concede due round per spostarvi correttamente nei giusti positioning. 
In pratica lancia il turbine bidirezionale, poi ci sarà un round bonus in cui avete ancora tempo per essere nei giusti positioning, 
infine lancia a special skill. E via cosi.
]]
local direzioneA = matches[2]
local direzioneB = matches[2]
cecho("\n&lt;white:red&gt; * TREMORE (doppio turbine) * &lt;reset&gt; Muoversi a "..direzioneA.."\n")
sposta(getPosition(direzioneA))</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>un tremore scuote il lato (.*) e l'angolo (.*) della stanza</string>
						<string>un tremore scuote il lato (.*) e il lato (.*) della stanza</string>
						<string>un tremore scuote il (.*) e l'angolo (.*) della stanza</string>
						<string>un tremore scuote il (.*) e il lato (.*) della stanza</string>
						<string>un tremore scuote l'angolo (.*) e l'angolo (.*) della stanza</string>
						<string>un tremore scuote l'angolo (.*) e il lato (.*) della stanza</string>
						<string>un tremore scuote l'angolo (.*) e il (.*) della stanza</string>
						<string>un tremore scuote il lato (.*) e il (.*) della stanza</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
						<integer>1</integer>
						<integer>1</integer>
						<integer>1</integer>
						<integer>1</integer>
						<integer>1</integer>
						<integer>1</integer>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>Unione</name>
					<script>--[[
Questo Luogotenente ha come special skill un incantesimo che vi toglie hp se il gruppo é nella stessa positioning. 
Se si é da soli basta semplicemente restare immobili e fare quanto piu danno possibile e a ogni fine special perdete solo 250 hp, 
ampiamente gestibili. 
Se siete un gruppo da tre\quattro basta dividersi il positioning e poi restare immobili, continuando a fare dps.
]]
cecho("\n&lt;white:red&gt; * UNIONE * &lt;reset&gt; Posizione diversa dal resto del gruppo (settata a 9)\n")
sposta(9)</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string> ride sguaiatamente, mentre l'intera stanza inizia a tremare</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>0</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>Aura</name>
					<script>--[[
Questo Luogotenente ha come special skill un aura con cui si autocura gli hp. 
Come prima cosa é fondamentale farsi castare da un mago lo spell shield che protegge dai magic missile che spara il Luogotenente. 
Quando poi durante il combat vedete questa scritta:

- Falthken, Luogotenente del Caos dice 'rxaccozglieyreyte moltzo pxiyu` di qyuanto xavete zseymiznyato

Dovete stoppare il combat immediatamente e smettere di fare dps in qualsiasi modo, idem chi sta tankando, bisogna stoppare. 
Quando poi vedrete questa scritta:

- Falthken, Luogotenente del Caos emette suoni di soddisfazione nel vedere le sue ferite rimarginarsi

Potete riprendere a fare dps in modo massiccio. Il combat va via cosi.
Se c'é un healer in gruppo, quando il Luogotenente casta l'aura di assorbimento (e solo in quel round) tirategli un heal/miracle/seeds, 
In questo modo avrà un malus il round successivo e perderà hp in base a quanti hp lo curate. 
]]
cecho("\n&lt;white:red&gt; * AURA * &lt;reset&gt; Ferma il combattimento\n")
send("stop")</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>\[(.*), (.*)\] dice 'R</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>Ritorna centro</name>
					<script>--Sbattendo i piedi, riesci a placare il tremore prima che esploda!
cecho("\n&lt;white:red&gt;Ritorno al centro&lt;reset&gt;\n")
sposta(5)</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>Per fortuna, il luogo d'origine non sembra essere stato colpito!</string>
						<string>I venti del caos ti investono</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>0</integer>
						<integer>0</integer>
					</regexCodePropertyList>
				</Trigger>
			</TriggerGroup>
			<TriggerGroup isActive="yes" isFolder="yes" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>Loot</name>
				<script></script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList />
				<regexCodePropertyList />
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>multi_loot</name>
					<script>if (ui.getAllCadNum)and(not ui.inCad)then
  ui.inCad = true;
  ui.getAllCadNum = ui.getAllCadNum + 1
  send("get all "..ui.getAllCadNum..".cad")
end
enableTrigger("multi_loot_valid")
enableTrigger("multi_loot_end")</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>1</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>Prendi .* da .*</string>
						<string>Non c'e` niente in .*</string>
						<string>Il cadavere .* non ti appartiene, non puoi prenderne i contenuti!</string>
						<string>Non puoi prendere .*</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
						<integer>1</integer>
						<integer>1</integer>
						<integer>1</integer>
					</regexCodePropertyList>
					<Trigger isActive="no" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>multi_loot_valid</name>
						<script>setTriggerStayOpen("multi_loot", 1)</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>Prendi .* da .*</string>
							<string>Non puoi prendere .*</string>
							<string>C'erano .* monete.</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>1</integer>
							<integer>1</integer>
							<integer>1</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="no" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>multi_loot_end</name>
						<script>disableTrigger("multi_loot_valid")
disableTrigger("multi_loot_end")
ui.inCad = false;</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>^$</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>1</integer>
						</regexCodePropertyList>
					</Trigger>
				</Trigger>
				<Trigger isActive="no" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>L'urlo di morte di (*) ti gela il sangue nelle vene.$</name>
					<script>ui.nCad = ui.nCad or 0
ui.nCad = ui.nCad + 1
send("get all.coin "..ui.nCad..".cad")</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>L'urlo di morte di (.*) ti gela il sangue nelle vene.$</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>Fine cadaveri</name>
					<script>ui.getAllCadNum = nil</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>^Non vedi nessun (?:.*)cad.$</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>Mangia\Conserva Ethereum</name>
					<script>expandAlias("p eth")</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>^Prendi Un frammento di Ethereum cristallizzato(.*)</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>Raccogli Ethereum a terra</name>
					<script>send("get all.framm")
</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>Un curioso frammento di qualcosa(.*)</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>Raccogli Monete a terra</name>
					<script>send("get all.monete")</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>Un mucchio di monete d'oro(.*)</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
			</TriggerGroup>
			<TriggerGroup isActive="yes" isFolder="yes" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>Apertura porte</name>
				<script></script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList />
				<regexCodePropertyList />
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="yes" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>Porta chiusa</name>
					<script>local dir = ui.path[ui.idxPath] or ""
expandAlias("open "..matches[2].." "..dir)
-- Rimozione dell'ultima direzione inserita in quanto porta chiusa
if (ui.idxPath &gt; 0) then
  ui.idxPath = ui.idxPath - 1
  ui.idxMem = ui.idxPath
end</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>^(?:Il|Lo|La|I|Gli|Le) (\S*) (?:e`|sono) chius(?:a|e|i|o).</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="yes" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>Porta chiusa a chiave</name>
					<script>local dir = ui.path[ui.idxPath] or ""
expandAlias("op "..matches[2].." "..dir)
</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>^(?:Il|Lo|La|I|Gli|Le) (\S*) sembra(?:no) serrat(?:a|e|i|o)</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
			</TriggerGroup>
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>auto_attac_first_mob</name>
				<script>enableTrigger("is_a_valid_mob")</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>1</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>^------- Creature in Stanza -------$</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>1</integer>
				</regexCodePropertyList>
				<Trigger isActive="no" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>is_a_valid_mob</name>
					<script>local mob = matches[1] 
if (mob) and (mob ~= "") and (ui.variables.attackFirstMob) then
  mob = ui.fRemoveArticle(mob)
  --mob = string.gsub(mob, " ", "-")
  mob = string.sub(mob, 1, string.find(mob, ' '))
  cecho(" &lt;orange&gt; (Auto attack first mob)\n");
  --if (ui.parameters.enablePugno) then
  --  expandAlias("pugno "..mob, false)
  --end
  expandAlias("attack "..mob, false)
end
ui.variables.attackFirstMob = nil;
disableTrigger("is_a_valid_mob")</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>1</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>^(\w+).*</string>
						<string>^$</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
			</Trigger>
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>Invasioni</name>
				<script>local t1 = matches[2] * 60 * 60 + matches[3] * 60 + matches[4]
local t2 = os.date("%H") * 60 * 60 + os.date("%M") * 60 + os.date("%S")
local location = matches[5]

t1 = t2 - t1
if (t1&gt;=1800) then -- 30 minuti
  t1 = t1 - 1800;
  t2 = math.floor(t1/60)
  t1 = t1 - t2*60
  cecho(" &lt;red&gt;... (CONCLUSA da "..t2..":"..t1.." min)")
else
  t1 = 1800 - t1
  t2 = math.floor(t1/60)
  t1 = t1 - t2*60
  cecho(" &lt;green&gt;... -"..t2..":"..t1.." min alla fine")
  --
  --sendToDiscordWebhook("Invasione in corso ["..location.."] -"..t2..":"..t1.." min alla fine")
end
setTriggerStayOpen("Invasioni", 1)</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>1</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>^\[.*\] \[Invasione\] \[(.*)\:(.*)\:(.*)\] Il velo tra le realta' si e' assottigliato a \[(.*)\]</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>1</integer>
				</regexCodePropertyList>
			</Trigger>
			<Trigger isActive="no" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>First AID (automatico)</name>
				<script>send("first")</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>Puoi medicarti di nuovo.</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>3</integer>
				</regexCodePropertyList>
			</Trigger>
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>Flee (automatico)</name>
				<script>send("flee", false)</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>Sei paralizzato dal panico! Non puoi fuggire!</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>3</integer>
				</regexCodePropertyList>
			</Trigger>
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="yes" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>Stand (automatico)</name>
				<script>if (not ui.wfStandUp) then
  ui.fEchon("Trig Auto stand - Resend last command: "..ui.fGetAliasOutputFormattedText(command))
  --
  expandAlias("stand;"..command)
  ui.wfStandUp = true;
end</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#000000</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>Prima forse dovresti alzarti, non credi?</string>
					<string>Ti devi alzare per lanciare quest'incantesimo.</string>
					<string>Nah... Sei troppo rilassato...</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>3</integer>
					<integer>3</integer>
					<integer>3</integer>
				</regexCodePropertyList>
			</Trigger>
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>Fine stand (automatico)</name>
				<script>ui.wfStandUp = false;</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>Sei gia` in piedi.</string>
					<string>Smetti di riposare e ti alzi.</string>
					<string>Ti alzi.</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>3</integer>
					<integer>3</integer>
					<integer>3</integer>
				</regexCodePropertyList>
			</Trigger>
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>Movimento MOB</name>
				<script>local str = matches[1]
local name = ui.fRemoveArticle(matches[2])
local dir = string.trim(string.lower(matches[3] or ""))
selectString(str, 1)
replace("")
dir = ui.dirCompress[dir]
if (string.find(str, "arriva da")) or
   (string.find(str, "arriva volando da")) then
  if (dir == "w") or (dir == "d") or (dir == "s") then
    cecho("&lt;red&gt;"..ui.dirToken[ui.dirReverse[dir]].." &lt;orange&gt;"..name)
  else
    cecho("&lt;orange&gt;"..name.." &lt;red&gt;"..ui.dirToken[ui.dirReverse[dir]])
  end
elseif (string.find(str, "va verso")) or
       (string.find(str, "vola verso")) then
  if (dir == "w") or (dir == "d") or (dir == "s") then
    cecho("&lt;green&gt;"..ui.dirToken[dir].." &lt;ForestGreen&gt;"..name)
  else
    cecho("&lt;ForestGreen&gt;"..name.." &lt;green&gt;"..ui.dirToken[dir])
  end
elseif (string.find(str, "si alza")) then
  cecho("&lt;red&gt;↑↑↑ &lt;orange&gt;"..name.." &lt;red&gt;↑↑↑")
else --if (string.find(str, "appare")) then
  cecho("&lt;red&gt;*** &lt;orange&gt;"..name.." &lt;red&gt;***")
end</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>^(.*) arriva.*( est|ovest|nord|sud|alto|basso)$</string>
					<string>^(.*) (?:va|vola) verso.*( est|ovest|nord|sud|alto|basso)$</string>
					<string>^(.*) appare improvvisamente.$</string>
					<string>^(.*) si alza lentamente.$</string>
					<string>^(.*) esce dal passaggio che si richiude alle sue spalle.$</string>
					<string>^(.*) viene fuori dal portale.$</string>
					<string>^(.*) si alza velocemente.$</string>
					<string>^(.*) si materializza con uno spruzzo di acqua colorata.</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>1</integer>
					<integer>1</integer>
					<integer>1</integer>
					<integer>1</integer>
					<integer>1</integer>
					<integer>1</integer>
					<integer>1</integer>
					<integer>1</integer>
				</regexCodePropertyList>
			</Trigger>
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="yes" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>Fallimento lancio incantesimo</name>
				<script>cecho("\n&lt;white&gt;&lt;"..command.."&gt;\n");</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff5500</mFgColor>
				<mBgColor>#000000</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>Su cosa vuoi lanciare quest'incantesimo?</string>
					<string>Non c'e' nessuno qui con questo nome.</string>
					<string>C'e` troppa pace qui per essere violenti.</string>
					<string>Non riesci a concentrarti abbastanza in questo posto.</string>
					<string>Impossibile! Non riesci a concentrarti abbastanza.</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>3</integer>
					<integer>3</integer>
					<integer>3</integer>
					<integer>3</integer>
					<integer>3</integer>
				</regexCodePropertyList>
			</Trigger>
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="yes" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>LOG + Auto update effets</name>
				<script>local str = "";
--
-- scudo di fuoco
if (matches[1] == "La tua pelle ha acquistato la consistenza del ghiaccio.") then
  ui.actAffects["scudo di ghiaccio"] = 3 
elseif (matches[1] == "La tua pelle ha perso la consistenza del ghiaccio.") then
  ui.actAffects["scudo di ghiaccio"] = -1
--
-- scudo di fuoco
elseif (matches[1] == "Convochi uno schermo di fiamme intorno a te stesso.") then
  ui.actAffects["scudo di fuoco"] = 26 
elseif (matches[1] == "La tua aura fiammeggiante svanisce.") then
  ui.actAffects["scudo di fuoco"] = -1
--
-- scarica di adrenalina
elseif (matches[1] == "Acceleri il metabolismo nel tuo corpo!") then
  ui.actAffects["scarica di adrenalina"] = 4
elseif (matches[1] == "Il metabolismo nel tuo corpo torna normale.") then
  ui.actAffects["scarica di adrenalina"] = -1
  expandAlias("dro kyrus")
--
-- forza psichica
elseif (matches[1] == "Ti senti piu` forte.") then
  ui.actAffects["forza psichica"] = 100
elseif (matches[1] == "La tua forza psichicamente indotta svanisce.") then
  ui.actAffects["forza psichica"] = -1
--
-- santuario
elseif (matches[1] == "Un'aura di luce bianca ti protegge.") then
  ui.actAffects["santuario"] = 3
  str = "* SANC *";
elseif (matches[1] == "L'aura bianca intorno al tuo corpo svanisce.") then
  ui.actAffects["santuario"] = -1
  str = "&lt;255,32,321:30,24,24&gt;Fine SANC";
--
-- mente oltre il corpo
elseif (matches[1] == "Costringi il tuo corpo a non aver bisogno di cibo ed acqua!") then
  ui.actAffects["mente oltre il corpo"] = 12
elseif (matches[1] == "Senti un gorgoglio nello stomaco.") then
  ui.actAffects["mente oltre il corpo"] = -1
--
-- scudo psichico
elseif (matches[1] == "Erigi uno scudo mentale intorno al tuo corpo.") then
  ui.actAffects["scudo psichico"] = 50
elseif (matches[1] == "Il tuo scudo psichico svanisce.") then
  ui.actAffects["scudo psichico"] = -1
--
-- pugno cinetico
elseif (rex.match(matches[1], [[Con ampi gesti crei un pugno di pura energia (.*)]])) then
  ui.parameters.enablePugno = false
elseif (matches[1] == "Senti di poter sferrare di nuovo un pugno cinetico.") then
  ui.parameters.enablePugno = true
--
-- avvelena lame
elseif (matches[1] == "Sulle tue lame non rimane piu' traccia di veleno.") then
  expandAlias("enve lee")
--
-- free cast
elseif (matches[1] == "La tua mente si apre per un istante all'infinito!") then
  if (ui.parameters.autoAttack) then
    cecho("&lt;yellow&gt; (Free cast available)\n");
    ui.parameters.freeCast = true;
  end
--
-- Invasione
elseif (matches[1] == "..Il velo tra le realta' si assottiglia..") then
  str = "&lt;0,255,0:30,24,24&gt;Inizio invasione..."
  expandAlias("events", false)
elseif  (matches[1] == "..Il velo tra le realta' torna al suo stato originale..") then
  str = "&lt;255,0,0:30,24,24&gt;... fine invasione."
  -- sendToDiscordWebhook("... fine invasione.")
end
--
if (str ~= "") then
  ui.fLog(str)
end
--
ui.fUpdateAffects()</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#00ffff</mFgColor>
				<mBgColor>#000000</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>Acceleri il metabolismo nel tuo corpo!</string>
					<string>Il metabolismo nel tuo corpo torna normale.</string>
					<string>Convochi uno schermo di fiamme intorno a te stesso.</string>
					<string>La tua aura fiammeggiante svanisce.</string>
					<string>Un'aura di luce bianca ti protegge.</string>
					<string>L'aura bianca intorno al tuo corpo svanisce.</string>
					<string>Costringi il tuo corpo a non aver bisogno di cibo ed acqua!</string>
					<string>Senti un gorgoglio nello stomaco.</string>
					<string>Erigi uno scudo mentale intorno al tuo corpo.</string>
					<string>Il tuo scudo psichico svanisce.</string>
					<string>Ti senti piu` forte.</string>
					<string>La tua forza psichicamente indotta svanisce.</string>
					<string>..Il velo tra le realta' .*</string>
					<string>Senti di poter sferrare di nuovo un pugno cinetico.</string>
					<string>La tua mente si apre per un istante all'infinito!</string>
					<string>Senti di poter sferrare di nuovo un pugno cinetico.</string>
					<string>Con ampi gesti crei un pugno di pura energia .*</string>
					<string>Sulle tue lame non rimane piu' traccia di veleno.</string>
					<string>La tua pelle ha perso la consistenza del ghiaccio.</string>
					<string>La tua pelle ha acquistato la consistenza del ghiaccio.</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>3</integer>
					<integer>3</integer>
					<integer>3</integer>
					<integer>3</integer>
					<integer>3</integer>
					<integer>3</integer>
					<integer>3</integer>
					<integer>3</integer>
					<integer>3</integer>
					<integer>3</integer>
					<integer>3</integer>
					<integer>3</integer>
					<integer>1</integer>
					<integer>3</integer>
					<integer>3</integer>
					<integer>3</integer>
					<integer>1</integer>
					<integer>3</integer>
					<integer>3</integer>
					<integer>3</integer>
				</regexCodePropertyList>
			</Trigger>
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>GAG</name>
				<script>deleteLine()
--cecho ("\n&lt;white&gt;   - GAG -   "..matches[1].."\n")
</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>.*  il suo fulmine non ti colpisce</string>
					<string>.* COLPISC</string>
					<string>.* cerca di lanciarti un incantesimo al quale sei immune.</string>
					<string>.* compie un'impressionante mossa di combattimento.</string>
					<string>.* crea delle fiamme dalle sue tempie!</string>
					<string>.* criticamente a colpire .*</string>
					<string>.* e` morto! R.I.P.</string>
					<string>.* fa una bella mossa, ma perde l'equilibrio e cade in terra.</string>
					<string>.* ha preso male la mira e il suo fulmine .*</string>
					<string>.* lancia un intreccio di raggi luminosi ma riesci a schivarli agilmente!</string>
					<string>.* ma (lo|la|li) manchi completamente.</string>
					<string>.* manca completamente.</string>
					<string>.* non riesce a raggiungerti con il suo tocco.</string>
					<string>.* non riesce ad assorbire la tua energia vitale</string>
					<string>.* pronuncia le parole.*</string>
					<string>.* rimbalza a terra.</string>
					<string>.* si concentra... .*</string>
					<string>.* si rende conto di avere spazio per agire indisturbat[ao] e prepara un potente incantesimo!</string>
					<string>.* smette di usare .*</string>
					<string>.* ti indica, ma riesci a schivare la tempesta gelida scatenata dalla sua mano!</string>
					<string>.* ti lancia un colonna di fuoco, ma tu riesci a spostarti dalla traiettoria</string>
					<string>^Cerchi di medicare alla meglio le tue ferite.</string>
					<string>^Eviti abilmente il getto d'acido .*</string>
					<string>^Eviti con facilita' il calcio .*</string>
					<string>^Flussi di energia planare .*</string>
					<string>^Hai raggiunto il limite massimo di punti esperienza.</string>
					<string>^I flussi di energia planare rinnovano il loro vigore!</string>
					<string>^Il cono di freddo lanciato .* ti colpisce in pieno!</string>
					<string>^Il tuo pensiero viaggia alla velocita' della luce!</string>
					<string>^Inizi il processo di alterazione delle cellule del tuo corpo.</string>
					<string>^L'energia planare si affievolisce e scompare.</string>
					<string>^La conoscenza della magia di .* aumenta il danno dell'incantesimo!</string>
					<string>^La tua concentrazione .*</string>
					<string>^La tua conoscenza della magia .*</string>
					<string>^DISABILITA La tua esperienza e` aumentata di .*</string>
					<string>^DISABILITA La tua parte di esperienza e` .*</string>
					<string>^Le fiamme mentali di .* non riescono a bruciarti</string>
					<string>^Le tue abilita' migliorano criticamente il tuo incantesimo di guarigione!</string>
					<string>^Scovi un punto debole nella mente del tuo bersaglio!</string>
					<string>^Ti sposti dalla traiettoria del cono congelante .*</string>
					<string>^Una palla di fuoco lanciata da .* ti sfiora</string>
					<string>.* facendolo cadere a terra rovinosamente.</string>
					<string>.* finisce a terra.</string>
					<string>Il veleno non sembra sortire alcun effetto!</string>
					<string>.* ti morde!</string>
					<string>.* riesce a migliorare criticamente il suo incantesimo di guarigione!</string>
					<string>Perdi la concentrazione e porti un colpo poco convinto.</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>1</integer>
					<integer>1</integer>
					<integer>1</integer>
					<integer>1</integer>
					<integer>1</integer>
					<integer>1</integer>
					<integer>1</integer>
					<integer>1</integer>
					<integer>1</integer>
					<integer>1</integer>
					<integer>1</integer>
					<integer>1</integer>
					<integer>1</integer>
					<integer>1</integer>
					<integer>1</integer>
					<integer>1</integer>
					<integer>1</integer>
					<integer>1</integer>
					<integer>1</integer>
					<integer>1</integer>
					<integer>1</integer>
					<integer>1</integer>
					<integer>1</integer>
					<integer>1</integer>
					<integer>1</integer>
					<integer>1</integer>
					<integer>1</integer>
					<integer>1</integer>
					<integer>1</integer>
					<integer>1</integer>
					<integer>1</integer>
					<integer>1</integer>
					<integer>1</integer>
					<integer>1</integer>
					<integer>1</integer>
					<integer>1</integer>
					<integer>1</integer>
					<integer>1</integer>
					<integer>1</integer>
					<integer>1</integer>
					<integer>1</integer>
					<integer>1</integer>
					<integer>1</integer>
					<integer>1</integer>
					<integer>1</integer>
					<integer>1</integer>
					<integer>3</integer>
				</regexCodePropertyList>
			</Trigger>
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>Inversione descrizione &lt;-&gt; danni</name>
				<script>local des = copy2decho(matches[2])
local dam = copy2decho(matches[3])
if (string.find(dam, "&lt;128,0,0:")) then
  -- Danno inferto
  dam = string.gsub(dam, "&lt;128,0,0:", "&lt;128,255,255:") -- &lt;255,164,32:
  dam = "|       "..dam
else
  -- Danno subito
  dam = dam.."       |"
end
for i=1, 7-(matches[3]):len() do
  dam = string.gsub(dam, '%[', '[ ')
end
dam = string.gsub(dam, '%[', '| ')
dam = string.gsub(dam, '%]', ' |')
deleteLine()
decho("\n"..dam.." "..des)
</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>(.*)(\[[+|-]\d*\])$</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>1</integer>
				</regexCodePropertyList>
			</Trigger>
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="yes" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>Aure</name>
				<script>local aura = matches[2]
deleteLine()
if (aura == "luce") then
  cecho("&lt;white&gt; (*)&lt;reset&gt;")
elseif (aura == "ghiaccio") then
  cecho("&lt;cyan&gt; (*)&lt;reset&gt;")
elseif (aura == "elettrica") then
  cecho("&lt;blue&gt; (*)&lt;reset&gt;")
elseif (aura == "fiammeggiante") then
  cecho("&lt;red&gt; (*)&lt;reset&gt;")
elseif (aura == "oscurita") then
  cecho("&lt;DimGrey&gt; (*)&lt;reset&gt;")
end
</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>^.* brilla di (luce) propria!$</string>
					<string>^.* e` avvolt[oa] da un\'aura (elettrica).$</string>
					<string>^.* e` avvolt[oa] in una luce (fiammeggiante)!$</string>
					<string>^.* e` avvolt[oa] nell'(oscurita)`!$</string>
					<string>^La pelle di .* ha la consistenza del (ghiaccio)!$</string>
					<string>^L'aria attorno a .* e` carica di (elettric)ita`!$</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>1</integer>
					<integer>1</integer>
					<integer>1</integer>
					<integer>1</integer>
					<integer>1</integer>
					<integer>1</integer>
				</regexCodePropertyList>
			</Trigger>
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>Inversione Mob &lt;-&gt; Livello</name>
				<script>local str = copy2decho(matches[2])
local qtt = copy2decho(matches[3])
local liv = copy2decho(matches[3])
if (matches[4]) then
  str = copy2decho(matches[2])
  qtt = copy2decho(matches[3])
  liv = copy2decho(matches[4])
else
  str = copy2decho(matches[2])
  qtt = "&lt;192,192,192:0,0,0&gt;[&lt;r&gt;&lt;255,0,0:0,0,0&gt;1&lt;r&gt;&lt;192,192,192:0,0,0&gt;]&lt;r&gt;"
  liv = copy2decho(matches[3])
end
deleteLine()
decho("\n"..qtt.." " ..liv.." "..str)
</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>^(.*) (\[Liv [\d\?]*\])$</string>
					<string>^(.*) (\[\d*\])(\[Liv [\d\?]*\])$</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>1</integer>
					<integer>1</integer>
				</regexCodePropertyList>
			</Trigger>
			<Trigger isActive="no" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>Send all vie Telegram</name>
				<script>local str = matches[1]
ui.telegramMessage = ui.telegramMessage or ""
if (rex.match(matches[1], [[^\[.*\].*]])) then
  expandAlias("#telegram tell KenCiro78 "..ui.telegramMessage, false)
  ui.telegramMessage = ""
else
  ui.telegramMessage = ui.telegramMessage.."\r\n"..str
end
</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>.*</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>1</integer>
				</regexCodePropertyList>
			</Trigger>
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>Combattimento automatico</name>
				<script>if (ui.parameters.autoAttack) then
  ui.parameters.freeCast = ui.parameters.freeCast or false;
  if (ui.parameters.freeCast) then 
    cecho("&lt;orange&gt;(Free cast: ");
    if (ui.variables.mana&lt;=200) then
      if (ui.variables.health&gt;=1000) then
        local hpToCani = math.floor((ui.variables.mana_max - ui.variables.mana) / 3);
        cecho("&lt;cyan&gt;Mana&lt;orange&gt;)\n");
        expandAlias("cani "..hpToCani, false)
        expandAlias("bl", false)     -- farà ripartire il trig
      else
        cecho("&lt;white&gt;Flee&lt;orange&gt;)\n");
        expandAlias("flee", false)   -- NON farà ripartire il trig
      end
    elseif (ui.variables.health&lt;=1700) then
      cecho("&lt;green&gt;Cure&lt;orange&gt;)\n");
      expandAlias("cell", false)
      expandAlias("bl", false)     -- farà ripartire il trig
    elseif (ui.parameters.autoAttackArea) then
      cecho("&lt;red&gt;AREA&lt;orange&gt;)\n");
      expandAlias("ub", false)
      expandAlias("bl", false)     -- farà ripartire il trig
    else
      cecho("&lt;yellow&gt;SINGLE&lt;orange&gt;)\n");
      expandAlias("cr", false)
      expandAlias("bl", false)     -- farà ripartire il trig
    end
    ui.parameters.freeCast = false;
  else
    cecho("&lt;orange&gt;(Recast)\n");
    expandAlias("bl", false)     -- farà ripartire il trig
  end
end</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>^Colpisci la mente .*</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>1</integer>
				</regexCodePropertyList>
			</Trigger>
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>Sei morto! Mi spiace...</name>
				<script>expandAlias("stand")</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>Sei morto! Mi spiace...</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>3</integer>
				</regexCodePropertyList>
			</Trigger>
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>Cristalli di Ethereum</name>
				<script>local str = string.lower(matches[2] or "") 
if (str == "affilato") then
  str = "+1 a Tiro per Colpire - Max +2";
elseif (str == "appuntito") then
  str = "+1 a Danno Fisico - Max +1";
elseif (str == "brillante") then
  str = "+1 a Colpire e Potere Magico - Max +1";
elseif (str == "concentrato") then
  str = "+1% a Focus Magico - Max +3";
elseif (str == "contundente") then
  str = "+1 a Riduzione da Impatto - Max +2";
elseif (str == "flessibile") then
  str = "+2 a Recupero Mana - Max +10";
elseif (str == "fluorescente") then
  str = "+6 a Punti Mana - Max +30"
elseif (str == "frastagliato") then
  str = "+1 a Colpire e Danno Fisico - Max +1";
elseif (str == "irrequieto") then
  str = "+1% ad Attacco Extra - Max +3";
elseif (str == "luminoso") then
  str = "+1 a Potere Magico - Max +1";
elseif (str == "pungente") then
  str = "+1 a Riduzione da Punta - Max +2";
elseif (str == "rigenerante") then
  str = "+4 a Recupero Ferita - Max +20";
elseif (str == "robusto") then
  str = "+3 a Punti Ferita - Max +45";
elseif (str == "tagliente") then
  str = "+1 a Riduzione da Taglio - Max +2";
end
str = ".[&lt;cyan&gt;"..str.."&lt;reset&gt;]"
for i = matches[1]:len(), 70 do
  str = "."..str;
end
cecho(str)</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>.*cristallo di Ethereum (\w*).*</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>1</integer>
				</regexCodePropertyList>
			</Trigger>
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>Eldorado</name>
				<script>local msg = string.lower(matches[2])
if (msg == "una fitta foresta dominata da una sagoma imponente") then
  msg = "da alma civitas : .s10ws9w3n10wusws2ws2wn (n giungla)"

elseif (msg == "tutto il globo, ma su niente") then
  msg = "da alma civitas : .s9e3n4es2e2d18e2n4e3s7e;open ea;.8e3s8e;open ea;.6e6n;open north;.7ne10ne3ne5ne7nw3n8en (d;run n giungla)"

elseif (msg == "una piccola valle dormiente tra i monti") then
  msg = "da alma civitas : .s9e3n4es2e2d18e2n4e3s7e;open ea;.8e3s6e2sue2sw (n giungla)"

elseif (msg == "una imponente foresta di quercie") then
  msg = "da alma civitas : .s9e3n4es2e2d18e2n4e3s7e;open ea;.8e3s8e;open ea;.6e6n;open north;.7ne10ne3ne2n (e sorgente)"

elseif (msg == "una spiaggetta in un bosco") then
  msg = "da alma civitas : .s9e3n4es2e2d18e2n4e3s7e;open ea;.8e3s8e;open ea;.6e6n;open north;.7ne5n3e5n (n giungla)"

elseif (msg == "una grotta che ospita presenze maligne") then
  msg = "da alma civitas : .8s2e2s2ws2es2w3swsws2en3e2n2e2n3n2wn3wden;.2e4sen2w (w necropoli)"

elseif (msg == "l'ansa di un fiume tropicale") then
  msg = "da alma civitas : .s9e3n4es2e2d18e2n4e3s7e;open ea;.8e3s8e;open ea;.6e6s;ope sou;.sd2sw5se (s laguna)"

elseif (msg == "degli orti ben coltivati") then
  msg = "da alma civitas : .s9e3n4es2e2d18e2n4e3s7e;open ea;.8e3s8e;open ea;.6e6s;open sou;.sd2sw5s2wsw (s contadini)"

elseif (msg == "una piccola radura su un altipiano") then
  msg = "da alma civitas ad alpes oppidum: .10ne3nw5nw3nw; (solo se chiuso verso north: lift grata) .4n oppure\n"
  msg = msg.."da alpes oppidum a una stradina nel sottobosco: .w2nesu2nueuen2w3nw3ue (s sorgente)"

elseif (msg == "un boschetto con un gazebo") then
  msg = "da alma civitas : .s10ws9w3n4w3s3ws3ese3s (lycantropia) .s2es3e3nw3s (w radura)"

elseif (msg == "un umido tunnel dove aleggia un odore di belve") then
  msg = "da alma civitas : .s9e12nd3e4s (s fossa belve)"

elseif (msg == "un luogo sotterraneo abitato, da strani rettili") then
  msg = "da alma civitas : .s9en2e3s7en;cut liana;d (n miniera)"

elseif (msg == "un'enorme belva di marmo") then
  msg = "da alma civitas .2s4w; kill tarquinio; .wn2edne (east fossa belve)"

elseif (msg == "delle potenti scariche di elettricità") then
  msg = "da alma civitas : .s9e3n4es2e2de2u2nuse2nwu (la fortezza!) .nwnw3n (solo se chiuso verso west: pull torcia) .wde2s2e (solo se chiuso verso est: push masso) .e2s2e4n (w drago blu)(.2w radura)"

elseif (msg == "draghi e cavalieri, ma sono immobili") then
  msg = "da alma civitas : .s9e3n4es2e2d18e2n4e3s7e;open ea;.8e3s8e;open ea;.6e6n;open north;.7ne10ne3ne5ne7n3w (run s miniera)"

elseif (msg == "vari simboli di morte") then
  msg = "da alma civitas a la piazza principale: .s9e3n4es2e2d18e2n4e3s6e\n"
  msg = msg.."da la piazza principale: knock/pick south poi open south;.2s;kill nahaz;get chia naha;unlock botola;lift botola;.d (d necropoli)"

elseif (msg == "un animale incerto tra mangiare o bere") then
  msg = "da alma civitas : .s9e3n4es2e2d18e2n4e3s7e;open ea;.8e3s8e;open ea;.6e6n;open north;.7ne10ne3ne5ne7nw3nw2nene (e fossa belve)"

elseif (msg == "un'intricato labirinto") then
  msg = "Portalare Hoeur ed entrare con stringa (ent port;e) .2d (n Miniere)\n"
  msg = msg.."Se Hoeur non c'è da alma civitas: .s10ws9w3n9w6s8w5s3w (spaventapasseri) .n3e5n4e2s3w4sd\n"
  msg = msg..".d;kill guerrieri;get chiave cad;unlo east;open east;\n"
  msg = msg.."unlo east;open east;e;open east;e;open east;.e4d3e\n"
  msg = msg.."Qui si spiega comunque cosa c'e' e cosa fanno.\n"
  msg = msg.."e;kill 4 o 5 drow;open east;e;open east;kill 14 minotauri hide;.4d3e (Hoeur);ent port;e(??);.2d (n Miniere)"

elseif (msg == "un enorme smeraldo intagliato") then
  msg = "andare alla pool per torre magia (.unwn;ent spe), poi andare .3s2u5n e siete a la sala delle udienze (d;run n giungla)"

elseif (msg == "un fiume che scorre") then
  msg = "il fiume el'azahred:\n"
  msg = msg.."        da tania:.dw5s;open sou;.2se3s8e;open east;.6e5s7e (s giungla .uw;run n)\n"
  msg = msg.."        da il centro della piazza del mercato .5s7e (s giungla .uw;run n)\n"
  msg = msg.."\n"
  msg = msg.."    fiume lys\n"
  msg = msg.."        da alma civitas .4se2s6w (d sorgente)\n"
  msg = msg.."\n"
  msg = msg.."    fiume oscuro\n"
  msg = msg.."        da alma civitas .4se2se;ope grata;.7en4e (n giungla .uw;run n)\n"
  msg = msg.."\n"
  msg = msg.."    fiume ara-raven\n"
  msg = msg.."        da tania:.dw5s;open sou;.2se3s8e;open east;.6e5s14w2n (d giungla .uw;run n)\n"
  msg = msg.."        da il centro della piazza del mercato:.5s14w2n (d giungla .uw;run n)"
else
  msg = '"'..msg..'" non trovato'
end

echo("\n"..msg.."\n")</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>^\[la chiromante\] dice \'(.*) \'</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>1</integer>
				</regexCodePropertyList>
			</Trigger>
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>Dare per avere</name>
				<script>local str = copy2decho(matches[1] or "")
str = string.gsub(str, ":0,0,0&gt;", ":30,24,24&gt;")
str = string.gsub(str, "&lt;0,0,255:", "&lt;128,128,255:")
ui.fLog(str)</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>^(.*) ti da['`] (.*)$</string>
					<string>^Dai (.*) a (.*).$</string>
					<string>^(.*) ti restituisce (.*)$</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>1</integer>
					<integer>1</integer>
					<integer>1</integer>
				</regexCodePropertyList>
			</Trigger>
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>Lingotti</name>
				<script>local str = string.lower(matches[2] or "")
str = string.trim(str);
--
if (str == "celestiale") or (str == "della natura") or (str == "infernale") or (str == "di vibranio") or (str == "dragonite") or (str == "ithildin") then
  str = "Fascia A (7)"
elseif (str == "runiche") or (str == "di palladio") or (str == "di titanio") or (str == "elementale") then
  str = "Fascia B (6)"
elseif (str == "di adamantio") or (str == "di ebanite") or (str == "di oricalco") or (str == "di mithril") then
  str = "Fascia C (5)"
elseif (str == "d'oro") or (str == "di platino") then
  str = "Fascia D (4)"
elseif (str == "d'argento") or (str == "di ossidiana") then
  str = "Fascia E (3)"
elseif (str == "d'acciaio") or (str == "di bronzo") or (str == "di rame") then
  str = "Fascia F (2)"
elseif (str == "di piombo") or (str == "di ottone") or (str == "di ferro") then
  str = "Fascia G (1)"
end

cecho(" [&lt;cyan&gt;"..str.."&lt;reset&gt;] ")</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>.*(?:frammento|lingotto) (.*) \(Componente\).*</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>1</integer>
				</regexCodePropertyList>
			</Trigger>
			<Trigger isActive="no" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>[Mago] Ultimo spell lanciato</name>
				<script>ui.variables.lastSpell = matches[2] or "";</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>^Pronunci le parole, \'(.*)\'$</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>1</integer>
				</regexCodePropertyList>
			</Trigger>
			<Trigger isActive="no" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>[Mago] Recast</name>
				<script>if (ui.variables.lastSpell) then
  send ("cast '"..ui.variables.lastSpell.."'")
end</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>Perdi la tua concentrazione!</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>3</integer>
				</regexCodePropertyList>
			</Trigger>
		</TriggerGroup>
		<TriggerGroup isActive="yes" isFolder="yes" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
			<name>generic_mapper</name>
			<script></script>
			<triggerType>0</triggerType>
			<conditonLineDelta>0</conditonLineDelta>
			<mStayOpen>0</mStayOpen>
			<mCommand></mCommand>
			<packageName>generic_mapper</packageName>
			<mFgColor>#ff0000</mFgColor>
			<mBgColor>#ffff00</mBgColor>
			<mSoundFile></mSoundFile>
			<colorTriggerFgColor>#000000</colorTriggerFgColor>
			<colorTriggerBgColor>#000000</colorTriggerBgColor>
			<regexCodeList />
			<regexCodePropertyList />
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>onNewLine Trigger</name>
				<script></script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>raiseEvent("onNewLine")</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>4</integer>
				</regexCodePropertyList>
			</Trigger>
			<TriggerGroup isActive="yes" isFolder="yes" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>English Trigger Group</name>
				<script></script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList />
				<regexCodePropertyList />
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>English Exits Trigger</name>
					<script>raiseEvent("onNewRoom",matches[2] or "")</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>(?i)^\s*\[\s*Exits:\s*(.*)\]</string>
						<string>^\s*There (?:is|are) \w+ (?:visible|obvious) exit[s]?:\s*(.*)</string>
						<string>^\[?[\s\w]*(?:[Vv]isible|[Oo]bvious) (?:[Pp]ath|[Ee]xit)[s]?(?: is| are)?:?\s*(.*)\]?</string>
						<string>^\s*You see[\w\s]* exit[s]? leading (.*)</string>
						<string>Exits:\s*(.*)</string>
						<string>There are no obvious exits.</string>
						<string>^\s*The (?:only )?obvious exit[s]? (?:is|are):? (.*)</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
						<integer>1</integer>
						<integer>1</integer>
						<integer>1</integer>
						<integer>1</integer>
						<integer>2</integer>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>English Failed Move Trigger</name>
					<script>raiseEvent("onMoveFail")</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>^(?:Alas, )?[Yy]ou can(?:no|')t (?:go|move) .*$</string>
						<string>^The .+ (?:is|seems to be) closed.$</string>
						<string>.+ (?:is not going to|will not) let you pass.$</string>
						<string>^That exit is blocked.$</string>
						<string>^You are blocked by .*$</string>
						<string>^There is no exit in that direction.$</string>
						<string>^The .* is locked.$</string>
						<string>^Alas, you cannot go that way\.\.\.$</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
						<integer>1</integer>
						<integer>1</integer>
						<integer>1</integer>
						<integer>1</integer>
						<integer>1</integer>
						<integer>1</integer>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>English Vision Fail Trigger</name>
					<script>raiseEvent("onVisionFail")</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>^It is pitch black...</string>
						<string>^It(?:'s| is) too dark</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>English Forced Move Trigger</name>
					<script>raiseEvent("onForcedMove",matches[2])</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>^Carefully getting your bearings, you set off (\w+) toward your goal.</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="no" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>English Multi-Line Exits Trigger</name>
					<script>map.prompt.exits = ""</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>1</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>(?i:^(obvious|visible) exits:)</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
					</regexCodePropertyList>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>Exit Line Trigger</name>
						<script>map.prompt.exits = map.prompt.exits .. ", " .. string.trim(matches[2])
setTriggerStayOpen("English Multi-Line Exits Trigger",1)</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>^([\w\s]+)\s*: [\w\s]+</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>1</integer>
						</regexCodePropertyList>
					</Trigger>
				</Trigger>
			</TriggerGroup>
			<TriggerGroup isActive="yes" isFolder="yes" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>Russian Trigger Group</name>
				<script></script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList />
				<regexCodePropertyList />
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>Russian Exits Trigger</name>
					<script>raiseEvent("onNewRoom",matches[2] or "")</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>^\s*\[\s*Выходы:\s*(.*)\]</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>Russian Failed Move Trigger</name>
					<script>raiseEvent("onMoveFail")</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>Извини, но ты не можешь туда идти.</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>0</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>Russian Vision Fail Trigger</name>
					<script>raiseEvent("onVisionFail")</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>Здесь слишком темно ...</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>0</integer>
					</regexCodePropertyList>
				</Trigger>
			</TriggerGroup>
			<TriggerGroup isActive="yes" isFolder="yes" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>Chinese Trigger Group</name>
				<script></script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList />
				<regexCodePropertyList />
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>Chinese Exits Trigger</name>
					<script>raiseEvent("onNewRoom",matches[2] or "")</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>^\s*这里明显的方向有 (.*)。</string>
						<string>^\s*这里明显的出口有 (.*)。</string>
						<string>^\s*这里明显的出口是 (.*)。</string>
						<string>^\s*这里唯一的出口是 (.*)。</string>
						<string>^\s*這裏明顯的出口是 (.*)。</string>
						<string>^\s*這裏唯一的出口是 (.*)。</string>
						<string>^\s*這裏明顯的方向有 (.*)。</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
						<integer>1</integer>
						<integer>1</integer>
						<integer>1</integer>
						<integer>1</integer>
						<integer>1</integer>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>Chinese Failed Movement Trigger</name>
					<script>raiseEvent("onMoveFail")</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>你又渴又饿，浑身无力，根本就走不动路。</string>
						<string>这个方向没有出路。</string>
						<string>^看来(\w+)不打算让你过去。</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>0</integer>
						<integer>0</integer>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
			</TriggerGroup>
		</TriggerGroup>
	</TriggerPackage>
	<TimerPackage />
	<AliasPackage>
		<AliasGroup isActive="yes" isFolder="yes">
			<name>Lumen et Umbra UI</name>
			<script></script>
			<command></command>
			<packageName>Lumen et Umbra UI</packageName>
			<regex></regex>
			<Alias isActive="yes" isFolder="no">
				<name>UI Aliases</name>
				<script>local alias = matches[2] or ""
local value = matches[3] or ""
-- Mostra tutti gli aliases
if (alias == "") then
  ui.fShowAllAliases()
-- Rimuove tutti gli aliases
elseif (alias == "remove_all") then
  ui.fRemoveAllAliases()
  ui.fEcho2n("Tutti gli alias sono stati rimossi.")
-- Mostra il singolo alias
elseif (value == "") then
  if (ui.aliases[alias]) then
    ui.fEcho2n(ui.fGetAliasFormattedText(alias))
  else
    ui.fError("L'alias "..ui.fGetAliasNameFormattedText(alias).." non esiste.")
  end
-- Rimuove il singolo alias
elseif value == "remove" then
  if (ui.fRemoveAlias(alias)) then
    ui.fEcho2n("L'alias "..ui.fGetAliasNameFormattedText(alias).." e' stato rimosso.")
  else
    ui.fError("L'alias "..ui.fGetAliasNameFormattedText(alias).." non esiste.")
  end
-- Crea o modifica l'alias
else
  local alreadyExist = ui.aliases[alias];
  local result, output = ui.fAddAlias(alias, value)
  if (result == -1) then
    ui.fError("L'alias "..ui.fGetAliasNameFormattedText(alias).." non è stato creato/modificato. La variabile "..ui.fGetVarNameFormattedText(output).." non esiste.")
  elseif (result == 1) then
    if (alreadyExist) then
      ui.fEcho2n("L'alias "..ui.fGetAliasNameFormattedText(alias).." è stato modificato: "..output..".")
    else
      ui.fEcho2n("L'alias "..ui.fGetAliasNameFormattedText(alias).." è stato creato: "..output..".")
    end
  else
    ui.fError("Errore non previsto.")
  end
end
ui.fSaveFileAliases()
ui.fUpdateAllAliasButton()
</script>
				<command></command>
				<packageName></packageName>
				<regex>^(?i)(?:uia(?:l(?:i(?:a(?:s(?:e(?:s)?)?)?)?)?)?)(?:\s+(\w*)\s*(.*))?$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>UI Buttons (configurazione)</name>
				<script>local button = matches[2] or ""
local alias = matches[3] or ""
-- Mostra tutti gli alias button
if (button == "") then
  ui.fShowAllAliasButtons()
-- Rimuove tutti gli alias buttons
elseif (button == "remove_all") then
  ui.fRemoveAllAliasButtons()
  ui.fEcho2n("Tutti i pulsanti alias sono stati rimossi.")
-- Mostra il singolo alias button
elseif (alias == "") then
  local type, number = ui.fExpandButton(button)
  if (type == "a") or (type == "b") or (type == "c") then
    button = type..number
    local alias = ui.fSearchAliasButton(button)
    if (alias) then
      ui.fEcho2n(ui.fGetAliasFormattedText(alias))
    else
      ui.fEcho2n("Nessun alias associato al pulsante "..ui.fGetAliasButtonFormattedText(button)..".")
    end
  else
      display(button)
    ui.fError(ui.fGetAliasButtonFormattedText(button).." non è un pulsante valido.")
  end
-- Rimuove il singolo alias button
elseif (alias == "remove") then
  local result = ui.fRemoveAliasButton(button)
  if (result == -2) then
    ui.fEcho2n("Nessun alias da rimuovere per il pulsante "..ui.fGetAliasButtonFormattedText(button)..".")
  elseif (result == -1) then
    ui.fError(ui.fGetAliasButtonFormattedText(button).." non è un pulsante valido.")
  elseif (result == 1) then
    ui.fEcho2n("L'alias associato al pulsante "..ui.fGetAliasButtonFormattedText(button).." è stato rimosso.")
  else
    ui.fError("Errore non previsto.")
  end
-- Crea o modifica l'alias button
else
  local result = ui.fAssignAliasButton(button, alias)
  if (result == -2) then
    ui.fError("L'alias "..ui.fGetAliasNameFormattedText(alias).." non esiste.")
  elseif (result == -1) then
    ui.fError(ui.fGetAliasButtonFormattedText(button).." non è un pulsante valido.")
  elseif (result == 1) then
    ui.fEcho2n("Il pulsante "..ui.fGetAliasButtonFormattedText(button).." è stato associato all'alias "..ui.fGetAliasNameFormattedText(alias)..".")
  else
    ui.fError("Errore non previsto.")
  end
end
ui.fSaveFileAliases()
ui.fUpdateAllAliasButton()</script>
				<command></command>
				<packageName></packageName>
				<regex>^(?i)(?:uib(?:u(?:t(?:t(?:o(?:n(?:s)?)?)?)?)?)?)(?:\s+(\w*)\s*(.*))?$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>UI Buttons (esecuzione)</name>
				<script>ui.fExecuteAliasButton(matches[2])</script>
				<command></command>
				<packageName></packageName>
				<regex>^(?i)([abc]\d)$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>UI Colors</name>
				<script>cecho(ui.fTitle("Colori disponibili:"))
ui.fDisplayColors({justText = false, removeDupes = true})</script>
				<command></command>
				<packageName></packageName>
				<regex>^(?i)(?:uic(?:o(?:l(?:o(?:r(?:s?)?)?)?)?)?)$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>UI Directiones</name>
				<script>-- TODO: integrare comando RUN ^(?i)(?:ru(?:n)?\s+)?([neswud])$
--
local dir = string.lower(matches[2]);
-- Don't save path if retrace
if (not ui.retrace) then
  ui.fSavePath(dir)
end
ui.retrace = false;
-- Initi cadaver counter
ui.nCad = 0
--
ui.fDebug("[alias] UI Directiones - Mem: "..ui.idxPath.."/"..ui.memPath.." - Dir: "..dir)
send(dir, false)</script>
				<command></command>
				<packageName></packageName>
				<regex>^(?i)([neswud])$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>UI Help</name>
				<script>local helpselect = string.lower(matches[2] or "")
--
if (helpselect == "") then
  ui.fHelp()
elseif (rex.match(helpselect, [[(?i)(?:uia(?:l(?:i(?:a(?:s(?:e(?:s)?)?)?)?)?)?)$]])) then
  ui.fHelp("alias")
elseif (rex.match(helpselect, [[(?i)(uib(?:u(?:t(?:t(?:o(?:n(?:s)?)?)?)?)?)?)$]])) then
  ui.fHelp("button")
elseif (rex.match(helpselect, [[(?i)(?:uic(?:o(?:l(?:o(?:r(?:s?)?)?)?)?)?)$]])) then
  ui.fHelp("color")
elseif (rex.match(helpselect, [[(?i)(?:uisetf(?:o(?:n(?:t(?:s(?:i(?:z(?:e)?)?)?)?)?)?)?)$]])) then
  ui.fHelp("fontsize")
elseif (rex.match(helpselect, [[(?i)(?:uihi(?:g(?:h(?:l(?:i(?:g(?:h(?:t(?:s)?)?)?)?)?)?)?)?)$]])) then
  ui.fHelp("highlight")
elseif (rex.match(helpselect, [[(?i)(?:uik(?:e(?:y(?:b(?:i(?:n(?:d)?)?)?)?)?)?)$]])) then
  ui.fHelp("keybind")
elseif (rex.match(helpselect, [[(?i)(?:t(?:a(?:r(?:g(?:e(?:t(?:s)?)?)?)?)?)?)$]])) then
  ui.fHelp("target")
elseif (rex.match(helpselect, [[(?i)(?:uip(?:r(?:o(?:f(?:i(?:l(?:(?:e)?s)?)?)?)?)?)?)$]])) then
  ui.fHelp("profile")
elseif (rex.match(helpselect, [[(?i)(?:uiv(?:a(?:r(?:i(?:a(?:b(?:l(?:e)?)?)?)?)?)?)?|@)$]])) then
  ui.fHelp("variable")
elseif (rex.match(helpselect, [[^\.(?:\.)?$]])) then
  ui.fHelp("walk")
elseif (rex.match(helpselect, [[(?i)(?:uiw(?:i(?:d(?:g(?:e(?:t?)?)?)?)?)?)$]])) then
  ui.fHelp("widget")
else
  ui.fHelp(helpselect)
end</script>
				<command></command>
				<packageName></packageName>
				<regex>^(?i)(?:uih(?:e(?:l(?:p?)?)?)?)(?:\s+(.*))?$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>UI Reply</name>
				<script>if (ui.reply) then
  local msg = matches[2] or ""
  expandAlias("telep "..ui.reply.." "..msg)
end</script>
				<command></command>
				<packageName></packageName>
				<regex>^(?i)(?:uir)(?:\s+(.*))?$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>UI Highlights</name>
				<script>--
local text = string.trim(matches[2] or "")
local color = string.trim(matches[3] or "")
--
if (color ~= "") and (color ~= "remove") then
  if (text == "") and (color == "remove_all") then
    text = "remove_all"
    color = ""
  elseif (text == "") and (color ~= "") then
    text = color
    color = ""
  elseif (text ~= "") and (not ui.fColorCheck(color)) then
    text = text.." "..color
    color = ""
  end
end
-- Mostra tutti gli highlights
if (text == "") and (color == "") then
  ui.fShowAllHighlights()
-- Rimuove tutti gli highlights
elseif (text == "remove_all") then
  ui.fRemoveAllHighlights()
  ui.fEcho2n("Tutti gli highlight sono stati eliminati.")
-- Rimuove il singolo highlight
elseif (color == "remove") then
  if (ui.fRemoveHighlight(text)) then
    ui.fEcho2n("L'highlight e' stato rimosso.")
  else
    ui.fError("L'highlight '"..text.."' non esiste.")
  end
-- Mostra il singolo highlight
elseif (color == "") then
  if (ui.highlights[text]) then
    ui.fEcho2n(ui.fGetHighlightFormattedText(text))
  else
    ui.fError("L'highlight '"..text.."' non esiste.")
  end
-- Crea o modifica l'Highlight
else
  local alreadyExist = ui.highlights[text];
  local result = ui.fAddHighlight(text, color)
  if (result == -2) then
    ui.fError("L'highlight '"..text.."' non è stato creato/modificato. Il colore '"..color.."' non è valido. Usare il comando "..ui.fGetCommandFormattedText("uicolor").." per l'elenco dei colori disponibili.")
  elseif (result == -1) then
    ui.fError("L'highlight '"..text.."' non è stato creato/modificato. Specificare un testo valido.")
  elseif (result == 1) then
    if (alreadyExist) then
      ui.fEcho2n("L'highlight &lt;"..color.."&gt;"..text.."&lt;reset&gt; è stato modificato.")
    else
      ui.fEcho2n("L'highlight &lt;"..color.."&gt;"..text.."&lt;reset&gt; è stato creato.")
    end
  else
    ui.fError("Errore non previsto.")
  end
end
--
ui.fSaveFileHighlights()</script>
				<command></command>
				<packageName></packageName>
				<regex>^(?i)(?:uihi(?:g(?:h(?:l(?:i(?:g(?:h(?:t(?:s)?)?)?)?)?)?)?)?)(?:\s?(.*)\s?( \w+))?$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>UI Keybind</name>
				<script>local element = matches[2] or ""
local key1 = matches[3] or ""
local key2 = matches[4] or ""
local key3 = matches[5] or ""
local isValid, mod1, mod2, key, keybind = ui.fGetKeyb(key1, key2, key3)
-- Mostra tutti i keybind associati a targetselement e aliases
if (element == "") then
  ui.fShowAllKeyb()
-- Rimuove tutti i keybind associati a argets e aliases
elseif (element == "remove_all") then
  ui.fRemoveAllKeyb()
  ui.fEcho2n("Tutti i tasti rapidi sono stati rimossi.")
-- Mostra il singolo keybind
elseif (key1 == "") then
  -- Target
  if (ui.targets[element]) then
    if (ui.targets[element].keybId) then
      ui.fEcho2n(ui.fGetTargetFormattedText(element))
    else
      ui.fEcho2n("Nessun tasto rapido è assegnato al target "..ui.fGetTargetFormattedText(element)..".")
    end
  -- Alias
  elseif (ui.aliases[element]) then
    if (ui.aliases[element].keybId) then
      ui.fEcho2n(ui.fGetAliasFormattedText(element))
    else
      ui.fEcho2n("Nessun tasto rapido è assegnato all'alias "..ui.fGetAliasNameFormattedText(element)..".")
    end
  else
    ui.fError("L'alias "..ui.fGetAliasNameFormattedText(element).." non esiste.")
  end
-- Rimuove il singolo keybind
elseif key1 == "remove" then
  local result
  -- Target
  if (ui.targets[element]) then
    keybind = ui.targets[element].keybind
    result = ui.fRemoveKeyb(ui.targets[element])
    if (result == -2) then
      ui.fError("Il target non esiste.")
    elseif (result == -1) then
      ui.fEcho2n("Nessun tasto rapido assegnato al target "..ui.fGetTargetFormattedText(element).." da rimuovere.")
    elseif (result == 1) then
      ui.fEcho2n("Il tasto rapido "..ui.fGetKeybFormattedText(keybind)..", associato al target "..ui.fGetTargetFormattedText(element)..", e' stato rimosso.")
    else
      ui.fError("Errore non previsto.")
    end
  -- Alias
  elseif (ui.aliases[element]) then
    keybind = ui.aliases[element].keybind
    result = ui.fRemoveKeyb(ui.aliases[element])
    if (result == -2) then
      ui.fError("L'alias non esiste.")
    elseif (result == -1) then
      ui.fEcho2n("Nessun tasto rapido assegnato all'alias "..ui.fGetAliasNameFormattedText(element).." da rimuovere.")
    elseif (result == 1) then
      ui.fEcho2n("Il tasto rapido "..ui.fGetKeybFormattedText(keybind)..", associato all'alias "..ui.fGetAliasNameFormattedText(element)..", e' stato rimosso.")
    else
      ui.fError("Errore non previsto.")
    end
  else
    ui.fError("L'alias "..ui.fGetAliasNameFormattedText(element).." non esiste o non è associato a nessun tasto rapido.")
  end
-- Crea o modifica il keybind
else
  local result, keybind, isTarget
  if (ui.targets[element]) then
    isTarget = true
    result, keybind = ui.fSetKeyb(ui.targets, element, [[ui.fExecuteTargetButton("]]..element..[[")]], key1, key2, key3)
  else
    isTarget = false
    result, keybind = ui.fSetKeyb(ui.aliases, element, ui.aliases[element].code, key1, key2, key3)
  end
  if (result == -4) then
    ui.fError("Il tasto rapido non è stato assegnato. La combinazione di tasti "..ui.fGetKeybFormattedText(keybind).." è già utilizzata in un alias.")
  elseif (result == -3) then
    ui.fError("Il tasto rapido non è stato assegnato. La combinazione di tasti "..ui.fGetKeybFormattedText(keybind).." è già utilizzata in un target.")
  elseif (result == -2) then
    ui.fError("Il tasto rapido non è stato assegnato. La combinazione di tasti "..ui.fGetKeybFormattedText(keybind).." non è valida.")
  elseif (result == -1) then
    ui.fError("Il tasto rapido non è stato assegnato. L'alias "..ui.fGetAliasNameFormattedText(element).." non esiste.")
  elseif (result == 1) and (isTarget) then
    ui.fEcho2n("Il tasto rapido è stato assegnato al target "..ui.fGetTargetFormattedText(element)..".")
  elseif (result == 1) and (not isTarget) then
    ui.fEcho2n("Il tasto rapido è stato assegnato all'alias "..ui.fGetAliasFormattedText(element)..".")
  elseif (result == 2) and (isTarget) then
    ui.fEcho2n("Il tasto rapido associato al target "..ui.fGetTargetFormattedText(element).." è stato rimosso.")
  elseif (result == 2) and (not isTarget) then
    ui.fEcho2n("Il tasto rapido associato all'alias "..ui.fGetAliasNameFormattedText(element).." è stato rimosso.")
  end
end
--
ui.fSaveFileAliases()
ui.fUpdateAllAliasButton()
--
ui.fSaveFileTargets()
ui.fUpdateAllTargetButton()
</script>
				<command></command>
				<packageName></packageName>
				<regex>^(?i)(?:uik(?:e(?:y(?:b(?:i(?:n(?:d)?)?)?)?)?)?)(?:\s*(\w+)?|$)(?:\s*(\w+)?|$)(?:\s*(\w+)?|$)(?:\s*(\w+)?|$)</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>UI Profiles</name>
				<script>local subCommand = matches[2] or ""
local profile = matches[3] or ""
-- Mostra tutti i profiles
if (subCommand == "") then
  ui.fShowAllProfiles()
-- Carica il Profile
elseif (subCommand == "load") then
  if (ui.fLoadProfile(profile)) then
    ui.fEcho2n("Il profilo "..ui.fGetProfileNameFormattedText(profile).." e' stato caricato.")
  else
    ui.fError("Il profilo "..ui.fGetProfileNameFormattedText(profile).." non e' stato caricato.")
  end
-- Save Profile
elseif (subCommand == "save") then
  if (ui.fSaveProfile(profile)) then
    ui.fEcho2n("Il profilo "..ui.fGetProfileNameFormattedText(profile).." e' stato salvato.")
  else
    ui.fError("Il profilo "..ui.fGetProfileNameFormattedText(profile).." non e' stato salvato.")
  end
-- Rimuove il singolo Profile
elseif (subCommand == "remove") then
  if (ui.fRemoveProfile(profile)) then
    ui.fEcho2n("Il profilo "..ui.fGetProfileNameFormattedText(profile).." e' stato rimosso.")
  else
    ui.fError("Il profilo "..ui.fGetProfileNameFormattedText(profile).." non e' stato rimosso.")
  end
-- Rimuove tutti i Profiles
elseif (subCommand == "remove_all") then
  ui.fRemoveAllProfiles()
  ui.fEcho2n("Tutti i profili sono stati rimossi.")
--
else
  ui.fError("Parametro non previsto.")
end</script>
				<command></command>
				<packageName></packageName>
				<regex>^(?i)(?:uip(?:r(?:o(?:f(?:i(?:l(?:e(?:s?)?)?)?)?)?)?)?)(?:\s+(\w*)\s*(.*))?$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>UI Widget</name>
				<script>local widgets = {
  ["affect"]        = GUI.Affect,
  ["buttons"]       = GUI.AliasButtons,
  ["equipment"]     = GUI.Equipment,
  ["group"]         = GUI.Group,
  --["help"]          = GUI.Help,
  ["inventory"]     = GUI.Inventory,
  ["map"]           = GUI.MapCompass,
  ["opponent"]      = GUI.Opponent,
  ["private"]       = GUI.PrivateChat,
  ["player"]        = GUI.Player,
  ["public"]        = GUI.PublicChat,
  ["target"]        = GUI.TargetButtons
}
local widget = string.lower(matches[2] or "")

if (widget == "all") then
  for _, w in pairs(widgets) do
    w:restore();
    w:show();
  end
  ui.fEcho2n("Tutti i widget sono stati ripristinati.")
elseif (widgets[widget]) then
  widgets[widget]:restore();
  widgets[widget]:show();
  ui.fEcho2n("Il widget "..ui.fGetCommandFormattedText(widget).." e' stato ripristinato.")
else
      ui.fError("Nome widget errato: Usare "..ui.fGetCommandFormattedText("Affect")..", "
                                            ..ui.fGetCommandFormattedText("Buttons")..", "
                                            ..ui.fGetCommandFormattedText("Equipment")..", "
                                            ..ui.fGetCommandFormattedText("Group")..", "
                                            ..ui.fGetCommandFormattedText("Inventory")..", "
                                            ..ui.fGetCommandFormattedText("Map")..", "
                                            ..ui.fGetCommandFormattedText("Opponent")..", "
                                            ..ui.fGetCommandFormattedText("Private")..", "
                                            ..ui.fGetCommandFormattedText("Player")..", "
                                            ..ui.fGetCommandFormattedText("Public").." o "
                                            ..ui.fGetCommandFormattedText("Target")..".")
end
</script>
				<command></command>
				<packageName></packageName>
				<regex>^(?i)(?:uiw(?:i(?:d(?:g(?:e(?:t?)?)?)?)?)?)(?:\s+(.*))?$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>UI Set font size</name>
				<script>local windows = string.lower(matches[2] or "")
local fontsize = tonumber(matches[3] or -1)
if (matches[3]) then
  if (fontsize &gt;= 1) and (fontsize &lt;= 30) then
    if (windows == "equipment") then
      ui.parameters.fsEquipment = fontsize
      GUI.Equipment.Main.Body.Console:setFontSize(ui.parameters.fsEquipment)
    elseif (windows == "help") then
      ui.parameters.fsHelp = fontsize
      GUI.Help.Main.Body.Console:setFontSize(ui.parameters.fsHelp)
    elseif (windows == "inventory") then
      ui.parameters.fsInventory = fontsize
      GUI.Inventory.Main.Body.Console:setFontSize(ui.parameters.fsInventory)
    elseif (windows == "map") then
      ui.parameters.fsMapCompass = fontsize
      GUI.MapCompass.Main.B2:setFontSize(ui.parameters.fsMapCompass)   
      GUI.MapCompass.Main.Body.Exits:setFontSize(ui.parameters.fsMapCompass)
      GUI.MapCompass.Main.Body.OtherExits:setFontSize(ui.parameters.fsMapCompass)
    elseif (windows == "private") then
      ui.parameters.fsPrivateChat = fontsize
      GUI.PrivateChat.Main.Body.Console:setFontSize(ui.parameters.fsPrivateChat)
    elseif (windows == "public") then
      ui.parameters.fsPublicChat = fontsize
      GUI.PublicChat.Main.Body.Console:setFontSize(ui.parameters.fsPublicChat)
    elseif (windows == "all") then
      -- Equipment
      ui.parameters.fsEquipment = fontsize
      GUI.Equipment.Main.Body.Console:setFontSize(ui.parameters.fsEquipment)
      -- Help
      ui.parameters.fsHelp = fontsize
      GUI.Help.Main.Body.Console:setFontSize(ui.parameters.fsHelp)
      -- Inventory
      ui.parameters.fsInventory = fontsize
      GUI.Inventory.Main.Body.Console:setFontSize(ui.parameters.fsInventory)
      -- Map
      ui.parameters.fsMapCompass = fontsize
      GUI.MapCompass.Main.B2:setFontSize(ui.parameters.fsMapCompass)   
      GUI.MapCompass.Main.Body.Exits:setFontSize(ui.parameters.fsMapCompass)
      GUI.MapCompass.Main.Body.OtherExits:setFontSize(ui.parameters.fsMapCompass)
      -- Private
      ui.parameters.fsPrivateChat = fontsize
      GUI.PrivateChat.Main.Body.Console:setFontSize(ui.parameters.fsPrivateChat)
      -- Public
      ui.parameters.fsPublicChat = fontsize
      GUI.PublicChat.Main.Body.Console:setFontSize(ui.parameters.fsPublicChat)
    else
      fontsize = 0
      ui.fError("Nome widget errato: Usare "..ui.fGetCommandFormattedText("All")..", "
                                            ..ui.fGetCommandFormattedText("Equipment")..", "
                                            ..ui.fGetCommandFormattedText("Help")..", "
                                            ..ui.fGetCommandFormattedText("Inventory")..", "
                                            ..ui.fGetCommandFormattedText("Map")..", "
                                            ..ui.fGetCommandFormattedText("Private").." o "
                                            ..ui.fGetCommandFormattedText("Public")..".")
    end
    --
    if (fontsize &gt; 0) then
      if (windows == "all") then
        ui.fEcho2n("La dimensione del font di tutti i widget e' stata impostata a "..ui.fGetCommandFormattedText(fontsize)..".")
      else
        ui.fEcho2n("La dimensione del font del widget "..ui.fGetCommandFormattedText(windows).." e' stata impostata a "..ui.fGetCommandFormattedText(fontsize)..".")
      end 
      table.save(ui.fileParameters, ui.parameters)
    end
  else
    ui.fError("La dimensione del font e' errata: Usare un valore compreso tra "..ui.fGetCommandFormattedText("1").." e "..ui.fGetCommandFormattedText("30")..".")
  end
else
  cecho(ui.fTitle("Dimensioni font"))
  cecho(ui.fGetNumberFormattedText(1)..ui.fGetCommandFormattedText(" Inventory")..ui.fGetOperatorFormattedText(" = ")..ui.fGetVarValueFormattedText(ui.parameters.fsInventory).."\n");
  cecho(ui.fGetNumberFormattedText(2)..ui.fGetCommandFormattedText(" Equipment")..ui.fGetOperatorFormattedText(" = ")..ui.fGetVarValueFormattedText(ui.parameters.fsEquipment).."\n");
  cecho(ui.fGetNumberFormattedText(3)..ui.fGetCommandFormattedText(" Map")..ui.fGetOperatorFormattedText(" = ")..ui.fGetVarValueFormattedText(ui.parameters.fsMapCompass).."\n");
  cecho(ui.fGetNumberFormattedText(4)..ui.fGetCommandFormattedText(" Private")..ui.fGetOperatorFormattedText(" = ")..ui.fGetVarValueFormattedText(ui.parameters.fsPrivateChat).."\n");
  cecho(ui.fGetNumberFormattedText(5)..ui.fGetCommandFormattedText(" Public")..ui.fGetOperatorFormattedText(" = ")..ui.fGetVarValueFormattedText(ui.parameters.fsPublicChat).."\n\n");
  ui.fEcho2n("Usare "..ui.fGetCommandFormattedText("uisetf[ontsize] &lt;nome_finestra&gt; ")..ui.fGetVarValueFormattedText("&lt;dimensione_font&gt;"))
end</script>
				<command></command>
				<packageName></packageName>
				<regex>^(?i)(?:uisetf(?:o(?:n(?:t(?:s(?:i(?:z(?:e)?)?)?)?)?)?)?)(?:\s*(\w+)?|$)(?:\s*(\w+)?|$)</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>UI Speedwalk</name>
				<script>ui.fDebug("[alias] UI Speedwalk")
--
local in_path = string.lower(matches[3] or "")
local out_path = ""
local backwards = (matches[2] == ".")
--
if (in_path == "") then
  -- Retrace your steps back
  if (backwards) then
    if (ui.idxPath &gt;= 1) then
      out_path = ui.dirReverse[ui.path[ui.idxPath]]
      ui.idxPath = ui.idxPath - 1;
      ui.retrace = true
    else
      ui.fEcho2n("Sei all'inizio del percorso memorizzato.")
    end
  -- Retrace your steps forward 
  elseif (not backwards) then
    if (ui.idxPath &lt; ui.memPath) then
      ui.idxPath = ui.idxPath + 1
      out_path = ui.path[ui.idxPath]
      ui.retrace = true
    else
      ui.fEcho2n("Sei alla fine del percorso memorizzato.")
    end
  end
else
  -- Speedwalk
  local number
  local idx = 1
  while (idx&lt;=in_path:len()) do
    number, idx = ui.fGetNextNumber(in_path, idx)
    if (idx&lt;=in_path:len()) then
      local char = string.lower(in_path:sub(idx, idx))
      for j=1, number do
        if (backwards) then
          out_path = ui.dirReverse[char]..out_path
        else
          out_path = out_path..char
        end
      end
      idx = idx + 1
    end
  end
end
--
if (backwards) then
  ui.fDebug("[alias] UI Speedwalk (Back) - in: "..in_path.." - out: "..out_path)
else
  ui.fDebug("[alias] UI Speedwalk (Forward) - in: "..in_path.." - out: "..out_path)
end
-- Execute out path
for j=1, out_path:len() do
  -- Execute Ui Direction alias
  expandAlias(out_path:sub(j, j), false); 
end</script>
				<command></command>
				<packageName></packageName>
				<regex>^\.(\.)?(?i)([nsewdu\d]+)?$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>UI Target</name>
				<script>local button_type = string.upper(matches[2])
local button_number = tonumber(matches[3])
local value = matches[4] or ""
local button = button_type..button_number
-- G buttons
if (button_type == "G") then
  if (button_number&lt;0) or (button_number&gt;9) then
    ui.fError(ui.fGetTargetFormattedText(button).." non valido. Usare un target compreso tra "..ui.fGetTargetFormattedText("G0").." e "..ui.fGetTargetFormattedText("G9"))
  elseif (value ~= "") then
    ui.fError(ui.fGetTargetFormattedText(button).." non è possibile assegnare o rimuovere un valore al target avversario "..ui.fGetTargetFormattedText(button))
  else
    ui.fExecuteTargetButton(button)
  end
-- O button
elseif (button_type == "O") then
  if (button_number~=0)  then
    ui.fError(ui.fGetTargetFormattedText(button).." non valido. Usare "..ui.fGetTargetFormattedText("T0"))
  elseif (value ~= "") then
    ui.fError(ui.fGetTargetFormattedText(button).." non è possibile assegnare o rimuovere un valore al target di gruppo "..ui.fGetTargetFormattedText(button))
  else
    ui.fExecuteTargetButton(button)
  end
-- T buttons
elseif (button_type == "T") then
  if (button_number&lt;1) or (button_number&gt;4) then
    ui.fError(ui.fGetTargetFormattedText(button).." non valido. Usare "..ui.fGetTargetFormattedText("T1")..", "..ui.fGetTargetFormattedText("T2")..", "..ui.fGetTargetFormattedText("T3").." oppure "..ui.fGetTargetFormattedText("T4"))
  elseif (value == "") then
    ui.fExecuteTargetButton(button)
  elseif (value == "remove") then
    if (ui.fAssignTargetButton(button, nil)) then
      ui.fEcho2n(ui.fGetTargetFormattedText(button).." valore rimosso.")
    else
      ui.fError(ui.fGetTargetFormattedText(button).." errore durante la rimozione del valore.")
    end
  else
    if (ui.fAssignTargetButton(button, value)) then
      ui.fEcho2n(ui.fGetTargetFormattedText(button).." valore impostato "..ui.fGetVarValueFormattedText(value)..".")
    else
      ui.fError(ui.fGetTargetFormattedText(button).." errore durante il cambio di valore.")
    end
  end
end</script>
				<command></command>
				<packageName></packageName>
				<regex>^(?i)([got])(\d)(?:\s+(.*))?$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>UI Variables</name>
				<script>local variable = matches[2]
local value = matches[3]
-- Mostra tutte le variabili
if variable == nil or variable == "" then
  ui.fShowAllVar()
-- Rimuove tutte le variabili
elseif variable == "remove_all" then
  ui.fRemoveAllVariables();
  ui.fEcho2n("Tutte le variabili sono state eliminate.")
-- Mostra la singola variabile
elseif value == nil or value == "" then
  if ui.variables[variable] then
    ui.fEcho2n(ui.fGetVarFormattedText(variable))
  else
    ui.fEcho2n("La variabile "..ui.fGetVarNameFormattedText(variable).." non esiste.")
  end
-- Rimuove la singola variabile
elseif value == "remove" then
  if not ui.variables[variable] then
    ui.fEcho2n("La variabile "..ui.fGetVarNameFormattedText(variable).." non esiste.")
  elseif table.contains(ui.pre_defined_variables, variable) then
    ui.variables[variable] = ""
    ui.fEcho2n("La variabile predefinita "..ui.fGetVarNameFormattedText(variable).." è stata pulita.")
  else
    ui.variables[variable] = nil
    ui.fEcho2n("La variabile "..ui.fGetVarNameFormattedText(variable).." e' stata rimossa.")
  end
-- Crea o modifica la variabile
else
  if (ui.variables[variable])then
    ui.variables[variable] = value
    ui.fEcho2n('La variabile è stata aggiornata: '..ui.fGetVarFormattedText(variable))
  else
    ui.variables[variable] = value
    ui.fEcho2n('La variabile è stata creata: '..ui.fGetVarFormattedText(variable))
  end
end
if (variable and variable == "target") then
  ui.fUpdateAllTargetButton()
  ui.fUpdateTarget()
end
table.save(ui.fileVariables, ui.variables)</script>
				<command></command>
				<packageName></packageName>
				<regex>^(?i)(?:uiv(?:a(?:r(?:i(?:a(?:b(?:l(?:e)?)?)?)?)?)?)?|@)(?:\s*@?(\w+)(?:\s*)?(.*))?$</regex>
			</Alias>
		</AliasGroup>
		<AliasGroup isActive="yes" isFolder="yes">
			<name>Directiones</name>
			<script></script>
			<command></command>
			<packageName></packageName>
			<regex></regex>
			<AliasGroup isActive="yes" isFolder="yes">
				<name>Eldorado</name>
				<script>--[[	
Eldorado: Ingressi
Eldorado e' nosummon, quindi ci si arriva solo a piedi conoscendo l'ingresso.
Mappa Eldorado
Attenzione: è pressoché completa, ma potrebbe contenere imprecisioni/inesattezze. Nel caso, segnalatele qui per piacere.
Indice
    1 Note per chi entra da solo
    2 Rooms di Eldo da cui si puo' astralare/portalare/recallare
    3 Una fitta foresta dominata da una sagoma imponente
    4 Tutto il globo, ma su niente
    5 Una piccola valle dormiente tra i monti
    6 Una imponente foresta di quercie
    7 Una spiaggetta in un bosco
    8 Una grotta che ospita presenze maligne
    9 L'ansa di un fiume tropicale
    10 Degli orti ben coltivati
    11 Una piccola radura su un altipiano
    12 Un boschetto con un gazebo
    13 Un umido tunnel dove aleggia un odore di belve
    14 Un luogo sotterraneo abitato, da strani rettili
    15 Un'enorme belva di marmo
    16 Delle potenti scariche di elettricità
    17 Draghi e cavalieri, ma sono immobili
    18 Vari simboli di morte
    19 Un animale incerto tra mangiare o bere
    20 Un intricato labirinto
    21 Un enorme smeraldo intagliato
    22 Un fiume che scorre
Note per chi entra da solo
Giungla: negli ingressi alla giungla l'ideale e' entrare e fare subito run w;run nord (si finisce in una locazione tranquilla). Occhio che vedono sneak.
Fossa belve: negli ingressi alla fossa delle belve l'ideale e' entrare di run sud;w;s;open sou;s
Laguna: negli ingressi alla laguna l'ideale e' entrare di s;w;2s;w (locazione nomob)
Miniera: l'ingresso alla miniera e' sicuro (non ci sono mob aggressivi, bisogna poi diggare a est)
Sorgente: negli ingressi alla sorgente l'ideale e' entrare di e;n;u (mob non aggressivi)
Contadini: l'ingresso dai contadini e' tranquillo, ma le contadine rubano coin
Se si e' da soli e non si conosce bene Eldorado, sempre meglio farsi venire a prendere all'ingresso (DENTRO l'area).
Rooms di Eldo da cui si puo' astralare/portalare/recallare
Presso una sorgente
La grande piazza della statua
La strada delle fiere (questa l'ho recuperata da http://it.groups.yahoo.com/group/leu/message/24095)
Una fitta foresta dominata da una sagoma imponente
Zona : Vulcano
/ Piedi /
Da ALMA CIVITAS : .s10ws9w3n10wusws2ws2wn (n Giungla)
Tutto il globo, ma su niente
Zona : Sala Giochi Karkas (I corridoi dell'infinito)
/ Portal /
Raggiungere Il centro della piazza del mercato tramite Portale su Turista (w fino a piazza) Da Il centro della piazza del mercato : .6n;open north;.7ne10ne3ne5ne7nw3n8en (d;run n Giungla)
/ Astral /
Raggiungere Il centro della piazza del mercato tramite Piano Astrale (.unwwnuw;ent spe;.s16w) Da Il centro della piazza del mercato : .6n;open north;.7ne10ne3ne5ne7nw3n8en (d;run n Giungla)
/ Piedi /
Da Tania: .dw5s;open sou;.2se3s8e;open east;.6e6n;open north;.7ne10ne3ne5ne7nw3n8en (d;run n Giungla)
Da ALMA CIVITAS : .s9e3n4es2e2d18e2n4e3s7e;open ea;.8e3s8e;open ea;.6e6n;open north;.7ne10ne3ne5ne7nw3n8en (d;run n Giungla)
oppure
Raggiungere Il centro della piazza del mercato tramite Aviani (da Alma .s7e3s, scendere alla PRIMA fermata, poi .13e fino a piazza)
Da Tania a Il centro della piazza del mercato: .dw5s;open sou;.2se3s8e;open east;.6e
Da Il centro della piazza del mercato : .6n;open north;.7ne10ne3ne5ne7nw3n8en (d;run n Giungla)
Se vi becca il troll e vi introia la path: .5ne3ne5ne7nw3n8en
Se vi becca ANCHE il cava-azzurro e vi introia la path: .3nw3n8en
Una piccola valle dormiente tra i monti
Zona : Picchi di Raven
/ Portal /
Raggiungere Il centro della piazza del mercato tramite Portale su Turista (w fino a piazza) Da Il centro della piazza del mercato : .8w2sue2sw (n Giungla)
/ Astral /
Raggiungere Il centro della piazza del mercato tramite Piano Astrale (.unwwnuw;ent spe;.s16w) Da Il centro della piazza del mercato : .8w2sue2sw (n Giungla)
/ Piedi /
Da Tania: .dw5s;open sou;.2se3s6e2sue2sw (n Giungla)
Da ALMA CIVITAS : .s9e3n4es2e2d18e2n4e3s7e;open ea;.8e3s6e2sue2sw (n Giungla)
oppure
Raggiungere Accesso ad una piccola valle tramite Aviani (da Alma .s7e3s, scendere alla PRIMA fermata, poi .5e2sue2sw)
Da Il centro della piazza del mercato : .8w2sue2sw (n Giungla)
Una imponente foresta di quercie
Zona : Foresta Rhowyn
/ Portal /
Raggiungere Il centro della piazza del mercato tramite Portale su Turista (w fino a piazza) Da Il centro della piazza del mercato : .6n;open north;.7ne10ne3ne2n (e Sorgente)
/ Astral /
Raggiungere Il centro della piazza del mercato tramite Piano Astrale (.unwwnuw;ent spe;.s16w) Da Il centro della piazza del mercato : .6n;open north;.7ne10ne3ne2n (e Sorgente)
/ Piedi /
Da Tania: .dw5s;open sou;.2se3s8e;open east;.6e6n;open north;.7ne10ne3ne2n (e Sorgente)
Da ALMA CIVITAS : .s9e3n4es2e2d18e2n4e3s7e;open ea;.8e3s8e;open ea;.6e6n;open north;.7ne10ne3ne2n (e Sorgente)
oppure
Raggiungere Il centro della piazza del mercato tramite Aviani (da Alma .s7e3s, scendere alla PRIMA fermata, poi .13e fino a piazza)
Da Tania a Il centro della piazza del mercato: .dw5s;open sou;.2se3s8e;open east;.6e
Da Il centro della piazza del mercato : .6n;open north;.7ne10ne3ne2n (e Sorgente)
Se vi becca il troll e vi introia la path: .5ne3ne2n
Una spiaggetta in un bosco
Zona : Foresta Rhowyn
/ Portal /
Raggiungere Il centro della piazza del mercato tramite Portale su Turista (w fino a piazza) Da Il centro della piazza del mercato : .6n;open north;.7ne5n3e5n (n Giungla)
/ Astral /
Raggiungere Il centro della piazza del mercato tramite Piano Astrale (.unwwnuw;ent spe;.s16w) Da Il centro della piazza del mercato : .6n;open north;.7ne5n3e5n (n Giungla)
/ Piedi /
Da Tania: .dw5s;open sou;.2se3s8e;open east;.6e6n;open north;.7ne5n3e5n (n Giungla)
Da ALMA CIVITAS : .s9e3n4es2e2d18e2n4e3s7e;open ea;.8e3s8e;open ea;.6e6n;open north;.7ne5n3e5n (n Giungla)
oppure
Raggiungere Il centro della piazza del mercato tramite Aviani (da Alma .s7e3s, scendere alla PRIMA fermata, poi .13e fino a piazza)
Da Tania a Il centro della piazza del mercato: .dw5s;open sou;.2se3s8e;open east;.6e
Da Il centro della piazza del mercato : .6n;open north;.7ne5n3e5n (n Giungla)
Se vi becca il troll e vi introia la path: .3e5n
Una grotta che ospita presenze maligne
Zona : Moria
/ Astral /
Raggiungere La caverna dorata tramite Piano Astrale (.unwws;ent spe) Da La caverna dorata : .2e4sen2w (w Necropoli)
/ Piedi /
Raggiungere La caverna dorata da ALMA CIVITAS : .8s2e2s2ws2es2w3swsws2en3e2n2e2n3n2wn3wden Da La caverna dorata : .2e4sen2w (w Necropoli)
L'ansa di un fiume tropicale
Zona : Aborigeni (Roo)
/ Astral /
Raggiungere La cima di una grande collina tramite Piano Astrale (.unwwnuwuw;ent spe) Da La cima di una grande collina : .n4w5se (s Laguna)
/ Piedi /
Da Tania: .dw5s;open sou;.2se3s8e;open east;.6e6s;ope sou;.sd2sw5se (s Laguna)
Da ALMA CIVITAS : .s9e3n4es2e2d18e2n4e3s7e;open ea;.8e3s8e;open ea;.6e6s;ope sou;.sd2sw5se (s Laguna)
oppure
Raggiungere Il centro della piazza del mercato tramite Aviani (da Alma .s7e3s, scendere alla PRIMA fermata, poi .13e fino a piazza)
Da Tania a Il centro della piazza del mercato: .dw5s;open sou;.2se3s8e;open east;.6e
Da Il centro della piazza del mercato : .6s;ope sou;.sd2sw5se (s Laguna)
Degli orti ben coltivati
Zona : Aborigeni (Roo)
/ Astral /
Raggiungere La cima di una grande collina tramite Piano Astrale (.unwwnuwuw;ent spe)
Da La cima di una grande collina : .n4w5s2wsw (s Contadini)
/ Piedi /
Da Tania: .dw5s;open sou;.2se3s8e;open east;.6e6s;open sou;.sd2sw5s2wsw (s Contadini)
Da ALMA CIVITAS : .s9e3n4es2e2d18e2n4e3s7e;open ea;.8e3s8e;open ea;.6e6s;open sou;.sd2sw5s2wsw (s Contadini)
oppure
Raggiungere Il centro della piazza del mercato tramite Aviani (da Alma .s7e3s, scendere alla PRIMA fermata, poi .13e fino a piazza)
Da Tania a Il centro della piazza del mercato: .dw5s;open sou;.2se3s8e;open east;.6e
Da Il centro della piazza del mercato : .6s;open sou;.sd2sw5s2wsw (s Contadini)
Una piccola radura su un altipiano
Zona : Altopiano dannati
/ Piedi /
Da Alma Civitas ad Alpes Oppidum: .10ne3nw5nw3nw; (solo se chiuso verso north: lift grata) .4n oppure
Raggiungere Alpes Oppidum tramite Aviani (da Alma .s7e2se e scendere alla PRIMA fermata, poi n)
Da Alpes Oppidum a Una stradina nel sottobosco: .w2nesu2nueuen2w3nw3ue (s Sorgente)
(attenzione perche' la path contiene delle private con dentro Alkiria e/o scorpione)
Un boschetto con un gazebo
Zona : Lycantropia
/ Portal /
Raggiungere Un boschetto tramite portal su Giovane Conte Boarish (giova-boarish) (w Radura)
/ Astral /
Raggiungere La Taverna dell'Umano Squartato tramite Piano Astrale (.unwwnuwun;ent spe) Da La Taverna dell'Umano Squartato : .s2en2es3e3nw3s (w Radura)
/ Piedi /
Da ALMA CIVITAS : .s10ws9w3n4w3s3ws3ese3s (L' ingresso di Lycantropia) .s2es3e3nw3s (w Radura)
oppure
Raggiungere Piazza Trionfo tramite Aviani (da Alma .s7e2sw e scendere alla PRIMA fermata) Da Piazza Trionfo : .es4wnw5s2es3e3nw3s (w Radura)
Un umido tunnel dove aleggia un odore di belve
Zona : Anfiteatro
/ Portal /
Raggiungere Ingresso all'Anfiteatro tramite Portale su Flaminio Da Ingresso all'Anfiteatro : .8nd3e4s (s Fossa Belve)
/ Piedi /
Da ALMA CIVITAS : .s9e12nd3e4s (s Fossa Belve)
Un luogo sotterraneo abitato, da strani rettili
Zona : Foresta di Alma
/ Portal /
Portale su Anaconda, ent port;n;cut liana;d (n Miniera)
/ Piedi /
Da ALMA CIVITAS : .s9en2e3s7en;cut liana;d (n Miniera)
Un'enorme belva di marmo
Zona : Colosseo
/ Astral /
Dal bordo del vuoto astrale allo specchio cangiante .unw;ent spe poi .2d3edne (east Fossa Belve)
/ Portal /
Portal su "golem-armatura" (exa portal dovrebbe dirvi: L'antro dei Golem), sperando che nessuno abbia avuto bisogno impellente di riallineare/praccare coi rescue, poi .dne
/ Piedi /
Da Alma Civitas .2s4w; kill tarquinio; .wn2edne (east Fossa Belve)
Delle potenti scariche di elettricità
Zona : Pennina
/ Portal /
Raggiungere Ingresso all'Anfiteatro tramite Portale su Flaminio
Da Ingresso all'Anfiteatro : .s4es2e2de2u2nuse2nwu (La fortezza!) .nwnw3n (solo se chiuso verso west: pull torcia) .wde2s2e (solo se chiuso verso est: push masso) .e2s2e4n (w Drago Blu)(.2w Radura)
/ Piedi /
Da ALMA CIVITAS : .s9e3n4es2e2de2u2nuse2nwu (La fortezza!) .nwnw3n (solo se chiuso verso west: pull torcia) .wde2s2e (solo se chiuso verso est: push masso) .e2s2e4n (w Drago Blu)(.2w Radura)
Draghi e cavalieri, ma sono immobili
Zona : Vingaard
/ Portal /
Raggiungere Frank tramite Portale su Frank .2e (run s Miniera)
/ Astral /
Raggiungere Il centro della piazza del mercato tramite Piano Astrale (.unwwnuw;ent spe;.s16w)
Da Il centro della piazza del mercato : .6n;open north;.7ne10ne3ne5ne7n3w (run s Miniera)
/ Piedi /
Da Tania: .dw5s;open sou;.2se3s8e;open east;.6e6n;open north;.7ne10ne3ne5ne7n3w (run s Miniera)
Da ALMA CIVITAS : .s9e3n4es2e2d18e2n4e3s7e;open ea;.8e3s8e;open ea;.6e6n;open north;.7ne10ne3ne5ne7n3w (run s Miniera)
oppure
Raggiungere Il centro della piazza del mercato tramite Aviani (da Alma .s7e3s, scendere alla PRIMA fermata, poi .13e fino a piazza)
Da Tania a Il centro della piazza del mercato: .dw5s;open sou;.2se3s8e;open east;.6e
Da Il centro della piazza del mercato : .6n;open north;.7ne10ne3ne5ne7n3w (run s Miniera)
Se vi becca il troll e vi introia la path: .5ne3ne5ne7n3w
Se vi becca ANCHE il cava-azzurro e vi introia la path: .3n3w
Vari simboli di morte
Zona : Villaggio Lorgae (Nahaz)
/ Portal /
Raggiungere La piazza principale tramite portale per Albergatore Gitano e poi .w5s;open sou;.2s6w;open wes;.2w oppure portal su Urgord e poi .ds
Da La piazza principale: knock/pick south poi open south;.2s;kill nahaz;get chia naha;unlock botola;lift botola;.d (d Necropoli)
/ Astral /
Raggiungere Il centro della piazza del mercato tramite Piano Astrale (.unwwnuw;ent spe;.s16w)
Da Il centro della piazza del mercato a La piazza principale: .5w;open wes;.9w3n7w;open wes;.2w
Da La piazza principale: knock/pick south poi open south;.2s;kill nahaz;get chia naha;unlock botola;lift botola;.d (d Necropoli)
/ Piedi /
Da Tania a La piazza principale: .dw5s;open sou;.2s6w;open wes;.2w
Da ALMA CIVITAS a La piazza principale: .s9e3n4es2e2d18e2n4e3s6e
oppure
Raggiungere La piazza principale tramite Aviani (da Alma .s7e3s, scendere alla PRIMA fermata, poi .w3n7w;ope wes;.2w)
Da La piazza principale: knock/pick south poi open south;.2s;kill nahaz;get chia naha;unlock botola;lift botola;.d (d Necropoli)
Un animale incerto tra mangiare o bere
Zona : Elminster (Archimedes)
/ Portal /
Raggiungere Mini torre di Elminster tramite Portale su Archimedes, il gufo di Elminster.
Se Elminster e' no init, raggiungere Il centro della piazza del mercato tramite Portale su Turista (w fino a piazza)
Da Il centro della piazza del mercato ad Archimedes : .6n;open north;.7ne10ne3ne5ne7nw3nw2nene (e Fossa Belve)
/ Astral /
Raggiungere Il centro della piazza del mercato tramite Piano Astrale (.unwwnuw;ent spe;.s16w)
Da Il centro della piazza del mercato ad Archimedes : .6n;open north;.7ne10ne3ne5ne7nw3nw2nene (e Fossa Belve)
/ Piedi /
Da Tania: .dw5s;open sou;.2se3s8e;open east;.6e6n;open north;.7ne10ne3ne5ne7nw3nw2nene (e Fossa Belve)
Da ALMA CIVITAS : .s9e3n4es2e2d18e2n4e3s7e;open ea;.8e3s8e;open ea;.6e6n;open north;.7ne10ne3ne5ne7nw3nw2nene (e Fossa Belve)
oppure
Raggiungere Il centro della piazza del mercato tramite Aviani (da Alma .s7e3s, scendere alla PRIMA fermata, poi .13e fino a piazza)
Da Tania a Il centro della piazza del mercato: .dw5s;open sou;.2se3s8e;open east;.6e
Da Il centro della piazza del mercato ad Archimedes : .6n;open north;.7ne10ne3ne5ne7nw3nw2nene (e Fossa Belve)
Se vi becca il troll e vi introia la path: .5ne3ne5ne7nw3nw2nene
Se vi becca ANCHE il cava-azzurro e vi introia la path: .3nw3nw2nene
Un intricato labirinto
Zona : Hoeur
/ Piedi /
Da Alma Civitas a Spaventapasseri: .s10ws9w3n9w6s8w5s3ws
Da Spaventapasseri: .n3e5n4e2s3w4sd
/ Portal /
Portalare Spaventapasseri (se Hoeur non c'e') poi .n3e5n4e2s3w4sd.
.d ci sono 2 guerrieri elfi sancati con chiave elfica, che apre ad est (fanno blunt ma si prendono di tutto e sono moscilli) unlo east;open east;
I mob successivi si possono skippare se si fa rapidamente questo appena presa la chiave: unlo east;open east;e;open east;e;open east;.e4d3e
Qui si spiega comunque cosa c'e' e cosa fanno.
Al primo east ci sono 4 o 5 drow guerrieri, un po' piu' tosti dei primi 2 (fanno blunt ma si prendono di acid/slash/pierce/blunt) open east;e;open east; ad east ci sono 14 minotauri hide (fanno slash, ma sono moscilli e sono solo resi fire elec) .4d3e e sei oltre il Hoeur! .2d (n Miniere)
Portalare Hoeur ed entrare con stringa (ent port;e) .2d (n Miniere)
Attenzione: il .2d finale porta in silence e non si puo' piu' tornare indietro! (per prudenza, prendete prima le pozioni argentee dai cadaveri dei drow guerrieri, fanno astral!)
Un enorme smeraldo intagliato
Zona : Torre Magia
Se non l'hanno già fatta prima, bisogna fare la quest per arrivare dalla Signora della Magia.
Se la questina di cui sopra è gia' stata fatta e non è ancora ripoppata, allora....
/ Astral /
Andare alla pool per Torre Magia (.unwn;ent spe), poi andare .3s2u5n e siete a La sala delle Udienze, dove c'è la Signora della magia, da qui (d;run n giungla)
/ Piedi /
Fate prima a farvi dare uno strappo in astral, comunque le path pedonali sono nella pagina della quest di cui sopra :)
Un fiume che scorre
Puo' essere una di queste entrate:
    Il Fiume El'Azahred:
        / Astral / .unwwnuw;ent spe;.s16w5s7e (s giungla .uw;run n per non crepare come un jamal nella giungla)
        / Piedi /
        Da Tania:.dw5s;open sou;.2se3s8e;open east;.6e5s7e (s giungla .uw;run n)
        Da Il centro della piazza del mercato .5s7e (s giungla .uw;run n)
    Fiume Lys
        / Portal / Portal su Skipper, poi .s6w (d sorgente)
        / Piedi / Da Alma Civitas .4se2s6w (d sorgente)
    Fiume Oscuro
        / Portal / Portal su Skipper, poi .se;ope grata;.7en4e (n giungla .uw;run n)
        / Piedi /
        Da Alma Civitas .4se2se;ope grata;.7en4e (n giungla .uw;run n)
        Da Tania: .dw5s;open sou;.2se3s8e;open east;.22en5en2de;kill cerbero (noscrap);get chia cada;unlo ea;open ea;.e2n2w2e (n giungla .uw;run n)
        Da Il centro della piazza del mercato: .16en5en2de;kill cerbero (noscrap);get chia cada;unlo ea;open ea;.e2n2w2e (n giungla .uw;run n)
        / Astral / .unwwnuw;ent spe;.4e fino a ciliegio, poi .2en2de;kill cerbero (noscrap);get chia cada;unlo ea;open ea;.e2n2w2e (n giungla .uw;run n)
    Fiume Ara-Raven
        / Piedi /
        Da Tania:.dw5s;open sou;.2se3s8e;open east;.6e5s14w2n (d giungla .uw;run n)
        Da Il centro della piazza del mercato:.5s14w2n (d giungla .uw;run n)
        / Astral / .unwwnuw;ent spe;.s16w5s14w2n (d giungla .uw;run n)
]]</script>
				<command></command>
				<packageName></packageName>
				<regex></regex>
				<Alias isActive="yes" isFolder="no">
					<name>Eldorado</name>
					<script>local path = {
  "dw assassino-gitano",
  ".enw;ask chiromante eldorado",
}
ui.fExecutePath(path, matches[2])</script>
					<command></command>
					<packageName></packageName>
					<regex>^(?i)eldorado(?:\s+(.*))?$</regex>
				</Alias>
			</AliasGroup>
			<AliasGroup isActive="yes" isFolder="yes">
				<name>Scatole</name>
				<script>--[[
Si prega tutti di contribuire fornendo nome mob, dir e caratteristiche. Insomma qualunque cosa possa essere utile a prenderle prima degli altri.
Inserite anche quelli nuovi che non conoscete, l'importante e' ampliare la lista, magari altri sanno dove sta...
= Elenco =
== una scatola nera laccata dentro un altare ==
'''PATH''': altare nella quest BoscoVerde .... Uccidere GUT , gettare chiave , andare nella stanza ANTICA CAPPELLA e aprire l'altare
== una scatola nera laccata trasportata da Alu-Fiend ==
'''PATH''': Si trova dentro la Torre della zona del Portale dove si editava Epico .. si uccide prima Molybienus , si getta chiave nera e si apre la Torre ... il mob si trova a nord ovest mi pare nella Room chiamata Sala-Dolore
== una scatola nera laccata trasportata da Amon ==
'''PATH''': Miniquest di Amon
== una scatola nera laccata dentro un antico forziere ==
'''PATH''': quest Ecate
== una scatola nera laccata trasportata da Ashark, lo sciamano ==
'''PATH''': da Platea Quadrata 9e3n4es2e2de2unue2nwun;e2ne3n2e; knock north;n (Bee, re dei giganti); turn dipinto; sta a west
== una scatola nera laccata trasportata da Ashura, il dio della Guerra ==
'''PATH''': Boss finale quest Regni
== una scatola nera laccata trasportata da Aslam l'evocatore ==
'''PATH''': mob intermedio della quest Tarrasque
== una scatola nera laccata trasportata da Asmodeo, Signore degli Incendiari ==
'''PATH''': mob della quest Oltre il Portale
== una scatola nera laccata trasportata da Avatar del Guardiano ==
'''PATH''': Boss finale quest Sottomondo di Zodak
== una scatola nera laccata trasportata da l'Avatar di Amharb. ==
'''PATH''': Boss finale quest Tempio dei Dannati
== una scatola nera laccata trasportata da Balrog ==
'''PATH''': Mob finale della nuova moria - dalla pool di moria (unwws) si segano gli orchi, uno ha la chiave di mithril che apre il portale dove sta l'orco nero. Si scende di sotto e si dà di stringa (se non si vuole fare xp) run n;sd2s e ci si ritrova una room prima del cimitero dove girano una quarantina di nani evanescenti. Uno ha la chiave arrugginita che apre verso il balrog. All'estremo sud c'e' il capo fantasma che è caster ma si dispa e muore bene. Poi 2s il Balrog: Mu over 50
== una scatola nera laccata dentro una bara d'ebano ==
'''PATH''': Raven , room del primo Stradh
== una scatola nera laccata trasportata da un Bar-Igura ==
'''PATH''': mob della quest Oltre il Portale
== una scatola nera laccata trasportata da una Banshee urlante ==
'''PATH''': mob della quest Sithicus
== una scatola nera laccata dentro un baule intarsiato d'argento ==
'''PATH''': Camera di Kelepho (ucciderlo e gettare chiavi per aprirlo) a Villa Kelepho
== una scatola nera laccata trasportata da Belak ==
'''PATH''': Penultimo Boss quest Cittadella
== una scatola nera laccata trasportata da Belial ==
'''PATH''' : Portalare ENN poi UP - NORD - WEST - NORD
== una scatola nera laccata trasportata da Biakko, il generale dell'esercito bianco ==
'''PATH''': campi di battaglia sotto quest Regni
== una scatola nera laccata trasportata da Il Bianco Sire ==
'''PATH''': Boss finale della quest Monte Celestia
== una scatola nera laccata trasportata da il Boia Infernale ==
'''PATH''': Mob che si trova dentro la zona di Ade
== una scatola nera laccata in Un buco pieno di melma fetida ==
'''PATH''': ???
== una scatola nera laccata trasportata da Calcryx ==
'''PATH''': Boss intermedio quest Cittadella
== una scatola nera laccata dentro le Carie ==
'''PATH''': Situata nella Room Bocca del Drago di Ancadalor , una delle prime Room 
== una scatola nera laccata trasportata da Il Cavaliere della forza ==
'''PATH''': (aka '''Darth Vader''') (ex '''ET''') - mob finale della quest Villa delle feste
== una scatola nera laccata trasportata da Cavaliere Della Morte ==
'''PATH''': dalla pool blu mezzanotte (fiume delle anime perdute, unww) 3e2sesed - aspettare teleport - d;pull naso;d;open ecorc;ds - castarsi wb o swimmare e aspettare doppia teleport, finché non esce un'uscita down - d4swdn2wdwddwnwun
== una scatola nera laccata trasportata da Un grosso cavernicolo ==
'''PATH''': mob intermedio della quest El Quebbar
== una scatola nera laccata trasportata da un chipmunk dai denti a sciabola ==
'''PATH''': mob della quest Giardini Infiniti
== una scatola nera laccata trasportata da Il Cuore di Ashardalon == 
'''PATH''': mob finale della quest Torre Notturna
== una scatola nera laccata trasportata da Dama morte ==
'''PATH''': boss finale Cattedrale
== una scatola nera laccata trasportata da Demogorgo ==
'''PATH''': da Efesto (room La Fucina degli Dei) knock south;s;turn vendetta;d
== una scatola nera laccata trasportata da Il demone del dolore ==
'''PATH''': alla Cittadella delle Nuvole (si sale la catena al centro del parco di Alma)
== una scatola nera laccata trasportata da un demone d'oro ==
'''PATH''': quest Ecate
== una scatola nera laccata trasportata dalla Devozione ==
'''PATH''': mob di Celestia del sesto girone
== una scatola nera laccata trasportata da l'incarnazione del Dio della Guerra ==
'''PATH''': mob di Eldorado Mappa Eldorado Ingressi Eldo
== una scatola nera laccata trasportata da DoomHammer ==
'''PATH''': Fortezza Pennina , nella camera degli ospiti
== una scatola nera laccata trasportata da Drago d'Acciaio ==
'''PATH''': da inserire... (è dalle parti della caverna SirGris&amp;gigante) - E' portalabile comunque
== una scatola nera laccata trasportata da Drago Astrale ==
'''PATH''': mob corsa quest Tarrasque
== una scatola nera laccata trasportata da Un Vecchio Drago Blu ==
'''PATH''': Il drago elettrico della fortezza pennina - da Platea Quadrata 9e3n4es2e2de2unue2nwunwnw3n;pull torcia;wde2s2e;push masso;2e - aspettare teleport - nw
== una scatola nera laccata trasportata da il Drago Nero ==
'''PATH''': da inserire
== una scatola nera laccata trasportata da il Drago di Ottone ==
'''PATH''': Drago policromatico quest Drow
== una scatola nera laccata trasportata da Il Drow Lich ==
'''PATH''': dalla pool blu mezzanotte (fiume delle anime perdute, unww) 3e2sesed - aspettare teleport - d;pull naso;d;open ecorc;ds - castarsi wb o swimmare e aspettare doppia teleport, finché non esce un'uscita down - d4s2ws si arriva a Un isolotto - dig tomba - d - segare spettro immu fisici - knock south oppure chiave-antica dello spettro - s (è immu cold, resi magici)
== una scatola nera laccata trasportata da Dugan il capofabbro ==
'''PATH''': mob della quest BoscoVerde
== una scatola nera laccata trasportata da Efesto ==
'''PATH''': Pool Grecia (.unwwnwu), .ws2w7nuneueuwu2e3de; push muro; ad east c'e' spia (hide) che ha punteruolo.
Con la chiave: west;down;unlock lastrone;lift lastrone;.2ed
== una scatola nera laccata trasportata da Elminster ==
'''PATH''': miniquest "Elminster". Si prende la chiave d'ombra da una delle 4 ombre guardiane hide tra la foresta di Rhowyn e Vingaard e poi si va da Elmi dove è sempre stato 
== una scatola nera laccata dentro un enorme forziere nero ==
'''PATH''': forziere finale quest Rhyodin
== una scatola nera laccata trasportata da Epheros l'angelo in disgrazia ==
'''PATH''': mob intermedio quest Tarrasque
== una scatola nera laccata dentro un espositore di vetro ==
'''PATH''': Villa di Kelepho
== una scatola nera laccata trasportata da Ethergaunt bianco ==
'''PATH''': Boss finale quest Dimora degli Incubi
== una scatola nera laccata trasportata da Eucropio ==
'''PATH''': mob finale quest Ancalador
== una scatola nera laccata trasportata da la Fede Cieca ==
'''PATH''': mob di Celestia del sesto girone
== una scatola nera laccata dentro una fonte mistica ==
'''PATH''': premio finale della quest Giardini Infiniti
== una scatola nera laccata dentro un forziere dei Premi ==
'''PATH''': Forziere finale della quest Polipo
== una scatola nera laccata dentro un forziere di legno ==
'''PATH''': forziere che si trova dentro la cassaforte nella dimora di Redferne ( chiave ce l'hanno Redferne e Naonyel )
== una scatola nera laccata dentro un forziere di ottone ==
'''PATH''': forziere sotto Aziz mob intermedio della quest Tarrasque
== una scatola nera laccata dentro il forziere del tempo ==
'''PATH''': forziere finale quest Vate del Caos
== una scatola nera laccata trasportata da Frosty ==
'''PATH''': dalla piazza di Talonia: 6n;open porta n;7ne10ne3ne5ne7nw3n6e5n2
== una scatola nera laccata trasportata da la Guardiana del Magazzino ==
'''PATH''': quest Ennaheg
== una scatola nera laccata trasportata da Genbu, il generale dell'esercito nero ==
'''PATH''': campi di battaglia sotto quest Regni
== una scatola nera laccata trasportata da Sir Ghalad ==
'''PATH''': Si trova ad Abyss. A west della seconda coppia di guerrieri nel corridoio a L (key pulsante). Ghalad sta 2wn in una cella (key macerie, da scavare). Attenzione che decapita senza pietà al primo bash cannato.
== una scatola nera laccata trasportata da Gog il Milleanime ==
'''PATH''': Si trova a Rhyodin. Dalla sala stravagante prendere chiave nello scrittoio. Quindi west e aprire a sud. Secret down key "anima" dopo teleport aprire a nord e li si trova Gog. E' un wa che menicchia e prende fireshield. In 2 si fa abbastanza agile
== una scatola nera laccata trasportata da Grenl ==
'''PATH''': mob della quest Cittadella
== una scatola nera laccata trasportata da Gritz la strega ==
'''PATH''': mob nella stessa room di Heli alla quest Ravenloft
== una scatola nera laccata trasportata da il Guardiano delle Armature ==
'''PATH''': Mob dentro Ennaheg
== una scatola nera laccata trasportata da il Guardiano delle Armi ==
'''PATH''': Mob dentro Ennaheg
== una scatola nera laccata trasportata da Gulthias ==
'''PATH''': Boss finale quest Cittadella
== una scatola nera laccata trasportata da Gut'la Has il Re dei Tiefling ==
'''PATH''': mob intermedio quest BoscoVerde
== una scatola nera laccata trasportata da Heli la fatucchiera ==
'''PATH''': mob intermedio quest Raven
== una scatola nera laccata trasportata da Hoeur ==
'''PATH''': a piedi: da Alma Civitas a spaventapasseri: .s10ws9w3n9w6s8w5s3ws poi da spaventapasseri: .n3e5n4e2s3w4sd
'''PATH''': con portal: portalare spaventapasseri (se Hoeur non c'e') poi .n3e5n4e2s3w4sd. 
== una scatola nera laccata trasportata da l'Incarnazione della Malvagita' (Stremadil) ==
'''PATH''': mob intermedio della quest El Quebbar
== una scatola nera laccata trasportata da Infirana ==
'''PATH''': Boss finale omonima Quest
== una scatola nera laccata trasportata da Inverno == 
'''PATH''': dalla piazza di Talonia: 6n;open porta n;7ne10ne3ne5ne7nw3n6e5nw
== una scatola nera laccata trasportata da Jeenyas ==
'''PATH''': mob della quest Sottomondo di Zodak
== una scatola nera laccata trasportata da Kalas ==
'''PATH''': mob intermedio della quest Abyss
== una scatola nera laccata trasportata da Kirin, il generale dell'esercito dei mercenari ==
'''PATH''': campi di battaglia sotto quest Regni
== una scatola nera laccata trasportata da La locusta regina ==
'''PATH''': boss finale della quest Locuste
== una scatola nera laccata trasportata da Magma ==
'''PATH''': dalla pool per Plutarco...
== una scatola nera laccata trasportata da La matrice abissale ==
'''PATH''': dalla pool per Plutarco est, nord ... si aspetta teleport, si killa. è wa sega e prende iceshield.
== una scatola nera laccata trasportata da Maya ==
'''PATH''': mob intermedio di El Quebbar
== una scatola nera laccata trasportata da Malinda ==
'''PATH''': mob intermedio di Ancadalor
== una scatola nera laccata trasportata da Melibis il fondatore della setta ==
'''PATH''': uno dei due mob finali della quest Polipo
== una scatola nera laccata trasportata da Milbolas, il primo console di Mordilnia ==
'''PATH''': mob intermedio della quest Polipo
== una scatola nera laccata trasportata da Mordenkainen il Negromante == 
'''PATH''': dalla pool oro (torre della magia, unwn) 2n2ed3s;open east;e2n sta con altri mob pippa, l'importante e' basharlo per non beccarsi un inutile disint ...
== una scatola nera laccata trasportata da Nadir ==
'''PATH''': mob della quest Sottomondo di Zodak
== una scatola nera laccata trasportata da NERO ==
'''PATH''': sotto il tribunale, mob intermedio della quest Polipo
== una scatola nera laccata trasportata da Nelle cantine ==
'''PATH''': DA SCOPRIRE 
== una scatola nera laccata trasportata da Nug ==
'''PATH''': si trova nella room La tana del Capro Nero che si trova nel Boschetto accanto l'ingresso di Dunwich verso est
== una scatola nera laccata trasportata da Nyarlathotep ==
'''PATH''': Boss finale quest Dunwich
== una scatola nera laccata trasportata da Osborne l'oste ==
'''PATH''': mob della quest Dunwich
== una scatola nera laccata trasportata da Paz'Rael il Signore dei Vrock == 
'''PATH''': penultimo mob della quest Oltre il Portale
== una scatola nera laccata trasportata da Periast il fondatore della setta ==
'''PATH''': uno dei due mob finali della quest Polipo
== una scatola nera laccata trasportata da Un Phaerimm == 
'''PATH''': mob della quest BoscoVerde
== una scatola nera laccata trasportata da Poseidone ==
'''PATH''': da pool verde smeraldo (Grecia, unwwnuw) nnwnn - swim o wb - ddenensue
== una scatola nera laccata trasportata da Il Primo Albero ==
'''PATH''': Da Alma Civitas: .8s2e2s2ws2es2w3se
== una scatola nera laccata trasportata da Il Primo Mandragora ==
'''PATH''': (a piedi) da Alma Civitas 10ne3nw5nw3nw;lift grata;4n (Alpes Oppidum) w2nesu2nue (da qui attenti alle private) d2es2en;turn girevole;2nwn2d2ndn2enen;open tela (qui veloci per non farsi beccare da Pietro il Ragno che paralizza d'arma) n;open libricino;d - aspettare teleport lunga - turn pagina;e;open diamante;e;bash spettro (se non ricordo male la key esatta è spettro, ma è da controllare ... comunque è spettro o spirito)
'''PATH''': (via astral) pool marrone (Drow, unwwn) _chilosaloscrive_
== una scatola nera laccata dentro il pungiglione dello scorpione gigante ==
'''PATH''': ???
== una scatola nera laccata trasportata da Pursan il possente ==
'''PATH''': mob intermedio della quest Dimora degli Incubi
== una scatola nera laccata trasportata da Quivalen Sath ==
'''PATH''': dal Alma Civitas .8s2e2s2enwn
== una scatola nera laccata trasportata da Rampicante vampiro ==
'''PATH''': mob intermedio della quest Giardini infiniti
== una scatola nera laccata trasportata da il Re ==
'''PATH''': Mob della Sala del trono di una delle 4 torri di Regni
== una scatola nera laccata trasportata da il Re Fantasma ==
'''PATH''': Boss finale di Rhyodin
== una scatola nera laccata trasportata da la Regina ==
'''PATH''': Mob della sala del trono di una delle 4 torri di Regni
== una scatola nera laccata trasportata da la Regina bianca ==
'''PATH''': Dal secondo piamo della libreria push pulsante, west, ent portale, ope parete, we, ent shadowdale, do, ent scacchiera. Da li muoversi tutto sud e la si trova tra il Re ed il Vescovo. Scacchiera
== una scatola nera laccata trasportata da la Regina nera ==
'''PATH''': Dal secondo piamo della libreria push pulsante, west, ent portale, ope parete, we, ent shadowdale, do, ent scacchiera. Da li muoversi tutto nord e la si trova tra il Re ed il Vescovo. Scacchiera
== una scatola nera laccata trasportata da Remiel l'Arcilich ==
'''PATH''': mob intermedio quest Infirana
== una scatola laccata dentro il ricordo del Paladino che fu
'''PATCH''': Room Finale quest LORD SOTH ---&gt; Turn scheggia -- Down
== una scatola nera laccata trasportata da Il leggendario Roc == 
'''PATH''': da Alma Civitas 10ne3nw5nw3nw;lift grata;4n (Alpes Oppidum) w2nesu2nued2es2e3se; pick south;s; pull arazzo;s;lift scala;u;dig spazzatura;nu4ndnn; lo troviamo a west ... va bashato fisso in quanto ha procedura speciale
== una scatola nera laccata trasportata da Sacrifice, la regina squalo ==
'''PATH''': mob intermedio della quest Dimora degli Incubi
== una scatola nera laccata trasportata da Santo del Fiume ==
'''PATH''': Chi lo sa lo posti ...
== una scatola nera laccata dentro un sarcofago d'oro ==
'''PATH''': Sarcofago di Abyss , accanto room di Arawn e Abisso
== una scatola nera laccata dentro un sarcofago nero ==
'''PATH''': Nella tomba nascosta del Generale a Rhyodin
== una scatola nera laccata trasportata da Scaglia Notturna == 
'''PATH''': mob finale (finto drago) della quest Khundrukar
== una scatola nera laccata trasportata da Sciamano Aborigeno ==
'''PATH''': dalla pool verde scuro (Roo, unwwnuwuw) run w; run s; 2w5s2wse
oppure dalla piazza di Talonia run s; d; sss; wsswwsssssssswwsee
== una scatola nera laccata dentro uno scrigno antico ==
'''PATH''': quest BoscoVerde (ha anche i cofanetti smeraldi, rubini e zaffiri)
== una scatola nera laccata trasportata da Seiryu, il generale dell'esercito azzurro ==
'''PATH''': campi di battaglia sotto quest Regni
'''Trovati''': per ora nessuno
== una scatola nera laccata trasportata da Siemel ==
'''PATH''': mob intermedio della quest El Quebbar
'''Trovati''': per ora nessuno
== una scatola nera laccata trasportata da Signora della Magia ==
'''PATH''': mob finale di Torre Magia
'''Trovati''': per ora nessuno
== una scatola nera laccata trasportata da Sin ==
'''PATH''': mob intermedio della quest Dimora degli Incubi
'''Trovati''': per ora nessuno
== una scatola nera laccata trasportata da Sommo Chierico ==
'''PATH''': mob di Vingaard
'''Trovati''': un lingotto d''''acciaio'''
== una scatola nera laccata trasportata da Lord Soth ==
'''PATH''': mob finale quest Lord Soth
'''Trovati''': per ora nessuno
== una scatola nera laccata trasportata da Lo Spirito di Huma ==
'''PATH''':  mob di Vingaard
'''Trovati''': un lingotto d''''argento'''
== una scatola nera laccata trasportata da La Statua di Benem == 
'''PATH''': Museo dei patroni a Talonia
'''Trovati''': un lingotto di '''ottone'''
== una scatola nera laccata trasportata da La statua di Limean ==
'''PATH''': da Piazza dell'Occhio ad Allania west sud
'''Trovati''': un lingotto di '''oricalco''' (a volte), un frammento di '''oricalco''' (fisso)
== una scatola nera laccata trasportata da La statua di Kazzuya ==
'''PATH''': Tempio dei dannati
'''Trovati''': un lingotto di '''ebanite''', un lingotto d''''acciaio'''
== una scatola nera laccata trasportata da La statua di Maabrash ==
'''PATH''': Tempio dei dannati
'''Trovati''': un lingotto di '''adamantio''', un lingotto d''''acciaio'''
== una scatola nera laccata trasportata da La Statua di Turambar ==
'''PATH''': Museo dei patroni a Talonia
'''Trovati''': un lingotto di '''mithril''' (a volte) , un frammento di '''mithril''' (fisso)
== una scatola nera laccata trasportata da Stohned, il Re ==
'''PATH''': da Platea Quadrata 9e3n4es2e2d2sen2d2swse2nw - uccidere Sandslab e prendergli chiave - e; pick east; e; unlock north;n;bash stoh
'''Trovati''': un lingotto di '''rame''', un lingotto di '''ferro''', un lingotto di '''ottone'''
== una scatola nera laccata trasportata da Suzaku, il generale dell'esercito rosso ==
'''PATH''': campi di battaglia sotto quest Regni
'''Trovati''': per ora nessuno
== una scatola nera laccata trasportata da Uey-Tlatoani ==
'''PATH''': mob di Eldorado Mappa EldoradoIngressi Eldo
'''Trovati''': una pietra '''runica''', un lingotto d''''oro''', un lingotto di '''platino'''
== una scatola nera laccata trasportata da la veggente ==
'''PATH''': mob intermedio della quest Villa delle feste
'''Trovati''': per ora nessuno
== una scatola nera laccata trasportata da Xibalba' ==
'''PATH''': mob di Eldorado Mappa Eldorado Ingressi Eldo
'''Trovati''': un lingotto d''''acciaio'''
== una scatola nera laccata trasportata da Xues Var ==
'''PATH''': Drago acido quest Drow
== una scatola nera laccata trasportata da Ymir ==
'''PATH''': cercasi volontario per scriverla...
== una scatola nera laccata trasportata da Zenith ==
'''PATH''': mob della quest Sottomondo di Zodak
== una scatola nera laccata trasportata da Erky Timbers ==
'''PATH''': Mob intermedio quest Cittadella
== una scatola nera laccata trasportata da Glasya, duchessa infernale ==
'''PATH''': Mob intermedio quest Dimora degli incubi
== una scatola nera laccata in Il ricordo del Paladino che fu ==
'''PATH''': Segreto down di Lord Soth, si apre con TURN SCHEGGIA e si trova anche la Spada Sacra (slash only-pa RARA 2d8 -2hit&amp;dam slay neutral) Sithicus
]]</script>
				<command></command>
				<packageName></packageName>
				<regex></regex>
			</AliasGroup>
			<Alias isActive="yes" isFolder="no">
				<name>Specchio bianco latte, Alma</name>
				<script>local path = {
  "astral",
  ".n;es",
}
ui.fExecutePath(path, matches[2])</script>
				<command></command>
				<packageName></packageName>
				<regex>^(?i)(?:biancolatte|alma)(?:\s+(.*))?$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>Specchio blu mezzanotte, Anime perdute</name>
				<script>local path = {
  "astral",
  ".un2w;es",
}
ui.fExecutePath(path, matches[2])</script>
				<command></command>
				<packageName></packageName>
				<regex>^(?i)blumezzanotte|animeperdute(?:\s+(.*))?$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>Specchio cangiante, Colosseo</name>
				<script>local path = {
  "astral",
  ".unw;es",
}
ui.fExecutePath(path, matches[2])</script>
				<command></command>
				<packageName></packageName>
				<regex>^(?i)cangiante|colosseo(?:\s+(.*))?$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>Specchio giallo e verde, Necrofagi</name>
				<script>local path = {
  "astral",
  ".un2wnue;es",
}
ui.fExecutePath(path, matches[2])</script>
				<command></command>
				<packageName></packageName>
				<regex>^(?i)gialloeverde|necrofagi(?:\s+(.*))?$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>Specchio granito, Mani</name>
				<script>local path = {
  "astral",
  ".un2w2n;es",
}
ui.fExecutePath(path, matches[2])</script>
				<command></command>
				<packageName></packageName>
				<regex>^(?i)granito|nani(?:\s+(.*))?$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>Specchio grigio, Abisso, Manticore</name>
				<script>local path = {
  "astral",
  ".un2wnuw2u;es",
}
ui.fExecutePath(path, matches[2])</script>
				<command></command>
				<packageName></packageName>
				<regex>^(?i)(?:grigio|abisso|manticore)(?:\s+(.*))?$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>Specchio grigio fumo, Drow</name>
				<script>local path = {
  "astral",
  ".un2wn;es",
}
ui.fExecutePath(path, matches[2])</script>
				<command></command>
				<packageName></packageName>
				<regex>^(?i)(?:grigiofumo|drow)(?:\s+(.*))?$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>Specchio grigio palude, Orshingal, Enfan</name>
				<script>local path = {
  "astral",
  ".une;es",
}
ui.fExecutePath(path, matches[2])</script>
				<command></command>
				<packageName></packageName>
				<regex>^(?i)(?:grigiopalude|orshingal|enfan)(?:\s+(.*))?$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>Specchio grigio scuro, Moria</name>
				<script>local path = {
  "astral",
  ".un2ws;es",
}
ui.fExecutePath(path, matches[2])</script>
				<command></command>
				<packageName></packageName>
				<regex>^(?i)grigioscuro|moria(?:\s+(.*))?$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>Specchio marrone sporco, Lycantropia</name>
				<script>local path = {
  "astral",
  ".un2wnuwun;es",
}
ui.fExecutePath(path, matches[2])</script>
				<command></command>
				<packageName></packageName>
				<regex>^(?i)marronesporco|lycantropia(?:\s+(.*))?$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>Specchio oro, torre, Torremagia</name>
				<script>local path = {
  "astral",
  ".unwn;es",
  ".nneedsssswwwwnnnneeeedssssws"
}
ui.fExecutePath(path, matches[2])</script>
				<command></command>
				<packageName></packageName>
				<regex>^(?i)oro|torremagia(?:\s+(.*))?$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>Specchio rosso bruciato, Old Thalos, Lamie</name>
				<script>local path = {
  "astral",
  ".un2wne;es",
}
ui.fExecutePath(path, matches[2])</script>
				<command></command>
				<packageName></packageName>
				<regex>^(?i)(?:rossobruciato|oldthalos|thalos|lamie)(?:\s+(.*))?$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>Specchio turchese, Deserto, Oasi</name>
				<script>local path = {
  "astral",
  ".un2wnuwus;es",
}
ui.fExecutePath(path, matches[2])</script>
				<command></command>
				<packageName></packageName>
				<regex>^(?i)(?:turchese|deserto|oasi)(?:\s+(.*))?$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>Specchio verde erba, Syracusa</name>
				<script>local path = {
  "astral",
  ".un2wnu;es",
}
ui.fExecutePath(path, matches[2])</script>
				<command></command>
				<packageName></packageName>
				<regex>^(?i)verdeerba|syracusa(?:\s+(.*))?$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>Specchio verde foresta, Barriera, Pilastri</name>
				<script>local path = {
  "astral",
  ".unwwnuwuuwds;es",
}
ui.fExecutePath(path, matches[2])</script>
				<command></command>
				<packageName></packageName>
				<regex>^(?i)(?:verdeforesta|barriera|pilastri)(?:\s+(.*))?$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>Specchio verde scuro, Roo, Aborigeni</name>
				<script>local path = {
  "astral",
  ".un2wnuwuw;es",
}
ui.fExecutePath(path, matches[2])</script>
				<command></command>
				<packageName></packageName>
				<regex>^(?i)(?:verdescuro|roo|aborigeni)(?:\s+(.*))?$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>Specchio verde smeraldo, Grecia</name>
				<script>local path = {
  "astral",
  ".un2wnuw;es",
}
ui.fExecutePath(path, matches[2])</script>
				<command></command>
				<packageName></packageName>
				<regex>^(?i)verdesmeraldo|grecia(?:\s+(.*))?$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>Allania</name>
				<script>local path = {
  "astral",
  ".unwwnuwuuwd4s4wdd",
}
ui.fExecutePath(path, matches[2])</script>
				<command></command>
				<packageName></packageName>
				<regex>^(?i)allania(?:\s+(.*))?$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>Allania (uscita)</name>
				<script>local path = {
  ".wssse;enter portale",
}
ui.fExecutePath(path, matches[2])</script>
				<command></command>
				<packageName></packageName>
				<regex>^(?i)exitallania(?:\s+(.*))?$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>Anaconda</name>
				<script>local path = {
  "dw alma",
  ".wdws;run e;.n2e3s7e",
}
ui.fExecutePath(path, matches[2])</script>
				<command></command>
				<packageName></packageName>
				<regex>^(?i)anaconda(?:\s+(.*))?$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>Banca Alma</name>
				<script>local path = {
  "dw alma",
  ".wdwseees",
}
ui.fExecutePath(path, matches[2])</script>
				<command></command>
				<packageName></packageName>
				<regex>^(?i)banca(?:\s+(.*))?$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>Camelot</name>
				<script>local path = {
  "astral",
  "n;ent spe;.nu;",
  "push pulsante;",
  "w;ent portale;op parete;.2w",
  ".see;bl sace",
  "get chiave cad;.wwn;op w;.wd;bl costrutto",
  "get simbolo cad;op porta s;s;ent portale",
}
ui.fExecutePath(path, matches[2])</script>
				<command></command>
				<packageName></packageName>
				<regex>^(?i)camelot(?:\s+(.*))?$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>Ennaheg</name>
				<script>local path = {
  "astral",
  ".unwwnuwuu;es;.edddnneeesdn",
}
ui.fExecutePath(path, matches[2])</script>
				<command></command>
				<packageName></packageName>
				<regex>^(?i)ennaheg(?:\s+(.*))?$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>Giganti di Montagna</name>
				<script>local path = {
  "dw orsetto",
  ".eeenwnuneddudu",
}
ui.fExecutePath(path, matches[2])</script>
				<command></command>
				<packageName></packageName>
				<regex>^(?i)gigantimontagna(?:\s+(.*))?$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>Giganti del Ghiaccio</name>
				<script>local path = {
  "astral",
  ".n;es;.nu;",
  "push pulsante",
  ".w;ent portale;open parete;.ww;ent shadowdale;.d;run n;op crepa;.n2esdn2e2n",
}
ui.fExecutePath(path, matches[2])</script>
				<command></command>
				<packageName></packageName>
				<regex>^(?i)gigantighiaccio(?:\s+(.*))?$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>Gilda Lame</name>
				<script>local path = {
  "dw cacciatore-_ask",
  ".s2e3ne",
}
ui.fExecutePath(path, matches[2])</script>
				<command></command>
				<packageName></packageName>
				<regex>^(?i)lame(?:\s+(.*))?$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>Magione</name>
				<script>local path = {
  "astral",
  ".n;es;.2se2s;run e;.nnwwwnwnn"
}
ui.fExecutePath(path, matches[2])</script>
				<command></command>
				<packageName></packageName>
				<regex>^(?i)magione(?:\s+(.*))?$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>Olimpo</name>
				<script>local path = {
  "astral",
  ".unwwnuw;es;.6en2u",
}
ui.fExecutePath(path, matches[2])</script>
				<command></command>
				<packageName></packageName>
				<regex>^(?i)olimpo(?:\s+(.*))?$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>Pennina</name>
				<script>local path = {
  "dw flaminio",
  ".s4es2e2de2u2nuse2nwu",
  ".nwnw4nen;pick porta e;op porta e;e;bu",
}
ui.fExecutePath(path, matches[2])</script>
				<command></command>
				<packageName></packageName>
				<regex>^(?i)pennina(?:\s+(.*))?$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>Piattaforma accademia</name>
				<script>local path = {
  "dw velestra",
}
ui.fExecutePath(path, matches[2])</script>
				<command></command>
				<packageName></packageName>
				<regex>^(?i)accademia(?:\s+(.*))?$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>Plutarco</name>
				<script>local path = {
  "astral",
  ".un2wnuw2u;ent spe;.edddnneeeuu",
  "push masso",
  ".eenesddww",
}
ui.fExecutePath(path, matches[2])</script>
				<command></command>
				<packageName></packageName>
				<regex>^(?i)plutarco(?:\s+(.*))?$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>Scacchiera</name>
				<script>local path = {
  "astral",
  ".n;es;.nu;",
  "push pulsante",
  ".w;ent portale;open parete;.ww;ent shadowdale;.dd;ent scacchiera",
}
ui.fExecutePath(path, matches[2])</script>
				<command></command>
				<packageName></packageName>
				<regex>^(?i)scacchiera(?:\s+(.*))?$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>Spaventapasseri</name>
				<script>local path = {
  "dw alma",
  ".wdws10ws9w3n9w6s8w5s3ws",
}
ui.fExecutePath(path, matches[2])</script>
				<command></command>
				<packageName></packageName>
				<regex>^(?i)spaventa|spaventapasseri(?:\s+(.*))?$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>Tesoro Re Greylin</name>
				<script>send("get chiave re")
send("tira tenda")
expandAlias("w")
send("unlock forziere")
send("open forziere")
send("get all forziere")
send("don fenice")
</script>
				<command></command>
				<packageName></packageName>
				<regex>^(greylin)$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>Tesoro Re Shik</name>
				<script>expandAlias("get chia shik")
expandAlias("tira arazzo")
expandAlias("s")
expandAlias("get ninnoli")
expandAlias("unlock cassa")
expandAlias("open cassa")
expandAlias("get monete cassa")</script>
				<command></command>
				<packageName></packageName>
				<regex>^(shik)$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>Scatole Nere</name>
				<script>local path = {
  "dw gitana-_ask",
  ".w2s;ask vecchietto ingredienti",
}
ui.fExecutePath(path, matches[2])</script>
				<command></command>
				<packageName></packageName>
				<regex>^(?i)scatole(?:\s+(.*))?$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>Deadhame</name>
				<script>local path = {
  "astral",
  ".n;es;.nu;",
  "push pulsante",
  ".w;ent portale;open parete;.ww;ent shadowdale;.de",
}
ui.fExecutePath(path, matches[2])</script>
				<command></command>
				<packageName></packageName>
				<regex>^(?i)deadhame(?:\s+(.*))?$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>Thor</name>
				<script>local path = {
  "dw topo-deserto;.3n5e3ued2e",
  "get chiave cad;op fessura;.e;op stalagmite;.n",
  "say raido",
}
ui.fExecutePath(path, matches[2])</script>
				<command></command>
				<packageName></packageName>
				<regex>^(?i)thor(?:\s+(.*))?$</regex>
			</Alias>
		</AliasGroup>
		<AliasGroup isActive="yes" isFolder="yes">
			<name>Quests</name>
			<script></script>
			<command></command>
			<packageName></packageName>
			<regex></regex>
			<Alias isActive="yes" isFolder="no">
				<name>Ancalador</name>
				<script>local path = {
  "portal turista;",
  "run w;",
  "op porta w;run w;",
  ".6essueessess5edd7e;bl guardiano-pietrificato",
  "ga cad;op portone e;e;op fessura;.seds;bl necromante",
  "get chiave cadavere;.ue;bu",
  "ga cad;.wwd;op portone w;w;bl malinda",
  "get chiave cadavere;op grata;d;op cancello d",
  "ga cadavere;.uuenun;",
}
ui.fExecutePath(path, matches[2])</script>
				<command></command>
				<packageName></packageName>
				<regex>^(?i)ancalador(?:\s+(.*))?$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>Cattedrale - Dama Morte</name>
				<script>local path = {
  "dw 11.saggio",
  "run w;run n;.w;enter vegetazione;open cancellata n;.n", -- cercare glifo su mob hide
  ".needswwses",
  "get chiave cad;unlock tessera;push tessera;.sesesws",
  ".5d;unlock schermo;push schermo",
  ".d;aa",
}
ui.fExecutePath(path, matches[2])</script>
				<command></command>
				<packageName></packageName>
				<regex>^(?i)dama(?:\s+(.*))?$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>Elminster</name>
				<script>local path = {
  "portal frank",
  ".4ennwnne;op n",
  ".n",
}
ui.fExecutePath(path, matches[2])</script>
				<command></command>
				<packageName></packageName>
				<regex>^(?i)elminster(?:\s+(.*))?$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>Infirama</name>
				<script>-- Necessita di atrezzi da scasso e pergamena trasucida in borsa per disarmare trapola al passo 5
local path = {
  "dw ironhome",  --&gt; cercare e psizionarsi su "La strada principale" e poi proseguire con passo 2
  "run s;.ddwwun;bl kedar;",
  "ga cad;op forziere;ga forziere;.dseeuueeusuuws;op porta s;.4swwn;bl gram;",
  "ga cad;.swsdw;op porta w;w;bl butc",
  "ga cad;ga;.eeueuess;op portone s;.ssesww;gg traslucida;tt traslucida;reci pergamena;gg scasso;tt scasso;use scasso rune;rr scasso;pp scasso;u;turn braccio;w;bl kru;",
  "ga cad;ga 2.cad;ga 3.cad;push pulsante;s;op baule;ga baule;.ned;op porta s;s;bu",
  "ga cad;ga 2.cad;op porta e;e;bl remi",
  "ga cad;op scrigno;get dente scrigno;.wneenw4nene;op porta e",
  "e;", --&gt; attendere telport
  "bu", --&gt; drago piccolo da stanare
  "n",  --&gt; infirana
  "ga cad;ga;op portale;.2e", --&gt; uscita
}
ui.fExecutePath(path, matches[2])</script>
				<command></command>
				<packageName></packageName>
				<regex>^(?i)infirama(?:\s+(.*))?$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>Locuste</name>
				<script>local path = {
  "astral",
  ".unwwnu;es;.eswwssed",
  ".dn;unlock grata;open grata;.nuue;run d ",
  "...da finire..."
}
ui.fExecutePath(path, matches[2])
--[[
Andate a Syracusa.
Astral
.unwwnu
enter specchio
.eswwssed
Cercate le Murene (partono hide) e killatele fino a trovare quella con la Testa di un pesce con dentro la chiave arruginita che da diritto alla quest.
Cercate la Grata, che dopo il primo Down si troverà a
.dn
unlock grata 
.nuue
run d 
Spostatevi sull'asse west, killate Aharnikx, Miirnihkx e gettate la chiave dal cadavere.
.wuusswss
disarm botola 
.w
Killate lo Sciamano, Guardiano e gettate la chiave dal cadavre.
unlock porta n
open porta n
Tirare lo Stregone e pulire a nord gli eventuali mobbetti ('Servi e Accoliti).
.n
Killate le 4 Monache, il Sacerdote e gettare la chiave dal cadavere.
unlock n
Pulire verso nord' eventuali Servi e Accoliti e da Altare delle Locuste
.3n
unlock east
open east
.e
Killate Uomo, Regina e gettate le 2 chiavi dal cadavere.
unlock forno
open forno
get all forno
.w3s
unlock lucchetto
open lucchetto
.d
Killate Ombra e gettate i premi dalla Cesta.
.u
astral
]]</script>
				<command></command>
				<packageName></packageName>
				<regex>^(?i)locuste(?:\s+(.*))?$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>Oltre il portale</name>
				<script>local path = {
  "dw Paktos",
  ".3n;pick chiavistello;open chiavistello;.w;",
  "spingi sarcofago;",
  ".2d2se2s2e;dig terra;.s;dig terra;.s;open portale;.w",
  "op barriera;enter barriera;",
  ".n2en8e",
  "ga molydeus;.8w2nw;",
  "op n;.2n",
}
ui.fExecutePath(path, matches[2])
</script>
				<command></command>
				<packageName></packageName>
				<regex>^(?i)oltre(?:\s+(.*))?$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>Tempio dannati</name>
				<script>local path = {
  "dw cane-famelico;.ues2ne4dnw4n",
}
ui.fExecutePath(path, matches[2])</script>
				<command></command>
				<packageName></packageName>
				<regex>^(?i)tempiodannati(?:\s+(.*))?$</regex>
			</Alias>
		</AliasGroup>
		<AliasGroup isActive="yes" isFolder="yes">
			<name>Varie</name>
			<script></script>
			<command></command>
			<packageName></packageName>
			<regex></regex>
			<Alias isActive="yes" isFolder="no">
				<name>Attacco automatico</name>
				<script>local opt = matches[2] or ""
if (opt == "+") then
  ui.parameters.autoAttack = true;
elseif (opt == "-") then
  ui.parameters.autoAttack = false;
elseif (opt == "a") then
  ui.parameters.autoAttackArea = true;
elseif (opt == "s") then
  ui.parameters.autoAttackArea = false;
else
  ui.variables.attackFirstMob = true; -- Attiva attacco primo mob in stanza
  send("info mobiles")                -- Farà scattare trigger per ricerap 1° mob e attacca
end
--
opt = "autoAttack ";
if ui.parameters.autoAttack then
  opt = opt.."&lt;green&gt;ON "
  if ui.parameters.autoAttackArea then
    opt = opt.."&lt;red&gt;(AREA)"
  else
    opt = opt.."&lt;orange&gt;(SINGLE)"
  end  
else
  opt = opt.."&lt;red&gt;OFF"
end
ui.fEcho2n(opt)  
</script>
				<command></command>
				<packageName></packageName>
				<regex>^aa([\+\-as])?$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>Esecuzione codice LUA da prompt comandi</name>
				<script>local f, e = loadstring("return "..matches[2])
--
if not f then
  f, e = assert(loadstring(matches[2]))
end
--
local r = function(...)
            if not table.is_empty({...}) then
              display(...)
            end
          end
--
r(f())</script>
				<command></command>
				<packageName></packageName>
				<regex>^lua (.*)$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>Explorer</name>
				<script>local dirTo = ""
local dirFrom = "";
--
if (ui.path[ui.idxPath]) then
  dirFrom = ui.dirReverse[ui.path[ui.idxPath]]
end
--
if (dirFrom == "e") then
  if (table.contains(ui.exits, "s")) then dirTo = "s"
  elseif (table.contains(ui.exits, "w")) then dirTo = "w"
  elseif (table.contains(ui.exits, "n")) then dirTo = "n"
  else dirTo = "e"
  end
elseif (dirFrom == "s") then
  if (table.contains(ui.exits, "w")) then dirTo = "w"
  elseif (table.contains(ui.exits, "n")) then dirTo = "n"
  elseif (table.contains(ui.exits, "e")) then dirTo = "e"
  else dirTo = "s"
  end
elseif (dirFrom == "w") then
  if (table.contains(ui.exits, "n")) then dirTo = "n"
  elseif (table.contains(ui.exits, "e")) then dirTo = "e"
  elseif (table.contains(ui.exits, "s")) then dirTo = "s"
  else dirTo = "w"
  end
else
  if (table.contains(ui.exits, "e")) then dirTo = "e"
  elseif (table.contains(ui.exits, "s")) then dirTo = "s"
  elseif (table.contains(ui.exits, "w")) then dirTo = "w"
  else dirTo = "n"
  end
end
-- echo("Arrivi da "..ui.dirToken[dirFrom].." e vai verso "..ui.dirToken[dirTo]..".")
expandAlias(dirTo)</script>
				<command></command>
				<packageName></packageName>
				<regex>^ee$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>Moltiplicatore di comandi</name>
				<script>local rpt = matches[2]
local command = matches[3]
local commands, varNameError = ui.fExpandVariables(command)
--
if (not varNameError) then
  local commands = ui.fExpandCommand(command);
  for i = 1, rpt do
    for _, command in ipairs(commands) do
      command = ui.fExpandVariables(command)
      expandAlias(command)
    end
  end
end</script>
				<command></command>
				<packageName></packageName>
				<regex>^(\d+)\*\s*(.*)</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>UI Repair</name>
				<script>local f = matches[2] or "fabbro"
local n = 0
--
for key, equipment in pairs(ui.equipment) do
  if (equipment.statusColor ~= "&lt;128,128,128:30,24,24&gt;") and
     (equipment.statusColor ~= "&lt;255,255,255:30,24,24&gt;") then
    send("remove "..equipment.number, false)
    send("give - "..f, false)
    if (equipment.location == "&lt;192,192,192:30,24,24&gt;impugnato&lt;r&gt;") then
      send("wi -", false)
    else
      send("wear -", false)
    end
    n = n + 1
  end
end
--
if (n==0) then
  ui.fEcho2n("Non hai nulla da riparare. Usare il comando "..ui.fGetCommandFormattedText("eq").." per aggiornare il tuo equipaggiamento.")
end</script>
				<command></command>
				<packageName></packageName>
				<regex>^(?i)(?:uirep(?:a(?:i(?:r?)?)?)?)(?:\s+(.*))?$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>Multi Loot</name>
				<script>ui.getAllCadNum = 1;
send("get all "..ui.getAllCadNum..".cad")
</script>
				<command></command>
				<packageName></packageName>
				<regex>^ll$</regex>
			</Alias>
		</AliasGroup>
		<AliasGroup isActive="yes" isFolder="yes">
			<name>generic_mapper</name>
			<script></script>
			<command></command>
			<packageName>generic_mapper</packageName>
			<regex></regex>
			<AliasGroup isActive="yes" isFolder="yes">
				<name>Setup Aliases</name>
				<script></script>
				<command></command>
				<packageName></packageName>
				<regex></regex>
				<Alias isActive="yes" isFolder="no">
					<name>Map Show Alias</name>
					<script>map.showMap()</script>
					<command></command>
					<packageName></packageName>
					<regex>^map show$</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>Find Map Prompt Alias</name>
					<script>map.find_prompt()</script>
					<command></command>
					<packageName></packageName>
					<regex>^find prompt$</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>Set Map Prompt Alias</name>
					<script>-- USE PATTERNS FOR STRING.GSUB
if matches[2] then
  map.make_prompt_pattern(matches[2])
else
  display(map.save.prompt_pattern)
end</script>
					<command></command>
					<packageName></packageName>
					<regex>^map prompt(?: (.*))?$</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>Set Map Ignore Alias</name>
					<script>-- USE PATTERNS FOR STRING.GSUB
if matches[2] then
  map.make_ignore_pattern(matches[2])
else
  display(map.save.ignore_patterns)
end</script>
					<command></command>
					<packageName></packageName>
					<regex>^map ignore(?: (.*))?$</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>Set Move Method Alias</name>
					<script>
if matches[2] then
  map.make_move_method(matches[2])
else
  display(map.save.move_methods)
end</script>
					<command></command>
					<packageName></packageName>
					<regex>^map movemethod(?: (.*))?$</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>Map Debug Alias</name>
					<script>map.configs.debug = not map.configs.debug
map.echo("Map debug set to: " .. (map.configs.debug and "on" or "off"))</script>
					<command></command>
					<packageName></packageName>
					<regex>^map debug$</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>Map Update Alias</name>
					<script>map.updateVersion()</script>
					<command></command>
					<packageName></packageName>
					<regex>^map update$</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>Map Config Alias</name>
					<script>-- adjust pattern to allow no argument, if no argument show general help about configs
if not matches[2] then
	cecho(map.help.config)
else
  local startStr, endStr = string.match(matches[2],"(.*) ([%w%.]+)")
  local vals = {'on', 'off', 'true', 'false'}
  local modes = {'lazy','simple','normal','complex'}
  if (table.contains(vals, endStr) or tonumber(endStr)) or (startStr == "mode" and table.contains(modes, endStr)) then
  	map.setConfigs(startStr, endStr)
  else
  	map.setConfigs(matches[2])
  end
end</script>
					<command></command>
					<packageName></packageName>
					<regex>^map config(?: ([\w\s\.]+))?$</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>Map Window Config Alias</name>
					<script>map.setConfigs("map_window",matches[3],matches[2])</script>
					<command></command>
					<packageName></packageName>
					<regex>^map window (x|y|w|h|origin|shown)(?: ([\w%]+))?</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>Map Translate Config Alias</name>
					<script>map.setConfigs("lang_dirs", {matches[3], matches[4]}, matches[2])</script>
					<command></command>
					<packageName></packageName>
					<regex>^map translate (\w+) (\w+) (\w+)$</regex>
				</Alias>
			</AliasGroup>
			<AliasGroup isActive="yes" isFolder="yes">
				<name>Information Aliases</name>
				<script></script>
				<command></command>
				<packageName></packageName>
				<regex></regex>
				<Alias isActive="yes" isFolder="no">
					<name>Map Quick Start Alias</name>
					<script>map.show_help("quick_start")</script>
					<command></command>
					<packageName></packageName>
					<regex>^map basics$</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>Map Help Alias</name>
					<script>map.show_help(matches[2])</script>
					<command></command>
					<packageName></packageName>
					<regex>^map help(?: (.*))?$</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>Map Rooms Alias</name>
					<script>map.echoRoomList(matches[2])</script>
					<command></command>
					<packageName></packageName>
					<regex>^map rooms (.*)$</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>Map Areas Alias</name>
					<script>map.echoAreaList()</script>
					<command></command>
					<packageName></packageName>
					<regex>^map areas$</regex>
				</Alias>
			</AliasGroup>
			<AliasGroup isActive="yes" isFolder="yes">
				<name>Regular Use Aliases</name>
				<script></script>
				<command></command>
				<packageName></packageName>
				<regex></regex>
				<Alias isActive="yes" isFolder="no">
					<name>Map Me Alias</name>
					<script>map.find_me(nil, nil, nil, true)</script>
					<command></command>
					<packageName></packageName>
					<regex>^map me$</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>Map Path Alias</name>
					<script>map.find_path(matches[2],matches[3])</script>
					<command></command>
					<packageName></packageName>
					<regex>^map path ([^;]+)(?:\s*;\s*(.+))?</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>Set Recall Alias</name>
					<script>map.set_recall()</script>
					<command></command>
					<packageName></packageName>
					<regex>^map recall$</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>Set Character Alias</name>
					<script>map.character = matches[2]</script>
					<command></command>
					<packageName></packageName>
					<regex>^map character (.*)$</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>Map Stop Alias</name>
					<script>raiseEvent("mapStop")
raiseEvent("sysSpeedwalkStopped")</script>
					<command></command>
					<packageName></packageName>
					<regex>^map stop$</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>Toggle Speedwalk Alias</name>
					<script>map.toggleSpeedwalk(matches[2])</script>
					<command></command>
					<packageName></packageName>
					<regex>^mpp(?:\s?(on|off))?$</regex>
				</Alias>
			</AliasGroup>
			<AliasGroup isActive="yes" isFolder="yes">
				<name>Map Creation Aliases</name>
				<script></script>
				<command></command>
				<packageName></packageName>
				<regex></regex>
				<Alias isActive="yes" isFolder="no">
					<name>Set Room Area Alias</name>
					<script>map.set_area(matches[2])</script>
					<command></command>
					<packageName></packageName>
					<regex>^set area (.*)$</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>Start Mapping Alias</name>
					<script>map.start_mapping(matches[2])</script>
					<command></command>
					<packageName></packageName>
					<regex>^start mapping(?: (.*))?$</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>Stop Mapping Alias</name>
					<script>map.stop_mapping()</script>
					<command></command>
					<packageName></packageName>
					<regex>^stop mapping$</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>Shift Room Alias</name>
					<script>map.shift_room(matches[2])</script>
					<command></command>
					<packageName></packageName>
					<regex>^shift (.*)$</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>Add Portal Alias</name>
					<script>map.set_portal(matches[2])</script>
					<command></command>
					<packageName></packageName>
					<regex>^add portal (.*)$</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>Show Moves Alias</name>
					<script>map.show_moves()</script>
					<command></command>
					<packageName></packageName>
					<regex>^show moves$</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>Clear Moves Alias</name>
					<script>map.clear_moves()</script>
					<command></command>
					<packageName></packageName>
					<regex>^clear moves$</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>Add Door Alias</name>
					<script>map.set_door(matches[2],matches[3],matches[4])</script>
					<command></command>
					<packageName></packageName>
					<regex>^add door (\w+)(?: (none|open|closed|locked))?(?: (yes|no))?$</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>Merge Rooms Alias</name>
					<script>map.merge_rooms()</script>
					<command></command>
					<packageName></packageName>
					<regex>^merge rooms$</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>Set Map Mode Alias</name>
					<script>map.set_mode(matches[2])</script>
					<command></command>
					<packageName></packageName>
					<regex>^map mode (\w+)$</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>Set Room Exit Alias</name>
					<script>map.set_exit(matches[2],matches[3])</script>
					<command></command>
					<packageName></packageName>
					<regex>^set exit (.+) (\d+)</regex>
				</Alias>
			</AliasGroup>
			<AliasGroup isActive="yes" isFolder="yes">
				<name>Map Sharing Aliases</name>
				<script></script>
				<command></command>
				<packageName></packageName>
				<regex></regex>
				<Alias isActive="yes" isFolder="no">
					<name>Save Map Alias</name>
					<script>saveMap(getMudletHomeDir() .. "/map.dat")</script>
					<command></command>
					<packageName></packageName>
					<regex>^map save$</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>Load Map Alias</name>
					<script>map.load_map(matches[2])</script>
					<command></command>
					<packageName></packageName>
					<regex>^map load(?: (.*))?$</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>Import Map Area Alias</name>
					<script>map.import_area(matches[2])</script>
					<command></command>
					<packageName></packageName>
					<regex>^map import (.*)</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>Export Map Area Alias</name>
					<script>map.export_area(matches[2])</script>
					<command></command>
					<packageName></packageName>
					<regex>^map export (.*)</regex>
				</Alias>
			</AliasGroup>
		</AliasGroup>
	</AliasPackage>
	<ActionPackage>
		<ActionGroup isActive="yes" isFolder="yes" isPushButton="no" isFlatButton="no" useCustomLayout="no">
			<name>Top</name>
			<packageName></packageName>
			<script></script>
			<css></css>
			<commandButtonUp></commandButtonUp>
			<commandButtonDown></commandButtonDown>
			<icon></icon>
			<orientation>1</orientation>
			<location>0</location>
			<posX>0</posX>
			<posY>0</posY>
			<mButtonState>1</mButtonState>
			<sizeX>0</sizeX>
			<sizeY>0</sizeY>
			<buttonColumn>1</buttonColumn>
			<buttonRotation>0</buttonRotation>
			<Action isActive="yes" isFolder="no" isPushButton="no" isFlatButton="no" useCustomLayout="no">
				<name>First Aid</name>
				<packageName></packageName>
				<script>local status = "";
if (isActive("First AID (automatico)", "trigger") &gt; 0) then
  disableTrigger("First AID (automatico)")
  status = "&lt;red&gt;OFF&lt;reset&gt;"
  setButtonStyleSheet("First Aid", [[
  QWidget {
    background-color: red;
    border: 3px #777777;
  } ]])
else
  enableTrigger("First AID (automatico)")
  status = "&lt;green&gt;ON&lt;reset&gt;"
  setButtonStyleSheet("First Aid", [[
  QWidget {
    background-color: green;
    border: 3px #777777;
  } ]])
end
cecho("Trigger First AID (automatico) "..status.."\n")
</script>
				<css>  QWidget {
    background-color: red;
    border: 3px #777777;
  } </css>
				<commandButtonUp></commandButtonUp>
				<commandButtonDown></commandButtonDown>
				<icon></icon>
				<orientation>1</orientation>
				<location>0</location>
				<posX>0</posX>
				<posY>0</posY>
				<mButtonState>1</mButtonState>
				<sizeX>0</sizeX>
				<sizeY>0</sizeY>
				<buttonColumn>1</buttonColumn>
				<buttonRotation>0</buttonRotation>
			</Action>
		</ActionGroup>
	</ActionPackage>
	<ScriptPackage>
		<ScriptGroup isActive="yes" isFolder="yes">
			<name>Lumen et Umbra UI</name>
			<packageName>Lumen et Umbra UI</packageName>
			<script>--[[
ver 1.230921
------------
- Aggiunto "ALL" come parametro del comando "uisetfontsize"
- Aggiunto comando "uiwidget &lt;nome_widget&gt;" per ripristinare un widget chiuso o minimizzato
- Aggiunto scrolbar sui widget scorrevoli
- Corretto inizializzazione widget a dimensioni e posizioni diverse.
- Corretto cancellazione dell'Health dif dell'opponent (in alcuni casi rimaneva attivo alla morte dell'avversatio)
- Corretto gestione profili
- Corretto visualizzazzione degli effetti (venivano sovrapposti)
- Corretto visualizzazione della pagina di bottoni alias alla partenza
- Migliorato l'help (visualizzato in finestra, esecuzioni link e comandi)
- Rimossi pulsanti Help e Impostazioni (inutilizzati).
--
ver 1.230914
------------
- Aggiunto @Target sul titolo della finestra Opponent
- Aggiunto evidenza grafica sulla quantità di hp persi o recuperati
- Aggiunto gestione profili
- Aggiunto ora per ogni messaggio rivecuto nelle finestre dei messaggi
- Aggiunto ordinamento Alias per nome
- Aggiunto ordinamento Keybind per tasti di scelta rapida
- Aggiunto ordinamento effetti per durata
- Aggiunto protezione su stack overflow negli alias (profondità ricorsiva settata a 20 livelli di chiamate)
- Aggiunto comando uiR[eply] per rispondere velocemente all'ultimo messaggo privato ricevuto
- Aggiunto uscite speciali e specchi di Astral all'elenco delle uscite nella finestra Map/Compasss
- Aggiunto visualizzazione del percorso memorizzato nella finestra Map/Compass
- Aggiunto visualizzazione delle posizioni nella finestra Map/Compass
- Corretto bug minori
- Corretto bug sulla cancellazione delle finestre all'apertura dello script (dovuto al nome delle label che compongono il bordo)
- Corretto dimensione delle icone degli effetti
- Corretto help di uiSetFontSize
- Corretto script di esecuzione degli alias
- Corretto tooltip sulle icone degli effetti
- Corretto trigger equipment e loot (non funzionavano con la visiualizzazione della rarità degli oggetti spenta) 
- Corretto trigger specchi di Astral (alcune descrizione di specchi non facevano partire il trig) 
- Corretto visualizzazione dei messaggi contenenti caratteri speciali nelle finestre dei messaggi
- Corretto visualizzazzione dell'elenco degli alias con evidenza di Alias, Variabili, Testo, etc
- Corretto visualizzazione della direzione del track nella finestra Map/Compasss
- Corretta definizione dei componenti Geyser per ottimizzazione memoria (annidiati correttamente)
- Eliminato Widget Tick\Experience e integrati nel Widget Player
- Migliorato gestione keybind
- Migliorato visualizzazione degli effetti
- Migliorato visualizzazione dei bottoni alias
- Migliorato visualizzazione della finestra gruppo
- Sostituito costruttore dei componenti Geyser da new() a new2()
- Sostituito nomi funzioni appartenenti all'UI (aggiunta desinenza "ui.f")
- Sostituite UserWindows con AdjustableContainer
--
ver 1.220210
------------
- cadidate release
--
ver 0.3b
--------
- Rimossa gestione dei tab\frame ereditata da CS.
- Rimossa gestine CCS ereditata da CS.
- Implementata gestione frame con Geyser.UserWindow.
- Sistemato il problema del riavvio obbligatorio di mudlet dopo l'installazione del pack 
- Nuova getione dell'ui.fHelp
--
ver 0.2b
--------
Alias buttons:
- I custom buttons sono diventati alias buttons
--
Comandi:
- Aggiunti comandi uiResizeL(h, w) e uiResizeR(h, w) per ridimensionare (o nascondere) le barre laterali
- Aggiunto comndo uiRepair per riparare automaticamente tutto l'equipaggiamento danneggiato
--
Interfaccia:
- Rivista procedura di inizializzazione (presenta ancora alcune discrepanze)
- Trasformati i box player, opponent, compass e group in widget che è possibile spostare, ridimensionare e nascondere
- Snellita gestione Affects
--
Target buttons (g0..g9)
- I componenti del gruppo sono diventati target selezionabili
--
Target buttons (o0)
- Il widget dell'avversario è diventato un target selezionabile
--
uiAlias:
- Nuova gestione con struttura semplificata
- Aggiunta la possibilità di eseguire tramite UiAlias, un altro uiAlias o un alias definito in Mudlet.
  Possibilità di esecuzione di codice lua chiamando la funzione lua() nel pattern dell'uiAlias 
  Attenzione: può creare ricorsione incontrollata (stack overwlow)
- Aggiunta la possibilità di associare una combinazione di tasti all'uiAlias
--
uiHighlights:
- Nuova gestione con struttura semplificata
- Definizione per nome (invece che per numero)
- Riconoscimento per parola intera
- Riconoscimento non più sensibili alle maiuscole\minuscole
--
uiKeybind:
- Nuova gestione: keibind associati a target e alias
--
uiSpeedWalk
- Memorizza lo storico della strada percorsa e permette di ripercorrela indeitro con il comando "..", e poi dinuovo in avanti con il comendo "."
--
ver 0.1b
--------
- primo rilascio
]]</script>
			<eventHandlerList />
			<ScriptGroup isActive="yes" isFolder="yes">
				<name>Functions</name>
				<packageName></packageName>
				<script></script>
				<eventHandlerList />
				<Script isActive="yes" isFolder="no">
					<name>Affects</name>
					<packageName></packageName>
					<script>function ui.fUpdateAffects()
  local x = 0
  local y = 0
  local i
  local orderTable = {}
  -- Simulation (for debug)
  if (ui.enDebug) then
    for i=1, 20 do
      if (ui.actAffects["affect_"..i] == nil) then
        ui.actAffects["affect_"..i] = i*2
      end
    end
  end
  -- Order Affects
  for affect in pairs(ui.actAffects) do
    orderTable[#orderTable+1] = affect
  end
  table.sort(orderTable, function (affect1, affect2) 
                           return ui.actAffects[affect1] &lt; ui.actAffects[affect2]
                         end )
  --
  i = 0;
  for j,affect in ipairs(orderTable) do
    if (ui.actAffects[affect] &lt; 0) then
      ui.actAffects[affect] = nil
    elseif (i&lt;20) then
      local color
      -- Duration color
      if (ui.actAffects[affect] == 0) then
        color = "red"
      elseif (ui.actAffects[affect] == 1) then
        color = "orange"
      elseif  (ui.actAffects[affect] == 2) then
        color = "yellow"
      else
        color = "green"
      end
      i = i + 1
      -- Duration
      GUI["AffectIcon"..i].time:setFgColor(color)
      GUI["AffectIcon"..i].time:echo("&lt;center&gt;"..ui.actAffects[affect])
      local CCS = GUI.CSS.AffectIcon
      if table.contains(ui.affects, affect) then
        -- Icon
        if (ui.affects[affect].icon) and (io.exists(ui.pathIcn..ui.affects[affect].icon)) then
          CCS = GUI.CSS.AffectIcon..[[
                  border-image: url("]]..ui.pathIcn..ui.affects[affect].icon..[[") 0px stretch;
                ]]
        -- BG Color
        elseif (ui.affects[affect].color) then
          CCS = GUI.CSS.AffectIcon..[[
                  background-color: qradialgradient(spread:pad, cx:0.5, cy:0, radius:1, fx:0.5, fy:0, stop:0 white, stop:1 "]]..ui.affects[affect].color..[[");
                ]]
        else
          CCS = GUI.CSS.AffectIcon..[[
                  background-color: qradialgradient(spread:pad, cx:0.5, cy:0, radius:1, fx:0.5, fy:0, stop:0 rgba(61, 174, 219, 255), stop:1 rgba(27, 87, 141, 255));;
                ]]
        end
        -- ShortName
        if (ui.affects[affect].shortName) then
          GUI["AffectIcon"..i].icon:echo(ui.affects[affect].shortName)
        else
          GUI["AffectIcon"..i].icon:echo(affect:sub(1, 5))
        end
      else
        local affectText = ui.fRemoveArticle(affect)
        local R = 9 * ((string.byte(affectText, 1) or 0x0) - 0x61) -- Primo carattere o 0 se la frase è vuota
        local G = 9 * ((string.byte(affectText, 2) or 0x0) - 0x61) -- Secondo carattere o 0 se la frase ha meno di 2 caratteri
        local B = 9 * ((string.byte(affectText, 3) or 0x0) - 0x61) -- Terzo carattere o 0 se la frase ha meno di 3 caratteri
        local color = string.format("#%02X%02X%02X", R, G, B)
        local text = ""
        --
        CCS = GUI.CSS.AffectIcon..[[
                background-color: qradialgradient(spread:pad, cx:0.5, cy:0, radius:1, fx:0.5, fy:0, stop:0 white, stop:1 ]]..color..[[);
              ]]
        --
        for word in affectText:gmatch("%S+") do
          text = text..string.sub(word, 1, 3).." "
        end
        GUI["AffectIcon"..i].icon:echo(text)
      end
      -- StyleSheet
      GUI["AffectIcon"..i].icon:setStyleSheet(CCS)
      -- ToolTip
      GUI["AffectIcon"..i]:setToolTip(affect, 10)
      -- Position
      GUI["AffectIcon"..i]:move(x, y)
      -- Show if inside box
      if (y&lt;=GUI.Affect.Main.Body:get_height() - 20) then
        GUI["AffectIcon"..i]:show();
      else
        GUI["AffectIcon"..i]:hide();
      end
      --
      if (x &gt; GUI.Affect.Main.Body:get_width() - 60) then
        x = 0
        y = y + 42
      else
        x = x + 32
      end
    end
  end
  -- Hide not used affects
  for i=i+1, 20 do
    if (GUI["AffectIcon"..i]) then
      GUI["AffectIcon"..i]:hide();
    end
  end
end
--
function ui.fTickUpdateAffects()
  ui.fDebug("ui.fTickUpdateAffects()");
  for affect in pairs(ui.actAffects) do
    ui.actAffects[affect] = ui.actAffects[affect] - 1
  end
  ui.fUpdateAffects()
end</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>Alias buttons</name>
					<packageName></packageName>
					<script>--
function ui.fGetAliasButtonFormattedText(button)
  return ui.cAliasButton.."["..button.."]".."&lt;reset&gt;"
end
--
function ui.fSearchAliasButton(button)
  local type, number = ui.fExpandButton(button)
  if (type == "a") or (type == "b") or (type == "c") then
    button = type..number
    for alias in pairs(ui.aliases) do
      if (ui.aliases[alias].button) and (ui.aliases[alias].button==button) then
        return alias
      end
    end
  end
  return nil
end
--
-- List all alias buttons
function ui.fShowAllAliasButtons()
  local i = 0
  cecho(ui.fTitle("Pulsanti alias"))
  for alias in ui.fOrderedPairs(ui.aliases) do
    if (ui.aliases[alias].button) then
      i = i + 1
      cecho(ui.fGetNumberFormattedText(i).." "..ui.fGetAliasFormattedText(alias).."\n")
    end
  end
  if (i&gt;0) then
    echo("\n")
  else
    cecho("Per maggiori info "..ui.fGetCommandFormattedText("ui.fHelp uibuttons").."\n\n")
  end
end
--
-- Remove alias button
function ui.fRemoveAliasButton(button)
  local ret = 0;
  local type, number = ui.fExpandButton(button)
  if (type == "a") or (type == "b") or (type == "c") then
    button = type..number 
    local alias = ui.fSearchAliasButton(button)
    if (alias) then
      ui.aliases[alias].button = nil
      return 1
    end
    return -2 -- Not alias assigned
  end
  return -1 -- Invaid button
end
--
-- Remove all alias button
function ui.fRemoveAllAliasButtons()
  for alias in pairs(ui.aliases) do
    if (ui.aliases[alias].button) then
      ui.aliases[alias].button = nil
    end
  end
end
--
-- Assign alias button
function ui.fAssignAliasButton(button, alias)
  local ret = 0;
  local type, number = ui.fExpandButton(button)
  if (type == "a") or (type == "b") or (type == "c") then
    button = type..number
    if (ui.aliases[alias]) then
      ui.fRemoveAliasButton(button)
      ui.aliases[alias].button = button
      return 1
    end
    return -2 -- Alias not exist
  end
  return -1 -- Invaid button
end
--
function ui.fExecuteAliasButton(button)
  local alias = nil;
  local type, number = ui.fExpandButton(button)
  if (type == "a") or (type == "b") or (type == "c") then
    button = type..number
    alias = ui.fSearchAliasButton(button)
    if (alias) then
      expandAlias(alias, false)
    else
      ui.fEcho2n(ui.fGetAliasButtonFormattedText(button).." non configurato. Usare il comanto "..ui.fGetCommandFormattedText(button.." &lt;alias&gt;").." per configurare.")
    end
  end
  return alias
end
--
function ui.fRefreshAliasButton(number)
  local found = nil;
  local bgColor
  local title = ""
  local keybind = ""
  local button = ui.parameters.page..number
  for alias in pairs(ui.aliases) do
    if (ui.aliases[alias].button) and (ui.aliases[alias].button==button) then
      found = alias
      break
    end
  end
  if (ui.parameters.page == "a") then
    bgColor = "200,0,0"
  elseif (ui.parameters.page == "b") then
    bgColor = "0,200,0"
  elseif (ui.parameters.page == "c") then
    bgColor = "0,0,200"
  end
  if (found) then
    title = found
    keybind = ui.aliases[found].keybind or ""
  end
  GUI.AliasButtons.Main.Body.CButtons["Custom"..number].index:echo("&lt;center&gt;"..ui.parameters.page..number)
  GUI.AliasButtons.Main.Body.CButtons["Custom"..number].icon:echo("&lt;center&gt;"..title)
  GUI.AliasButtons.Main.Body.CButtons["Custom"..number].keybind:echo("&lt;center&gt;"..keybind)
  GUI.AliasButtons.Main.Body.CButtons["Custom"..number]:setStyleSheet([[
    QLabel{
      background-color: rgba(]]..bgColor..[[,.5);
      ]]..GUI.CSS.AliasButtons..[[
    }
    QLabel::hover{
      background-color: rgba(]]..bgColor..[[,1);
    }
  ]])
  GUI.AliasButtons.Main.Body.CButtons["Custom"..number].icon:setStyleSheet(GUI.CSS.ButtonsIcon)
end
--
function ui.fUpdateAllAliasButton()
  for i = 0, 9 do
    ui.fRefreshAliasButton(i)
  end
  GUI.AliasButtons.Main.Body.Navigator.Page:echo("&lt;center&gt;"..ui.parameters.page)
end
--
function ui.fClickAliasButton(number)
  local button = ui.parameters.page..number
  ui.fExecuteAliasButton(button)
end
--
-- Incrase page index
function ui.fIncraseButtonsPage()
  ui.parameters.page = ui.parameters.page or "";
  if (ui.parameters.page == "a") then
    ui.parameters.page = "b"
  elseif (ui.parameters.page == "b") then
    ui.parameters.page = "c"
  else
    ui.parameters.page = "a"
  end
  table.save(ui.fileParameters, ui.parameters)
  ui.fUpdateAllAliasButton()
end
--
-- Decrase page index
function ui.fDecraseButtonsPage()
  ui.parameters.page = ui.parameters.page or "";
  if (ui.parameters.page == "a") then
    ui.parameters.page = "c"
  elseif (ui.parameters.page == "c") then
    ui.parameters.page = "b"
  else
    ui.parameters.page = "a"
  end
  table.save(ui.fileParameters, ui.parameters)
  ui.fUpdateAllAliasButton()
end</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>Aliases</name>
					<packageName></packageName>
					<script>--
function ui.fGetAliasNameFormattedText(alias)
  return ui.cAliasName..alias.."&lt;reset&gt;"
end
--
function ui.fGetAliasOutputFormattedText(command, input)
  if (command) then
    input = input or ""
    -- Add same spaces between commands
    command = string.gsub(command, "(%s*/%s*)", " / ")
    command = string.gsub(command, "(%s*;%s*)", "; ")
    -- Format Aliases
    command = string.gsub(command, "^(%w+)", function(str)
                                               if ui.aliases[str] then
                                                 return ui.fGetAliasNameFormattedText(str)..ui.cAliasOutput
                                               end
                                             end)
    command = string.gsub(command, "/ (%w+)", function(str)
                                                if ui.aliases[str] then
                                                  return "/ "..ui.fGetAliasNameFormattedText(str)..ui.cAliasOutput
                                                end
                                              end)
    command = string.gsub(command, "; (%w+)", function(str)
                                                if ui.aliases[str] then
                                                  return "; "..ui.fGetAliasNameFormattedText(str)..ui.cAliasOutput
                                                end
                                              end)
    -- Format Variables
    command = string.gsub(command, ui.varID.."(%w+)", function(str)
                                                        if not ui.variables[str] then
                                                          return ui.fGetVarNameFormattedText(str)..ui.fGetOperatorFormattedText("(")..ui.cError.."Variabile non trovata!"..ui.fGetOperatorFormattedText(")")..ui.cAliasOutput
                                                        else
                                                          return ui.fGetVarFormattedText(str)..ui.cAliasOutput
                                                        end
                                                      end)
    -- Format commands separator
    command = string.gsub(command, ";", ui.cSeparator..";"..ui.cAliasOutput)
    command = string.gsub(command, "/", ui.cSeparator.."/"..ui.cAliasOutput)
    -- Format input command
    command = string.gsub(command, "#", ui.fGetInputFormattedText("#"..input)..ui.cAliasOutput)
    --
    return ui.cAliasOutput..command.."&lt;reset&gt;"
  end
  return ""
end
--
function ui.fGetAliasFormattedText(alias)
  local ret = ""
  if (ui.aliases[alias]) then
    ret = ui.fGetAliasNameFormattedText(alias).." "..ui.fGetOperatorFormattedText("»").." "..ui.fGetAliasOutputFormattedText(ui.aliases[alias].text)
    if (ui.aliases[alias].keybId) then
      ret = ui.fGetKeybFormattedText(ui.aliases[alias].keybind).." "..ret
    end
    if (ui.aliases[alias].button) then
      ret = ui.fGetAliasButtonFormattedText(ui.aliases[alias].button).." "..ret
    end
  end
  return ret
end
--
-- List all aliases
function ui.fShowAllAliases()
  local i = 0
  cecho(ui.fTitle("Aliases"))
  for alias in ui.fOrderedPairs(ui.aliases) do
    i = i + 1
    cecho(ui.fGetNumberFormattedText(i).." "..ui.fGetAliasFormattedText(alias).."\n")
  end
  if (i&gt;0) then
    echo("\n")
  else
    cecho("Per maggiori info "..ui.fGetCommandFormattedText("ui.fHelp uialias").."\n\n")
  end
end
--
function ui.fRemoveAlias(alias)
  if (ui.aliases[alias]) then
    ui.fRemoveKeyb(ui.aliases[alias]);
    if (ui.aliases[alias]["id"]) then
      killAlias(ui.aliases[alias]["id"])
    end
    ui.aliases[alias] = nil
    return true
  end
  return false
end
--
function ui.fRemoveAllAliases()
  for alias in pairs(ui.aliases) do
    ui.fRemoveAlias(alias)
  end
  ui.aliases = {}
end
--
function ui.fAddAlias(alias, value)
  local command
  local commands, varNameError = ui.fExpandVariables(value, true)
  if (not varNameError) then
    -- Init alias (if no exist)
    ui.aliases[alias] = ui.aliases[alias] or {}
    -- Remove old alias
    if (ui.aliases[alias].id) then
      killAlias(ui.aliases[alias].id)
    end
    -- Save value in text format
    ui.aliases[alias].text = value
    -- Generate alias code
    local code = [[
ui.levelCode = (ui.levelCode or -1) + 1
if (ui.levelCode &gt; 20) then
  ui.levelCode = ui.levelCode -1
  ui.fError("Stack overflow protection.")
  return
end
--
matches = matches or {}
local __mtchs2__ = matches[2] or ""
]]
    commands = ui.fExpandCommand(value)
    if (#commands == 1) then
      -- Single command
      command = ui.fExpandVariables(value, true)
      if (string.match(command, "__mtchs2__")) then
        code = code..[[
-- Single command with #
ui.fEchon(ui.fGetAliasOutputFormattedText("]]..value..[[", __mtchs2__), ui.levelCode);
expandAlias("]]..command..[[", false);
]]
      else
        -- Search for variables in command
        local last_variable = ""
        local last_expanded_variable = ""
        for variable in string.gfind(command, "ui.variables%.%w+") do
          last_variable = string.gsub(variable, "ui.variables%.", "@")
          last_expanded_variable = variable
        end
        if (last_variable == "") then
          -- If not variables in comman, add matches[2]
          code = code..[[
-- Single command without # and without variables
if (__mtchs2__ == "") then
  ui.fEchon(ui.fGetAliasOutputFormattedText("]]..value..[["), ui.levelCode);
  expandAlias("]]..command..[[", false);
else
  -- Append matches[2]
  ui.fEchon(ui.fGetAliasOutputFormattedText("]]..value..[[ #", __mtchs2__), ui.levelCode);
  expandAlias("]]..command..[[".." "..__mtchs2__, false);
end
]]
        else
          -- If variables in command, replace last variable with matches[2]
          local command_matches = string.gsub(command, last_expanded_variable, "__mtchs2__")
          code = code..[[
-- Single command without # but with variables
if (__mtchs2__ == "") then
  ui.fEchon(ui.fGetAliasOutputFormattedText("]]..value..[["), ui.levelCode);
  expandAlias("]]..command..[[", false);
else
  -- Replace last variable with matches[2]
  ui.fEchon(ui.fGetAliasOutputFormattedText("]]..string.gsub(value, last_variable, "#")..[[", __mtchs2__), ui.levelCode);
  expandAlias("]]..command_matches..[[", false);
end
]]
        end
      end
    else
      -- Multiple commands
      code = code..[[
-- Multiple commands
]]
      for _, cmd in ipairs(commands) do
        command = ui.fExpandVariables(cmd, true)
        code = code..[[
ui.fEchon(ui.fGetAliasOutputFormattedText("]]..cmd..[[", __mtchs2__), ui.levelCode);
expandAlias("]]..command..[[", false);
]]
      end
    end
    code = code..[[
--
ui.levelCode = math.max(-1, ui.levelCode - 1)
]]
    -- Save alias code (for debug only)
    ui.aliases[alias].code = code
    -- Assign keybind
    local mod1 = ui.aliases[alias].mod1 or "";
    local mod2 = ui.aliases[alias].mod2 or "";
    local key = ui.aliases[alias].key or "";
    local result, keybind
    if (mod2 ~= "") then
      result, keybind = ui.fSetKeyb(ui.aliases, alias, ui.aliases[alias].code, mod2, mod1, key)
    elseif (mod1 ~= "") then
      result, keybind = ui.fSetKeyb(ui.aliases, alias, ui.aliases[alias].code, mod1, key)
    elseif (key ~= "") then
      result, keybind = ui.fSetKeyb(ui.aliases, alias, ui.aliases[alias].code, key)
    else
      result, keybind = ui.fSetKeyb(ui.aliases, alias, ui.aliases[alias].code)
    end
    -- Remove keybind if not valid (or already used)
    if (result &lt;= 0) then
      ui.fRemoveKeyb(ui.aliases[alias])
    end
    -- Create alias
    ui.aliases[alias].id = tempAlias([[^]]..alias..[[(?: (.*))?$]], code)
    return 1, ui.fGetAliasFormattedText(alias)
  end
  return -1, varNameError  -- Variable not exist
end
--
-- Save aliases data from file
function ui.fSaveFileAliases()
  local aliasesDataToSave = {}
  for alias in pairs(ui.aliases) do
    aliasesDataToSave[alias] = {}
    aliasesDataToSave[alias].text = ui.aliases[alias].text
    aliasesDataToSave[alias].mod1 = ui.aliases[alias].mod1
    aliasesDataToSave[alias].mod2 = ui.aliases[alias].mod2
    aliasesDataToSave[alias].key = ui.aliases[alias].key
    aliasesDataToSave[alias].button = ui.aliases[alias].button
  end
  table.save(ui.fileAliases, aliasesDataToSave)
end
--
-- Read Aliases data from file
function ui.fReadFileAliases()
  -- Remove actual Aliases
  ui.aliases = ui.aliases or {}
  ui.fRemoveAllAliases()
  -- Load Aliases
  if (io.exists(ui.fileAliases)) then
    table.load(ui.fileAliases, ui.aliases)
  end
  --
  -- Create Aliases
  for alias in pairs(ui.aliases) do
    ui.fAddAlias(alias, ui.aliases[alias].text)
  end
end</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>Border</name>
					<packageName></packageName>
					<script>function ui.fAddBorder(sender, border)
  if (sender) then
    border = border or 1
    if (border == 1) then
      sender.LT = Geyser.Label:new2({name = sender.name .. "LT", x = 0, y = 0, width = 20, height = 20 }, sender)
      sender.LT:setStyleSheet([[background-color: rgba(30, 24, 24, 100%); background-image: url("]]..ui.pathImg..[[frameBorderLT.png")]]);
      sender.LT:enableClickthrough()
      sender.T1 = Geyser.Label:new2({name = sender.name .. "T1", x = 20, y = 0, width = 40, height = 20 }, sender)
      sender.T1:setStyleSheet([[background-color: rgba(30, 24, 24, 100%); background-image: url("]]..ui.pathImg..[[frameBorderT1.png")]]);
      sender.T1:enableClickthrough()
      sender.T2 = Geyser.Label:new2({name = sender.name .. "T2", x = 60, y = 0, width = -60, height = 20 }, sender)
      sender.T2:setStyleSheet([[background-color: rgba(30, 24, 24, 100%); background-image: url("]]..ui.pathImg..[[frameBorderT2.png")]]);
      sender.T2:enableClickthrough()
      sender.T3 = Geyser.Label:new2({name = sender.name .. "T3", x = -60, y = 0, width = 40, height = 20 }, sender)
      sender.T3:setStyleSheet([[background-color: rgba(30, 24, 24, 100%); background-image: url("]]..ui.pathImg..[[frameBorderT3.png")]]);
      sender.T3:enableClickthrough()
      sender.RT = Geyser.Label:new2({name = sender.name .. "RT", x = -20, y = 0, width = 20, height = 20 }, sender)
      sender.RT:setStyleSheet([[background-color: rgba(30, 24, 24, 100%); background-image: url("]]..ui.pathImg..[[frameBorderRT.png")]]);
      sender.RT:enableClickthrough()
      sender.L1 = Geyser.Label:new2({name = sender.name .. "L1", x = 0, y = 20, width = 20, height = 40 }, sender)
      sender.L1:setStyleSheet([[background-color: rgba(30, 24, 24, 100%); background-image: url("]]..ui.pathImg..[[frameBorderL1.png")]]);
      sender.L1:enableClickthrough()
      sender.L2 = Geyser.Label:new2({name = sender.name .. "L2", x = 0, y = 60, width = 20, height = -60 }, sender)
      sender.L2:setStyleSheet([[background-color: rgba(30, 24, 24, 100%); background-image: url("]]..ui.pathImg..[[frameBorderL2.png")]]);
      sender.L2:enableClickthrough()
      sender.L3 = Geyser.Label:new2({name = sender.name .. "L3", x = 0, y = -60, width = 20, height = 40 }, sender)
      sender.L3:setStyleSheet([[background-color: rgba(30, 24, 24, 100%); background-image: url("]]..ui.pathImg..[[frameBorderL3.png")]]);
      sender.L3:enableClickthrough()
      sender.Body = Geyser.Label:new2({name = sender.name .. "Body", x = 20, y = 20, width = -20, height = -20}, sender)
      sender.Body:setStyleSheet([[background-color: rgba(30, 24, 24, 100%)]]);
      sender.Body:enableClickthrough()
      sender.R1 = Geyser.Label:new2({name = sender.name .. "R1", x = -20, y = 20, width = 20, height = 40}, sender)
      sender.R1:setStyleSheet([[background-color: rgba(30, 24, 24, 100%); background-image: url("]]..ui.pathImg..[[frameBorderR1.png")]]);
      sender.R1:enableClickthrough()
      sender.R2 = Geyser.Label:new2({name = sender.name .. "R2", x = -20, y = 60, width = 20, height = -60 }, sender)
      sender.R2:setStyleSheet([[background-color: rgba(30, 24, 24, 100%); background-image: url("]]..ui.pathImg..[[frameBorderR2.png")]]);
      sender.R2:enableClickthrough()
      sender.R3 = Geyser.Label:new2({name = sender.name .. "R3", x = -20, y = -60, width = 20, height = 40 }, sender)
      sender.R3:setStyleSheet([[background-color: rgba(30, 24, 24, 100%); background-image: url("]]..ui.pathImg..[[frameBorderR3.png")]]);
      sender.R3:enableClickthrough()
      sender.LB = Geyser.Label:new2({name = sender.name .. "LB", x = 0, y = -20, width = 20, height = 20}, sender)
      sender.LB:setStyleSheet([[background-color: rgba(30, 24, 24, 100%); background-image: url("]]..ui.pathImg..[[frameBorderLB.png")]]);
      sender.LB:enableClickthrough()
      sender.B1 = Geyser.Label:new2({name = sender.name .. "B1", x = 20, y = -20, width = 40, height = 20}, sender)
      sender.B1:setStyleSheet([[background-color: rgba(30, 24, 24, 100%); background-image: url("]]..ui.pathImg..[[frameBorderB1.png")]]);
      sender.B1:enableClickthrough()
      sender.B2 = Geyser.Label:new2({name = sender.name .. "B2", x = 60, y = -20, width = -60, height = 20 }, sender)
      sender.B2:setStyleSheet([[background-color: rgba(30, 24, 24, 100%); background-image: url("]]..ui.pathImg..[[frameBorderB2.png")]]);
      sender.B2:enableClickthrough()
      sender.B3 = Geyser.Label:new2({name = sender.name .. "B3", x = -60, y = -20, width = 40, height = 20 }, sender)
      sender.B3:setStyleSheet([[background-color: rgba(30, 24, 24, 100%); background-image: url("]]..ui.pathImg..[[frameBorderB3.png")]]);
      sender.B3:enableClickthrough()
      sender.RB = Geyser.Label:new2({name = sender.name .. "RB", x = -20, y = -20, width = 20, height = 20}, sender)
      sender.RB:setStyleSheet([[background-color: rgba(30, 24, 24, 100%); background-image: url("]]..ui.pathImg..[[frameBorderRB.png")]]);
      sender.RB:enableClickthrough()
    elseif (border == 2) then
      sender.LT = Geyser.Label:new2({name = sender.name .. "LT",x = 0, y = 0, width = 15, height = 15},sender)
      sender.LT:setStyleSheet([[background-color: rgba(30, 24, 24, 100%); background-image: url("]]..ui.pathImg..[[footerBorderLT.png")]]);
      sender.LT:enableClickthrough()
      sender.T = Geyser.Label:new2({name = sender.name .. "T",x = 15, y = 0, width = -15, height = 15},sender)
      sender.T:setStyleSheet([[background-color: rgba(30, 24, 24, 100%); background-image: url("]]..ui.pathImg..[[footerBorderT.png")]]);
      sender.T:enableClickthrough()
      sender.RT = Geyser.Label:new2({name = sender.name .. "RT",x = -15, y = 0, width = 15, height = 15},sender)
      sender.RT:setStyleSheet([[background-color: rgba(30, 24, 24, 100%); background-image: url("]]..ui.pathImg..[[footerBorderRT.png")]]);
      sender.RT:enableClickthrough()
      sender.L = Geyser.Label:new2({name = sender.name .. "L",x = 0, y= 15, width = 15, height = -15},sender)
      sender.L:setStyleSheet([[background-color: rgba(30, 24, 24, 100%); background-image: url("]]..ui.pathImg..[[footerBorderL.png")]]);
      sender.L:enableClickthrough()
      sender.Body = Geyser.Label:new2({name = sender.name .. "Body",x = 15, y = 15, width = -15, height = -15},sender)
      sender.Body:setStyleSheet([[background-image: url("]]..ui.pathImg..[[footerBody.png")]]);
      sender.Body:enableClickthrough()
      sender.R = Geyser.Label:new2({name = sender.name .. "R",x = -15, y = 15, width = 15, height = -15},sender)
      sender.R:setStyleSheet([[background-color: rgba(30, 24, 24, 100%); background-image: url("]]..ui.pathImg..[[footerBorderR.png")]]);
      sender.R:enableClickthrough()
      sender.LB = Geyser.Label:new2({name = sender.name .. "LB",x = 0, y = -15, width = 15, height = 15},sender)
      sender.LB:setStyleSheet([[background-color: rgba(30, 24, 24, 100%); background-image: url("]]..ui.pathImg..[[footerBorderLB.png")]]);
      sender.LB:enableClickthrough()
      sender.B = Geyser.Label:new2({name = sender.name .. "B",x = 15, y = -15, width = -15, height = 15},sender)
      sender.B:setStyleSheet([[background-color: rgba(30, 24, 24, 100%); background-image: url("]]..ui.pathImg..[[footerBorderB.png")]]);
      sender.B:enableClickthrough()
      sender.RB = Geyser.Label:new2({name = sender.name .. "RB",x = -15, y = -15, width = 15, height = 15},sender)
      sender.RB:setStyleSheet([[background-color: rgba(30, 24, 24, 100%); background-image: url("]]..ui.pathImg..[[footerBorderRB.png")]]);
      sender.RB:enableClickthrough()
    elseif (border == 3) then
      sender.Body = Geyser.Label:new2({name = sender.name .. "Body",x = 0, y = 0, width = "100%", height = "100%"}, sender)
      sender.Body:setStyleSheet(GUI.CSS.Border3);
      sender.Body:enableClickthrough()
    end
  end
end</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>Colors</name>
					<packageName></packageName>
					<script>--
-- Coded by Mudlet community developer demonnic
-- internal sorting function, sorts first by hue, then luminosity, then value
local sortColorsByHue = function(lhs, rhs)
  local lh, ll, lv = unpack(lhs.sort)
  local rh, rl, rv = unpack(rhs.sort)
  if lh &lt; rh then
    return true
  elseif lh &gt; rh then
    return false
  elseif ll &lt; rl then
    return true
  elseif ll &gt; rl then
    return false
  else
    return lv &lt; rv
  end
end
--
-- Internal sorting function, removes _ from snake_case and compares to camelCase
local sortColorsByName = function(a, b)
  local aname = string.gsub(string.lower(a.name), "_", "")
  local bname = string.gsub(string.lower(b.name), "_", "")
  return aname &lt; bname
end
--
-- Internal function used to turn sorted colors table into columns
local chunkify = function(tbl, num_chunks)
  local pop =
    function(t)
      return table.remove(t, 1)
    end
  local tbl = table.deepcopy(tbl)
  local tblsize = #tbl
  local base_chunk_size = tblsize / num_chunks
  local chunky_chunks = tblsize % num_chunks
  local chunks = {}
  for i = 1, num_chunks do
    local chunk_size = base_chunk_size
    if i &lt;= chunky_chunks then
      chunk_size = chunk_size + 1
    end
    local chunk = {}
    for j = 1, chunk_size do
      chunk[j] = pop(tbl)
    end
    chunks[i] = chunk
  end
  return chunks
end
--
-- internal function, converts rgb to hsv
-- found at https://github.com/EmmanuelOga/columns/blob/master/utils/color.lua#L89
local rgbToHsv = function(r, g, b)
  r, g, b = r / 255, g / 255, b / 255
  local max, min = math.max(r, g, b), math.min(r, g, b)
  local h, s, v
  v = max
  local d = max - min
  if max == 0 then
    s = 0
  else
    s = d / max
  end
  if max == min then
    h = 0
    -- achromatic
  else
    if max == r then
      h = (g - b) / d
      if g &lt; b then
        h = h + 6
      end
    elseif max == g then
      h = (b - r) / d + 2
    elseif max == b then
      h = (r - g) / d + 4
    end
    h = h / 6
  end
  return h, s, v
end
--
-- internal stepping function, removes some of the noise for a more pleasing sort
-- cribbed from the python on https://www.alanzucconi.com/2015/09/30/colour-sorting/
local step = function(r, g, b)
  local lum = math.sqrt(.241 * r + .691 * g + .068 * b)
  local reps = 8
  local h, s, v = rgbToHsv(r, g, b)
  local h2 = math.floor(h * reps)
  local lum2 = math.floor(lum * reps)
  local v2 = math.floor(v * reps)
  if h2 % 2 == 1 then
    v2 = reps - v2
    lum2 = reps - lum2
  end
  return h2, lum2, v2
end
--
local function calc_luminosity(r, g, b)
  r = r &lt; 11 and r / (255 * 12.92) or ((0.055 + r / 255) / 1.055) ^ 2.4
  g = g &lt; 11 and g / (255 * 12.92) or ((0.055 + g / 255) / 1.055) ^ 2.4
  b = b &lt; 11 and b / (255 * 12.92) or ((0.055 + b / 255) / 1.055) ^ 2.4
  return (0.2126 * r) + (0.7152 * g) + (0.0722 * b)
end
--
local function include(color, options)
  if options.removeDupes then
    if string.find(color, "_") or string.find(color:lower(), 'gray') then
      return false
    else
      return true
    end
  else
    if string.find(color, "ansi_%d%d%d") then
      return false
    else
      return true
    end
  end
end
--
local function echoColor(color, options)
  local rgb = color.rgb
  local fgc = "white"
  if calc_luminosity(unpack(rgb)) &gt; 0.5 then
    fgc = "black"
  end
  local colorString
  if options.justText then
    colorString = string.format('&lt;%s:%s&gt; %-23s&lt;reset&gt; ', color.name, 'black', color.name, spacer)
  else
    colorString = string.format('&lt;%s:%s&gt; %-23s&lt;reset&gt; ', fgc, color.name, color.name)
  end
  if options.window == "main" then
    if options.echoOnly then
      cecho(colorString)
    else
      cechoLink(
        colorString, [[appendCmdLine("]]..color.name..[[")]], table.concat(rgb, ", "), true
      )
    end
  else
    if options.echoOnly then
      cecho(options.window, colorString)
    else
      cechoLink(
        options.window,
        colorString,
        [[appendCmdLine("]]..color.name..[[")]],
        table.concat(rgb, ", "),
        true
      )
    end
  end
end
--
function ui.fDisplayColors(options)
  local options = options or {}
  local optionsType = type(options)
  assert(
    optionsType == "table",
    "ui.fDisplayColors(options) argument error: options as table expects, got "..optionsType
  )
  options.cols = options.cols or 4
  options.search = options.search or ""
  options.sort = options.sort or false
  if options.removeDupes == nil then
    options.removeDupes = true
  end
  if options.columnSort == nil then
    options.columnSort = true
  end
  if type(options.window) == "table" then
    options.window = options.window.name
  end
  options.window = options.window or "main"
  local color_table = options.color_table or color_table
  local cols, search, sort = options.cols, options.search, options.sort
  local colors = {}
  for k, v in pairs(color_table) do
    local color = {}
    color.rgb = v
    color.name = k
    color.sort = {step(unpack(v))}
    if include(k, options) and k:lower():find(search) then
      table.insert(colors, color)
    end
  end
  if sort then
    table.sort(colors, sortColorsByName)
  else
    table.sort(colors, sortColorsByHue)
  end
  if options.columnSort then
    local columns_table = chunkify(colors, cols)
    local lines = #columns_table[1]
    for i = 1, lines do
      for j = 1, cols do
        local color = columns_table[j][i]
        if color then
          echoColor(color, options)
        end
      end
      echo(options.window, "\n")
    end
  else
    local i = 1
    for _, k in ipairs(colors) do
      echoColor(k, options)
      if i == cols then
        echo(options.window, "\n")
        i = 1
      else
        i = i + 1
      end
    end
    if i ~= 1 then
      echo(options.window, "\n")
    end
  end
end
--
-- Check color
function ui.fColorCheck(color)
  local color = color:lower()
  color = color:gsub("_", "")
  for color_name, _ in pairs(color_table) do
    if color_name:lower() == color then
      return color_name
    end
  end
  return false
end
</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>Generic</name>
					<packageName></packageName>
					<script>--
function ui.fClickTarget(sender)
  if (sender) then
    local type, number = ui.fExpandButton(sender)
    if (type == "g") or (type == "o") then
      ui.fExecuteTargetButton(sender)
    end
  end
end
--
function ui.fGenOrderedIndex( t )
  local orderedIndex = {}
  for key in pairs(t) do
    table.insert(orderedIndex, key)
  end
  table.sort(orderedIndex)
  return orderedIndex
end
--
function ui.fOrderedNext(t, state)
  -- Equivalent of the next function, but returns the keys in the alphabetic
  -- order. We use a temporary ordered key table that is stored in the
  -- table being iterated.
  local key = nil
  if state == nil then
    -- the first time, generate the index
    t.__orderedIndex = ui.fGenOrderedIndex(t)
    key = t.__orderedIndex[1]
  else
    -- Fetch the next value
    for i = 1,table.getn(t.__orderedIndex) do
      if t.__orderedIndex[i] == state then
        key = t.__orderedIndex[i+1]
      end
    end
  end
  if key then
    return key, t[key]
  end
  -- No more value to return, cleanup
  t.__orderedIndex = nil
  return
end
--
function ui.fOrderedPairs(t, state)
  -- Equivalent of the pairs() function on tables. Allows to iterate in order
  return ui.fOrderedNext, t, state
end
--
function ui.fDebug(text)
  if ui.enDebug then
    ui.fEchon("&lt;orange&gt;- DEBUG - &lt;white&gt;("..getTime(true, "hh:mm:ss.zzz")..") "..ui.cText..text.."&lt;reset&gt;")
  end
end
--
function ui.fEcho(text)
  text = ui.echo..ui.cText..text.."&lt;reset&gt;"
  cecho(text)
end
--
function ui.fEchon(text, level)
  local tab = ""
  if (level) and (level &gt; 0) then 
    for i=2, level do
      tab = tab.."    "
    end
    tab = tab..ui.fGetOperatorFormattedText("  » ")
  end
  text = ui.echo..tab..ui.cText..text.."&lt;reset&gt;\n"
  cecho(text)
end
--
function ui.fEcho2n(text)
  text = ui.echo..ui.cText..text.."&lt;reset&gt;\n\n"
  cecho(text)
end
--
function ui.fError(text)
  text = ui.echo..ui.cError.."[ERRORE] "..ui.cText..text.."&lt;reset&gt;\n\n"
  cecho(text)
end
--
function ui.fDecho(text)
  text = copy2decho(ui.echo..ui.cText)..text..copy2decho("&lt;reset&gt;").."\n\n"
  decho(text)
end
--
function ui.fTitle(text)
  local title = "\n"..ui.echo..ui.cTitle..text.."\n"
  text = string.gsub(ui.echo..text, "\&lt;%a+\&gt;", "")
  for i=1, text:len() do
    title = title.."-"
  end
  title = title.."\n"
  return title
end
--
function ui.fLog(text)
  text = "\n&lt;128,128,128:30,24,24&gt;"..os.date("%H:%M:%S").." - &lt;255,255,255:30,24,24&gt;"..text.."\n"
  GUI.PrivateChat.Main.Body.Console:decho(text)
  ui.lastFromPrivate = ""
end
--
function ui.fGetNumberFormattedText(number)
  if (number &lt; 10) then
    return "&lt;white&gt;[&lt;steel_blue&gt; "..number.."&lt;white&gt;]".."&lt;reset&gt;"
  end
  return "&lt;white&gt;[&lt;steel_blue&gt;"..number.."&lt;white&gt;]".."&lt;reset&gt;"
end
--
function ui.fRemoveArticle(text)
  text = " "..text.." "
  text = string.gsub(text, "&gt;", "&gt; ")
  text = string.gsub(text, " con ", " ")
  text = string.gsub(text, " d'", " ")
  text = string.gsub(text, " da ", " ")
  text = string.gsub(text, " di ", " ")
  text = string.gsub(text, " dei ", " ")
  text = string.gsub(text, " del ", " ")
  text = string.gsub(text, " dell'", " ")
  text = string.gsub(text, " degli ", " ")
  text = string.gsub(text, " della ", " ")
  text = string.gsub(text, " delle ", " ")
  text = string.gsub(text, " dello ", " ")
  text = string.gsub(text, " gli ", " ")
  text = string.gsub(text, " i ", " ")
  text = string.gsub(text, " il ", " ")
  text = string.gsub(text, " Il ", " ")
  text = string.gsub(text, " in ", " ")
  text = string.gsub(text, " l'", " ")
  text = string.gsub(text, " la ", " ")
  text = string.gsub(text, " le ", " ")
  text = string.gsub(text, " lo ", " ")
  text = string.gsub(text, " un ", " ")
  text = string.gsub(text, " un'", " ")
  text = string.gsub(text, " una ", " ")
  text = string.gsub(text, " uno ", " ")
  text = string.gsub(text, " Uno ", " ")
  text = string.gsub(text, "&gt; ", "&gt;")
  text = string.trim(text)
  return text
end
--
function ui.fParsingItem(text)
  -- TODO: missing colors
  local statusColor = "&lt;128,128,128:30,24,24&gt;"
  if (string.find(text, "indistruttibil")) then
    text = string.gsub(text, "...E` indistruttibile!", "")
    text = string.gsub(text, "...Sono indistruttibili!", "")
    statusColor = "&lt;255,255,255:30,24,24&gt;"
  elseif (string.find(text, "in condizioni eccellenti")) then
    text = string.gsub(text, "...E` in condizioni eccellenti", "")
    text = string.gsub(text, "...Sono in condizioni eccellenti", "")
    statusColor = "&lt;128,128,128:30,24,24&gt;"
  elseif (string.find(text, "in ottime condizioni")) then
    text = string.gsub(text, "...&lt;r&gt;&lt;0,255,0:0,0,0&gt;E` in ottime condizioni&lt;r&gt;", "")
    text = string.gsub(text, "...&lt;r&gt;&lt;0,255,0:0,0,0&gt;Sono in ottime condizioni&lt;r&gt;", "")
    statusColor = "&lt;0,255,0:30,24,24&gt;"
  elseif (string.find(text, "danni superficiali")) then
    text = string.gsub(text, "...&lt;r&gt;&lt;255,255,0:0,0,0&gt;Presenta danni superficiali&lt;r&gt;", "")
    text = string.gsub(text, "...&lt;r&gt;&lt;255,255,0:0,0,0&gt;Presentano danni superficiali&lt;r&gt;", "")
    statusColor = "&lt;255,255,0:30,24,24&gt;"
  elseif (string.find(text, "danneggiat")) then
    text = string.gsub(text, "...&lt;r&gt;&lt;0,255,255:0,0,0&gt;E` danneggiato ed usurato&lt;r&gt;", "")
    text = string.gsub(text, "...&lt;r&gt;&lt;0,255,255:0,0,0&gt;Sono danneggiati ed usurati&lt;r&gt;", "")
    statusColor = "&lt;0,255,255:30,24,24&gt;"
  elseif (string.find(text, "in pessime condizioni")) then
    text = string.gsub(text, "...&lt;255,255,0:0,0,0&gt;E` in pessime condizioni", "")
    text = string.gsub(text, "...&lt;255,255,0:0,0,0&gt;Sono in pessime condizioni", "")
    statusColor = "&lt;255,255,0:30,24,24&gt;"
  elseif (string.find(text, "bisogno di essere riparat")) then
    text = string.gsub(text, "...&lt;255,0,0:0,0,0&gt;Ha bisogno di essere riparato", "")
    text = string.gsub(text, "...&lt;255,0,0:0,0,0&gt;Hanno bisogno di essere riparati", "")
    statusColor = "&lt;255,0,0:30,24,24&gt;"
  elseif (string.find(text, "per cadere in pezzi")) then
    text = string.gsub(text, "...Sta per cadere in pezzi", "")
    text = string.gsub(text, "...Stanno per cadere in pezzi", "")
    statusColor = "-TO DO-"
  elseif (string.find(text, "rompersi da un momento all'altro")) then
    text = string.gsub(text, "...Potrebbe rompersi da un momento all'altro!", "")
    text = string.gsub(text, "...Potrebbero rompersi da un momento all'altro!", "")
    statusColor = "&lt;128,0,0:30,24,24&gt;"
  elseif (string.find(text, "in frantumi. Inutilizzabil")) then
    text = string.gsub(text, "...E` in frantumi. Inutilizzabile!", "")
    text = string.gsub(text, "...Sono in frantumi. Inutilizzabili!", "")
    statusColor = "-TO DO-"
  end
  local good = string.find(text, "luce blu")
  if (good) then
    text = string.gsub(text, "...Ha un alone di &lt;r&gt;&lt;0,0,255:0,0,0&gt;luce blu&lt;r&gt;", "")
    text = string.gsub(text, "...Hanno un alone di &lt;r&gt;&lt;0,0,255:0,0,0&gt;luce blu&lt;r&gt;", "")
  end
  local evil = string.find(text, "luce rossa")
  if (evil) then
    text = string.gsub(text, "...Ha un alone di &lt;r&gt;&lt;255,0,0:0,0,0&gt;luce rossa&lt;r&gt;", "")
    text = string.gsub(text, "...Hanno un alone di &lt;r&gt;&lt;255,0,0:0,0,0&gt;luce rossa&lt;r&gt;", "")
  end
  local bright = string.find(text, "alone luminoso")
  if (bright) then
    text = string.gsub(text, "...Ha un &lt;r&gt;&lt;255,255,255:0,0,0&gt;alone luminoso&lt;r&gt;", "")
    text = string.gsub(text, "...Hanno un &lt;r&gt;&lt;255,255,255:0,0,0&gt;alone luminoso&lt;r&gt;", "")
  end
  local noisy = string.find(text, "forte ronzio")
  if (noisy) then
    text = string.gsub(text, "...Emette un &lt;r&gt;&lt;128,128,128:0,0,0&gt;forte ronzio&lt;r&gt;", "")
    text = string.gsub(text, "...Emettono un &lt;r&gt;&lt;128,128,128:0,0,0&gt;forte ronzio&lt;r&gt;", "")
  end
  local brittle = string.find(text, "molto fragil")
  if (brittle) then
    text = string.gsub(text, "...&lt;0,128,128:0,0,0&gt;Sembra molto fragile", "")
    text = string.gsub(text, "...&lt;0,128,128:0,0,0&gt;Sembrano molto fragili", "")
  end
  text = ui.fRemoveArticle(text)
  return text, statusColor, good, evil, bring, noisy, brittle
end
--
function ui.fExpandVariables(value, toAlias)
  if (toAlias) then
    value = string.gsub(value, "#", '"..__mtchs2__.."')
    value = string.gsub(value, ui.varID.."(%w+)", '"..ui.variables.%1.."')
  else
    value = string.gsub(value, ui.varID.."(%w+)", "ui.variables.%1")
  end
  --
  for varName in string.gfind(value, "ui.variables%.(%w+)") do
    if (not ui.variables[varName]) then
      return nil, varName
    elseif (not toAlias) then
      value = string.gsub(value, "ui.variables%.(%w+)", ui.variables[varName])
    end
  end
  return value, nil
end
--
function ui.fGetCommandFormattedText(command)
  return ui.cCommand..command.."&lt;reset&gt;"
end
--
function ui.fGetOperatorFormattedText(operator)
  return ui.cOperator..operator.."&lt;reset&gt;"
end
--
function ui.fGetInputFormattedText(input)
  return ui.cInput..input.."&lt;reset&gt;"
end
--
function ui.fExpandCommand(value)
  if string.match(value, "/") then
    return string.split(value, "%s*/%s*")
  end
  return string.split(value, "%s*;%s*")
end
--
-- Expand button name. Es. ui.fExpandButton("T5") -&gt; "t", 5
function ui.fExpandButton(button)
  local val = 0
  button = string.lower(button or "")
  if (string.find(button, "^[abcgot]%d$")) then
    return string.sub(button, 1, 1), tonumber(string.sub(button, 2, 2))
  end
  return nil, nil
end
--
function ui.fTitleCase(first, rest)
   return first:upper()..rest:lower()
end
--
function ui.fExecutePath(table, option)
  if (not option) then
    -- execute all
    for i = 1, #table do
      expandAlias(table[i])
    end
--[[    if (#table == 1) then
      -- Execute first (alone)
      expandAlias(table[1])
    else
      -- Show all
      for i = 1, #table do
        cecho(ui.fGetNumberFormattedText(i).." "..ui.fGetAliasOutputFormattedText(table[i]).."\n")
      end
    end
]]
  else
    local itemNumber = tonumber(option)
    if (itemNumber) then
      if (itemNumber == 0) then
        -- Show all
        for i = 1, #table do
          cecho(ui.fGetNumberFormattedText(i).." "..ui.fGetAliasOutputFormattedText(table[i]).."\n")
        end
      elseif (itemNumber &gt;= 1) and (itemNumber &lt;= #table) then
        expandAlias(table[itemNumber])
      else
        ui.fError("Indice non valido.")
      end
    else
      -- execute command for all (es. tell Pippo)
      for i = 1, #table do
        send(option.." "..i..") "..table[i]:gsub("(%s*;%s*)", " | "))
      end    
    end
  end
end
--
function ui.fDeleteDirectory(dir)
  local lfs = require('lfs')
  local deletedir
  deletedir = function(dir)
    for file in lfs.dir(dir) do
      local file_path = dir..'/'..file
      if file ~= "." and file ~= ".." then
        if lfs.attributes(file_path, 'mode') == 'file' then
          os.remove(file_path)
        elseif lfs.attributes(file_path, 'mode') == 'directory' then
          deletedir(file_path)
        end
      end
    end
    lfs.rmdir(dir)
  end
  --
  deletedir(dir)
end
--
function ui.fCopyFile(old_path, new_path)
  local old_file = io.open(old_path, "rb")
  local new_file = io.open(new_path, "wb")
  local old_file_sz, new_file_sz = 0, 0
  if not old_file or not new_file then
    return false
  end
  --
  local block = old_file:read(2^13)
  while block do
    new_file:write(block)
    block = old_file:read(2^13)
  end
  --
  old_file_sz = old_file:seek("end")
  old_file:close()
  --
  new_file_sz = new_file:seek("end")
  new_file:close()
  return new_file_sz == old_file_sz
end</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>Group</name>
					<packageName></packageName>
					<script>--
function ui.fUpdateGroup()
  -- Show 10 members max
  local nGroupMembers = ui.enDebug and math.random(0, 12) or ui.totalMember
  local wndH = GUI.Group.Main.Body:get_height();
  local wndW = GUI.Group.Main.Body:get_width();
  local memberH = 55
  local memberW = 100;
  local nCol = 2;
  local nRow = 5;
  local i = 1
  local mod
  --
  if (nGroupMembers &lt;= math.floor(wndH / memberH)) then
    nCol = 1;
  end
  nRow = math.min(10/nCol, math.floor(wndH / memberH));
  memberW = wndW / nCol;
  --
  if nGroupMembers &gt; 10 then
    nGroupMembers = 10
  end
  --
  for r = 1, nRow do
    for c = 1, nCol do
      i = (r-1)*nCol + c; 
      mod = i % 10
      --
      GUI.Group.Main.Body["g"..mod]:resize(memberW-5, memberH-5)
      GUI.Group.Main.Body["g"..mod]:move((c-1)*memberW, (r-1)*memberH)
      if (i &gt; nGroupMembers) then
        GUI.Group.Main.Body["g"..mod]:hide();
        ui.fAssignTargetButton("g"..mod, nil)
      else
        local memberName = ui.enDebug and "D3Bu4 G"..i or (ui.group[i][1] or "")
        local isLeader = ui.enDebug and true or (ui.group[i][2] or false)
        local memberHp = ui.enDebug and math.random(0, 100) or (ui.group[i][3] or 0)
        local memberMana = ui.enDebug and math.random(0, 100) or (ui.group[i][4] or 0)
        local memberPow = ui.enDebug and math.random(0, 100) or (ui.group[i][5] or 0)
        --
        --GUI.Group.Main.Body["g"..mod].Health.front:echo(ansi2string(memberName))
        GUI.Group.Main.Body["g"..mod].Health:setValue(memberHp, 100, memberHp.."% "..ansi2string(memberName))
        GUI.Group.Main.Body["g"..mod].Mana:setValue(memberMana, 100)
        GUI.Group.Main.Body["g"..mod].Stamina:setValue(memberPow, 100)
        --
        if (ui.enDebug) then
          isLeader = (mod == nGroupMembers)
        end
        
        if (isLeader) then
          GUI.Group.Main.Body["g"..mod].Gem:show()
        else
          GUI.Group.Main.Body["g"..mod].Gem:hide()
        end
        GUI.Group.Main.Body["g"..mod]:show();
        ui.fAssignTargetButton("g"..mod, memberName)
      end
    end
  end
  --
  for g = i+1, 10 do
    mod = g % 10
    GUI.Group.Main.Body["g"..mod]:hide()
    ui.fAssignTargetButton("g"..mod, nil)
  end
  --
  GUI.Group:setTitle("Gruppo ["..nGroupMembers.."]")
end</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>Help</name>
					<packageName></packageName>
					<script>--
function ui.fHelp(cmd)
  local line
  -- Restore widget
  clearWindow("GUI.Help.Main.Body.Console")
  GUI.Help:show()
  --
  -- Command
  if cmd and cmd ~= "" then
    cmd = cmd:lower():gsub(" ","_")
    if not ui.help[cmd] then
      cmd = "error"
    end
  else
    cmd = "help"
  end
  --
  -- Pharse lines
  for line in ui.help[cmd]:gmatch("([^\n]*)\n") do
    local str_match, end_match  = rex.find(line, [[\&lt;(?&lt;tag&gt;[^&gt;\s]+)(?&lt;argument&gt;\s*[^&gt;]*)\&gt;(?&lt;inside&gt;.*?)\&lt;\/\k&lt;tag&gt;\&gt;]])
    while (str_match) do
      local before = ""
      local match  = string.sub(line, str_match, end_match);
      local after  = ""
      local tag, argument, inside = rex.match(match, [[\&lt;(?&lt;tag&gt;[^&gt;\s]+)(?&lt;argument&gt;\s*[^&gt;]*)\&gt;(?&lt;inside&gt;.*?)\&lt;\/\k&lt;tag&gt;\&gt;]])
      --
      if (str_match &gt; 1) then
        before = string.sub(line, 1, str_match-1);
      end
      --
      if (end_match &lt; string.len(line)) then
        after = string.sub(line, end_match+1, string.len(line));
      end
      --
      -- Before
      GUI.Help.Main.Body.Console:cecho(before)
      --
      -- Match
      tag = tag:lower()
      if (tag == "alias") then
        inside = ui.fGetAliasFormattedText(inside)          
        GUI.Help.Main.Body.Console:cecho(inside)
      elseif (tag == "aliasname") then
        inside = ui.fGetAliasNameFormattedText(inside)
        GUI.Help.Main.Body.Console:cecho(inside)
      elseif (tag == "aliasoutput") then
        inside = ui.fGetAliasOutputFormattedText(inside)
        GUI.Help.Main.Body.Console:cecho(inside)
      elseif (tag == "button") then
        inside = ui.cAliasButton..inside.."&lt;reset&gt;"          
        GUI.Help.Main.Body.Console:cecho(inside)
      elseif (tag == "command") then
        inside = ui.fGetCommandFormattedText(inside)
        GUI.Help.Main.Body.Console:cecho(inside)
      elseif (tag == "exec") then
        argument = string.trim(argument);
        GUI.Help.Main.Body.Console:fg("orange")
        GUI.Help.Main.Body.Console:setUnderline(true)
        GUI.Help.Main.Body.Console:echoLink(inside, [[expandAlias("]]..argument..[[")]], argument, true)
        GUI.Help.Main.Body.Console:setUnderline(false)
        GUI.Help.Main.Body.Console:resetFormat()
      elseif (tag == "input") then
        inside = ui.fGetInputFormattedText(inside)          
        GUI.Help.Main.Body.Console:cecho(inside)
      elseif (tag == "keybind") then
        inside = ui.cKeybind..inside.."&lt;reset&gt;"          
        GUI.Help.Main.Body.Console:cecho(inside)        
      elseif (tag == "link") then
        argument = string.trim(argument);
        GUI.Help.Main.Body.Console:fg("yellow")
        GUI.Help.Main.Body.Console:setUnderline(true)
        GUI.Help.Main.Body.Console:echoLink(inside, [[ui.fHelp("]]..argument..[[")]], argument, true)
        GUI.Help.Main.Body.Console:setUnderline(false)
        GUI.Help.Main.Body.Console:resetFormat()
      elseif (tag == "profile") then
        inside = ui.fGetProfileNameFormattedText(inside)
        GUI.Help.Main.Body.Console:cecho(inside)
      elseif (tag == "title") then
        inside = ui.fTitle(inside)
        GUI.Help.Main.Body.Console:cecho(inside)
      elseif (tag == "var") then
        inside = ui.fGetVarFormattedText(inside)
        GUI.Help.Main.Body.Console:cecho(inside)
      elseif (tag == "varname") then
        inside = ui.cVarName..inside.."&lt;reset&gt;"
        GUI.Help.Main.Body.Console:cecho(inside)
      elseif (tag == "varvalue") then
        inside = ui.fGetVarValueFormattedText(inside)          
        GUI.Help.Main.Body.Console:cecho(inside)
      else
        -- Match non riconosciuto
        GUI.Help.Main.Body.Console:cecho(match)
      end
      --
      line = after
      str_match, end_match = rex.find(line, [[\&lt;(?&lt;tag&gt;[^&gt;\s]+)(?&lt;argument&gt;\s*[^&gt;]*)\&gt;(?&lt;inside&gt;.*?)\&lt;\/\k&lt;tag&gt;\&gt;]])
    end
    --
    -- line\after
    GUI.Help.Main.Body.Console:cecho(line.."\n")
  end
end
--
function ui.fHelp_links(htext, hlinktext, hurl, hcaption)
  if htext ~= nil and hlinktext ~= nil and hurl ~= nil and hcaption ~= nil then
    GUI.Help:cecho(ui.cText..htext.." ")
    GUI.Help:cechoLink(ui.cLink..hlinktext..ui.cText.."\n",
              [[openWebPage("https://]]..hurl..[[")]],
              hcaption,
              true)
  end
end</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>Highlights</name>
					<packageName></packageName>
					<script>--
function ui.fGetHighlightFormattedText(highlight)
  if (ui.highlights[highlight]) then
    return "&lt;"..ui.highlights[highlight].color.."&gt;"..highlight.."&lt;reset&gt;"
  end
  return ""
end
--
function ui.fShowAllHighlights()
  local i = 0
  local num
  cecho(ui.fTitle("Highlights"))
  for highlight in pairs(ui.highlights) do
    i = i + 1
    cecho(ui.fGetNumberFormattedText(i).." "..ui.fGetHighlightFormattedText(highlight).."\n")
  end
  if (i&gt;0) then
    echo("\n")
  else
    cecho("Per maggiori info "..ui.fGetCommandFormattedText("ui.fHelp uihighlights").."\n\n")
  end
end
--
function ui.fRemoveHighlight(highlight)
  if (ui.highlights[highlight]) then
    if (ui.highlights[highlight].id) then
      killTrigger(ui.highlights[highlight].id)
    end
    ui.highlights[highlight] = nil
    return true
  end
  return false
end
--
function ui.fRemoveAllHighlights()
  for highlight in pairs(ui.highlights) do
    ui.fRemoveHighlight(highlight)
  end
  ui.highlights = {}
end
--
function ui.fAddHighlight(highlight, color)
  if ui.fColorCheck(color) then
    highlight = highlight or "" 
    if (highlight ~= "") then
      -- Init highlight (if not exist)
      ui.highlights[highlight] = ui.highlights[highlight] or {}
      -- Remove old highlight
      if (ui.highlights[highlight].id) then
        killTrigger(ui.highlights[highlight].id)
      end
      -- Create trigger
      ui.highlights[highlight].id = tempRegexTrigger([[(?i)(?:^|\W|\s)(]]..highlight..[[)(?:\W|$|\s)]], function()
                                                                                                          selectString(matches[2], 1)
                                                                                                          fg(color)
                                                                                                          resetFormat()
                                                                                                        end)
      ui.highlights[highlight].color = color
      return 1
    end
    return -1 -- Invaid text
  end
  return -2 -- Invalid color
end
--
-- Save Highlights data from file
function ui.fSaveFileHighlights()
  local highlightsDataToSave = {}
  for highlight in pairs(ui.highlights) do
    highlightsDataToSave[highlight] = {}
    highlightsDataToSave[highlight].color = ui.highlights[highlight].color
  end
  table.save(ui.fileHighlights, highlightsDataToSave)
end
--
-- Read Highlights data from file
function ui.fReadFileHighlights()
  -- Remove actual Highlights
  ui.highlights = ui.highlights or {}
  ui.fRemoveAllHighlights()
  -- Load Highlights
  if (io.exists(ui.fileHighlights)) then
    table.load(ui.fileHighlights, ui.highlights)
  end
  --
  -- Create Highlights
  for highlight in pairs(ui.highlights) do
    ui.fAddHighlight(highlight, ui.highlights[highlight].color)
  end
end</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>Keybind</name>
					<packageName></packageName>
					<script>--
function ui.fGetKeybFormattedText(keybind)
  if (keybind) then
    return ui.cKeybind.."["..keybind.."]".."&lt;reset&gt;"
  end
  return ""
end
--
-- Validate 3 keys for keybind (order: mod1 mod2 key)
function ui.fGetKeyb(key1, key2, key3)
  local isValid = false;
  local mod1 = "";
  local mod2 = "";
  local key = "";
  local keybind = ""
  key1 = string.upper(key1 or "")
  key2 = string.upper(key2 or "")
  key3 = string.upper(key3 or "")
  if (key3 ~= "") then  -- es: key1=CTRL key2=ALT key3=F1
    if (key1 ~= key2) and
       (table.contains(ui.keyb_modifier, key1)) and
       (table.contains(ui.keyb_modifier, key2)) and
       (table.contains(ui.keyb_single,   key3)) then
      local idx1 = table.index_of(table.keys(ui.keyb_modifier), key1)
      local idx2 = table.index_of(table.keys(ui.keyb_modifier), key2)
      mod1 = idx1 &lt; idx2 and key2 or key1
      mod2 = idx1 &lt; idx2 and key1 or key2
      key = key3
      isValid = true
    end
  elseif (key2 ~= "") then  -- es: key1=CTRL key2=F1
    if (table.contains(ui.keyb_modifier, key1) and table.contains(ui.keyb_single, key2))then
      mod1 = key1
      mod2 = ""
      key = key2
      isValid = true
    end
  elseif (key1~= "") then -- es: key1=F1
    if (table.contains(ui.keyb_single, key1)) then
      mod1 = ""
      mod2 = ""
      key = key1
      isValid = true
    end
  else
    mod1 = ""
    mod2 = ""
    key = ""
    isValid = true
  end
  if (mod2 ~= "") then
    keybind = string.gsub(mod1 or "", "(%a)([%w_']*)", ui.fTitleCase).."+"..
               string.gsub(mod2 or "", "(%a)([%w_']*)", ui.fTitleCase).."+"..
               string.gsub(key or "", "(%a)([%w_']*)", ui.fTitleCase)
  elseif (mod1 ~= "") then
    keybind = string.gsub(mod1 or "", "(%a)([%w_']*)", ui.fTitleCase).."+"..
               string.gsub(key or "", "(%a)([%w_']*)", ui.fTitleCase)
  elseif (key ~= "") then
    keybind = string.gsub(key or "", "(%a)([%w_']*)", ui.fTitleCase)
  end
  return isValid, mod1, mod2, key, keybind
end
--
function ui.fSearchKeyb(table, keybind, excludeKey)
  keybind = keybind or ""
  excludeKey = excludeKey or ""
  if (keybind ~= "") and (table) then
    for key in pairs(table) do
      if (key ~= excludeKey) and (table[key].keybind == keybind) then
        return key
      end
    end
  end
  return nil
end
--
function ui.fShowAllKeyb()
  local orderTable = {}
  -- Order Target keybind
  for target in pairs(ui.targets) do
    orderTable[#orderTable+1] = target
  end
  table.sort(orderTable, function (target1, target2) 
                           keybind1 = ui.targets[target1].keybind or ""
                           keybind2 = ui.targets[target2].keybind or ""                  
                           if (rex.match(keybind1, [[F\d$]])) then
                             keybind1 = keybind1:gsub("F%w", "F0%1")                             
                           end
                           if (rex.match(keybind2, [[F\d$]])) then
                             keybind2 = keybind2:gsub("F%w", "F0%1")                             
                           end
                           return keybind1 &lt; keybind2
                         end )
  -- Show Target keybind
  cecho(ui.fTitle("Target keybind"))
  for i,target in ipairs(orderTable) do
    if (ui.targets[target].keybId) then
      if (ui.targets[target].target) then
        cecho(ui.fGetNumberFormattedText(i).." "..ui.fGetTargetFormattedText(target)..ui.fGetOperatorFormattedText(" » ")..ui.fGetVarNameFormattedText("target")..ui.fGetOperatorFormattedText(" = ")..ui.fGetVarValueFormattedText(ui.targets[target].target).."\n")
      else
        cecho(ui.fGetNumberFormattedText(i).." "..ui.fGetTargetFormattedText(target).."\n")
      end
    end
  end
  if (#orderTable==0) then
    cecho("Per maggiori info "..ui.fGetCommandFormattedText("ui.fHelp uikeybind").."\n")
  end
  -- Order Aliases keybind
  orderTable = {}
  for alias in pairs(ui.aliases) do
    if (ui.aliases[alias].keybId) then
      orderTable[#orderTable+1] = alias
    end
  end
  table.sort(orderTable, function (alias1, alias2) 
                           keybind1 = ui.aliases[alias1].keybind
                           keybind2 = ui.aliases[alias2].keybind                           
                           if (rex.match(keybind1, [[F\d$]])) then
                             keybind1 = keybind1:gsub("F%w", "F0%1")                             
                           end
                           if (rex.match(keybind2, [[F\d$]])) then
                             keybind2 = keybind2:gsub("F%w", "F0%1")                             
                           end
                           return keybind1 &lt; keybind2
                         end )
  -- Show Aliases keybind
  cecho(ui.fTitle("Aliases keybind"))
  for i,alias in ipairs(orderTable) do
    cecho(ui.fGetNumberFormattedText(i).." "..ui.fGetAliasFormattedText(alias).."\n")
  end
  if (#orderTable==0) then
    cecho("Per maggiori info "..ui.fGetCommandFormattedText("ui.fHelp uikeybind").."\n\n")
  else
    echo("\n")
  end
end
--
-- Delete keybind from a table
function ui.fRemoveKeyb(element)
  if (element) then
    if (element.mod1) then
      element.mod1 = nil
    end
    if (element.mod2) then
      element.mod2 = nil
    end
    if (element.key) then
      element.key = nil
    end
    if (element.keybind) then
      element.keybind = nil
    end
    if (element.keybId) then
      killKey(element.keybId)
      element.keybId = nil
      return 1 -- keyb removed
    end
    return -1 -- Not keyb to remove
  end
  return -2 -- Invalid element
end
--
function ui.fRemoveAllKeyb()
  for element in pairs(ui.aliases) do
    ui.fRemoveKeyb(ui.aliases[element])
  end
  for element in pairs(ui.targets) do
    ui.fRemoveKeyb(ui.targets[element])
  end
end
--
-- Set, modify or delete a keybind
function ui.fSetKeyb(table, tKey, code, key1, key2, key3)
  local isValid, mod1, mod2, key, keybind = ui.fGetKeyb(key1, key2, key3)
  if (table[tKey]) then
    if (isValid) then
      if (ui.fSearchKeyb(ui.targets, keybind, tKey) == nil) then
        if (ui.fSearchKeyb(ui.aliases, keybind, tKey) == nil) then
          -- Remove old keybind
          ui.fRemoveKeyb(table[tKey]);
          -- Create new keybind
          if (mod2 ~= "") then
            table[tKey].keybId = tempKey(ui.keyb_modifier[mod1] + ui.keyb_modifier[mod2], ui.keyb_single[key], code)
          elseif (mod1 ~= "") then
            table[tKey].keybId = tempKey(ui.keyb_modifier[mod1], ui.keyb_single[key], code)
          elseif (key ~= "") then
            table[tKey].keybId = tempKey(ui.keyb_single[key], code)
          else
            return 2, keybind -- keybind removed
          end
          -- Save data
          table[tKey].mod1 = mod1
          table[tKey].mod2 = mod2
          table[tKey].key = key
          table[tKey].keybind = keybind
          return 1, keybind -- keybind changed or created
        end
        return -4, keybind -- keybind already used in an alias
      end
      return -3, keybind -- keybind already used in a target
    end
    return -2, keybind -- Not valid keys
  end
  return -1, keybind -- Alias not exist
end
--
-- Save Targets data from file
function ui.fSaveFileTargets()
  local targetsDataToSave = {}
  for target in pairs(ui.targets) do
    targetsDataToSave[target] = {}
    targetsDataToSave[target].mod1 = ui.targets[target].mod1
    targetsDataToSave[target].mod2 = ui.targets[target].mod2
    targetsDataToSave[target].key = ui.targets[target].key
    targetsDataToSave[target].target = ui.targets[target].target
  end
  table.save(ui.fileTargets, targetsDataToSave)
end</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>Map/Compass</name>
					<packageName></packageName>
					<script>--
function ui.fGetPosition(line)
  local position = ""
  local icon = ""
  --
  -- Player icon or track direction
  if (ui.track == nil) or (ui.track == "") then
    icon = "&lt;255,255,255:30,24,24&gt;⨂&lt;69,69,69:30,24,24&gt;"
  else
    icon = ui.dirTokenColor[ui.track]..ui.dirToken[ui.track].."&lt;69,69,69:30,24,24&gt;"
  end
  --
  -- West side
  if ((line == 3) and (ui.position == "sud-ovest")) or
     ((line == 2) and (ui.position == "ovest")) or
     ((line == 1) and (ui.position == "nord-ovest")) then
    position = icon.."      "
  --
  -- Central side
  elseif ((line == 3) and (ui.position == "sud")) or
         ((line == 2) and (ui.position == "centro")) or
         ((line == 1) and (ui.position == "nord")) then
    position = "   "..icon.."   "
  --
  -- East side
  elseif ((line == 3) and (ui.position == "sud-est")) or
         ((line == 2) and (ui.position == "est")) or
         ((line == 1) and (ui.position == "nord-est")) then
    position = "      "..icon
  --
  --  No position in line
  else
    position = "       "
  end
  --
  return position
end
--
function ui.fGetToken(exits, dir)
  local token = ""
  if (table.contains(exits, dir)) then
    local idx = table.index_of(exits, dir)
    table.remove(exits, idx)
    --
    -- Close exit
    if (exits[idx]) and (exits[idx] == "(chiuso)") then
      token = "&lt;255,0,0:30,24,24&gt;"..ui.dirTokenClose[dir].."&lt;69,69,69:30,24,24&gt;"
      table.remove(exits, idx)
    --
    -- Secret exit
    elseif (exits[idx]) and (exits[idx] == "(segreto)") then
      token = "&lt;255,0,0:30,24,24&gt;"..ui.dirTokenSecret[dir].."&lt;69,69,69:30,24,24&gt;"
      table.remove(exits, idx)
    --
    -- From direction  
    elseif (ui.path[ui.idxPath]) and (ui.dirReverse[ui.path[ui.idxPath]] == dir ) then
      token = ui.dirTokenColor[dir]..ui.dirTokenFrom[dir].."&lt;69,69,69:30,24,24&gt;"
    --
    -- Normal exit
    else
      token = ui.dirTokenColor[dir]..ui.dirToken[dir].."&lt;69,69,69:30,24,24&gt;"
    end
  --
  -- No exit
  elseif (ui.dirTokenX[dir]) then
    token = ui.dirTokenX[dir]
  end
  --
  return token
end
--
function ui.fUpdateMap()
  local token
  local exits = {}
  --
  -- Generate directiones table
  ui.exits = {}
  for token in string.gmatch(ui.strExits, "[^%s]+") do
    local dir = string.lower(token)
    if (ui.dirCompress[dir]) then
      table.insert(exits, ui.dirCompress[dir]);
      table.insert(ui.exits, ui.dirCompress[dir]);
    else
      table.insert(exits, token);
    end
  end
  --
  clearWindow("GUI.MapCompass.Main.Body.Exits")
  clearWindow("GUI.MapCompass.Main.Body.OtherExits")
  --
  -- Room name
  GUI.MapCompass:setTitle(ui.roomName)
  --
  -- Exits and Position
  GUI.MapCompass.Main.Body.Exits:decho("&lt;69,69,69:30,24,24&gt;┌───"..ui.fGetToken(exits, "n").."───"..ui.fGetToken(exits, "u").."\n")
  GUI.MapCompass.Main.Body.Exits:decho("&lt;69,69,69:30,24,24&gt;│"..ui.fGetPosition(1).."│\n")
  GUI.MapCompass.Main.Body.Exits:decho("&lt;69,69,69:30,24,24&gt;"..ui.fGetToken(exits, "w")..ui.fGetPosition(2)..ui.fGetToken(exits, "e").."\n")
  GUI.MapCompass.Main.Body.Exits:decho("&lt;69,69,69:30,24,24&gt;│"..ui.fGetPosition(3).."│".."\n")
  GUI.MapCompass.Main.Body.Exits:decho("&lt;69,69,69:30,24,24&gt;"..ui.fGetToken(exits, "d").."───"..ui.fGetToken(exits, "s").."───┘\n")
  --
  -- Storico del percorso  
  local str;
  if (ui.idxPath == ui.memPath) then
    str = ui.idxPath;
  elseif (ui.memPath - ui.idxPath &lt;= 4) then 
    str = ui.memPath;
  elseif (ui.idxPath &gt; 4) then 
    str = ui.idxPath + 4;
  else
    str = 8;
  end
  --
  for i=str, str-7, -1 do
    if (ui.path[i]) then
      local dir = ui.path[i]
      --
      if (i&lt;=ui.idxPath) then
        dir = ui.dirReverse[dir]
      end
      --      
      if (i == ui.memPath) and (ui.idxPath == ui.memPath)then
        dir = "⨂ "..dir
      elseif (i == ui.idxPath) then
        dir = " ⨂ "..dir
      elseif (i == 1) and (ui.idxPath == 0) then
        dir = dir.." ⨂"
      end
      GUI.MapCompass.Main.Body.Exits:decho(dir)
    end
  end
  --
  -- Other exits
  if (table.size (exits) &gt; 0) then
    GUI.MapCompass.Main.Body.OtherExits:setFgColor("white")
    GUI.MapCompass.Main.Body.OtherExits:echo("Altre uscite:\n")
    while (exits[1] ~= nil) do
      token = exits[1]
      if (exits[2] ~= nil) and (exits[2] == "(chiuso)") then
        table.remove(exits, 2)
        token = "("..token..")"
      end
      GUI.MapCompass.Main.Body.OtherExits:decho(ui.dirToken["e"].." "..token.."\n")
      table.remove(exits, 1)
    end
  end
  --
  -- Room type
  GUI.MapCompass.Main.B2:echo("&lt;center&gt;"..ui.roomType)
end
--</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>Opponent (GMCP)</name>
					<packageName></packageName>
					<script>--
function ui.fIncrement_difTimer_o(time_left)
  if ui.difTimer_o then
    killTimer(ui.difTimer_o)
  end
  --
  if time_left &gt; 0 then
    ui.difTimer_o = tempTimer(1, function() ui.fIncrement_difTimer_o(time_left - 1) end)
    GUI.Opponent.Main.Health.dif:show()
  else
    GUI.Opponent.Main.Health.dif:hide()
  end
end
--
function ui.fUpdateOpponent()
  local title
  local hp
  local hpMax
  local levDif
  local hpDif = GUI.Opponent.Main.Health.front:get_width()
  --
  -- init last hp
  ui.parameters.last_hp_opponent = ui.parameters.last_hp_opponent or 0
  --
  if (ui.enDebug) then
    ui.variables.opponent_health     = math.random(0, 100)
    ui.variables.opponent_health_max = 100
    ui.variables.opponent_level      = math.random(0, 99)
    ui.variables.opponent_name       = "C4tt1v0ne"
  else
    ui.variables.opponent_health     = gmcp.MSDP.OPPONENT_HEALTH or ui.variables.opponent_health
    ui.variables.opponent_health_max = gmcp.MSDP.OPPONENT_HEALTH_MAX or ui.variables.opponent_health_max
    ui.variables.opponent_level      = gmcp.MSDP.OPPONENT_LEVEL or ui.variables.opponent_level
    ui.variables.opponent_name       = gmcp.MSDP.OPPONENT_NAME or ui.variables.opponent_name
  end
  --
  hp = tonumber(ui.variables.opponent_health) or 0
  hpMax = tonumber(ui.variables.opponent_health_max) or 0
  levDif = tonumber(ui.variables.level) - tonumber(ui.variables.opponent_level)
  --
  if (ui.variables.opponent_name ~= "") then
    --
    -- Showed name
    title = ui.variables.opponent_name;
    --
    -- Name
    ui.variables.opponent_name = string.gsub(ui.variables.opponent_name, "(\$c%d+)", "")
    ui.variables.opponent_name = ui.fRemoveArticle(ui.variables.opponent_name)
    ui.variables.opponent_name = string.gsub(ui.variables.opponent_name, " ", "-")
    --
    GUI.Opponent.Main.Health.front:echo(ui.variables.opponent_name)
    --
    -- Level color
    local color
    if (levDif &gt;= 5) then
      color = "white"
    elseif (levDif &gt;= 0) then
      color = "green"
    elseif (levDif &gt;= -5) then
      color = "orange"
    else
      color = "red"
    end
    --
    GUI.Opponent.Level:setFgColor(color)
    GUI.Opponent.Level:echo("&lt;center&gt;"..ui.variables.opponent_level)
    GUI.Opponent.Level:show()
    --
    -- HP
    GUI.Opponent.Main.Health:setValue(hp, hpMax,"&lt;p align=right&gt;"..hp.."%  &lt;/p&gt;")
    --
    -- Keybind
    ui.fAssignTargetButton("o0", ui.variables.opponent_name)    
  else
    --
    -- reset showed name
    title = "* nessuno *"    --
    --
    -- Remove name
    GUI.Opponent.Main.Health.front:echo("")
    --
    -- Hide level
    GUI.Opponent.Level:hide()
    --
    -- Reset HP
    GUI.Opponent.Main.Health:setValue(0, 100, "")
    --
    -- Remove Keybind
    ui.fAssignTargetButton("o0", nil)
  end
  --
  -- Diff. hp
  hpDif = GUI.Opponent.Main.Health.front:get_width() - hpDif
  if (hpDif ~= 0) then
    if (hpDif &lt; 0) then
      GUI.Opponent.Main.Health.dif:move(GUI.Opponent.Main.Health.front:get_x() - GUI.Opponent.Main:get_x() + GUI.Opponent.Main.Health.front:get_width(),
                                        GUI.Opponent.Main.Health.front:get_y() - GUI.Opponent.Main:get_y())
      GUI.Opponent.Main.Health.dif:resize(-hpDif,
                                          GUI.Opponent.Main.Health.front:get_height())
      --
      GUI.Opponent.Main.Health.dif:setStyleSheet(GUI.CSS.GaugeBack..[[
        qproperty-alignment: 'AlignRight';
        border: 1px solid rgba(255, 0, 0, 0.8);
        background-color: rgba(255, 0, 0, 0.4);
      ]])
      --
      GUI.Opponent.Main.Health.dif:echo("--")
    elseif (hpDif &gt; 0) then
      GUI.Opponent.Main.Health.dif:move(GUI.Opponent.Main.Health.front:get_x() - GUI.Opponent.Main:get_x() + GUI.Opponent.Main.Health.front:get_width() - hpDif,
                                        GUI.Opponent.Main.Health.front:get_y() - GUI.Opponent.Main:get_y() + 2)
      GUI.Opponent.Main.Health.dif:resize(hpDif - 1,
                                          GUI.Opponent.Main.Health.front:get_height() - 4)
      --
      GUI.Opponent.Main.Health.dif:setStyleSheet(GUI.CSS.GaugeBack..[[
        qproperty-alignment: 'AlignRight';
        border: 1px solid rgba(0, 255, 0, 0.8);
        background-color: rgba(0, 255, 0, 0.4);
      ]])
      --
      GUI.Opponent.Main.Health.dif:echo("++")
    end
    ui.fIncrement_difTimer_o(2)
  end
  ui.parameters.last_hp_opponent = hp;
  --
  -- Target on title
  if (ui.variables.target) and (ui.variables.target ~= "") then
    title = title.." (T:"..ui.variables.target..")"
  end
  GUI.Opponent:setTitle(title)
  table.save(ui.fileVariables, ui.variables)
end</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>Path</name>
					<packageName></packageName>
					<script>--
function ui.fGetNextNumber(text, index)
  local number = ""
  index = tonumber(index or 1)
  while (index&lt;=text:len()) and (string.match(string.lower(text:sub(index, index)), "[0123456789]")) do
    number = number..string.lower(text:sub(index, index))
    index = index + 1
  end
  if (number == "") then
    number = "1"
  end
  number = tonumber(number)
  return number, index
end
--s
function ui.fSavePath(dir)
  --if (ui.path[ui.idxPath]) and (dir == ui.dirReverse[ui.path[ui.idxPath]]) then
  --  ui.idxPath = ui.idxPath - 1
  --elseif (ui.path[ui.idxPath+1]) and (dir == ui.path[ui.idxPath+1]) then
  --  ui.idxPath = ui.idxPath + 1
  --else
  if (ui.idxPath &lt; ui.maxPath) then
    ui.idxPath = ui.idxPath + 1
    ui.path[ui.idxPath] = dir
    ui.memPath = ui.idxPath
  else
    for i=1, ui.maxPath-1 do
      ui.path[i] = ui.path[i+1]
    end
    ui.path[ui.maxPath] = dir    
    ui.idxPath = ui.maxPath
  end
end
--</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>Player (GMCP)</name>
					<packageName></packageName>
					<script>--
function ui.fIncrement_difTimer_p(time_left)
  if ui.difTimer_p then
    killTimer(ui.difTimer_p)
  end
  --
  if time_left &gt; 0 then
    ui.difTimer_p = tempTimer(1, function() ui.fIncrement_difTimer_p(time_left - 1) end)
    GUI.Player.Main.Health.dif:show()
  else
    GUI.Player.Main.Health.dif:hide()
  end
end
--
function ui.fUpdatePlayer()
  ui.variables.ac             = gmcp.MSDP.AC or ui.variables.ac
  ui.variables.alignment      = gmcp.MSDP.ALIGNMENT or ui.variables.alignment
  ui.variables.experience     = gmcp.MSDP.EXPERIENCE or ui.variables.experience
  ui.variables.money          = gmcp.MSDP.MONEY or ui.variables.money
  ui.variables.character_name = gmcp.MSDP.CHARACTER_NAME or ui.variables.character_name
  ui.variables.health         = gmcp.MSDP.HEALTH or ui.variables.health
  ui.variables.health_max     = gmcp.MSDP.HEALTH_MAX or ui.variables.health_max
  ui.variables.level          = gmcp.MSDP.LEVEL or ui.variables.level
  ui.variables.mana           = gmcp.MSDP.MANA or ui.variables.mana
  ui.variables.mana_max       = gmcp.MSDP.MANA_MAX or ui.variables.mana_max
  ui.variables.movement       = gmcp.MSDP.MOVEMENT or ui.variables.movement
  ui.variables.movement_max   = gmcp.MSDP.MOVEMENT_MAX or ui.variables.movement_max
  ui.variables.character_name = gmcp.MSDP.CHARACTER_NAME or ui.variables.character_name
  --
  -- for debug
  if (ui.enDebug) then
    ui.variables.health         = math.random(0, 100)
    ui.variables.health_max     = 100
    ui.variables.level          = math.random(0, 60)
    ui.variables.mana           = math.random(0, 100)
    ui.variables.mana_max       = 100
    ui.variables.movement       = math.random(0, 100)
    ui.variables.movement_max   = 100
    ui.variables.character_name = "D3Bu4 M0D3"
  end
  --
  -- HP
  local hp = tonumber(ui.variables.health) or hp
  local hpMax = tonumber(ui.variables.health_max) or hpMAx
  local hpPerc = 0
  local dif = GUI.Player.Main.Health.front:get_width()
  ui.parameters.last_hp = ui.parameters.last_hp or 0;
  --
  if (hpMax ~= 0) then 
    hpPerc = math.floor(100 * hp / hpMax) 
  end
  --
  if (hpPerc &lt; 40) and (hp &lt; ui.parameters.last_hp) then
    playSoundFile(ui.pathSnd..[[hurt.wav]], 10)
  end
  ui.parameters.last_hp = hp
  --
  -- Mana
  local mana = tonumber(ui.variables.mana)
  local manaMax = tonumber(ui.variables.mana_max)
  local manaPerc = 0
  ui.parameters.last_mana = ui.parameters.last_mana or 0;
  --
  if (manaMax ~= 0) then 
    manaPerc = math.floor(100 * mana / manaMax) 
  end
  --
  if (mana &lt; ui.parameters.last_mana) then
    playSoundFile(ui.pathSnd..[[cast.wav]], 10)
  end
  ui.parameters.last_mana = mana
  --
  -- Stamina
  local stamina = tonumber(ui.variables.movement)
  local staminaMax = tonumber(ui.variables.movement_max)
  local staminaPerc = 0
  --
  if (staminaMax ~= 0) then 
    staminaPerc = math.floor(100 * stamina / staminaMax) 
  end
  --
  -- Update variables
  table.save(ui.fileVariables, ui.variables)
  --
  if (ui.lastMoney) then
    if (ui.variables.money &lt; ui.lastMoney) then
      ui.fLog("&lt;255,0,0:30,24,24&gt;Perdi "..(ui.variables.money - ui.lastMoney).." monete d'oro.")
    elseif (ui.variables.money &gt; ui.lastMoney) then
      ui.fLog("&lt;0,255,0:30,24,24&gt;Guadagni "..(ui.variables.money - ui.lastMoney).." monete d'oro.")    
    end 
  end
  ui.lastMoney = ui.variables.money
  --
  -- Redraw widget
  GUI.Player:setTitle(ui.variables.character_name)
  GUI.Player.Level:echo("&lt;center&gt;"..ui.variables.level)
  GUI.Player.Main.Experience:setValue(ui.variables.experience, 300000000)
  GUI.Player.Main.Health:setValue(hpPerc, 100,"&lt;p align=right&gt;"..hp.."/"..hpMax.." - "..hpPerc.."% &lt;/p&gt;")
  GUI.Player.Main.Mana:setValue(manaPerc, 100,"&lt;p align=right&gt;"..mana.."/"..manaMax.." - "..manaPerc.."% &lt;/p&gt;")
  GUI.Player.Main.Stamina:setValue(staminaPerc, 100,"&lt;p align=right&gt;"..stamina.."/"..staminaMax.." - "..staminaPerc.."% &lt;/p&gt;")
  --
  dif = GUI.Player.Main.Health.front:get_width() - dif
  if (dif &lt; 0) then
    GUI.Player.Main.Health.dif:move(GUI.Player.Main.Health.front:get_x() - GUI.Player.Main:get_x() + GUI.Player.Main.Health.front:get_width(),
                                    GUI.Player.Main.Health.front:get_y() - GUI.Player.Main:get_y());
    GUI.Player.Main.Health.dif:resize(-dif,
                                      GUI.Player.Main.Health.front:get_height())
    GUI.Player.Main.Health.dif:echo("- -")
    GUI.Player.Main.Health.dif:setStyleSheet(GUI.CSS.GaugeBack..[[
      qproperty-alignment: 'AlignRight';
      border: 1px solid rgba(255, 0, 0, 0.8);
      background-color: rgba(255, 0, 0, 0.4);
    ]])
    ui.fIncrement_difTimer_p(2)
  elseif (dif &gt; 0) then
    GUI.Player.Main.Health.dif:move(GUI.Player.Main.Health.front:get_x() - GUI.Player.Main:get_x() + GUI.Player.Main.Health.front:get_width() - dif,
                                    GUI.Player.Main.Health.front:get_y() - GUI.Player.Main:get_y() + 2)
    GUI.Player.Main.Health.dif:resize(dif-1,
                                      GUI.Player.Main.Health.front:get_height() - 4)
    GUI.Player.Main.Health.dif:echo("++")
    GUI.Player.Main.Health.dif:setStyleSheet(GUI.CSS.GaugeBack..[[
      qproperty-alignment: 'AlignRight';
      border: 1px solid rgba(0, 255, 0, 0.8);
      background-color: rgba(0, 255, 0, 0.4);
    ]])
    ui.fIncrement_difTimer_p(2)
  end
end</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>Profiles</name>
					<packageName></packageName>
					<script>--
function ui.fGetProfileNameFormattedText(profile)
  return ui.cProfileName..profile.."&lt;reset&gt;"
end
--
--
function ui.fInitProfiles()
  local lfs = require("lfs")
  --
  if (lfs.chdir(ui.pathPrf)) then
    ui.fDebug("ui.fInitProfiles() - Cartella profili inizializzata correttamente.")
  elseif (lfs.mkdir(ui.pathPrf)) then
    ui.fDebug("ui.fInitProfiles() - Cartella profili creata correttamente.")
  else
    ui.fDebug("ui.fInitProfiles() - Impossibile caricare la cartella profili.")
  end
end
--
-- Get saved profiles list
function ui.fGetProfiles()
  local lfs = require("lfs")
  local profiles = {}
  --
  if (lfs.chdir(ui.pathPrf)) then
    for profile in lfs.dir(ui.pathPrf) do
      if (profile~=".") and (profile~="..") and (lfs.chdir(ui.pathPrf..profile)) then
        profiles[#profiles+1] = profile
      end
    end
  end
  return profiles
end
--
function ui.fContainProfile(profiles, profile)
  for _, p in pairs(profiles) do
    if (p == profile) then
      return true
    end
  end
  return false;
end
--
-- List all aliases
function ui.fShowAllProfiles()
  local profiles = ui.fGetProfiles()
  local nProfiles = 0
  --
  cecho(ui.fTitle("Profili"))
  for profile in ui.fOrderedPairs(profiles) do
    nProfiles = nProfiles + 1
    cecho(ui.fGetNumberFormattedText(nProfiles).." "..ui.fGetProfileNameFormattedText(profiles[profile]).."\n")
  end
  --
  if (nProfiles&gt;0) then
    echo("\n")
  else
    cecho("Per maggiori info "..ui.fGetCommandFormattedText("uihelp uiprofiles").."\n\n")
  end
end
--
function ui.fLoadProfile(profile)
  local profiles = ui.fGetProfiles()
  if (ui.fContainProfile(profiles, profile)) then
    --
    -- Load variables
    if (ui.fCopyFile(ui.pathPrf..profile.."/"..ui.fileNameVariables, ui.fileVariables)) then
      ui.fDebug("Reload 'Variables' from file")
      ui.fReadFileVariables()
    end
    --
    -- Load targets
    if (ui.fCopyFile(ui.pathPrf..profile.."/"..ui.fileNameTargets, ui.fileTargets)) then
      ui.fDebug("Reload Load 'Targets' from file")
      ui.fReadFileTargets()
    end
    --
    -- Load Aliases
    if (ui.fCopyFile(ui.pathPrf..profile.."/"..ui.fileNameAliases, ui.fileAliases)) then
      ui.fDebug("Reload 'Aliases' from file")
      ui.fReadFileAliases()
    end
    --
    -- Load Highlights
    if (ui.fCopyFile(ui.pathPrf..profile.."/"..ui.fileNameHighlights, ui.fileHighlights)) then
      ui.fDebug("Reload Load 'Highlights' from file")
      ui.fReadFileHighlights()
    end
    -- Refresh widget
    ui.fUpdateTarget()
    ui.fUpdateOpponent()
    ui.fUpdateGroup() 
    ui.fUpdatePlayer()
    ui.fUpdateAllAliasButton()
    --
    return true
  end
  return nil
end
--
function ui.fRemoveProfile(profile)
  local profiles = ui.fGetProfiles()
  if (ui.fContainProfile(profiles, profile)) then
    ui.fDeleteDirectory(ui.pathPrf..profile)
    return true
  end
  return nil
end
--
function ui.fRemoveAllProfiles()
  local profiles = ui.fGetProfiles()
  for profile in pairs(profiles) do
    ui.fDeleteDirectory(ui.pathPrf..profiles[profile])
  end
  return true
end
--
function ui.fSaveProfile(profile)
  local lfs = require("lfs")
  local profiles = ui.fGetProfiles()
  --
  if (ui.fContainProfile(profiles, profile)) then
    ui.fDeleteDirectory(ui.pathPrf..profile)
  end
  --
  if (lfs.mkdir(ui.pathPrf..profile)) then
    ui.fCopyFile(ui.fileAliases,    ui.pathPrf..profile.."/"..ui.fileNameAliases)
    ui.fCopyFile(ui.fileHighlights, ui.pathPrf..profile.."/"..ui.fileNameHighlights)
    ui.fCopyFile(ui.fileTargets,    ui.pathPrf..profile.."/"..ui.fileNameTargets)
    ui.fCopyFile(ui.fileVariables,  ui.pathPrf..profile.."/"..ui.fileNameVariables)
    return true
  end
  return nil
end</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>Targets</name>
					<packageName></packageName>
					<script>--
function ui.fGetTargetChild(type, number)
  if (type == "g") then
    return GUI.Group.Main.Body[type..number];
  elseif (type == "o") then
    return GUI.Opponent.Main
  elseif (type == "t") then
    return GUI.TargetButtons.Main.Body[type..number]
  else
    return nil
  end
end
--
function ui.fGetTargetFormattedText(target)
  local str = ui.cTarget.."["..target.."]"
  if (ui.targets[target]) and (ui.targets[target].keybId) then
    str = str.." "..ui.fGetKeybFormattedText(ui.targets[target].keybind)
  end
  return str.."&lt;reset&gt;"
end
--
-- Refresh target button
function ui.fRefreshTargetButton(button)
  local type, number = ui.fExpandButton(button)
  local child = ui.fGetTargetChild(type, number)
  --
  if (child ~= nil) then
    button = type..number 
    if (ui.targets[button]) then
      local mod1 = ui.targets[button].mod1 or "";
      local mod2 = ui.targets[button].mod2 or "";
      local key = ui.targets[button].key or "";
      local result, keybind
      local target
      local CCS, bgColor
      -- Target
      if (ui.targets[button].target) and (ui.targets[button].target ~= "") then
        target = ui.targets[button].target
      else
        target = "'"..button.."'";
      end
      -- Keybind
      if (mod2 ~= "") then
        result, keybind = ui.fSetKeyb(ui.targets, button, [[ui.fExecuteTargetButton("]]..button..[[")]], mod2, mod1, key)
      elseif (mod1 ~= "") then
        result, keybind = ui.fSetKeyb(ui.targets, button, [[ui.fExecuteTargetButton("]]..button..[[")]], mod1, key)
      elseif (key ~= "") then
        result, keybind = ui.fSetKeyb(ui.targets, button, [[ui.fExecuteTargetButton("]]..button..[[")]], key)
      else
        result, keybind = ui.fSetKeyb(ui.targets, button, [[ui.fExecuteTargetButton("]]..button..[[")]])
      end
      if (result &lt;= 0) then
        ui.fRemoveKeyb(ui.targets[button])
      end
      -- Echo
      child.keybind:echo("&lt;center&gt;"..keybind)
      -- CCS
      if (type == "g") then
        CCS = GUI.CSS.Border3;
        bgColor = "150,150,0"
      elseif (type == "o") then
        CCS = GUI.CSS.Border3;
        bgColor = "150,0,0"
      elseif (type == "t") then
        GUI.TargetButtons.Main.Body[button]:echo("&lt;center&gt;"..target)
        CCS = GUI.CSS.Target;
        bgColor = "150,0,0"
      end
      --
      if (target == ui.variables["target"]) then
        child:setStyleSheet([[
          QLabel{
            ]]..CCS..[[
            background-color: rgba(]]..bgColor..[[,1);
          }
        ]])
      else
        child:setStyleSheet([[
          QLabel{
            ]]..CCS..[[
            background-color: rgba(]]..bgColor..[[,.4);
          }
          QLabel::hover{
            ]]..CCS..[[
            background-color: rgba(]]..bgColor..[[,1);
          }
        ]])
      end
      return true
    end
  end
  return false
end
-- 
-- Refresh all target button
function ui.fUpdateAllTargetButton()
  for i=0, 9 do
    if (i &gt;= 1) and (i &lt;= 4) then
      ui.fRefreshTargetButton("t"..i)
    end
    ui.fRefreshTargetButton("g"..i)
  end
  ui.fRefreshTargetButton("o0")
end
--
-- Refresh Target
function ui.fUpdateTarget()
  if (not ui.variables.target) or (ui.variables.target == "") then
    GUI.TargetButtons:setTitle("Target")
  else
    GUI.TargetButtons:setTitle("Target: "..ui.variables["target"])
  end
end
--
-- Assign Target button
function ui.fAssignTargetButton(button, value)
  local ret = 0;
  local type, number = ui.fExpandButton(button)
  if (type == "g") or (type == "o") or (type == "t") then
    button = type..number
    ui.targets[button] = ui.targets[button] or {}
    ui.targets[button].target = value
    ui.fUpdateAllTargetButton()
    ui.fUpdateTarget()
    ui.fSaveFileTargetButtons()
    return 1 -- Value assigned (can be nil)
  end
  return -1 -- Invaid button
end
--
-- Execute Target button
function ui.fExecuteTargetButton(button)
  local type, number = ui.fExpandButton(button)
  if (type == "g") or (type == "o") or (type == "t") then
    button = type..number
    if (ui.targets[button]) and (ui.targets[button].target) then
      if (ui.variables["target"] == ui.targets[button].target) then
        ui.variables["target"] = ""
        ui.fEcho2n(ui.fGetTargetFormattedText(button).." nessun "..ui.fGetVarNameFormattedText("target").." selezionato")
      else
        ui.variables["target"] = ui.targets[button].target
        ui.fEcho2n(ui.fGetTargetFormattedText(button).." "..ui.fGetVarNameFormattedText("target").." impostato su "..ui.fGetVarValueFormattedText(ui.variables.target).."&lt;reset&gt;.")
      end
      ui.fUpdateTarget()
    elseif (type == "g") then
      ui.fEcho2n("Nessun componente del gruppo da associare a "..ui.fGetTargetFormattedText(button)..".")
    elseif (type == "o") then
      ui.fEcho2n("Nessun avversario ingaggiato da associare a "..ui.fGetTargetFormattedText(button)..".")
    elseif (type == "t") then
      ui.fEcho2n(ui.fGetTargetFormattedText(button).." non configurato. Usare il comanto "..ui.fGetCommandFormattedText(button.." &lt;testo&gt;").." per configurare.")
    end
    -- Save @target
    table.save(ui.fileVariables, ui.variables)
    ui.fUpdateAllTargetButton()
  else
    ui.fEcho2n(ui.fGetTargetFormattedText(button).." pulsante non valido.")
  end
  ui.fUpdateOpponent()
end
--
-- Save buttons data from file
function ui.fSaveFileTargetButtons()
  local targetsDataToSave = {}
  for button in pairs(ui.targets) do
    targetsDataToSave[button] = {}
    targetsDataToSave[button].target = ui.targets[button].target
    targetsDataToSave[button].mod1 = ui.targets[button].mod1
    targetsDataToSave[button].mod2 = ui.targets[button].mod2
    targetsDataToSave[button].key = ui.targets[button].key
  end
  table.save(ui.fileTargets, targetsDataToSave)
end
--
-- Read Targets data from file
function ui.fReadFileTargets()
  -- Remove actual Targets
  ui.targets = {}
  -- Load Targets
  if (io.exists(ui.fileTargets)) then
    table.load(ui.fileTargets, ui.targets)
  else
    -- Update only if file targets not esist otherwise it would reassign any removed keys
    ui.targets = table.update(ui.pre_defined_target_buttons, ui.targets)
  end
  -- Save
  table.save(ui.fileTargets, ui.targets)
end
--</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>Tick</name>
					<packageName></packageName>
					<script>function ui.fIncrementTickTimer(time_left)
  if time_left + 1 &lt;= 75 then
    time_left = time_left + 1
  else
    if (ui.enDebug) then
      time_left = 70      
    else
      time_left = 1
    end
    ui.fTickUpdateAffects()
  end
  if ui.ticktimer then
    killTimer(ui.ticktimer)
  end
  ui.ticktimer = tempTimer(1, function() ui.fIncrementTickTimer(time_left) end)
  GUI.Player.Main.Tick:setValue(time_left, 75)
end
</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>Variables</name>
					<packageName></packageName>
					<script>--
function ui.fGetVarNameFormattedText(varName)
  return ui.cVarID..ui.varID..ui.cVarName..varName.."&lt;reset&gt;"
end
--
function ui.fGetVarValueFormattedText(varValue)
  return ui.cVarCont..tostring(varValue)
end
--
function ui.fGetVarFormattedText(variable)
  if (ui.variables[variable]) then
    if (ui.variables[variable] == "") then
      return ui.fGetVarNameFormattedText(variable)
    end
    return ui.fGetVarValueFormattedText(ui.variables[variable])..ui.fGetVarNameFormattedText(variable)
  end
  return ""
end
--
function ui.fRemoveAllVariables()
  ui.variables = {}
  ui.variables = table.deepcopy(ui.pre_defined_variables)
end
--
function ui.fShowAllVar()
  local app = {}
  local numVar = 0
  local numPreVar = 0
  cecho(ui.fTitle("Variabili predefinite"))
  for variable in pairs(ui.variables) do
    local var = ui.fGetVarNameFormattedText(variable)
    if (ui.variables[variable]) and (ui.variables[variable]  ~= "") then
      var = var..ui.fGetOperatorFormattedText(" = ")..ui.fGetVarValueFormattedText(ui.variables[variable])
    end
    if (ui.pre_defined_variables[variable] == nil) then
      numVar = numVar + 1
      table.insert(app, ui.fGetNumberFormattedText(numVar).." "..var.."\n")
    else
      numPreVar = numPreVar + 1
      cecho(ui.fGetNumberFormattedText(numPreVar).." "..var.."\n")
    end
  end
  cecho(ui.fTitle("Variabili"))
  if (numVar&gt;0) then
    for data in pairs(app) do
      cecho(app[data])
    end
    echo("\n")
  else
    cecho("Per maggiori info "..ui.fGetCommandFormattedText("ui.fHelp uivariables").."\n\n")
  end
end
--
-- Read Variables data from file
function ui.fReadFileVariables()
  -- Remove actual Variables
  ui.variables = {}
  -- Load Variables
  if (io.exists(ui.fileVariables)) then
    table.load(ui.fileVariables, ui.variables)
  end
  --
  -- Merge pre defined variables
  ui.variables = table.update(ui.pre_defined_variables, ui.variables)
  -- Save
  table.save(ui.fileVariables, ui.variables)
end
--</script>
					<eventHandlerList />
				</Script>
			</ScriptGroup>
			<ScriptGroup isActive="yes" isFolder="yes">
				<name>Graphic elements</name>
				<packageName></packageName>
				<script></script>
				<eventHandlerList />
				<Script isActive="yes" isFolder="no">
					<name>Affects Widget</name>
					<packageName></packageName>
					<script>function ui.fInitAffectsWidget()
  --
  -- Alias buttons 
  GUI.Affect = Adjustable.Container:new2({
    name = "GUI.Affect",
    x = 0,
    y = 250,
    width = 300,
    height = 80,
    titleText ="Effetti",
    titleTxtColor = "orange",
    buttonsize = 12,
    buttonFontSize = 5,
    adjLabelstyle = GUI.CSS.AC, 
    buttonstyle = GUI.CSS.ACButtons,
  })
  --
  GUI.Affect.Main = Geyser.Label:new2({
    name = "GUI.Affect.Main",
    x = 3,
    y = 25,
    width = "100%-6",
    height = "100%-28",
  },GUI.Affect)
  --
  -- Border
  ui.fAddBorder(GUI.Affect.Main, 2)
  --
  -- Affect icon
  local i
  for i=1, 20 do
    local col = (i-1) % 10;
    local row = (i&lt;=10)and(0)or(1)
    --
    GUI["AffectIcon"..i] = Geyser.Label:new2({
      name = "GUI.AffectIcon"..i,
      x = 30*col,
      y = 30*row,
      width = 30,
      height = 30,
    }, GUI.Affect.Main.Body)
    GUI["AffectIcon"..i]:setStyleSheet(GUI.CSS.Affect);
    --
    -- Icon
    GUI["AffectIcon"..i].icon = Geyser.Label:new2({
      name = "GUI.AffectIcon"..i..".icon",
      x = 4, y = 4,
      width = -4,
      height = -5,
    }, GUI["AffectIcon"..i])
    GUI["AffectIcon"..i].icon:enableClickthrough() -- for tooltip
    GUI["AffectIcon"..i].icon:setStyleSheet(GUI.CSS.AffectIcon)
    GUI["AffectIcon"..i].icon:setFgColor("black");
    GUI["AffectIcon"..i].icon:setFontSize(5);
    --
    -- Time
    GUI["AffectIcon"..i].time = Geyser.Label:new2({
      name = "GUI.AffectIcon"..i..".time",
      x = 0, y = -1,
      width = 30,
      height = 10,
    }, GUI["AffectIcon"..i])
    GUI["AffectIcon"..i].time:setStyleSheet([[
      background-color: rgba(0, 0, 0, 0);
    ]])
    GUI["AffectIcon"..i].time:setFontSize(6);
    --
    GUI["AffectIcon"..i]:hide()
  end
  --
  -- Wrapping function
  local Minimize = GUI.Affect.minimize
  local Restore = GUI.Affect.restore
  --
  function GUI.Affect:minimize(...)
    GUI.Affect.Main:hide()
    return Minimize(GUI.Affect)
  end
  --
  function GUI.Affect:restore(...)
    GUI.Affect.Main:show()
    return Restore(GUI.Affect)
  end
end</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>Alias Buttons Widget</name>
					<packageName></packageName>
					<script>function ui.fInitAliasButtonsWidget()
  --
  -- Alias buttons 
  GUI.AliasButtons = Adjustable.Container:new2({
    name = "GUI.AliasButtons",
    x = 310,
    y = 0,
    width = 920,
    height = 130,
    titleText ="Pulsanti alias",
    titleTxtColor = "orange",
    buttonsize = 12,
    buttonFontSize = 5,
    adjLabelstyle = GUI.CSS.AC, 
    buttonstyle = GUI.CSS.ACButtons,
  })
  --
  --
  GUI.AliasButtons.Main = Geyser.Label:new2({
    name = "GUI.AliasButtons.Main",
     x = 3,
    y = 25,
    width = "100%-6",
    height = "100%-28",
  },GUI.AliasButtons)
  --
  -- Border
  ui.fAddBorder(GUI.AliasButtons.Main, 2)
  --
  -- Navigator box
  GUI.AliasButtons.Main.Body.Navigator = Geyser.Label:new2({
    name = "GUI.AliasButtons.Body.Main.Navigator",
    x = 0, 
    y = 0,
    width = 25,
    height = "100%",
    h_policy = Geyser.Fixed,
  },GUI.AliasButtons.Main.Body)
  --
  -- Up button
  GUI.AliasButtons.Main.Body.Navigator.Up = Geyser.Label:new2({
    name = "GUI.AliasButtons.Main.Body.Navigator.Up",
    x = 0, 
    y = 0,
    width = "100%",
    height = 25,
    v_policy = Geyser.Fixed,
  },GUI.AliasButtons.Main.Body.Navigator)
  GUI.AliasButtons.Main.Body.Navigator.Up:setStyleSheet([[border-image: url("]]..ui.pathImg..[[miniArrowUp.png")]]);
  GUI.AliasButtons.Main.Body.Navigator.Up:setClickCallback("ui.fIncraseButtonsPage")
  --
  -- Selected button page
  GUI.AliasButtons.Main.Body.Navigator.Page = Geyser.Label:new2({
    name = "GUI.AliasButtons.Main.Body.Navigator.Page",
    x = 0, 
    y = 25,
    width = 25,
    height = "100%-50",
  },GUI.AliasButtons.Main.Body.Navigator)
  GUI.AliasButtons.Main.Body.Navigator.Page:setColor(0, 0, 0, 0)
  --
  -- Down button
  GUI.AliasButtons.Main.Body.Navigator.Down = Geyser.Label:new2({
    name = "GUI.AliasButtons.Main.Body.Navigator.Down",
    x = 0, 
    y = "100%-25",
    width = "100%",
    height = 25,
    v_policy = Geyser.Fixed,
  },GUI.AliasButtons.Main.Body.Navigator)
  GUI.AliasButtons.Main.Body.Navigator.Down:setStyleSheet([[border-image: url("]]..ui.pathImg..[[miniArrowDown.png")]]);
  GUI.AliasButtons.Main.Body.Navigator.Down:setClickCallback("ui.fDecraseButtonsPage")
  --
  -- Alias Buttons Box
  GUI.AliasButtons.Main.Body.CButtons = GUI.CButtons or Geyser.Label:new({
    name = "GUI.AliasButtons.Main.Body.CButtons",
    x = 25, 
    y = 0,
    width = "100%-25",
    height = "100%",
  },GUI.AliasButtons.Main.Body)
  --
  -- Buttons
  for order=1,10 do
    local i = order % 10
    --
    -- Name
    GUI.AliasButtons.Main.Body.CButtons["Custom"..i] = Geyser.Label:new2({
      name = "GUI.AliasButtons.Main.Body.CButtons.Custom"..i,
      x = (10*i).."%", 
      y = 0,
      width = "10%",
      height = "100%",
    },GUI.AliasButtons.Main.Body.CButtons)
    GUI.AliasButtons.Main.Body.CButtons["Custom"..i]:setStyleSheet(GUI.CSS.AliasButtons);
    GUI.AliasButtons.Main.Body.CButtons["Custom"..i]:setClickCallback("ui.fClickAliasButton", i, nil)
    --
    -- Icon
    GUI.AliasButtons.Main.Body.CButtons["Custom"..i].icon = Geyser.Label:new2({
      name = "GUI.AliasButtons.Main.Body.CButtons.Custom"..i..".icon",
      x = 10, y = 10,
      width = -10,
      height = -10,
    }, GUI.AliasButtons.Main.Body.CButtons["Custom"..i])
    GUI.AliasButtons.Main.Body.CButtons["Custom"..i].icon:enableClickthrough()
    --
    -- Index
    GUI.AliasButtons.Main.Body.CButtons["Custom"..i].index = Geyser.Label:new2({
      name = "GUI.AliasButtons.Main.Body.CButtons.Custom"..i..".index",
      x = 0, y = 0,
      width = 25,
      height = 25,
      fontSize = 8,
    }, GUI.AliasButtons.Main.Body.CButtons["Custom"..i])
    GUI.AliasButtons.Main.Body.CButtons["Custom"..i].index:setStyleSheet([[border-image: url("]]..ui.pathImg..[[round.png") 0px stretch;]]);
    GUI.AliasButtons.Main.Body.CButtons["Custom"..i].index:enableClickthrough()
    --
    -- Keybid
    GUI.AliasButtons.Main.Body.CButtons["Custom"..i].keybind = Geyser.Label:new2({
      name = "GUI.AliasButtons.Main.Body.CButtons.Custom"..i..".keybind",
      x = 5, y = -15,
      width = -5,
      height = 15,
    }, GUI.AliasButtons.Main.Body.CButtons["Custom"..i])
    GUI.AliasButtons.Main.Body.CButtons["Custom"..i].keybind:enableClickthrough()
    GUI.AliasButtons.Main.Body.CButtons["Custom"..i].keybind:setStyleSheet(GUI.CSS.Keybind);
    GUI.AliasButtons.Main.Body.CButtons["Custom"..i].keybind:setFontSize(ui.parameters.fsKeybind);
  end
  --
  -- Wrapping function
  local Minimize = GUI.AliasButtons.minimize
  local Restore = GUI.AliasButtons.restore
  --
  function GUI.AliasButtons:minimize(...)
    GUI.AliasButtons.Main:hide()
    return Minimize(GUI.AliasButtons)
  end
  --
  function GUI.AliasButtons:restore(...)
    GUI.AliasButtons.Main:show()
    return Restore(GUI.AliasButtons)
  end
end</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>Equipment Widget</name>
					<packageName></packageName>
					<script>function ui.fInitEquipmentWidget()
  --
  -- Equip
  GUI.Equipment = Adjustable.Container:new2({
    name = "GUI.Equipment",
    x = 310,
    y = 140,
    width = 300,
    height = 500,
    titleText ="Equipaggiamento",
    titleTxtColor = "orange",
    buttonsize = 12,
    buttonFontSize = 5,
    adjLabelstyle = GUI.CSS.AC, 
    buttonstyle = GUI.CSS.ACButtons,
  })
  --
  GUI.Equipment.Main = Geyser.Label:new2({
    name = "GUI.Equipment.Main",
    x = 3,
    y = 25,
    width = "100%-6",
    height = "100%-28",
  },GUI.Equipment)
  --
  -- Border
  ui.fAddBorder(GUI.Equipment.Main, 1)
  --
  -- Body
  GUI.Equipment.Main.Body.Console = Geyser.MiniConsole:new2({
    name = 'GUI.Equipment.Main.Body.Console',
    x=0,
    y=0,
    width = "100%", 
    height = "100%",
    autoWrap = true,
    scrollBar = true,
  }, GUI.Equipment.Main.Body)
  GUI.Equipment.Main.Body.Console:setColor(30, 24, 24)
  GUI.Equipment.Main.Body.Console:setBgColor(30, 24, 24)
  GUI.Equipment.Main.Body.Console:setFontSize(ui.parameters.fsEquipment)
  --
  -- Wrapping function
  local Minimize = GUI.Equipment.minimize
  local Restore = GUI.Equipment.restore
  --
  function GUI.Equipment:minimize(...)
    GUI.Equipment.Main:hide()
    return Minimize(GUI.Equipment)
  end
  --
  function GUI.Equipment:restore(...)
    GUI.Equipment.Main:show()
    return Restore(GUI.Equipment)
  end
end</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>Group Widget</name>
					<packageName></packageName>
					<script>function ui.fInitGroupWidget()
  --
  -- Group Members
  GUI.Group = Adjustable.Container:new2({
    name = "GUI.Group",
    x = 930,
    y = 140,
    width = 300,
    height = 500,
    titleText ="Gruppo",
    titleTxtColor = "orange",
    buttonsize = 12,
    buttonFontSize = 5,
    adjLabelstyle = GUI.CSS.AC, 
    buttonstyle = GUI.CSS.ACButtons,
  })
  --
  GUI.Group.Main = Geyser.Label:new2({
    name = "GUI.Group.Main",
   x = 3,
    y = 25,
    width = "100%-6",
    height = "100%-28",
  },GUI.Group)
  --
  -- Border
  ui.fAddBorder(GUI.Group.Main, 2)
  --
  local i
  for i=1, 10 do
    local mod = i % 10
    --
    -- Member
    GUI.Group.Main.Body["g"..mod] = Geyser.Label:new2({
      name = "GUI.Group.Main.Body.g"..mod
    }, GUI.Group.Main.Body)
    GUI.Group.Main.Body["g"..mod]:setClickCallback("ui.fClickTarget", "g"..mod)
    --
    -- Member Health Gauges
    GUI.Group.Main.Body["g"..mod].Health = Geyser.Gauge:new2({
      name = "GUI.Group.Main.Body.g"..mod..".Health",
      x = 10,
      y = 7,
      width = -5,
      height = 20,
    }, GUI.Group.Main.Body["g"..mod])
    GUI.Group.Main.Body["g"..mod].Health:setValue(0, 100)
    GUI.Group.Main.Body["g"..mod].Health:enableClickthrough()
    --
    GUI.Group.Main.Body["g"..mod].Health.back:setStyleSheet(GUI.CSS.GaugeBack..[[
      background-color: rgba(150, 0, 0, 0.3);
    ]])
    GUI.Group.Main.Body["g"..mod].Health.back:enableClickthrough()
    --
    GUI.Group.Main.Body["g"..mod].Health.front:setStyleSheet(GUI.CSS.GaugeFront..[[
      background-color: QLinearGradient( x1: 0, y1: 0, x2: 0, y2: 1, stop: 0 #ee0000, stop: 0.65 #990000, stop: 1 #bb0000);
    ]])
    GUI.Group.Main.Body["g"..mod].Health.front:enableClickthrough()
    --
    -- Member Mana Gauges
    GUI.Group.Main.Body["g"..mod].Mana = Geyser.Gauge:new2({
      name = "GUI.Group.Main.Body.g"..mod..".Mana",
      x = 10,
      y = 25,
      width = -5,
      height = 7,
    }, GUI.Group.Main.Body["g"..mod])
    GUI.Group.Main.Body["g"..mod].Mana:setValue(0, 100)
    GUI.Group.Main.Body["g"..mod].Mana:enableClickthrough()
    --
    GUI.Group.Main.Body["g"..mod].Mana.back:setStyleSheet(GUI.CSS.GaugeBack..[[
      background-color: rgba(0, 0, 150, .3);
    ]])
    GUI.Group.Main.Body["g"..mod].Mana.back:enableClickthrough()
    --
    GUI.Group.Main.Body["g"..mod].Mana.front:setStyleSheet(GUI.CSS.GaugeFront..[[
      background-color: QLinearGradient( x1: 0, y1: 0, x2: 0, y2: 1, stop: 0 #0000ee, stop: 0.65 #000099, stop: 1 #0000bb);
    ]])
    GUI.Group.Main.Body["g"..mod].Mana.front:enableClickthrough()
    --
    -- Member Stamina Gauges
    GUI.Group.Main.Body["g"..mod].Stamina = Geyser.Gauge:new2({
      name = "GUI.g"..mod..".Stamina",
      x = 10,
      y = 30,
      width = -5,
      height = 7,
    }, GUI.Group.Main.Body["g"..mod])
    GUI.Group.Main.Body["g"..mod].Stamina:setValue(0, 100)
    GUI.Group.Main.Body["g"..mod].Stamina:enableClickthrough()
    --
    GUI.Group.Main.Body["g"..mod].Stamina.back:setStyleSheet(GUI.CSS.GaugeBack..[[
      background-color: rgba(0, 150, 0, .2);
    ]])
    GUI.Group.Main.Body["g"..mod].Stamina.back:enableClickthrough()
    --
    GUI.Group.Main.Body["g"..mod].Stamina.front:setStyleSheet(GUI.CSS.GaugeFront..[[
      background-color: QLinearGradient( x1: 0, y1: 0, x2: 0, y2: 1, stop: 0 #00aa00, stop: 0.65 #006600, stop: 1 #008800);
    ]])
    GUI.Group.Main.Body["g"..mod].Stamina.front:enableClickthrough()
    --
    -- Member gem
    GUI.Group.Main.Body["g"..mod].Gem = Geyser.Label:new2({
      name = "GUI.Group.Main.Body.g"..mod..".Gem",
      x = 0, y = 0,
      width = 30,
      height = 30,
    }, GUI.Group.Main.Body["g"..mod])
    GUI.Group.Main.Body["g"..mod].Gem:setStyleSheet([[
      border-image: url("]]..ui.pathImg..[[gemBlue.png") 0px stretch;
    ]]);
    GUI.Group.Main.Body["g"..mod].Gem:enableClickthrough()
    --
    -- Index
    GUI.Group.Main.Body["g"..mod].index = Geyser.Label:new2({
      name = "GUI.Group.Main.Body.g"..mod..".index",
      x = -20, 
      y = -20,
      width = 25,
      height = 25,
      fontSize = 8,
    }, GUI.Group.Main.Body["g"..mod])
    GUI.Group.Main.Body["g"..mod].index:echo("&lt;center&gt;g"..mod.."")
    GUI.Group.Main.Body["g"..mod].index:setStyleSheet([[border-image: url("]]..ui.pathImg..[[round.png") 0px stretch;]]);
    GUI.Group.Main.Body["g"..mod].index:enableClickthrough()
    --
    -- Keybid
    GUI.Group.Main.Body["g"..mod].keybind = Geyser.Label:new2({
      name = "GUI.Group.Main.Body.g"..mod..".keybind",
      x = 5, y = -10,
      width = -5,
      height = 15,
    }, GUI.Group.Main.Body["g"..mod])
    GUI.Group.Main.Body["g"..mod].keybind:enableClickthrough()
    GUI.Group.Main.Body["g"..mod].keybind:setStyleSheet(GUI.CSS.Keybind);
    GUI.Group.Main.Body["g"..mod].keybind:setFontSize(ui.parameters.fsKeybind);
    GUI.Group.Main.Body["g"..mod].keybind:echo("&lt;center&gt;keybind")
  end
  --
  -- Wrapping function
  local Minimize = GUI.Group.minimize
  local Restore = GUI.Group.restore
  --
  function GUI.Group:minimize(...)
    GUI.Group.Main:hide()
    return Minimize(GUI.Group)
  end
  --
  function GUI.Group:restore(...)
    GUI.Group.Main:show()
    return Restore(GUI.Group)
  end
end</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>Help Widget</name>
					<packageName></packageName>
					<script>function ui.fInitHelpWidget()
  --
  -- Public messages
  GUI.Help = Adjustable.Container:new2({
    name = "GUI.Help",
    x = 20,
    y = 20,
    width = 1000,
    height = 500,
    titleText ="Lumen et Umbra UI - Help",
    titleTxtColor = "orange",
    buttonsize = 12,
    buttonFontSize = 5,
    adjLabelstyle = GUI.CSS.AC, 
    buttonstyle = GUI.CSS.ACButtons,
  })
  --
  GUI.Help.Main = Geyser.Label:new2({
    name = "GUI.Help.Main",
    x = 3,
    y = 25,
    width = "100%-6",
    height = "100%-28",
  },GUI.Help)
  --
  -- Border
  ui.fAddBorder(GUI.Help.Main, 1)
  --
  -- Body
  GUI.Help.Main.Body.Console = Geyser.MiniConsole:new2({
    name = 'GUI.Help.Main.Body.Console',
    x=0,
    y=0,
    width = "100%", 
    height = "100%",
    autoWrap = true,
    scrollBar = true,
  }, GUI.Help.Main.Body)
  GUI.Help.Main.Body.Console:setColor(30, 24, 24)
  GUI.Help.Main.Body.Console:setBgColor(30, 24, 24)
  GUI.Help.Main.Body.Console:setFontSize(ui.parameters.fsHelp)
  --
  -- Wrapping function
  local Minimize = GUI.Help.minimize
  local Restore = GUI.Help.restore
  --
  function GUI.Help:minimize(...)
    GUI.Help.Main:hide()
    return Minimize(GUI.Help)
  end
  --
  function GUI.Help:restore(...)
    GUI.Help.Main:show()
    return Restore(GUI.Help)
  end
end</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>Inventory Widget</name>
					<packageName></packageName>
					<script>function ui.fInitInventoryWidget()
  --
  -- Inventory
  GUI.Inventory = Adjustable.Container:new2({
    name = "GUI.Inventory",
    x = 620,
    y = 140,
    width = 300,
    height = 500,
    titleText ="Inventario/Contenitore",
    titleTxtColor = "orange",
    buttonsize = 12,
    buttonFontSize = 5,
    adjLabelstyle = GUI.CSS.AC, 
    buttonstyle = GUI.CSS.ACButtons,
  })
  --
  GUI.Inventory.Main = Geyser.Label:new2({
    name = "GUI.Inventory.Main",
    x = 3,
    y = 25,
    width = "100%-6",
    height = "100%-28",
  },GUI.Inventory)
  --
  -- Border
  ui.fAddBorder(GUI.Inventory.Main, 1)
  --
  -- Body
  GUI.Inventory.Main.Body.Console = Geyser.MiniConsole:new2({
    name = 'GUI.Inventory.Main.Body.Console',
    x=0,
    y=0,
    width = "100%", 
    height = "100%",
    autoWrap = true,
    scrollBar = true,
  }, GUI.Inventory.Main.Body)
  GUI.Inventory.Main.Body.Console:setColor(30,24,24)
  GUI.Inventory.Main.Body.Console:setBgColor(30,24,24)
  GUI.Inventory.Main.Body.Console:setFontSize(ui.parameters.fsInventory)
  --
  -- Wrapping function
  local Minimize = GUI.Inventory.minimize
  local Restore = GUI.Inventory.restore
  --
  function GUI.Inventory:minimize(...)
    GUI.Inventory.Main:hide()
    return Minimize(GUI.Inventory)
  end
  --
  function GUI.Inventory:restore(...)
    GUI.Inventory.Main:show()
    return Restore(GUI.Inventory)
  end
end</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>Map\Compass Widget</name>
					<packageName></packageName>
					<script>function ui.fInitMapCompassWidget()
  --
  -- Compass
  GUI.MapCompass = Adjustable.Container:new2({
    name = "GUI.MapCompass",
    x = 0,
    y = 340,
    width = 300,
    height = 170,
    titleText ="Mappa",
    titleTxtColor = "orange",
    buttonsize = 12,
    buttonFontSize = 5,
    adjLabelstyle = GUI.CSS.AC, 
    buttonstyle = GUI.CSS.ACButtons,
  })
  --
  GUI.MapCompass.Main = Geyser.Label:new2({
    name = "GUI.MapCompass.Main",
    x = 3,
    y = 25,
    width = "100%-6",
    height = "100%-28",
  },GUI.MapCompass)
  --
  -- Border
  ui.fAddBorder(GUI.MapCompass.Main, 1)
  GUI.MapCompass.Main.B2:setFontSize(ui.parameters.fsMapCompass)   
  --
  -- Exits
  GUI.MapCompass.Main.Body.Exits = Geyser.MiniConsole:new2({ 
    name = 'GUI.MapCompass.Main.Body.Exits',
    x=0,
    y=0,
    width = 70, 
    height = "100%",
    autoWrap = true,
    scrollBar = false,
  }, GUI.MapCompass.Main.Body)
  GUI.MapCompass.Main.Body.Exits:setColor(30,24,24)
  GUI.MapCompass.Main.Body.Exits:setBgColor(30,24,24)
  GUI.MapCompass.Main.Body.Exits:setFontSize(ui.parameters.fsMapCompass)
  --
  -- Other Exits
  GUI.MapCompass.Main.Body.OtherExits = Geyser.MiniConsole:new2({ 
    name = 'GUI.MapCompass.Main.Body.OtherExits',
    x=70,
    y=0,
    width = "100%-70", 
    height = "100%",
    autoWrap = true,
    scrollBar = false,
  }, GUI.MapCompass.Main.Body)
  GUI.MapCompass.Main.Body.OtherExits:setColor(30,24,24)
  GUI.MapCompass.Main.Body.OtherExits:setBgColor(30,24,24)
  GUI.MapCompass.Main.Body.OtherExits:setFontSize(ui.parameters.fsMapCompass)
  --
  -- Wrapping function
  local Minimize = GUI.MapCompass.minimize
  local Restore = GUI.MapCompass.restore
  --
  function GUI.MapCompass:minimize(...)
    GUI.MapCompass.Main:hide()
    return Minimize(GUI.MapCompass)
  end
  --
  function GUI.MapCompass:restore(...)
    GUI.MapCompass.Main:show()
    return Restore(GUI.MapCompass)
  end
end</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>Opponent Widget</name>
					<packageName></packageName>
					<script>function ui.fInitOpponentWidget()
  --
  -- Opponent
  GUI.Opponent = Adjustable.Container:new2({
    name = "GUI.Opponent",
    x = 0,
    y = 160,
    width = 300,
    height = 80,
    titleText = "Avversario",
    titleTxtColor = "orange",
    buttonsize = 12,
    buttonFontSize = 5,
    adjLabelstyle = GUI.CSS.AC, 
    buttonstyle = GUI.CSS.ACButtons,
  });
  --
  -- Opponent Level
  GUI.Opponent.Level = Geyser.Label:new2({
    name = "GUI.Opponent.Level",
    x = -60,
    y = 2,
    width = 25,
    height = 25,
    fontSize = 8,
  }, GUI.Opponent)
  GUI.Opponent.Level:setStyleSheet([[border-image: url("]]..ui.pathImg..[[round.png") 0px stretch;]]);
  GUI.Opponent.Level:enableClickthrough()
  --
  --
  GUI.Opponent.Main = Geyser.Label:new2({
    name = "GUI.Opponent.Main",
    x = 3,
    y = 25,
    width = "100%-6",
    height = "100%-28",
  }, GUI.Opponent)
  GUI.Opponent.Main:setStyleSheet(GUI.CSS.Border3..[[
    background-color: rgba(77, 0, 0);
  ]]);
  GUI.Opponent.Main:setClickCallback("ui.fExecuteTargetButton", "o0", nil)
  --
  -- Opponent Health Gauges
  GUI.Opponent.Main.Health = Geyser.Gauge:new2({
    name = "GUI.Opponent.Main.Health",
    x = 15,
    y = 14,
    width = -10,
    height = -11,
  },GUI.Opponent.Main)
  GUI.Opponent.Main.Health:setValue(0, 100)
  GUI.Opponent.Main.Health:enableClickthrough()
  --
  GUI.Opponent.Main.Health.back:setStyleSheet(GUI.CSS.GaugeBack..[[
    background-color: rgba(00, 0, 0, 0.3);
  ]]);
  GUI.Opponent.Main.Health.back:enableClickthrough()
  --
  GUI.Opponent.Main.Health.front:setStyleSheet(GUI.CSS.GaugeFront..[[
    background-color: QLinearGradient( x1: 0, y1: 0, x2: 0, y2: 1, stop: 0 #ee0000, stop: 0.65 #990000, stop: 1 #bb0000);
  ]])
  GUI.Opponent.Main.Health.front:enableClickthrough()
  --
  --
  GUI.Opponent.Main.Health.dif = Geyser.Label:new2({
    name = "GUI.Opponent.Main.Health.dif",
    x = 0,
    y = 0,
    width = "10",
    height = "10",
  }, GUI.Opponent.Main)
  GUI.Opponent.Main.Health.dif:enableClickthrough()
  GUI.Opponent.Main.Health.dif:setFontSize(5)
  --
  -- Opponent Gem
  GUI.Opponent.Main.Gem = Geyser.Label:new2({
    name = "GUI.Opponent.Main.Gem",
    x = 0, y = 0,
    width = 30,
    height = 30,
  }, GUI.Opponent.Main)
  GUI.Opponent.Main.Gem:setStyleSheet([[
    margin: 0px;
    border-image: url("]]..ui.pathImg..[[gemRed.png") 0px stretch;
  ]]);
  GUI.Opponent.Main.Gem:enableClickthrough()
  --
  -- Keybid
  GUI.Opponent.Main.keybind = Geyser.Label:new2({
    name = "GUI.Opponent.Main.keybind",
    x = 5, y = -15,
    width = -5,
    height = 15,
  }, GUI.Opponent.Main)
  GUI.Opponent.Main.keybind:enableClickthrough()
  GUI.Opponent.Main.keybind:setStyleSheet(GUI.CSS.Keybind);
  GUI.Opponent.Main.keybind:setFontSize(ui.parameters.fsKeybind);
  --
  -- Wrapping function
  local Minimize = GUI.Opponent.minimize
  local Restore = GUI.Opponent.restore
  --
  function GUI.Opponent:minimize(...)
    GUI.Opponent.Main:hide()
    return Minimize(GUI.Opponent)
  end
  --
  function GUI.Opponent:restore(...)
    GUI.Opponent.Main:show()
    return Restore(GUI.Opponent)
  end
end</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>Pivate Chat Widget</name>
					<packageName></packageName>
					<script>function ui.fInitPrivateChatWidget()
  --
  -- Private messages
  GUI.PrivateChat = Adjustable.Container:new2({
    name = "GUI.PrivateChat",
    x = 1240,
    y = 0,
    width = 300,
    height = 315,
    titleText ="Canale privato",
    titleTxtColor = "orange",
    buttonsize = 12,
    buttonFontSize = 5,
    adjLabelstyle = GUI.CSS.AC, 
    buttonstyle = GUI.CSS.ACButtons,
  })
  --
  GUI.PrivateChat.Main = Geyser.Label:new2({
    name = "GUI.PrivateChat.Main",
    x = 3,
    y = 25,
    width = "100%-6",
    height = "100%-28",
  },GUI.PrivateChat)
  --
  -- Border
  ui.fAddBorder(GUI.PrivateChat.Main, 1)
  --
  -- Body
  GUI.PrivateChat.Main.Body.Console = Geyser.MiniConsole:new2({
    name = 'GUI.PrivateChat.Main.Body.Console',
    x=0,
    y=0,
    width = "100%", 
    height = "100%",
    autoWrap = true,
    scrollBar = true,
  }, GUI.PrivateChat.Main.Body)
  GUI.PrivateChat.Main.Body.Console:setColor(30, 24, 24)
  GUI.PrivateChat.Main.Body.Console:setBgColor(30, 24, 24)
  GUI.PrivateChat.Main.Body.Console:setFontSize(ui.parameters.fsPrivateChat)
  --
  -- Wrapping function
  local Minimize = GUI.PrivateChat.minimize
  local Restore = GUI.PrivateChat.restore
  --
  function GUI.PrivateChat:minimize(...)
    GUI.PrivateChat.Main:hide()
    return Minimize(GUI.PrivateChat)
  end
  --
  function GUI.PrivateChat:restore(...)
    GUI.PrivateChat.Main:show()
    return Restore(GUI.PrivateChat)
  end
end</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>Player Widget</name>
					<packageName></packageName>
					<script>function ui.fInitPlayerWidget()
  --
  -- Player 
  GUI.Player = Adjustable.Container:new2({
    name = "GUI.Player",
    x = 0,
    y = 0,
    width = 300,
    height = 150,
    titleText ="Player",
    titleTxtColor = "orange",
    buttonsize = 12,
    buttonFontSize = 5,
    adjLabelstyle = GUI.CSS.AC, 
    buttonstyle = GUI.CSS.ACButtons,
  })
  --
  -- Player Level
  GUI.Player.Level = Geyser.Label:new2({
    name = "GUI.Player.Level",
    x = -60,
    y = 2,
    width = 25,
    height = 25,
    fontSize = 8,
  }, GUI.Player)
  GUI.Player.Level:setStyleSheet([[border-image: url("]]..ui.pathImg..[[round.png") 0px stretch;]]);
  GUI.Player.Level:enableClickthrough()
  --
  -- Main
  GUI.Player.Main = Geyser.Label:new2({
    name = "GUI.Player.Main",
    x = 3,
    y = 25,
    width = "100%-6",
    height = "100%-28",
  }, GUI.Player)
  GUI.Player.Main:setStyleSheet(GUI.CSS.Border3..[[
    background-color: rgba(30,24,24);
  ]]);
  --
  -- Experience 
  GUI.Player.Main.Experience = Geyser.Gauge:new2({
    name = "GUI.Player.Main.Experience",
    x = 8, 
    y = 10,
    width = -5,
    height = 6,
  },GUI.Player.Main)
  GUI.Player.Main.Experience:setValue(0, 100)
  --
  GUI.Player.Main.Experience.front:echo("")
  --
  GUI.Player.Main.Experience.back:setStyleSheet(GUI.CSS.GaugeBack..[[
    background-color: rgba(255, 255, 255, 0.1);
  ]])
  --
  GUI.Player.Main.Experience.front:setStyleSheet(GUI.CSS.GaugeFront..[[
    background-color: purple;
  ]])
  --
  -- Player Health Gauges
  GUI.Player.Main.Health = Geyser.Gauge:new2({
    name = "GUI.Player.Main.Health",
    x = 8,
    y = 15,
    width = -5,
    height = "50%-10",
  },GUI.Player.Main)
  GUI.Player.Main.Health:setValue(0, 100)
  --
  GUI.Player.Main.Health.back:setStyleSheet(GUI.CSS.GaugeBack..[[
    background-color: rgba(150, 0, 0, 0.3);
  ]])
  --
  GUI.Player.Main.Health.front:setStyleSheet(GUI.CSS.GaugeFront..[[
    background-color: QLinearGradient( x1: 0, y1: 0, x2: 0, y2: 1, stop: 0 #ee0000, stop: 0.65 #990000, stop: 1 #bb0000);
  ]])
  GUI.Player.Main.Health.front:echo("Vita")
  --
  --
  GUI.Player.Main.Health.dif = Geyser.Label:new2({
    name = "GUI.Player.Main.Health.dif",
    x = 0,
    y = 0,
    width = "10",
    height = "10",
  }, GUI.Player.Main)
  GUI.Player.Main.Health.dif:setFontSize(5)
  --
  -- Tick
  GUI.Player.Main.Tick = Geyser.Gauge:new2({
    name = "GUI.Player.Main.Tick",
    x = 8,
    y = "50%+4",
    width = -5,
    height = 6,
  }, GUI.Player.Main)
  GUI.Player.Main.Tick:setValue(0, 75)
  --
  GUI.Player.Main.Tick.back:setStyleSheet(GUI.CSS.GaugeBack..[[
    background-color: rgba(255, 255, 255, 0.1);
  ]])
  --
  GUI.Player.Main.Tick.front:setStyleSheet(GUI.CSS.GaugeFront..[[
    background-color: grey;
  ]])
  --
  -- Player Mana Gauges
  GUI.Player.Main.Mana = Geyser.Gauge:new2({
    name = "GUI.Player.Main.Mana",
    x = 8,
    y = "50%+10",
    width = -5,
    height = "25%-6",
  },GUI.Player.Main)
  GUI.Player.Main.Mana:setValue(0, 100)
  --
  GUI.Player.Main.Mana.back:setStyleSheet(GUI.CSS.GaugeBack..[[
    background-color: rgba(0, 0, 150, .3);
  ]])
  --
  GUI.Player.Main.Mana.front:setStyleSheet(GUI.CSS.GaugeFront..[[
    background-color: QLinearGradient( x1: 0, y1: 0, x2: 0, y2: 1, stop: 0 #0000ee, stop: 0.65 #000099, stop: 1 #0000bb);
  ]])
  GUI.Player.Main.Mana.front:echo("Mana")
  --
  -- Player Stamina Gauges (used for moviment)
  GUI.Player.Main.Stamina = Geyser.Gauge:new2({
    name = "GUI.Player.Main.Stamina",
    x = 8,
    y = "75%+3",
    width = -5,
    height = "25%-6",
  },GUI.Player.Main)
  GUI.Player.Main.Stamina:setValue(0, 100)
  --
  GUI.Player.Main.Stamina.back:setStyleSheet(GUI.CSS.GaugeBack..[[
    background-color: rgba(0, 150, 0, .2);
  ]])
  --
  GUI.Player.Main.Stamina.front:setStyleSheet(GUI.CSS.GaugeFront..[[
    background-color: QLinearGradient( x1: 0, y1: 0, x2: 0, y2: 1, stop: 0 #00aa00, stop: 0.65 #006600, stop: 1 #008800);
  ]])
  GUI.Player.Main.Stamina.front:echo("Movimento")
  --
  -- Player Gem
  GUI.Player.Main.Gem = Geyser.Label:new2({
    name = "GUI.Player.Gem",
    x = 0,
    y = 0,
    width = 28,
    height = 28,
  }, GUI.Player.Main)
  GUI.Player.Main.Gem:setStyleSheet([[
    margin: 0px;
    background-image: url("]]..ui.pathImg..[[gemEmpty.png");
  ]]);
  --
  -- Wrapping function
  local Minimize = GUI.Player.minimize
  local Restore = GUI.Player.restore
  --
  function GUI.Player:minimize(...)
    GUI.Player.Main:hide()
    return Minimize(GUI.Player)
  end
  --
  function GUI.Player:restore(...)
    GUI.Player.Main:show()
    return Restore(GUI.Player)
  end
end</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>Public Chat Widget</name>
					<packageName></packageName>
					<script>function ui.fInitPublicChatWidget()
  --
  -- Public messages
  GUI.PublicChat = Adjustable.Container:new2({
    name = "GUI.PublicChat",
    x = 1240,
    y = 325,
    width = 300,
    height = 315,
    titleText ="Canale pubblico",
    titleTxtColor = "orange",
    buttonsize = 12,
    buttonFontSize = 5,
    adjLabelstyle = GUI.CSS.AC, 
    buttonstyle = GUI.CSS.ACButtons,
  })
  --
  GUI.PublicChat.Main = Geyser.Label:new2({
    name = "GUI.PublicChat.Main",
    x = 3,
    y = 25,
    width = "100%-6",
    height = "100%-28",
  },GUI.PublicChat)
  --
  -- Border
  ui.fAddBorder(GUI.PublicChat.Main, 1)
  --
  -- Body
  GUI.PublicChat.Main.Body.Console = Geyser.MiniConsole:new2({
    name = 'GUI.PublicChat.Main.Body.Console',
    x=0,
    y=0,
    width = "100%", 
    height = "100%",
    autoWrap = true,
    scrollBar = true,
  }, GUI.PublicChat.Main.Body)
  GUI.PublicChat.Main.Body.Console:setColor(30, 24, 24)
  GUI.PublicChat.Main.Body.Console:setBgColor(30, 24, 24)
  GUI.PublicChat.Main.Body.Console:setFontSize(ui.parameters.fsPublicChat)
  --
  -- Wrapping function
  local Minimize = GUI.PublicChat.minimize
  local Restore = GUI.PublicChat.restore
  --
  function GUI.PublicChat:minimize(...)
    GUI.PublicChat.Main:hide()
    return Minimize(GUI.PublicChat)
  end
  --
  function GUI.PublicChat:restore(...)
    GUI.PublicChat.Main:show()
    return Restore(GUI.PublicChat)
  end
end</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>Target Buttons Widget</name>
					<packageName></packageName>
					<script>function ui.fInitTargetButtonsWidget()
  --
  -- Target
  GUI.TargetButtons = Adjustable.Container:new2({
    name = "GUI.TargetButtons",
    x = 0,
    y = 520,
    width = 300,
    height = 120,
    titleText ="Target",
    titleTxtColor = "orange",
    buttonsize = 12,
    buttonFontSize = 5,
    adjLabelstyle = GUI.CSS.AC, 
    buttonstyle = GUI.CSS.ACButtons,
  })
  --
  GUI.TargetButtons.Main = Geyser.Label:new2({
    name = "GUI.TargetButtons.Main",
    x = 3,
    y = 25,
    width = "100%-6",
    height = "100%-28",
  },GUI.TargetButtons)
  --
  -- Border
  ui.fAddBorder(GUI.TargetButtons.Main, 2)
  --
  -- Target buttons
  GUI.TargetButtons.Main.Body.t1 = Geyser.Label:new2({
    name = "GUI.TargetButtons.Main.Body.t1",
    x = 0,
    y = 0,
    width = "50%",
    height = "50%",
  },GUI.TargetButtons.Main.Body)
  --
  GUI.TargetButtons.Main.Body.t2 = Geyser.Label:new2({
    name = "GUI.TargetButtons.Main.Body.t2",
    x = "50%",
    y = 0,
    width = "50%",
    height = "50%",
  },GUI.TargetButtons.Main.Body)
  --
  GUI.TargetButtons.Main.Body.t3 = Geyser.Label:new2({
    name = "GUI.TargetButtons.Main.Body.t3",
    x = 0,
    y = "50%",
    width = "50%",
    height = "50%",
  },GUI.TargetButtons.Main.Body)
  --
  GUI.TargetButtons.Main.Body.t4 = Geyser.Label:new2({
    name = "GUI.TargetButtons.Main.Body.t4",
    x = "50%",
    y = "50%",
    width = "50%",
    height = "50%",
  },GUI.TargetButtons.Main.Body)
  --
  for i=1,4 do
    GUI.TargetButtons.Main.Body["t"..i]:setFontSize(9)
    GUI.TargetButtons.Main.Body["t"..i]:setFgColor("LightGoldenrod")
    GUI.TargetButtons.Main.Body["t"..i]:setClickCallback("ui.fExecuteTargetButton", "t"..i, nil)
    --
    -- Index
    GUI.TargetButtons.Main.Body["t"..i].index = Geyser.Label:new2({
      name = "GUI.TargetButtons.Main.Body.t"..i..".index",
      x = 0, y = 0,
      width = 25,
      height = 25,
    }, GUI.TargetButtons.Main.Body["t"..i])
    GUI.TargetButtons.Main.Body["t"..i].index:setFontSize(6)
    GUI.TargetButtons.Main.Body["t"..i].index:echo("&lt;center&gt;t"..i.."")
    GUI.TargetButtons.Main.Body["t"..i].index:setStyleSheet([[border-image: url("]]..ui.pathImg..[[round.png") 0px stretch;]]);
    GUI.TargetButtons.Main.Body["t"..i].index:enableClickthrough()
    --
    -- Keybid
    GUI.TargetButtons.Main.Body["t"..i].keybind = Geyser.Label:new2({
      name = "GUI.TargetButtons.Main.Body.t"..i..".keybind",
      x = 5, y = -15,
      width = -5,
      height = 15,
    }, GUI.TargetButtons.Main.Body["t"..i])
    GUI.TargetButtons.Main.Body["t"..i].keybind:enableClickthrough()
    GUI.TargetButtons.Main.Body["t"..i].keybind:setStyleSheet(GUI.CSS.Keybind)
    GUI.TargetButtons.Main.Body["t"..i].keybind:setFontSize(ui.parameters.fsKeybind)
  end
  --
  -- Wrapping function
  local Minimize = GUI.TargetButtons.minimize
  local Restore = GUI.TargetButtons.restore
  --
  function GUI.TargetButtons:minimize(...)
    GUI.TargetButtons.Main:hide()
    return Minimize(GUI.TargetButtons)
  end
  --
  function GUI.TargetButtons:restore(...)
    GUI.TargetButtons.Main:show()
    return Restore(GUI.TargetButtons)
  end
end</script>
					<eventHandlerList />
				</Script>
			</ScriptGroup>
			<Script isActive="yes" isFolder="no">
				<name>Init Structures</name>
				<packageName></packageName>
				<script>--
ui = ui or {}
ui.enDebug = false
ui.release = "1-230914"
ui.autoUpdate = true
ui.echo = "&lt;blue&gt;[  &lt;DodgerBlue&gt;UI  &lt;blue&gt;] "
--
-- Colors
ui.cAliasButton = "&lt;orange&gt;"
ui.cAliasName = "&lt;violet&gt;"
ui.cAliasOutput = "&lt;PaleGoldenrod&gt;"
ui.cCommand = "&lt;steel_blue&gt;"
ui.cError = "&lt;DarkOrange&gt;"
ui.cInput = "&lt;MediumSeaGreen&gt;" -- #
ui.cKeybind = "&lt;cyan&gt;"
ui.cLink = "&lt;blue&gt;"
ui.cOperator = "&lt;salmon&gt;"      -- » or «
ui.cProfileName = "&lt;green&gt;"
ui.cSeparator = "&lt;orange_red&gt;" -- ; or /
ui.cTarget = "&lt;orange&gt;"
ui.cText = "&lt;grey&gt;"
ui.cTitle = "&lt;white&gt;"
ui.cVarID = "&lt;steel_blue&gt;"
ui.cVarName = "&lt;DeepPink&gt;"
ui.cVarCont = "&lt;LightBlue&gt;"
--
ui.fDebug("[init] Structures")
--
-- Outpt file path
ui.pathPkg = getMudletHomeDir().."/"
ui.pathTpl = ui.pathPkg.."Lumen et Umbra UI/"
--
ui.pathIcn = ui.pathTpl.."icons/"
ui.pathImg = ui.pathTpl.."images/"
ui.pathPrf = ui.pathPkg.."../../profilesLeu/"
ui.pathSnd = ui.pathTpl.."sounds/"
--
ui.fileNameAliases = "aliases.lua";
ui.fileNameHighlights = "highlights.lua";
ui.fileNameParameters = "parameters.lua";
ui.fileNameTargets = "targets.lua";
ui.fileNameVariables = "variables.lua";
--
ui.fileAliases = ui.pathTpl..ui.fileNameAliases;
ui.fileHighlights = ui.pathTpl..ui.fileNameHighlights;
ui.fileParameters = ui.pathTpl..ui.fileNameParameters;
ui.fileTargets = ui.pathTpl..ui.fileNameTargets;
ui.fileVariables = ui.pathTpl..ui.fileNameVariables;
--
ui.varID = "@"
--
-- Icons for affect 
ui.affects = {
--  ["[CD] Nuovo Dungeon"]        = {icon = "skill_115.png", color = "blue", shortName = "CD Dung" },
--  ["[CD] Nuova Missione"]       = {icon = "skill_115.png", color = "blue", shortName = "CD Miss" },  
--  ["avvelena"]                  = {icon = nil,             color = "YellowGreen", shortName = "Vel" },
--  ["chiaroveggenza"]            = {icon = nil,             color = "magenta", shortName = "Chiaro" },  
--  ["colpo psichico"]            = {icon = nil,             color = "magenta", shortName = "Colpo PSI" },  
--  ["forza psichica"]            = {icon = "skill_9.png",   color = "OrangeRed", shortName = "PSI Str" },
--  ["individua il magico"]       = {icon = 'Skill_322.png', color = "DarkOrchid", shortName = "Ind. mag." },
--  ["individua il male"]         = {icon = 'skill_72.png',  color = "DarkOrchid", shortName = "Ind. mal." },
--  ["individua invisibile"]      = {icon = "Skill_312.png", color = "DarkOrchid", shortName = "Ind. inv." },
--  ["levitazione"]               = {icon = "skill_156.png", color = "blue", shortName = "Lev" },
--  ["nuotare (cooldown)"]        = {icon = "skill_110.png", color = "blue", shortName = "Swim" },
--  ["percepisci vita"]           = {icon = "skill_44.png",  color = "DarkOrchid", shortName = "True Live" },
--  ["primo soccorso"]            = {icon = nil,             color = "green", shortName = "First AID" },  
--  ["santuario"]                 = {icon = "Skill_243.png", color = "white", shortName = "Sanc" },
--  ["scarica di adrenalina"]     = {icon = "Skill_472.png", color = "yellow", shortName = "PSI Dro" },
--  ["scopri le trappole"]        = {icon = "skill_166.png", color = "brown", shortName = "Det. trap" },
--  ["scudo di fuoco"]            = {icon = "Skill_448.png", color = "firebrick", shortName = "PSI Fire" },
--  ["scudo psichico"]            = {icon = "skill_168.png", color = "cyan", shortName = "PSI Shield" },
--  ["vera vista"]                = {icon = "Skill_264.png", color = "DarkOrchid", shortName = "Vera Vista" },
}
--
-- Modifier for keybind
ui.keyb_modifier = {
  CTRL = mudlet.keymodifier.Control,
  ALT = mudlet.keymodifier.Alt,
}
--
-- Keys for keybind
ui.keyb_single = {
  ["0"] = mudlet.key["0"],
  ["1"] = mudlet.key["1"],
  ["2"] = mudlet.key["2"],
  ["3"] = mudlet.key["3"],
  ["4"] = mudlet.key["4"],
  ["5"] = mudlet.key["5"],
  ["6"] = mudlet.key["6"],
  ["7"] = mudlet.key["7"],
  ["8"] = mudlet.key["8"],
  ["9"] = mudlet.key["9"],
  A = mudlet.key.A,
  B = mudlet.key.B,
  C = mudlet.key.C,
  D = mudlet.key.D,
  E = mudlet.key.E,
  F = mudlet.key.F,
  G = mudlet.key.G,
  H = mudlet.key.H,
  I = mudlet.key.I,
  J = mudlet.key.J,
  K = mudlet.key.k,
  L = mudlet.key.L,
  M = mudlet.key.M,
  N = mudlet.key.N,
  O = mudlet.key.O,
  P = mudlet.key.P,
  Q = mudlet.key.Q,
  R = mudlet.key.R,
  S = mudlet.key.S,
  T = mudlet.key.T,
  U = mudlet.key.U,
  V = mudlet.key.V,
  W = mudlet.key.W,
  X = mudlet.key.X,
  Y = mudlet.key.Y,
  Z = mudlet.key.Z,
  F1  = mudlet.key.F1,
  F2  = mudlet.key.F2,
  F3  = mudlet.key.F3,
  F4  = mudlet.key.F4,
  F5  = mudlet.key.F5,
  F6  = mudlet.key.F6,
  F7  = mudlet.key.F7,
  F8  = mudlet.key.F8,
  F9  = mudlet.key.F9,
  F10 = mudlet.key.F10,
  F11 = mudlet.key.F11,
  F12 = mudlet.key.F12,
}
--
ui.dirCompress = {
  down  = "d",
  basso = "d",
  d     = "d",
  east  = "e",
  est   = "e",
  e     = "e",
  north = "n",
  nord  = "n",
  n     = "n",
  south = "s",
  sud   = "s",
  s     = "s",
  up    = "u",
  alto  = "u",
  u     = "u",
  west  = "w",
  ovest = "w",
  w     = "w",
}
--
ui.dirExpand = {
  d = "basso",
  e = "est",
  n = "nord",
  s = "sud",
  u = "alto",
  w = "ovest",
}
--
ui.dirTokenX = {
  d = "└",
  e = "│",
  n = "─",
  s = "─",
  u = "┐",
  w = "│",
}
--
ui.dirToken = {
  d = "⤦",
  e = "▷",
  n = "△",
  s = "▽",
  u = "⤤",
  w = "◁",
}
--
ui.dirTokenSecret = {
  d = "S",
  e = "S",
  n = "S",
  s = "S",
  u = "S",
  w = "S",
}
--
ui.dirTokenClose = {
  d = "□",
  e = "□",
  n = "□",
  s = "□",
  u = "□",
  w = "□",
}
--
ui.dirTokenFrom = {
  d = "◆",
  e = "◆",
  n = "◆",
  s = "◆",
  u = "◆",
  w = "◆",
}
--
ui.dirTokenColor = {
  d     = "&lt;255,255,255:30,24,24&gt;", -- white
  e     = "&lt;255,255,0:30,24,24&gt;",   -- yellow
  n     = "&lt;0,255,0:30,24,24&gt;",     -- green
  s     = "&lt;0,0,255:30,24,24&gt;",     -- blue
  u     = "&lt;0,255,255:30,24,24&gt;",   -- cyan
  w     = "&lt;255,0,255:30,24,24&gt;",   -- magenta
}
--
ui.dirReverse = {
  d     = "u",
  basso = "alto",
  e     = "w",
  est   = "ovest",
  n     = "s",
  nord  = "sud",
  s     = "n",
  sud   = "nord",
  u     = "d",
  alto  = "basso",
  w     = "e",
  ovest = "est",
}
--
ui.lastFromPrivate = ui.lastFromPrivate or ""
ui.lastFromPubblic = ui.lastFromPubblic or ""
--
ui.roomName = ui.roomName or ""
ui.roomType = ui.roomType or ""
--
ui.strExits = ui.strExits or ""
ui.exits = ui.exits or {}
ui.track = ui.track or ""
ui.position = ui.position or "centro"
--
-- Pre defined variables
ui.pre_defined_variables = {
  ac = 0,
  alignment = 0,
  character_name = "@character_name",
  experience = 0,
  health = 100,
  health_max = 100,
  level = 1,
  mana = 70,
  mana_max = 100,
  money = 0,
  movement = 30,
  movement_max = 100,
  opponent_health = 0,
  opponent_health_max = 100,
  opponent_level = 1,
  opponent_name = "",
  target = "",
}
--
-- Pre defined target buttons
ui.pre_defined_target_buttons = {
  g0 = { mod1 = "CTRL", mod2 = "", key = "F10" },
  g1 = { mod1 = "CTRL", mod2 = "", key = "F1" },
  g2 = { mod1 = "CTRL", mod2 = "", key = "F2" },
  g3 = { mod1 = "CTRL", mod2 = "", key = "F3" },
  g4 = { mod1 = "CTRL", mod2 = "", key = "F4" },
  g5 = { mod1 = "CTRL", mod2 = "", key = "F5" },
  g6 = { mod1 = "CTRL", mod2 = "", key = "F6" },
  g7 = { mod1 = "CTRL", mod2 = "", key = "F7" },
  g8 = { mod1 = "CTRL", mod2 = "", key = "F8" },
  g9 = { mod1 = "CTRL", mod2 = "", key = "F9" },
  o0 = { mod1 = "CTRL", mod2 = "", key = "0" },
  t1 = { mod1 = "CTRL", mod2 = "", key = "1" },
  t2 = { mod1 = "CTRL", mod2 = "", key = "2" },
  t3 = { mod1 = "CTRL", mod2 = "", key = "3" },
  t4 = { mod1 = "CTRL", mod2 = "", key = "4" },
}
--
-- Storico Path
ui.idxPath = 0;
ui.memPath = 0;
ui.maxPath = 50;
ui.path = {}
--
-- Group
ui.group = ui.group or {}
ui.totalMember = 0
--
-- Affects
ui.actAffects = ui.actAffects or {}
--
-- General
ui.pre_defined_parameters = {
  fsMapCompass = 7,
  fsEquipment = 8,
  fsHelp = 8,
  fsInventory = 8,
  fsKeybind = 6,
  fsPrivateChat = 8,
  fsPublicChat = 8,
  page = "a"
}</script>
				<eventHandlerList />
			</Script>
			<Script isActive="yes" isFolder="no">
				<name>Init CSS</name>
				<packageName></packageName>
				<script>--
ui.fDebug("[init] CSS")
--
GUI = GUI or {}
GUI.CSS = GUI.CSS or {}
--
-- Affect
GUI.CSS.Affect = [[
QLabel {
  border: 1px solid;
  border-radius: 14px;
  border-image: url("]]..ui.pathImg..[[round.png") 0px stretch;
  background-color: rgba(30, 24, 0);
}
]]
--
-- Affect Icon
GUI.CSS.AffectIcon = [[
  border: 0px solid;
  border-radius: 10px;
  qproperty-alignment: 'AlignVCenter | AlignCenter';
  qproperty-wordWrap: true;
]]
--
-- Target buttons
GUI.CSS.Target = [[
  margin: 5px;
  border-style: outset;
  border-width: 2px;
  border-color: "#aa8822";
  border-radius: 5px 10px;
  qproperty-wordWrap: true;
]]
--
-- Group target buttons
GUI.CSS.Border3 = [[
  margin: 0;
  border: 6px solid transparent;
  border-image: url("]]..ui.pathImg..[[playerBG.png") 6px stretch;
  background-color: rgba(30,24,24);
]]
--
-- Alias buttons
GUI.CSS.AliasButtons = [[
  border: 10px solid transparent;
  border-image: url("]]..ui.pathImg..[[buttonBorder.png") 10px stretch;
  margin: 5px;
]]
--
-- Buttons Icon
GUI.CSS.ButtonsIcon = [[
  background-color: rgba(0,0,0,0);
  qproperty-wordWrap: true;
]]
--
-- Gauge back
GUI.CSS.GaugeBack = [[
  border: none;
  border-radius: 5px;
  margin: 1px;
]]
--
-- Gauge front
GUI.CSS.GaugeFront = [[
  border-radius: 3px;
  margin:  2px 0px 2px 0px;
]]
--
-- Target Name
GUI.CSS.Name = [[
  background-color: rgba(0,0,0,.6);
  opacity: 50;
  border-color: black;
  border-width: 1px;
  border-radius: 5px;
  border-style: none;
  margin: 1px;
  qproperty-wordWrap: true;
]]
--
-- Keybind
GUI.CSS.Keybind = [[
  background-color: rgba(0, 0, 0, 0);
]]
GUI.CSS.AC = [[
  border: 2px solid rgb(90,72,72); 
  border-top-left-radius: 10px;
  border-top-right-radius: 10px;
  background-color: rgb(30,24,24);
]]
--
GUI.CSS.ACButtons = [[
  QLabel{
    border-radius: 5px;
    background-color: rgb(90,72,72);
  }
  QLabel::hover{
    background-color: rgb(180,144,144);}
]]</script>
				<eventHandlerList />
			</Script>
			<Script isActive="yes" isFolder="no">
				<name>Init Help</name>
				<packageName></packageName>
				<script>ui.fDebug("[init] Help")
--
ui.help = {}
--
ui.help.error = [[
Non esiste aiuto per questa parola
]]
--
ui.help.help = [[
&lt;title&gt;Lumen et Umbra UI Help&lt;/title&gt;
Lumen et Umbra UI comprende un insieme di componenti grafici, script, trigger,
etc, creati per personalizzare l'esperienza di gioco con il MUD Lumen et Umbra.

Usare il comando &lt;command&gt;uih[elp] &lt;comando&gt;&lt;/command&gt; per avere informazioni sugli argomenti:

Comandi principali:
  - &lt;command&gt;uia[liases]&lt;/command&gt;     - Gestione &lt;link alias&gt;aliases&lt;/link&gt;
  - &lt;command&gt;uib[uttons]&lt;/command&gt;     - Gestione &lt;link button&gt;pulsanti per alias&lt;/link&gt; (a0..a9, b0..b9, c0..c9)
  - &lt;command&gt;uihi[ghlights]&lt;/command&gt;  - Gestione &lt;link highlight&gt;highlights&lt;/link&gt;
  - &lt;command&gt;uik[eibind]&lt;/command&gt;     - Gestione &lt;link keybind&gt;tasti rapidi&lt;/link&gt; per aliases e targets
  - &lt;command&gt;uip[rofiles]&lt;/command&gt;    - Gestione &lt;link profile&gt;profili&lt;/link&gt;
  - &lt;command&gt;uiv[ariables]&lt;/command&gt;   - Gestione &lt;link variable&gt;variabili&lt;/link&gt;

Altri comandi:
  - &lt;command&gt;.&lt;/command&gt;/&lt;command&gt;..&lt;/command&gt;            - Integrazione &lt;link walk&gt;walk/speedwalk&lt;/link&gt;
  - &lt;command&gt;uic[olors]&lt;/command&gt;      - Lista &lt;link color&gt;colori&lt;/link&gt; disponibili per &lt;link highlight&gt;highlights&lt;/link&gt;
  - &lt;command&gt;uisetf[ontsize]&lt;/command&gt; - Gestione &lt;link fontsize&gt;dimensione font&lt;/link&gt; dei widget
  - &lt;command&gt;uiw[idget]&lt;/command&gt;      - Ripristino &lt;link widget&gt;widget&lt;/link&gt; chiusi

Altri argomenti:
  - &lt;command&gt;target&lt;/command&gt;          - Utilizzo della variabile &lt;link target&gt;Target&lt;/link&gt;
]]
--
ui.help.alias = [[
&lt;title&gt;Aliases&lt;/title&gt;
Gli aliases permettono di eseguire lunghi comandi digitando poche lettere.
E' possibile arricchire il comando associato all'alias utilizzando le variabili
create con il comando &lt;command&gt;uivariable&lt;/command&gt;. 
E' possibile associare più comandi ad un alias utilizzando gli appositi separatori (]]..ui.cSeparator..[[;&lt;reset&gt; o ]]..ui.cSeparator..[[/&lt;reset&gt;).

&lt;white&gt;Configurazione:&lt;reset&gt;
  &lt;command&gt;uia[liases]&lt;/command&gt;                   Per visualizzare l'elenco degli aliases
  &lt;command&gt;uia[liases]&lt;/command&gt; &lt;aliasName&gt;&lt;alias&gt;&lt;/aliasName&gt;           Per visualizzare il singolo alias
  &lt;command&gt;uia[liases]&lt;/command&gt; &lt;aliasName&gt;&lt;alias&gt;&lt;/aliasName&gt; &lt;command&gt;&lt;comandi&gt;&lt;/command&gt; Per creare o modificare un alias
  &lt;command&gt;uia[liases]&lt;/command&gt; &lt;aliasName&gt;&lt;alias&gt;&lt;/aliasName&gt; &lt;command&gt;remove&lt;/command&gt;    Per eliminare un alias
  &lt;command&gt;uia[liases] remove_all&lt;/command&gt;        Per eliminare tutti gli aliases

&lt;white&gt;Utilizzo:&lt;reset&gt;
  &lt;aliasName&gt;&lt;alias&gt;&lt;/aliasName&gt; &lt;input&gt;[argomento]&lt;/input&gt;           Per eseguire l'alias

&lt;white&gt;Caratteri speciali:&lt;reset&gt;
  -   &lt;input&gt;#&lt;/input&gt;     Parametro
  -   ]]..ui.cVarID..ui.varID..[[&lt;reset&gt;     Variabile
  - ]]..ui.cSeparator..[[;&lt;reset&gt; o ]]..ui.cSeparator..[[/&lt;reset&gt;   Divisore comandi

&lt;white&gt;Esempio 1&lt;reset&gt; 
  =&gt; &lt;command&gt;uia&lt;/command&gt; &lt;aliasName&gt;hl&lt;/aliasName&gt; &lt;aliasOutput&gt;cast 'heal'&lt;/aliasOutput&gt;

  digitando: &lt;aliasName&gt;hl&lt;/aliasName&gt;
  eseguirà : &lt;aliasOutput&gt;cast 'heal'&lt;/aliasOutput&gt;       

  digitando: &lt;aliasName&gt;hl&lt;/aliasName&gt; &lt;input&gt;Pippo&lt;/input&gt;
  eseguirà : &lt;aliasOutput&gt;cast 'heal'&lt;/aliasOutput&gt; &lt;input&gt;Pippo&lt;/input&gt; 

&lt;white&gt;Esempio 2&lt;reset&gt;
  =&gt; &lt;command&gt;uia&lt;/command&gt; &lt;aliasName&gt;bt&lt;/aliasName&gt; &lt;aliasOutput&gt;bash&lt;/aliasOutput&gt; &lt;varName&gt;target&lt;/varName&gt;   
  (con &lt;varName&gt;target&lt;/varName&gt; = &lt;varValue&gt;Pluto&lt;/varValue&gt;)

  digitando: &lt;aliasName&gt;bt&lt;/aliasName&gt;
  eseguirà : &lt;aliasOutput&gt;bash&lt;/aliasOutput&gt; &lt;varValue&gt;Pluto&lt;/varValue&gt;

  digitando: &lt;aliasName&gt;bt&lt;/aliasName&gt; &lt;input&gt;Pippo&lt;/input&gt;
  eseguirà :&lt;aliasOutput&gt;bash&lt;/aliasOutput&gt; &lt;input&gt;Pippo&lt;/input&gt;
  (&lt;varName&gt;target&lt;/varName&gt; non cambia, rimarrà &lt;varValue&gt;Pluto&lt;/varValue&gt;)

&lt;white&gt;Esempio 3&lt;reset&gt;
  =&gt; &lt;command&gt;uia&lt;/command&gt; &lt;aliasName&gt;aa&lt;/aliasName&gt; &lt;varName&gt;action&lt;/varName&gt; &lt;varName&gt;target&lt;/varName&gt;
  (con &lt;varName&gt;action&lt;/varName&gt; = &lt;varValue&gt;kick&lt;/varValue&gt; e &lt;varName&gt;target&lt;/varName&gt; = &lt;varValue&gt;Pluto&lt;/varValue&gt;)
   
  digitando: &lt;aliasName&gt;aa&lt;/aliasName&gt;
  eseguirà : &lt;varValue&gt;kick&lt;/varValue&gt; &lt;varValue&gt;Pluto&lt;/varValue&gt;

  digitando: &lt;aliasName&gt;aa&lt;/aliasName&gt; &lt;input&gt;Pippo&lt;/input&gt;
  eseguirà : &lt;varValue&gt;kick&lt;/varValue&gt; &lt;input&gt;Pippo&lt;/input&gt;

&lt;white&gt;Esempio 4&lt;reset&gt;
  =&gt; &lt;command&gt;uia&lt;/command&gt; &lt;aliasName&gt;dd&lt;/aliasName&gt; &lt;aliasOutput&gt;get&lt;/aliasOutput&gt; &lt;input&gt;#&lt;/input&gt; &lt;varName&gt;bag&lt;/varName&gt;]]..ui.cSeparator..[[;&lt;reset&gt;&lt;aliasOutput&gt;drink&lt;/aliasOutput&gt; &lt;input&gt;#&lt;/input&gt;]]..ui.cSeparator..[[;&lt;reset&gt;&lt;aliasOutput&gt;put&lt;/aliasOutput&gt; &lt;input&gt;#&lt;/input&gt; &lt;varName&gt;bag&lt;/varName&gt;
  (con &lt;varName&gt;bag&lt;/varName&gt; = &lt;varValue&gt;moltetasche&lt;/varValue&gt;)

  digitando: &lt;aliasName&gt;dd&lt;/aliasName&gt; &lt;input&gt;limonata&lt;/input&gt;
  eseguirà : &lt;aliasOutput&gt;get&lt;/aliasOutput&gt; &lt;input&gt;limonata&lt;/input&gt; &lt;varValue&gt;moltetasche&lt;/varValue&gt;
             &lt;aliasOutput&gt;drink&lt;/aliasOutput&gt; &lt;input&gt;limonata&lt;/input&gt;
             &lt;aliasOutput&gt;put&lt;/aliasOutput&gt; &lt;input&gt;limonata&lt;/input&gt; &lt;varValue&gt;moltetasche&lt;/varValue&gt;

Ritorna alla pagina principale dell'&lt;link help&gt;help&lt;/link&gt;.
]]
--
ui.help.button = [[
&lt;title&gt;Pulsanti per alias&lt;/title&gt;
I pulsanti degli alias sono i pulsanti che posso essere personalizzati 
assonciandogli un alias. Sono identificati con una lettera (a, b oppure c) e un
numero (da 0 a 9) per un totale di 30 pulsanti configurabili (da &lt;button&gt;[a0]&lt;/button&gt; a &lt;button&gt;[a9]&lt;/button&gt;, da &lt;button&gt;[b0]&lt;/button&gt; a &lt;button&gt;[b9]&lt;/button&gt;, da &lt;button&gt;[c0]&lt;/button&gt; a &lt;button&gt;[c9]&lt;/button&gt;).

&lt;white&gt;Configurazione:&lt;reset&gt;
  &lt;command&gt;uib[uttons]&lt;/command&gt;                   Per visualizzare l'elenco dei pulsanti configurati
  &lt;command&gt;uib[uttons]&lt;/command&gt; &lt;button&gt;&lt;button&gt;&lt;/button&gt;          Per visualizzare il singolo pulsante
  &lt;command&gt;uib[uttons]&lt;/command&gt; &lt;button&gt;&lt;button&gt;&lt;/button&gt; &lt;aliasName&gt;&lt;alias&gt;&lt;/aliasName&gt;  Per associare un alias al pusante
  &lt;command&gt;uib[uttons]&lt;/command&gt; &lt;button&gt;&lt;button&gt;&lt;/button&gt; &lt;command&gt;remove&lt;/command&gt;   Per eliminare l'alias associato al pulsante
  &lt;command&gt;uib[uttons] remove_all&lt;/command&gt;        Per eliminare gli aliases associati a tutti i pulsanti

&lt;white&gt;Utilizzo:&lt;reset&gt;
  &lt;button&gt;&lt;button&gt;&lt;/button&gt; o click             Per eseguire l'alias associato al pulsante

Ritorna alla pagina principale dell'&lt;link help&gt;help&lt;/link&gt;.
]]
--
ui.help.color = [[
&lt;title&gt;Colori&lt;/title&gt;
E' possibile visualizzare l'elenco dei colori che si possono utilizzare negli
uiHilights tramite il comando &lt;command&gt;uiColors&lt;/command&gt;.  

&lt;white&gt;Utilizzo:&lt;reset&gt;
  &lt;command&gt;uic[olors]&lt;/command&gt;    Per visualizzare l'elenco dei colori

Ritorna alla pagina principale dell'&lt;link help&gt;help&lt;/link&gt;.
]]
--
ui.help.fontsize = [[
&lt;title&gt;Impostare la dimensione del font dei widget&lt;/title&gt;
E' possibile cambiare la dimensione del font di alcuni widget dell'UI.

&lt;white&gt;Utilizzo:&lt;reset&gt;
  &lt;command&gt;uisetf[ontsize] &lt;nome_widget&gt; &lt;dimensione_font&gt;&lt;/command&gt;

I &lt;command&gt;&lt;nome_widget&gt;&lt;/command&gt; disponibili sono: &lt;command&gt;all&lt;/command&gt; (per tutti contemporaneamente), &lt;command&gt;equipment&lt;/command&gt;, &lt;command&gt;help&lt;/command&gt;, &lt;command&gt;inventory&lt;/command&gt;, &lt;command&gt;map&lt;/command&gt;, &lt;command&gt;private&lt;/command&gt; o &lt;command&gt;public&lt;/command&gt;.

Le &lt;command&gt;&lt;dimensione_font&gt;&lt;/command&gt; devono essere un valore compreso tra &lt;varValue&gt;1&lt;/varValue&gt; e &lt;varValue&gt;30&lt;/varValue&gt;.

Ritorna alla pagina principale dell'&lt;link help&gt;help&lt;/link&gt;.
]]
--
ui.help.highlight = [[
&lt;title&gt;Highlights&lt;/title&gt;
Gli Highlights permettono di evidenziare le parole e le frasi del mud 
cambiandone il colore. Questo può semplificare la visualizzazione di elementi 
importanti come, ad esempio, evidenziare la presenza di una &lt;red&gt;cassa&lt;reset&gt; nella 
descrizione di una stanza.

&lt;white&gt;Configurazione:&lt;reset&gt;
  &lt;command&gt;uihi[lights]&lt;/command&gt;                   Per visualizzare l'elenco degli highlights
  &lt;command&gt;uihi[lights]&lt;/command&gt; &lt;testo&gt;           Per visualizzare il colore del testo
  &lt;command&gt;uihi[lights]&lt;/command&gt; &lt;testo&gt; &lt;colore&gt;  Per associare un colore a un testo
  &lt;command&gt;uihi[lights]&lt;/command&gt; &lt;testo&gt; &lt;command&gt;remove&lt;/command&gt;    Per eliminare highlights associato al testo
  &lt;command&gt;uihi[lights] remove_all&lt;/command&gt;        Per eliminare gli aliases associati a tutti i pulsanti

Per un elenco completo dei colori disponibili, utilizzare il comando uicolors.

Ritorna alla pagina principale dell'&lt;link help&gt;help&lt;/link&gt;.
]]
--
ui.help.keybind = [[
&lt;title&gt;Tasti rapidi per aliases e target&lt;/title&gt;
E' possibile associare una combinazione di tasti a un alias o a un target con
il comando &lt;command&gt;uikeybind&lt;/command&gt;.

&lt;white&gt;Configurazione:&lt;reset&gt;
  &lt;command&gt;uik[eybind]&lt;/command&gt;                           Per visualizzare l'elenco dei tasti rapidi
  &lt;command&gt;uik[eybind]&lt;/command&gt; &lt;aliasName&gt;&lt;alias&gt;&lt;/aliasName&gt;|&lt;button&gt;&lt;target&gt;&lt;/button&gt;          Per visualizzare i tasti dell'alias\del target
  &lt;command&gt;uik[eybind]&lt;/command&gt; &lt;aliasName&gt;&lt;alias&gt;&lt;/aliasName&gt;|&lt;button&gt;&lt;target&gt;&lt;/button&gt; &lt;keybind&gt;&lt;tasti&gt;&lt;/keybind&gt;  Per associare uun tasto all'alias\al target
  &lt;command&gt;uik[eybind]&lt;/command&gt; &lt;aliasName&gt;&lt;alias&gt;&lt;/aliasName&gt;|&lt;button&gt;&lt;target&gt;&lt;/button&gt; &lt;command&gt;remove&lt;/command&gt;   Per eliminare i tasti dell'alias\del target
  &lt;command&gt;uik[eybind] remove_all&lt;/command&gt;                Per eliminare tutti i tasti rapidi

I tasti utillizzabili possono essere i tasti funzione (&lt;keybind&gt;f1&lt;/keybind&gt;, &lt;keybind&gt;f2&lt;/keybind&gt;, &lt;keybind&gt;f3&lt;/keybind&gt;, etc), i caratteri
dell'alfabeto (&lt;keybind&gt;a&lt;/keybind&gt;, &lt;keybind&gt;b&lt;/keybind&gt;, &lt;keybind&gt;c&lt;/keybind&gt;, etc) e i numeri (&lt;keybind&gt;0&lt;/keybind&gt;, &lt;keybind&gt;1&lt;/keybind&gt;, &lt;keybind&gt;2&lt;/keybind&gt;, etc), presi singolarmente oppure
preceduti da &lt;keybind&gt;CTRL&lt;/keybind&gt; o &lt;keybind&gt;ALT&lt;/keybind&gt; (oppure entrambi).

Ritorna alla pagina principale dell'&lt;link help&gt;help&lt;/link&gt;.
]]
--
ui.help.profile = [[
&lt;title&gt;Profili&lt;/title&gt;
Tramite l'utilizzo dei profili è possibile salvare alias, highlights, target e variabili  

&lt;white&gt;Configurazione:&lt;reset&gt;
  &lt;command&gt;uip[rofiles]&lt;/command&gt;                   Per visualizzare l'elenco dei disponibili
  &lt;command&gt;uip[rofiles] load&lt;/command&gt; &lt;profile&gt;&lt;profilo&gt;&lt;/profile&gt;    Per caricare un profile
  &lt;command&gt;uip[rofiles] save&lt;/command&gt; &lt;profile&gt;&lt;profilo&gt;&lt;/profile&gt;    Per salvare i dati in uso su un profilo
  &lt;command&gt;uip[rofiles] remove&lt;/command&gt; &lt;profile&gt;&lt;profilo&gt;&lt;/profile&gt;  Per rimuovere un profilo
  &lt;command&gt;uip[rofiles] remove_all&lt;/command&gt;        Per eliminare tutti i profile

Ritorna alla pagina principale dell'&lt;link help&gt;help&lt;/link&gt;.
]]
--
ui.help.target = [[
&lt;title&gt;Target (g0..g9, o0, t1..t4)&lt;/title&gt;
La variable &lt;varName&gt;target&lt;/varName&gt; è una variabile predefinita dell'UI di Lumen et Umbra che è
possibile impostare in modi differenti. Oltre ad essere trattata come una 
variabile gestibile dal comando &lt;command&gt;uivariables&lt;/command&gt; è possibile impostarla utilizzando
o i 4 tasti target (&lt;button&gt;t1&lt;/button&gt;, &lt;button&gt;t2&lt;/button&gt;, &lt;button&gt;t3&lt;/button&gt; e &lt;button&gt;t4&lt;/button&gt;), oppure cliccando sul riquadro del nemico
attualmente ingaggiato (&lt;button&gt;o0&lt;/button&gt;) o ancora cliccando su uno dei componenti del gruppo
di gioco (da &lt;button&gt;g0&lt;/button&gt; a &lt;button&gt;g9&lt;/button&gt;).
I tasti &lt;button&gt;t1&lt;/button&gt;, &lt;button&gt;t2&lt;/button&gt;, &lt;button&gt;t3&lt;/button&gt; e &lt;button&gt;t4&lt;/button&gt; sono configurabili, mentre &lt;button&gt;o0&lt;/button&gt; e da &lt;button&gt;g0&lt;/button&gt; a &lt;button&gt;g9&lt;/button&gt; sono preimpostati in base
all'avversario ingaggiato e la composizione dale gruppo (l'ultima aggiornata 
con il comando &lt;white&gt;group&lt;reset&gt;.

&lt;white&gt;Configurazione:&lt;reset&gt;
  &lt;command&gt;t1..4&lt;/command&gt; &lt;valore&gt;        Per assegnare un valore a T1..T4
  &lt;command&gt;t1..4 remove&lt;/command&gt;          Per rimuovere il valore aassegnato a T1..T4

&lt;white&gt;Utilizzo:&lt;reset&gt;
  &lt;g0..9&gt; o click             Per assegnare a &lt;varName&gt;target&lt;/varName&gt; un componente del gruppo
  &lt;0o&gt; o click                Per assegnare a &lt;varName&gt;target&lt;/varName&gt; l'avversario ingaggiato
  &lt;t1..4&gt; o click             Per assegnare a &lt;varName&gt;target&lt;/varName&gt; il valore assegnato a t1..4

Ritorna alla pagina principale dell'&lt;link help&gt;help&lt;/link&gt;.
]]
--
ui.help.variable = [[
&lt;title&gt;Variabili&lt;/title&gt;
E' possibile definire delle variabili (retentive) da riutilizzare negli alias.
E' possibile richiamare una variabile all'interno di un alias facendo precedere
al nome della variabile il carattere speciale &lt;command&gt;@&lt;/command&gt;.
Alcune delle variabili sono già dichiarate (variabili predefinite), e vengno
utilizzate per gli elementi l'interfaccia.
Le variabili sono utlizzabili nel codice dei vostri script facendo accesso alla
tabella ui.variables[nomevariabile].

&lt;white&gt;Configurazione:&lt;reset&gt;
  &lt;command&gt;uiv[ariable]&lt;/command&gt;|&lt;command&gt;]]..ui.varID..[[&lt;/command&gt;                       Per visualizzare l'elenco delle variabili
  &lt;command&gt;uiv[ariable]&lt;/command&gt;|&lt;command&gt;]]..ui.varID..[[&lt;/command&gt; &lt;varName&gt;&lt;nome&gt;&lt;/varName&gt;                Per visualizzare il valore di una variabile
  &lt;command&gt;uiv[ariable]&lt;/command&gt;|&lt;command&gt;]]..ui.varID..[[&lt;/command&gt; &lt;varName&gt;&lt;nome&gt;&lt;/varName&gt; &lt;varValue&gt;&lt;valore&gt;&lt;/varValue&gt;       Per creare o modificare una variabile
  &lt;command&gt;uiv[ariable]&lt;/command&gt;|&lt;command&gt;]]..ui.varID..[[&lt;/command&gt; &lt;varName&gt;&lt;nome&gt;&lt;/varName&gt; &lt;command&gt;remove&lt;/command&gt;         Per rimuovere una variabile
  &lt;command&gt;uiv[ariable]&lt;/command&gt;|&lt;command&gt;]]..ui.varID..[[&lt;/command&gt; &lt;command&gt;remove_all&lt;/command&gt;            Per rimuovere tutte le variabili

Ritorna alla pagina principale dell'&lt;link help&gt;help&lt;/link&gt;.
]]
--
ui.help.walk = [[
&lt;title&gt;Walk, Speedwalk e Backwalk&lt;/title&gt;
Lumen et Umbra UI comprende uno strumento per la gestione dei movimenti del
personaggio. Tramite i comandi "&lt;command&gt;.&lt;/command&gt;" e "&lt;command&gt;..&lt;/command&gt;" è possibile percorrere lunghi
&lt;percorsi&gt; espressi, per esempio, nel formato "ee2w4suuu9n" oltre che 
ripercorrere i propri passi. 

&lt;white&gt;Utilizzo:&lt;reset&gt;
  &lt;command&gt;.&lt;/command&gt;&lt;percorso&gt;   Per eseguire il percorso specificato
  &lt;command&gt;..&lt;/command&gt;&lt;percorso&gt;  Per eseguire il percorso specificato all'indietro
  &lt;command&gt;.&lt;/command&gt;             Per ripercorere i propri passi (massimo 50 locazioni)
  &lt;command&gt;..&lt;/command&gt;            Per ripercorere i propri passi all'indietro (massimo 50 locazioni)

&lt;white&gt;Attenzione:&lt;reset&gt;
- Vengono memorizzate le direzioni inviate anche se il movimento nella locazione
non dovesse avvenire a causa di un ostacolo.
- Funziona solo con i comandi "d", "e", "n", "s", "u" e "w". 
- Non funziona con il comando "enter".
- Non funziona con il comando "run".

Ritorna alla pagina principale dell'&lt;link help&gt;help&lt;/link&gt;.
]]
--
ui.help.widget = [[
&lt;title&gt;Ripristino dei widget chiusi&lt;/title&gt;
E' possibile ripristinare i widget dell'UI che sono stati minimizzati o chiusi.

&lt;white&gt;Utilizzo:&lt;reset&gt;
  &lt;command&gt;uiw[idget] &lt;nome_widget&gt;&lt;/command&gt;

I &lt;command&gt;&lt;nome_widget&gt;&lt;/command&gt; disponibili sono: &lt;exec uiwidget all&gt;all&lt;/exec&gt; (per tutti contemporaneamente), &lt;exec uiwidget affect&gt;affect&lt;/exec&gt;, &lt;exec uiwidget buttons&gt;buttons&lt;/exec&gt;, &lt;exec uiwidget equipment&gt;equipment&lt;/exec&gt;, &lt;exec uiwidget group&gt;group&lt;/exec&gt;, &lt;exec uiwidget inventory&gt;inventory&lt;/exec&gt;, &lt;exec uiwidget map&gt;map&lt;/exec&gt;, &lt;exec uiwidget opponent&gt;opponent&lt;/exec&gt;, &lt;exec uiwidget private&gt;private&lt;/exec&gt;, &lt;exec uiwidget player&gt;player&lt;/exec&gt;, &lt;exec uiwidget public&gt;public&lt;/exec&gt; o &lt;exec uiwidget target&gt;target&lt;/exec&gt; per i relativi widgets.

Ritorna alla pagina principale dell'&lt;link help&gt;help&lt;/link&gt;.
]]
</script>
				<eventHandlerList />
			</Script>
			<Script isActive="yes" isFolder="no">
				<name>Init Widgets</name>
				<packageName></packageName>
				<script>--
-- GMCP
gmcp = gmcp or {}
gmcp.MSDP = gmcp.MSDP or {}
--
-- Load parameters
ui.fDebug("[init] Load 'Parameters' from file")
ui.parameters = ui.parameters or {}
if (io.exists(ui.fileParameters)) then
  table.load(ui.fileParameters, ui.parameters)
end
ui.parameters = table.update(ui.pre_defined_parameters, ui.parameters)
table.save(ui.fileParameters, ui.parameters)
--
-- Load variables
ui.fDebug("[init] Load 'Variables' from file")
ui.fReadFileVariables()
--
-- Load targets
ui.fDebug("[init] Load 'Targets' from file")
ui.fReadFileTargets()
--
-- Load Aliases
ui.fDebug("[init] Load 'Aliases' from file")
ui.fReadFileAliases()
--
-- Load Highlights
ui.fDebug("[init] Load 'Highlights' from file")
ui.fReadFileHighlights()
--
-- Opponent
ui.fDebug("[init] Opponent")
ui.fInitOpponentWidget()
--
-- Group
ui.fDebug("[init] Group")
ui.fInitGroupWidget()
--
-- Target Buttons
ui.fDebug("[init] Target Buttons")
ui.fInitTargetButtonsWidget()
--
--  Opponent and Groups are also targets. Widgets needed before updating
ui.fUpdateAllTargetButton()
ui.fUpdateTarget()
ui.fUpdateOpponent()
ui.fUpdateGroup() 
--
-- Player
ui.fDebug("[init] Player")
ui.fInitPlayerWidget()
ui.fUpdatePlayer()
--
-- Alias Button
ui.fDebug("[init] Alias Buttons")
ui.fInitAliasButtonsWidget()
ui.fUpdateAllAliasButton()
--
-- Affects
ui.fDebug("[init] Affects")
ui.fInitAffectsWidget()
ui.fUpdateAffects()
--
-- Map/Compass
ui.fDebug("[init] Map/Compass")
ui.fInitMapCompassWidget()
ui.fUpdateMap()
--
-- Inventory
ui.fDebug("[init] Inventory")
ui.fInitInventoryWidget()
--
-- Equipment
ui.fDebug("[init] Equipment")
ui.fInitEquipmentWidget()
--
-- Public
ui.fDebug("[init] Public Chat")
ui.fInitPublicChatWidget()
--
-- Private
ui.fDebug("[init] Private Chat")
ui.fInitPrivateChatWidget()
--
-- Help
ui.fDebug("[init] Help")
ui.fInitHelpWidget()
GUI.Help:hide()
--
-- Profile
ui.fDebug("[init] Profiles")
ui.fInitProfiles()
--
-- GMCP
ui.fDebug("[init] setMergeTables()")
setMergeTables("MSDP")
--
-- Events
ui.fDebug("[init] Register events")
registerAnonymousEventHandler("gmcp.MSDP","ui.fUpdateOpponent")
registerAnonymousEventHandler("gmcp.MSDP","ui.fUpdatePlayer")
--
-- Debug
if (ui.enDebug) then
  -- Tick simulation
  ui.fIncrementTickTimer(75)
end
--
ui.fDebug("[init] ... end UI init!")
--
ui.fEchon("&lt;orange&gt; - Lumen et Umbra UI v"..ui.release.." -&lt;white&gt; "..ui.fGetCommandFormattedText("uih[elp]").."&lt;white&gt; per iniziare.")</script>
				<eventHandlerList />
			</Script>
		</ScriptGroup>
		<Script isActive="yes" isFolder="no">
			<name>Other init</name>
			<packageName></packageName>
			<script>ui.parameters.enablePugno = ui.parameters.enablePugno or true</script>
			<eventHandlerList />
		</Script>
		<ScriptGroup isActive="yes" isFolder="yes">
			<name>Telegram Connector</name>
			<packageName>Telegram Connector</packageName>
			<script></script>
			<eventHandlerList />
			<Script isActive="yes" isFolder="no">
				<name>TelegramMainScript</name>
				<packageName></packageName>
				<script>-- #########################################################################
-- TODO
--  * Add #COMMANDS
--    * #TELEGRAM CONFIGURE
--    * #TELEGRAM ENABLE/DISABLE
--    * #TELEGRAM VERSION
--    * #TELEGRAM HELP
--    * #TELEGRAM UPDATE
--    * #HELP
--    * #VERSION
--    * #ABOUT
-- #########################################################################
-- Telegram configure 
--    -&gt; collect and store Token and update interval
--    -&gt; also allow setting a char name, or use Profile Name
--    -&gt; also allowed "senders"
-- 
local url_versionDownload = "https://github.com/takilara/MudletTelegramConnector/releases/latest/download/version.lua"
local url_latestVersion = "https://github.com/takilara/MudletTelegramConnector/releases/latest/download/"
local URL_GETUPDATES=nil
local URL_SENDMESSAGE=nil
local lineBuffer = {}
local current_message_id = -1
local current_chat_id = -1
--
Telegram = Telegram or {}
Telegram.Version = "v0.0.4"
Telegram.PackageName = "Telegram Connector"
Telegram.downloadPath = getMudletHomeDir().."/telegram downloads/"
Telegram.Options = {}
Telegram.MyName = "lep" -- Telegram.MyName or getProfileName()
Telegram.UpdateInterval = Telegram.UpdateInterval or 10 -- seconds
Telegram.Enabled = Telegram.Enabled or true
Telegram.Enabled = true
Telegram.EventHandlerIds = Telegram.EventHandlerIds or {}
Telegram.AliasHandlerIds = Telegram.AliasHandlerIds or {}
Telegram.URL = "https://api.telegram.org/bot"
Telegram.getReturnHandler = Telegram.getReturnHandler or nil
Telegram.getUpdateTimerId = Telegram.getUpdateTimerId or nil
Telegram.LastIdHandled = Telegram.LastIdHandled or -1
--Telegram.LastIdHandled = -1
function Telegram:SaveConfig()
  cecho("&lt;cyan&gt;Saving Telegram config...\n")
  table.save(getMudletHomeDir().."/telegram_options.lua", Telegram.Options)
end
--
function Telegram:SetToken(token)
  Telegram.Options["Token"] = token
  Telegram:UpdateUrls()
end
--
function Telegram:checkVersion()
  local path = Telegram.downloadPath .. "versions.lua"
  local versions = {}  
  table.load(path, versions)
  local pos = table.index_of(versions, Telegram.Version) or 0
  local line = ""
  if pos ~= 1 then
    line = "&lt;orange&gt;(online - ".. versions[1] ..")\n \t #TELEGRAM UPGRADE to upgrade"
  else
    line =""
  end
  return line
end
--
function Telegram:downloadVersionFile()
  if not io.exists(Telegram.downloadPath) then lfs.mkdir(Telegram.downloadPath) end
  local filename = "versions.lua"
  Telegram.downloading=true
  downloadFile(Telegram.downloadPath .. filename, url_versionDownload)
end
--
function Telegram:downloadLatestVersion()
  cecho("&lt;cyan&gt;Downloading the latest version of "..Telegram.PackageName)
  print()
  if not io.exists(Telegram.downloadPath) then lfs.mkdir(Telegram.downloadPath) end
  local filename = "TelegramConnector.mpackage"
  Telegram.downloading=true
  downloadFile(Telegram.downloadPath .. filename, url_latestVersion .. filename)
end
--
function Telegram:update_version()
  print("Update the version")
  Telegram:killAllExistingEventHandlers()
  uninstallPackage("Telegram Connector")
  installPackage(Telegram.downloadPath .. "TelegramConnector.mpackage")
end
--
function Telegram:UpdateUrls()
  if Telegram.Options["Token"]~=nil then
    URL_GETUPDATES=Telegram.URL..Telegram.Options.Token.."/getUpdates"
    URL_SENDMESSAGE=Telegram.URL..Telegram.Options.Token.."/sendMessage"
  end
end
--
function Telegram:LoadConfig()
  if io.exists(getMudletHomeDir().."/telegram_options.lua") then
    cecho("&lt;cyan&gt;Loading Telegram config...\n")
    table.load(getMudletHomeDir().."/telegram_options.lua", Telegram.Options) -- using / is OK on Windows too.
  else
    -- save it if it doesnt exits
    cecho("&lt;cyan&gt;Creating new Telegram config...\n")
    Telegram:DeleteConfig()
    Telegram:SaveConfig()
    Telegram:Reset()
  end
  Telegram:UpdateUrls()
end
--
function Telegram:HandleUserCommand(cmd,args)
  cmd = string.lower(cmd)
  local cmdA = string.split(args," ")
  sub_cmd = string.lower(table.remove(cmdA,1))
  sub_args = table.concat(cmdA," ")
  if (cmd=="help") then         -- Hook to global #HELP
    Telegram:showHelp()
  elseif (cmd=="version") then  -- Hook to global #VERSION
    Telegram:showVersion()
  elseif (cmd=="about") then    -- Hook to global #ABOUT
    Telegram:showAbout()
  -- Package specific below
  elseif (cmd=="telegram") then
    if sub_cmd=="" then
      Telegram:showHelp()
      Telegram:showStatus()
    elseif sub_cmd=="enable" then
      Telegram.Enabled = true
      cecho("&lt;green&gt;"..Telegram.PackageName.." ENABLED\n")
    elseif sub_cmd=="disable" then
      Telegram.Enabled = false
      cecho("&lt;orange&gt;"..Telegram.PackageName.." DISABLED\n")
    elseif sub_cmd=="version" then
      Telegram:showVersion()
    elseif sub_cmd=="help" then
      Telegram:showHelp()
    elseif sub_cmd=="about" then
      Telegram:showAbout()
    elseif sub_cmd=="status" then
      Telegram:showStatus()
    elseif sub_cmd=="delete" then
      Telegram:DeleteConfig()
      Telegram:SaveConfig()
      Telegram:Reset()
    elseif sub_cmd=="token" then
      Telegram:SetToken(sub_args)
      Telegram:CheckConfig()
      Telegram:SaveConfig()
    elseif sub_cmd=="auth" or sub_cmd=="authorize" then
      Telegram:Authorize(sub_args)
    elseif sub_cmd=="unauth" then
      Telegram:UnAuthorize(sub_args)
    elseif sub_cmd=="interval" then
      Telegram:SetInterval(sub_args)
    elseif sub_cmd=="tell" then
      local msgA = string.split(sub_args," ")
      local username = table.remove(msgA,1)
      local msg = table.concat(msgA," ")
      Telegram:Tell(username, msg)
    elseif sub_cmd=="whisper" then
      local msgA = string.split(sub_args," ")
      local username = table.remove(msgA,1)
      local msg = table.concat(msgA," ")
      Telegram:Tell(username, msg, true)
    elseif sub_cmd=="upgrade" then
      Telegram:downloadLatestVersion()
    end 
  end
end
--
function Telegram:showHelp()
  cecho("&lt;cyan&gt;".. Telegram.PackageName ..":\n")
  cecho(string.format("&lt;cyan&gt;%-30s- %s\n",string.format(" %s","#HELP"),"Show Helpfile(s)"))
  cecho(string.format("&lt;cyan&gt;%-30s- %s\n",string.format(" %s","#VERSION"),"Show version(s)"))
  cecho(string.format("&lt;cyan&gt;%-30s- %s\n",string.format(" %s","#TELEGRAM STATUS"),"Show Telegram Status"))
  cecho(string.format("&lt;cyan&gt;%-30s- %s\n",string.format(" %s","#TELEGRAM TOKEN &lt;token&gt;"),"Set Telegram Token"))
  cecho(string.format("&lt;cyan&gt;%-30s- %s\n",string.format(" %s","#TELEGRAM UPGRADE"),"Upgrade the package"))
  cecho(string.format("&lt;cyan&gt;%-30s- %s\n",string.format(" %s","#TELEGRAM INTERVAL &lt;seconds&gt;"),"Set polling interval, default 10s"))
  cecho(string.format("&lt;cyan&gt;%-30s- %s\n",string.format(" %s","#TELEGRAM TELL &lt;username&gt; &lt;message&gt;"),"Send a message to a telegram user"))
  cecho(string.format("&lt;cyan&gt;%-30s- %s\n",string.format(" %s","#TELEGRAM WHISPER &lt;username&gt; &lt;message&gt;"),"Send a message to a telegram user (no notification)"))
  cecho(string.format("&lt;cyan&gt;%-30s- %s\n",string.format(" %s","#TELEGRAM ENABLE/DISABLE"),"Enable or Disable the package"))
  cecho(string.format("&lt;cyan&gt;%-30s- %s\n",string.format(" %s","#TELEGRAM AUTH &lt;name&gt;"),"Authorize a Telegram user."))
  cecho(string.format("&lt;cyan&gt;%-30s- %s\n",string.format(" %s","#TELEGRAM UNAUTH &lt;name&gt;"),"UnAuthorize a Telegram user."))
  cecho("&lt;cyan&gt;---------------------------------------------------------------------------------------\n")
  print()
end
--
function Telegram:showAbout()
  print("Show about")
end
--
function Telegram:SetInterval(seconds)
  local s = tonumber(seconds)
  if s then
    cecho("&lt;green&gt;Set Telegram polling inverval to "..s.." seconds\n")
    Telegram.Options.Interval=s
    Telegram:SaveConfig()
    if Telegram.getUpdateTimerId~=nil then
      killTimer(Telegram.getUpdateTimerId)
    end
    Telegram.getUpdateTimerId = tempTimer(Telegram.Options.Interval,[[Telegram:getUpdates()]],true)
  else
    cecho("&lt;orange&gt;'"..seconds.."' is not a valid interval...\n")
  end
end
--
function Telegram:Authorize(name)
  if Telegram.Options.PendingAuthorization[name]~=nil then
    Telegram.Options.Authorized[name]=Telegram.Options.PendingAuthorization[name]
    Telegram.Options.PendingAuthorization[name]=nil
    cecho("&lt;green&gt;Authorized '"..name.."' for Telegram usage. You can now also send messages using\n")
    cecho("&lt;green&gt;#TELEGRAM TELL "..name.." &lt;message&gt;\n")    
    Telegram.SaveConfig()
  else
    cecho("&lt;orange&gt;'"..name.."' not pending authorization, have him/her send a message to the bot first...\n")
  end
end
--
function Telegram:UnAuthorize(name)
  if Telegram.Options.Authorized[name]~=nil then
    Telegram.Options.Authorized[name]= nil
    Telegram.Options.PendingAuthorization[name]=nil
    cecho("&lt;green&gt;UnAuthorized '"..name.."' for Telegram usage. \n")
    Telegram.SaveConfig()
  else
    cecho("&lt;orange&gt;'"..name.."' not authorized, nothing done...\n")
  end
end
--
function Telegram:showStatus()
  cecho("&lt;cyan&gt;---------------------------- TELEGRAM CONNECTOR STATUS --------------------------------\n")
  Telegram:showVersion()
  cecho("&lt;cyan&gt;Token: '"..Telegram.Options["Token"].."'\n")
  cecho("&lt;cyan&gt;Enabled: '"..tostring(Telegram.Options.Enabled).."'\n")
  cecho("&lt;cyan&gt;Polling Interval: "..Telegram.Options.Interval.." seconds\n")
  -- authorized
  cecho("&lt;cyan&gt;Authorized:\n")
  local countAuthorized =0
  local countPending =0
  for _ in pairs(Telegram.Options.Authorized) do countAuthorized = countAuthorized + 1 end
  for _ in pairs(Telegram.Options.PendingAuthorization) do countPending = countPending + 1 end
  if countAuthorized&gt;0 then
    for name,v in pairs(Telegram.Options.Authorized) do
      cecho("\t&lt;green&gt;"..name.."\n")
    end
  else
    cecho("\t&lt;orange&gt;NONE!\n")
  end
  -- pending authorization
  if countPending&gt;0 then
    cecho("&lt;cyan&gt;Pending Authorization:\n")
    for name,v in pairs(Telegram.Options.PendingAuthorization) do
      cecho("\t&lt;orange&gt;"..name.."\n")
    end
  end
  -- ignored
  cecho("&lt;cyan&gt;---------------------------------------------------------------------------------------\n")
  Telegram:Reset()
  Telegram:CheckConfig()
  Telegram:getUpdates()
end
--
function Telegram:showVersion()
  local vline = Telegram:checkVersion()
  cecho(string.format("&lt;cyan&gt;%-50s: %s %s\n",Telegram.PackageName,Telegram.Version,vline))
end
--
function Telegram:DeleteConfig()
  cecho("&lt;cyan&gt;Deleting Telegram config...\n")
  Telegram.Options = {}
  Telegram.Options.Authorized={}
  Telegram.Options.PendingAuthorization = {} -- populate from file
  Telegram.Options.Enabled = true
  Telegram.Options.Token=""
  Telegram.Options.Interval=10
  Telegram:UpdateUrls()
end
--
function Telegram:getInitialUpdates()
  if Telegram.Options.Enabled and Telegram.Options.Token~="" then
    getHTTP(URL_GETUPDATES)
  end
end
--
function Telegram:getUpdates()
  if Telegram.Options.Enabled and Telegram.Options.Token~="" then
    local header = {["Content-Type"] = "application/json"}
    local opts = {}
    opts["allowed_updates"] = {"message"}
    if Telegram.LastIdHandled == -1 then
      opts["offset"] = -2
    else
      opts["offset"] = Telegram.LastIdHandled+1
    end
    postHTTP(yajl.to_string(opts),URL_GETUPDATES,header)
  end
end
--
function Telegram:onHttpPost(event, ...)
  if event=="sysPostHttpError" then
    if string.find(arg[1],"telegram")~=nil then
      display(arg)
    end
  else
    local content = yajl.to_value(arg[2])
    local url = arg[1]      -- use this to check if this is a telegram message, and if so what type
    local response = arg[3] -- not sure what to use this for
    --if string.starts(url,Telegram.URL) then
    if url:starts("https://api.telegram.org") then    -- we only care about telegram messages
      if url == URL_GETUPDATES then
        if content["ok"] then
          Telegram:ParseUpdates(content["result"])
        else
          cecho("&lt;orange&gt;getUpdates was not successful, check URL\n")
          display(arg)
        end
      end
    end
  end
end
--
function Telegram:onHttpGetDone(event, ...)
  local content = yajl.to_value(arg[2])
  local url = arg[1]      -- use this to check if this is a telegram message, and if so what type
  local response = arg[3] -- not sure what to use this for
  --if string.starts(url,Telegram.URL) then
  if url:starts("https://api.telegram.org") then    -- we only care about telegram messages
    if url == URL_GETUPDATES then
      if content["ok"] then
        Telegram:ParseUpdates(content["result"])
      else
        cecho("&lt;orange&gt;getUpdates was not successful, check URL\n")
        display(arg)
      end
    else
      cecho("&lt;orange&gt;GET Not handled\n")
      display(url)
      display(contents)
    end
  end
end
--
function Telegram:Reset()
  Telegram.LastIdHandled=-1
  Telegram:UpdateUrls()
end
--
function Telegram:onFileDownloaded(event, ...)
  if event == "sysDownloadDone" and Telegram.downloading then
    local file = arg[1]
    if string.ends(file,"/versions.lua") then
      Telegram.downloading=false
      Telegram:checkVersion()
    elseif string.ends(file,"/TelegramConnector.mpackage") then
      Telegram.downloading=false
      Telegram:update_version()
    end
  end
end
--
function Telegram:ParseUpdates(contents)
  if Telegram.LastIdHandled==-1 then
    print("just loaded, update lasthandled to..")
    for i,m in pairs(contents) do
      if m["message"]~=nil then
        if m["message"]["message_id"] then
          Telegram.LastIdHandled = m["message"]["message_id"]
        end
      end
    end
    print("Last id handled set to:"..Telegram.LastIdHandled)
  end
  for i,m in pairs(contents) do
    if m["message"]==nil then
      --print("system message, ignore")
    else
      local t = m["message"]["chat"]["type"]  -- private or group
      local message_id = m["message"]["message_id"]
      local chat_id = m["message"]["chat"]["id"]
      local from_id = m["message"]["from"]["id"]
      local sender_id = m["message"]["from"]["id"]
      local cmd = m["message"]["text"]
      local from_username = m["message"]["from"]["username"]
      if message_id&gt;Telegram.LastIdHandled then
        if t=="group" then
          -- is this message for me?
          cmdA = cmd:split(" ")
          local cmdName = string.lower(cmdA[1])
          if string.find(cmdName,string.lower(Telegram.MyName))~=nil then
            -- remove first word
            table.remove(cmdA,1)
            cmd = table.concat(cmdA," ")
          else
            print("This command is for '"..cmdName.."', i am '"..Telegram.MyName.."', Ignore it...")
            cmd = nil
          end
        else
          -- private message, just execute it
        end
        if cmd~=nil then
          if Telegram:CheckAuthorized(from_username) then
            Telegram:HandleCommand(cmd,message_id,chat_id,from_username)
          else
            cecho("&lt;orange&gt;Telegram (".. from_username .." UNAUTHORIZED) has asked me to: '"..cmd.."'\n")
            cecho("&lt;orange&gt;#TELEGRAM AUTH "..from_username.." to authorize\n")
            cecho("&lt;orange&gt;#TELEGRAM IGNORE "..from_username.." to ignore future requests\n")
            -- add to pending approvals
            Telegram.Options.PendingAuthorization[from_username]=from_id
            local msg = "&lt;b&gt;"..Telegram:HtmlEncode("Command ignored....\nUser '"..from_username.."' not authorized\n#TELEGRAM AUTH "..from_username.." in Mudlet to Authorize.").."&lt;/b&gt;"
            local retMsg = {}
            retMsg["chat_id"]=chat_id
            retMsg["text"]=msg
            retMsg["reply_to_message_id"]=message_id
            retMsg["disable_notification"]=true
            retMsg["parse_mode"]="HTML"
            current_message_id = message_id
            current_chat_id = chat_id
            Telegram:SendMessage(retMsg)
            Telegram.LastIdHandled = message_id            
          end
        else
          -- just update the id
          Telegram.LastIdHandled = message_id
        end
      end
    end
  end
end
--
function Telegram:HtmlEncode(str)
  str = string.gsub(str,"&amp;","&amp;amp;")
  str = string.gsub(str,"&lt;","&amp;lt;")
  str = string.gsub(str,"&gt;","&amp;gt;")
  return str
end
--
function Telegram:CaptureLine(...)
  if isPrompt() then
    killTrigger(Telegram.lineTriggerId)
    Telegram.lineTriggerId = nil
    local htmlMsg = Telegram:HtmlEncode(table.concat(lineBuffer,"\n"))     
    local retMsg = {}
    retMsg["chat_id"]=current_chat_id
    retMsg["text"]="&lt;pre&gt;"..htmlMsg.."&lt;/pre&gt;"
    retMsg["reply_to_message_id"]=current_message_id
    retMsg["disable_notification"]=true
    retMsg["parse_mode"]="HTML"
    Telegram:SendMessage(retMsg)
  else
    -- dont add prompt
    table.insert(lineBuffer,line)
  end
end
--
function Telegram:Tell(username,msg,disable_notification)
  disable_notification = disable_notification or false
  if Telegram.Options.Authorized[username]~=nil then
    local htmlMsg = Telegram:HtmlEncode(msg) 
    local retMsg = {}
    retMsg["chat_id"]= Telegram.Options.Authorized[username]
    retMsg["text"]=msg
    retMsg["disable_notification"]= disable_notification
    Telegram:SendMessage(retMsg)
  else
    cecho("&lt;orange&gt;'"..username.."' is not authorized, use:\n")
    cecho("&lt;orange&gt;#TELEGRAM AUTH "..username.."\n")
  end
end
--
function Telegram:SendMessage(msgTable)
  local header = {["Content-Type"] = "application/json"}
  Telegram:UpdateUrls()
  cecho("&lt;cyan&gt;Sending to telegram...\n")
  postHTTP(yajl.to_string(msgTable),URL_SENDMESSAGE,header)
end
--
function Telegram:CheckConfig()
  if Telegram.Options["Token"]=="" then
    cecho("&lt;orange&gt;Token has not been set.\n")
    cecho("&lt;orange&gt;#TELEGRAM TOKEN &lt;token&gt; to set..\n")
  end
  local countAuthorized = 0
  for _ in pairs(Telegram.Options.Authorized) do countAuthorized = countAuthorized + 1 end
  --    
  if countAuthorized==0 then
    cecho("&lt;orange&gt;No one has been authorized. Send a message to the bot from Telegram, then!\n")
    cecho("&lt;orange&gt;#TELEGRAM AUTH &lt;charname&gt;\n")
  end
end
--
function Telegram:CheckAuthorized(from_username)
  if Telegram.Options.Authorized[from_username]==nil then
    return false
  else
    return true
  end
end
--
function Telegram:HandleCommand(cmd,message_id,chat_id,from_username)
  -- check if Authorized
  -- notify "On It"
  cecho("&lt;cyan&gt;Telegram (".. from_username ..") has asked me to: '"..cmd.."'\n")
  local retMsg = {}
  retMsg["chat_id"]=chat_id
  retMsg["text"]="on it"
  retMsg["reply_to_message_id"]=message_id
  retMsg["disable_notification"]=true
  current_message_id = message_id
  current_chat_id = chat_id
  Telegram:SendMessage(retMsg)
  -- start capture
  lineBuffer = {}
  -- enable line trigger
  if Telegram.lineTriggerId then 
    killTrigger(Telegram.lineTriggerId)
    Telegram.lineTriggerId = nil
  end
  Telegram.lineTriggerId = tempLineTrigger(0,99,[[Telegram:CaptureLine()]])
  -- send command
  expandAlias(cmd)
  -- update last handled
  Telegram.LastIdHandled = message_id
  -- stop Capture
  -- send last 3 lines back
  return true
end
--
function Telegram:killAllExistingEventHandlers()
  -- kill all dynamic handlers
  -- ... events
  for i,handlerId in pairs(Telegram.EventHandlerIds) do
    if tonumber(handlerId) then
      killAnonymousEventHandler(handlerId)
      Telegram.EventHandlerIds[i]= nil
    end
  end
  -- ... Aliases
  for i,handlerId in pairs(Telegram.AliasHandlerIds) do
    --print("Should remove alias "..handlerId)
    if tonumber(handlerId) then
      killAlias(handlerId)
      Telegram.AliasHandlerIds[i]= nil
    end
  end
  if Telegram.getReturnHandler~=nil then
    killAnonymousEventHandler(Telegram.getReturnHandler)
  end
  if Telegram.getUpdateTimerId~=nil then
    killTimer(Telegram.getUpdateTimerId)
  end
end
-- Init
--Telegram:killAllExistingEventHandlers()
-- setup dynamic eventHandlers
--table.insert(Telegram.EventHandlerIds,registerAnonymousEventHandler("sysPostHttpDone", [[Telegram:onHttpPost]]))
--table.insert(Telegram.EventHandlerIds,registerAnonymousEventHandler("sysPostHttpError", [[Telegram:onHttpPost]]))
--table.insert(Telegram.EventHandlerIds,registerAnonymousEventHandler("sysDownloadDone", [[Telegram:onFileDownloaded]]))
--table.insert(Telegram.AliasHandlerIds,tempAlias([[^#(?i)(\btelegram\b|\bhelp\b|\bversion\b|\babout\b)(?-i)\s*(.*)$]],[[Telegram:HandleUserCommand(matches[2],matches[3])]]))
--for i,handlerId in pairs(Telegram.AliasHandlerIds) do
--  if tonumber(handlerId) then
--    enableAlias(handlerId)
--  end
--end
-- manual handlers
--Telegram.getReturnHandler = registerAnonymousEventHandler("sysGetHttpDone", [[Telegram:onHttpGetDone]])
--Telegram:downloadVersionFile()
--Telegram:LoadConfig()
--Telegram.getUpdateTimerId = tempTimer(Telegram.Options.Interval,[[Telegram:getUpdates()]],true)
--Telegram:CheckConfig()
--Telegram:getInitialUpdates()</script>
				<eventHandlerList />
			</Script>
		</ScriptGroup>
		<ScriptGroup isActive="yes" isFolder="yes">
			<name>Varie</name>
			<packageName>Luogotenenti_scripts</packageName>
			<script></script>
			<eventHandlerList />
			<ScriptGroup isActive="yes" isFolder="yes">
				<name>Discord Webhook</name>
				<packageName></packageName>
				<script></script>
				<eventHandlerList />
				<Script isActive="yes" isFolder="no">
					<name>sendToDiscordWebhook</name>
					<packageName></packageName>
					<script>function sendToDiscordWebhook(message)
  local httpdone = registerAnonymousEventHandler('sysPostHttpDone', function(event, rurl, response)
                                                                      if rurl == url then 
                                                                        display(r) 
                                                                      else
                                                                        return true 
                                                                      end
                                                                    end, true)
  --
  local httperror = registerAnonymousEventHandler('sysPostHttpError', function(event, response, rurl)
                                                                        if rurl == url then 
                                                                          display(r) 
                                                                        else 
                                                                          return true 
                                                                        end
                                                                      end, true)
  --
  local url = "https://discord.com/api/webhooks/1069019910606430298/C38n1RlUOmsQq3q1fqwbOllc8gG9SUu2SfWK3sjBlGDmpBQV4YdcE4sPuVBHegeTnDmU"
  --
  local data = {
    username = "Invasione [by Kyrus]", 
    avatar_url = "https://s3.amazonaws.com/grapevine-haus/games/46/cover/thumbnail-054bf964-d5ae-4b54-8dc8-63cb85a87538.png",
    content = message
  }

  local header = {
    ["Content-Type"] = "application/json",
  }
  --
  postHTTP(yajl.to_string(data), url, header)
  killAnonymousEventHandler(httpdone)
  killAnonymousEventHandler(httperror)
end</script>
					<eventHandlerList />
				</Script>
			</ScriptGroup>
			<ScriptGroup isActive="yes" isFolder="yes">
				<name>Luogotenenti</name>
				<packageName></packageName>
				<script></script>
				<eventHandlerList />
				<Script isActive="yes" isFolder="no">
					<name>luogotenenti</name>
					<packageName></packageName>
					<script>function getPosition(direzione)
  if direzione == 'sud' then
    return 2
  elseif direzione == 'est' then
    return 6
  elseif direzione == 'nord' then
    return 8
  elseif direzione == 'ovest' then
    return 4
  elseif direzione == 'sud-ovest' then
    return 1
  elseif direzione == 'sud-est' then
    return 3
  elseif direzione == 'nord-est' then
    return 9
  elseif direzione == 'nord-ovest' then
    return 7
  elseif direzione == 'centro' then
    return 5
  end
end
--
function sposta(direction)
  local actualPosition = getPosition(ui.position)
  if (actualPosition==direction) then
    cecho("\n&lt;white:green&gt;Movimento non necessario. Sei gia' in ("..actualPosition..")&lt;reset&gt;",false)
  else
    if (actualPosition == 1) and (direction == 4 or direction == 2) then
      onestepmove=true      
    elseif (actualPosition == 2) and (direction == 1 or direction == 3) then
      onestepmove=true      
    elseif (actualPosition == 3) and (direction == 2 or direction == 6) then
      onestepmove=true      
    elseif (actualPosition == 4) and (direction == 1 or direction == 7) then
      onestepmove=true      
    elseif (actualPosition == 5) or (direction == 5) then
      onestepmove=true
    elseif (actualPosition == 6) and (direction == 3 or direction == 9) then
      onestepmove=true      
    elseif (actualPosition == 7) and (direction == 4 or direction == 8) then
      onestepmove=true      
    elseif (actualPosition == 8) and (direction == 6 or direction == 7) then
      onestepmove=true      
    elseif (actualPosition == 9) and (direction == 6 or direction == 8) then
      onestepmove=true      
    else
      onestepmove=false
    end
    
    if onestepmove then    
      cecho("\n&lt;white:orange&gt;Movimento veloce da ("..actualPosition..") a ("..direction..")&lt;reset&gt;\n",false)      
      send("sposta "..direction, true)      
    else
      cecho("\n&lt;white:red&gt;Movimento lento da ("..actualPosition..") a (5) a ("..direction..")&lt;reset&gt;\n",false)
      send("sposta 5", true)
      send("sposta "..direction, true)
    end
  end
end</script>
					<eventHandlerList />
				</Script>
			</ScriptGroup>
		</ScriptGroup>
		<ScriptGroup isActive="yes" isFolder="yes">
			<name>generic_mapper</name>
			<packageName>generic_mapper</packageName>
			<script></script>
			<eventHandlerList />
			<Script isActive="yes" isFolder="no">
				<name>Map Script</name>
				<packageName></packageName>
				<script>-- Jor'Mox's Generic Map Script
-- the script self-updates, changing this value will bring an update to all installations
-- make sure versions.lua has the latest version in it
local version = "2.0.27"

    -- look into options for non-standard door usage for speedwalk
    -- come up with aliases to set translations and custom exits, add appropriate help info

mudlet = mudlet or {}
mudlet.mapper_script = true
map = map or {}

map.help = {[[
    &lt;cyan&gt;Generic Map Script&lt;reset&gt;

    This script allows for semi-automatic mapping using the included triggers.
    While different games can have dramatically different ways of displaying
    information, some effort has been put into giving the script a wide range of
    potential patterns to look for, so that it can work with minimal effort in
    many cases. The script locates the room name by searching up from the
    detected exits line until a prompt is found or it runs out of text to
    search, clearing saved text each time a prompt is detected or a movement
    command is sent, with the room name being set to the last line of text
    found. An accurate prompt pattern is necessary for this to work well, and
    sometimes other text can end up being shown between the prompt and the room
    name, or on the same line as the room name, which can be handled by
    providing appropriate patterns telling the script to ignore that text. Below
    is an overview of the included commands and important events that this
    script uses to work. Additional information on each command or event is
    available in individual help files.

    &lt;cyan&gt;Fundamental Commands:&lt;reset&gt;
        These are commands used to get the mapper functional on a basic level

        &lt;link: show&gt;map show&lt;/link&gt; - Displays or hides a map window
        &lt;link: quick start&gt;map basics&lt;/link&gt; - Shows a quick-start guide with some basic information to
            help get the script working
        &lt;link: 1&gt;map help &lt;optional command name&gt;&lt;/link&gt; - Shows either this help file or the
            help file for the command given
        &lt;link: find prompt&gt;find prompt&lt;/link&gt; - Instructs the script to look for a prompt that matches
            a known pattern
        &lt;link: prompt&gt;map prompt&lt;/link&gt; - Provides a specific pattern to the script that matches
            your prompt, uses Lua string-library patterns
        &lt;link: ignore&gt;map ignore&lt;/link&gt; - Provides a specific pattern for the script to ignore,
            uses Lua string-library patterns
        &lt;link: movemethod&gt;map movemethod&lt;/link&gt; - Adds a movement method for the script to look for when mapping.
        &lt;link: debug&gt;map debug&lt;/link&gt; - Toggles on debug mode, in which extra messages are shown
            with the intent of assisting in troubleshooting getting the
            script setup
        &lt;link: me&gt;map me&lt;/link&gt; - Locates the user on the map, if possible
        &lt;link: path&gt;map path &lt;room name&gt; &lt;; optional area name&gt;&lt;/link&gt; - Finds a walking path to
            the named room, in the named area if specified
        &lt;link: character&gt;map character &lt;name&gt;&lt;/link&gt; - Sets a given name as the current character for
            the purposes of the script, used for different prompt patterns
            and recall locations
        &lt;link: recall&gt;map recall&lt;/link&gt; - Sets the current room as the recall location of the
            current character
        &lt;link: config&gt;map config &lt;configuration&gt; &lt;optional value&gt;&lt;/link&gt; - Sets or toggles the
            given configuration either turning it on or off, if no value is
            given, or sets it to the given value
        &lt;link: window&gt;map window &lt;configuration&gt; &lt;value&gt;&lt;/link&gt; - Sets the given configuration for
            the map window to the given value
        &lt;link: translate&gt;map translate &lt;english direction&gt; &lt;translated long direction&gt;&lt;/link&gt;
            &lt;link: translate&gt;&lt;translated short direction&gt;&lt;/link&gt; - Sets the provided translations for
            the given english direction word.

    &lt;cyan&gt;Mapping Commands:&lt;reset&gt;
        These are commands used in the process of actually creating a map

        &lt;link: start mapping&gt;start mapping &lt;optional area name&gt;&lt;/link&gt; - Starts adding content to the
            map, using either the area of the room the user is currently in,
            or the area name provided
        &lt;link: stop mapping&gt;stop mapping&lt;/link&gt; - Stops adding content to the map
        &lt;link: set area&gt;set area &lt;area name&gt;&lt;/link&gt; - Moves the current room to the named area
        &lt;link: mode&gt;map mode &lt;lazy, simple, normal or complex&gt;&lt;/link&gt; - Sets the mapping mode, which
            defines how new rooms are added to the map.
        &lt;link: add door&gt;add door &lt;direction&gt; &lt;optional door status&gt; &lt;optional one way&gt;&lt;/link&gt; -
            Creates a door in the given direction, with the given status
            (default closed), in both directions, unless a one-direction door
            is specified
        &lt;link: add portal&gt;add portal &lt;entry command&gt;&lt;/link&gt; - Creates a portal in the current room,
            using the given command for entry
        &lt;link: shift&gt;shift &lt;direction&gt;&lt;/link&gt; - Moves the current room on the map in the given
            direction
        &lt;link: merge rooms&gt;merge rooms&lt;/link&gt; - Combines overlapping rooms that have the same name into
            a single room
        &lt;link: clear moves&gt;clear moves&lt;/link&gt; - Clears the list of movement commands maintained by the
            script
        &lt;link: set exit&gt;set exit &lt;direction&gt; &lt;roomID&gt;&lt;/link&gt; - Creates a one-way exit in the given
            direction to the room with the specified roomID, can also be used
            with portals
        &lt;link: areas&gt;map areas&lt;/link&gt; - Shows a list of all area, with links to show a list of
            rooms in the area
        &lt;link: rooms&gt;map rooms &lt;area name&gt;&lt;/link&gt; - Shows a list of rooms in the named area

    &lt;cyan&gt;Sharing and Backup Commands:&lt;reset&gt;

        &lt;link: save&gt;map save&lt;/link&gt; - Creates a backup of the map
        &lt;link: load&gt;map load &lt;remote address&gt;&lt;/link&gt; - Loads a map backup, or a map file from a
            remote address
        &lt;link: export&gt;map export &lt;area name&gt;&lt;/link&gt; - Creates a file from the named area that can
            be shared
        &lt;link: import&gt;map import &lt;area name&gt;&lt;/link&gt; - Loads an area from a file

    &lt;cyan&gt;Mapping Events:&lt;reset&gt;
        These events are used by triggers to direct the script's behavior

        &lt;link: onNewRoom&gt;onNewRoom&lt;/link&gt; - Signals that a room has been detected, optional exits
            argument
        &lt;link: onMoveFail&gt;onMoveFail&lt;/link&gt; - Signals that an attempted move failed
        &lt;link: onForcedMove&gt;onForcedMove&lt;/link&gt; - Signals that the character moved without a command
            being entered, required direction argument
        &lt;link: onRandomMove&gt;onRandomMove&lt;/link&gt; - Signals that the character moved in an unknown
            direction without a command being entered
        &lt;link: onVisionFail&gt;onVisionFail&lt;/link&gt; - Signals that the character moved but some or all of
            the room information was not able to be gathered

    &lt;cyan&gt;Key Variables:&lt;reset&gt;
        These variables are used by the script to keep track of important
            information

        &lt;yellow&gt;map.prompt.room&lt;reset&gt; - Can be set to specify the room name
        &lt;yellow&gt;map.prompt.exits&lt;reset&gt; - Can be set to specify the room exits
        &lt;yellow&gt;map.prompt.hash&lt;reset&gt; - Can be set to specify the room hash
            Notice: if you set this, mapper will only find room by
            getRoomIDbyHash(hash)
        &lt;yellow&gt;map.character&lt;reset&gt; - Contains the current character name
        &lt;yellow&gt;map.save.recall&lt;reset&gt; - Contains a table of recall roomIDs for all
            characters
        &lt;yellow&gt;map.save.prompt_pattern&lt;reset&gt; - Contains a table of prompt patterns for all
            characters
        &lt;yellow&gt;map.save.ignore_patterns&lt;reset&gt; - Contains a table of patterns of text the
            script ignores
        &lt;yellow&gt;map.configs&lt;reset&gt; - Contains a number of different options that can be set
            to modify script behavior
        &lt;yellow&gt;map.currentRoom&lt;reset&gt; - Contains the roomID of the room your character is
            in, according to the script
        &lt;yellow&gt;map.currentName&lt;reset&gt; - Contains the name of the room your character is in,
            according to the script
        &lt;yellow&gt;map.currentExits&lt;reset&gt; - Contains a table of the exits of the room your
            character is in, according to the script
        &lt;yellow&gt;map.currentArea&lt;reset&gt; - Contains the areaID of the area your character is
            in, according to the script
]]}
map.help.save = [[
    &lt;cyan&gt;Map Save&lt;reset&gt;
        syntax: &lt;yellow&gt;map save&lt;reset&gt;

        This command creates a copy of the current map and stores it in the
        profile folder as map.dat. This can be useful for creating a backup
        before adding new content, in case of problems, and as a way to share an
        entire map at once.
]]
map.help.load = [[
    &lt;cyan&gt;Map Load&lt;reset&gt;
        syntax: &lt;yellow&gt;map load &lt;optional download address&gt;&lt;reset&gt;

        This command replaces the current map with the map stored as map.dat in
        the profile folder. Alternatively, if a download address is provided, a
        map is downloaded from that location and loaded to replace the current
        map. If no filename is given with the download address, the script tries
        to download map.dat. If a filename is given it MUST end with .dat.
]]
map.help.show = [[
    &lt;cyan&gt;Map Show&lt;reset&gt;
        syntax: &lt;yellow&gt;map show&lt;reset&gt;

        This command shows a map window, as specified by the window configs set
        via the &lt;link: window&gt;map window command&lt;/link&gt;. It isn't necessary to use this method to
        show a map window to use this script, any map window will work.
]]
map.help.export = [[
    &lt;cyan&gt;Map Export&lt;reset&gt;
        syntax: &lt;yellow&gt;map export &lt;area name&gt;&lt;reset&gt;

        This command creates a file containing all the informatino about the
        named area and stores it in the profile folder, with a file name based
        on the area name. This file can then be imported, allowing for easy
        sharing of single map areas. The file name will be the name of the area
        in all lower case, with spaces replaced with underscores, and a .dat
        file extension.
]]
map.help.import = [[
    &lt;cyan&gt;Map Import&lt;reset&gt;
        syntax: &lt;yellow&gt;map import &lt;area name&gt;&lt;reset&gt;

        This command imports a file from the profile folder with a name matching
        the name of the file, and uses it to create an area on the map. The area
        name used can be capitalized or not, and may have either spaces or
        underscores between words. The actual area name is stored within the
        file, and is not set by the area name used in this command.
]]
map.help.start_mapping = [[
    &lt;cyan&gt;Start Mapping&lt;reset&gt;
        syntax: &lt;yellow&gt;start mapping &lt;optional area name&gt;&lt;reset&gt;

        This command instructs the script to add new content to the map when it
        is seen. When first used, an area name is mandatory, so that an area is
        created for new rooms to be placed in. If used with an area name while
        the map shows the character within a room on the map, that room will be
        moved to be in the named area, if it is not already in it. If used
        without an area name, the room is not moved, and mapping begins in the
        area the character is currently located in.
]]
map.help.stop_mapping = [[
    &lt;cyan&gt;Stop Mapping&lt;reset&gt;
        syntax: &lt;yellow&gt;stop mapping&lt;reset&gt;

        This command instructs the script to stop adding new content until
        mapping is resumed at a later time. The map will continue to perform
        other functions.
]]
map.help.find_prompt = [[
    &lt;cyan&gt;Find Prompt&lt;reset&gt;
        syntax: &lt;yellow&gt;find prompt&lt;reset&gt;

        This command instructs the script to begin searching newly arriving text
        for something that matches one of its known prompt patterns. If one is
        found, that pattern will be set as the current prompt pattern. This
        should typically be the first command used to set up this script with a
        new profile. If your prompt appears after using this command, but there
        is no message saying that the prompt has been found, it will be
        necessary to use the map prompt command to manually set a pattern.
]]
map.help.prompt = [[
    &lt;cyan&gt;Map Prompt&lt;reset&gt;
        syntax: &lt;yellow&gt;map prompt &lt;prompt pattern&gt;&lt;reset&gt;

        This command manually sets a prompt pattern for the script to use.
        Because of the way this script works, the prompt pattern should match
        the entire prompt, so that if the text matching the pattern were
        removed, the line with the prompt would be blank. The patterns must be
        of the type used by the Lua string library. If you are unsure about what
        pattern to use, seek assistance on the Mudlet Forums or the Mudlet
        Discord channel.
]]
map.help.debug = [[
    &lt;cyan&gt;Map Debug&lt;reset&gt;
        syntax: &lt;yellow&gt;map debug&lt;reset&gt;

        This command toggles the map script's debug mode on or off when it is
        used. Debug mode provides some extra messages to help with setting up
        the script and identifying problems to help with troubleshooting. If you
        are getting assistance with setting up this script, using debug mode may
        make the process faster and easier.
]]
map.help.ignore = [[
    &lt;cyan&gt;Map Ignore&lt;reset&gt;
        syntax: &lt;yellow&gt;map ignore &lt;ignore pattern&gt;&lt;reset&gt;

        This command adds the given pattern to a list the script maintains to
        help it locate the room name. Any text that might appear after a command
        is sent to move and before the room name appears, or after the prompt
        and before the room name if several movement commands are sent at once,
        should have an ignore pattern added for it.

        If the given pattern is already in the list of ignore patterns, that
        pattern will be removed from the list.
]]
map.help.movemethod = [[
    &lt;cyan&gt;Move Method&lt;reset&gt;
        syntax: &lt;yellow&gt;map movemethod &lt;movement word&gt;&lt;reset&gt;

        This command will add a movement method for the script to look for
        when moving between rooms. If your game has methods such as "walk north",
        "swim south" or similar, add "walk" or "swim" as necessary. For single
        room movement only.

        If the given method is already in the list of movement methods, that
        method will be removed from the list.
]]
map.help.areas = [[
    &lt;cyan&gt;Map Areas&lt;reset&gt;
        syntax: &lt;yellow&gt;map areas&lt;reset&gt;

        This command displays a linked list of all areas in the map. When
        clicked, the rooms in the selected area will be displayed, as if the
        'map rooms' command had been used with that area as an argument.
]]
map.help.rooms = [[
    &lt;cyan&gt;Map Rooms&lt;reset&gt;
        syntax: &lt;yellow&gt;map rooms &lt;area name&gt;&lt;reset&gt;

        This command shows a list of all rooms in the area, with the roomID and
        the room name, as well as a count of how many rooms are in the area
        total. Note that the area name argument is not case sensitive.
]]
map.help.set_area = [[
    &lt;cyan&gt;Set Area&lt;reset&gt;
        syntax: &lt;yellow&gt;set area &lt;area name&gt;&lt;reset&gt;

        This command move the current room into the named area, creating the
        area if needed.
]]
map.help.mode = [[
    &lt;cyan&gt;Map Mode&lt;reset&gt;
        syntax: &lt;yellow&gt;map mode &lt;lazy, simple, normal, or complex&gt;&lt;reset&gt;

        This command changes the current mapping mode, which determines what
        happens when new rooms are added to the map.

        In lazy mode, connecting exits aren't checked and a room is only added if
        there isn't an adjacent room with the same name.

        In simple mode, if an adjacent room has an exit stub pointing toward the
        newly created room, and the new room has an exit in that direction,
        those stubs are connected in both directions.

        In normal mode (default), the newly created room is connected to the room you left
        from, so long as it has an exit leading in that direction.

        In complex mode, none of the exits of the newly connected room are
        connected automatically when it is created.
]]
map.help.add_door = [[
    &lt;cyan&gt;Add Door&lt;reset&gt;
        syntax: &lt;yellow&gt;add door &lt;direction&gt; &lt;optional none, open, closed, or locked&gt;
        &lt;optional yes or no&gt;&lt;reset&gt;

        This command places a door on the exit in the given direction, or
        removes it if "none" is given as the second argument. The door status is
        set as given by the second argument, default "closed". The third
        argument determines if the door is a one-way door, default "no".
]]
map.help.add_portal = [[
    &lt;cyan&gt;Add Portal&lt;reset&gt;
        syntax: &lt;yellow&gt;add portal &lt;optional -f&gt; &lt;entry command&gt;&lt;reset&gt;

        This command creates a special exit in the current room that is entered
        by using the given entry command. The given entry command is then sent,
        moving to the destination room. If the destination room matches an
        existing room, the special exit will link to that room, and if not a new
        room will be created. If the optional "-f" argument is given, a new room
        will be created for the destination regardless of if an existing room
        matches the room seen when arriving at the destination.
]]
map.help.shift = [[
    &lt;cyan&gt;Shift&lt;reset&gt;
        syntax: &lt;yellow&gt;shift &lt;direction&gt;&lt;reset&gt;

        This command moves the current room one step in the direction given, on
        the map.
]]
map.help.merge_rooms = [[
    &lt;cyan&gt;Merge Rooms&lt;reset&gt;
        syntax: &lt;yellow&gt;merge rooms&lt;reset&gt;

        This command combines all rooms that share the same coordinates and the
        same room name into a single room, with all of the exits preserved and
        combined.
]]
map.help.clear_moves = [[
    &lt;cyan&gt;Clear Moves&lt;reset&gt;
        syntax: &lt;yellow&gt;clear moves&lt;reset&gt;

        This command clears the script's queue of movement commands, and is
        intended to be used after you attempt to move while mapping but the
        movement is prevented in some way that is not caught and handled by a
        trigger that raises the onMoveFail event.
]]
map.help.set_exit = [[
    &lt;cyan&gt;Set Exit&lt;reset&gt;
        syntax: &lt;yellow&gt;set exit &lt;direction&gt; &lt;destination roomID&gt;&lt;reset&gt;

        This command sets the exit in the current room in the given direction to
        connect to the target room, as specified by the roomID. This is a
        one-way connection.
]]
map.help.onnewroom = [[
    &lt;cyan&gt;onNewRoom Event&lt;reset&gt;

        This event is raised to inform the script that a room has been detected.
        When raised, a string containing the exits from the detected room should
        be passed as a second argument to the raiseEvent function, unless those
        exits have previously been stored in map.prompt.exits.
]]
map.help.onmovefail = [[
    &lt;cyan&gt;onMoveFail Event&lt;reset&gt;

        This event is raised to inform the script that a move was attempted but
        the character was unable to move in the given direction, causing that
        movement command to be removed from the script's movement queue.
]]
map.help.onforcedmove = [[
    &lt;cyan&gt;onForcedMove Event&lt;reset&gt;

        This event is raised to inform the script that the character moved in a
        specified direction without a command being entered. When raised, a
        string containing the movement direction must be passed as a second
        argument to the raiseEvent function.

        The most common reason for this event to be raised is when a character
        is following someone else.
]]
map.help.onrandommove = [[
    &lt;cyan&gt;onRandomMove Event&lt;reset&gt;

        This event is raised to inform the script that the character has moved
        in an unknown direction. The script will compare the next room seen with
        rooms that are adjacent to the current room to try to determine the best
        match for where the character has gone.

        In some situations, multiple options are equally viable, so mistakes may
        result. The script will automatically keep verifying positioning with
        each step, and automatically correct the shown location on the map when
        possible.
]]
map.help.onvisionfail = [[
    &lt;cyan&gt;onVisionFail Event&lt;reset&gt;

        This event is raised to inform the script that some or all of the room
        information was not able to be gathered, but the character still
        successfully moved between rooms in the intended direction.
]]
map.help.onprompt = [[
    &lt;cyan&gt;onPrompt Event&lt;reset&gt;

        This event can be raised when using a non-conventional setup to trigger
        waiting messages from the script to be displayed. Additionally, if
        map.prompt.exits exists and isn't simply an empty string, raising this
        event will cause the onNewRoom event to be raised as well. This
        functionality is intended to allow people who have used the older
        version of this script to use this script instead, without having to
        modify the triggers they created for it.
]]
map.help.me = [[
    &lt;cyan&gt;Map Me&lt;reset&gt;
        syntax: &lt;yellow&gt;map me&lt;reset&gt;

        This command forces the script to look at the currently captured room
        name and exits, and search for a potentially matching room, moving the
        map if applicable. Note that this command is generally never needed, as
        the script performs a similar search any time the room name and exits
        don't match expectations.
]]
map.help.path = [[
    &lt;cyan&gt;Map Path&lt;reset&gt;
        syntax: &lt;yellow&gt;map path &lt;room name&gt; &lt;; optional area name&gt;&lt;reset&gt;

        This command tries to find a walking path from the current room to the
        named room. If an area name is given, only rooms within that area that
        is given are checked. Neither the room name nor the area name are case
        sensitive, but otherwise an exact match is required. Note that a
        semicolon is required between the room name and area name, if an area
        name is given, but spaces before or after the semicolon are optional.

        Example: &lt;yellow&gt;map path main street ; newbie town&lt;reset&gt;
]]
map.help.character = [[
    &lt;cyan&gt;Map Character&lt;reset&gt;
        syntax: &lt;yellow&gt;map character &lt;name&gt;&lt;reset&gt;

        This command tells the script what character is currently being used.
        Setting a character is optional, but recall locations and prompt
        patterns are stored by character name, so using this command allows for
        easy switching between different setups. The name given is stored in
        map.character. The name is a case sensitive exact match. The value of
        map.character is not saved between sessions, so this must be set again
        if needed each time the profile is opened.
]]
map.help.recall = [[
    &lt;cyan&gt;Map Recall&lt;reset&gt;
        syntax: &lt;yellow&gt;map recall&lt;reset&gt;

        This command tells the script that the current room is the recall point
        for the current character, as stored in map.character. This information
        is stored in map.save.recall[map.character], and is remembered between
        sessions.
]]
map.help.config = [[
    &lt;cyan&gt;Map Config&lt;reset&gt;
        syntax: &lt;yellow&gt;map config &lt;setting&gt; &lt;optional value&gt;&lt;reset&gt;

        This command changes any of the available configurations listed below.
        If no value is given, and the setting is either 'on' or 'off', then the
        value is switched. When naming a setting, spaces can be used in place of
        underscores. Details of what options are available and what each one
        does are provided.

        &lt;yellow&gt;speedwalk_delay&lt;reset&gt; - When using the speedwalk function of the script,
            this is the amount of time the script waits after either sending
            a command or, if speedwalk_wait is set, after arriving in a new
            room, before the next command is sent. This may be any number 0
            or higher.

        &lt;yellow&gt;speedwalk_wait&lt;reset&gt; - When using the speedwalk function of the script,
            this indicates if the script waits for your character to move
            into a new room before sending the next command. This may be true
            or false.

        &lt;yellow&gt;speedwalk_random&lt;reset&gt; - When using the speedwalk function of the script
            with a speedwalk_delay value, introduces a randomness to the wait
            time by adding some amount up to the speedwalk_delay value. This
            may be true or false.

        &lt;yellow&gt;stretch_map&lt;reset&gt; - When adding a new room that would overlap an existing
            room, if this is set the map will stretch out to prevent the
            overlap, with all rooms further in the direction moved getting
            pushed one further in that direction. This may be true or false.

        &lt;yellow&gt;max_search_distance&lt;reset&gt; - When mapping, this is the maximum number of
            rooms that the script will search in the movement direction for a
            matching room before deciding to create a new room. This may be
            false, or any positive whole number. This can also be set to 0,
            which is the same as setting it to false.

        &lt;yellow&gt;search_on_look&lt;reset&gt; - When this is set, using the "look" command causes
            the map to verify your position using the room name and exits
            seen following using the command. This may be true or false.

        &lt;yellow&gt;clear_lines_on_send&lt;reset&gt; - When this is set, any time a command is sent,
            any lines stored from the game used to search for the room name
            are cleared. This may be true or false.

        &lt;yellow&gt;mode&lt;reset&gt; - This is the default mapping mode on startup, and defines how
            new rooms are added to the map. May be "lazy", "simple",
            "normal" or "complex".

        &lt;yellow&gt;download_path&lt;reset&gt; - This is the path that updates are downloaded from.
            This may be any web address where the versions.lua and
            generic_mapper.xml files can be downloaded from.

        &lt;yellow&gt;prompt_test_patterns&lt;reset&gt; - This is a table of default patterns checked
            when using the "find prompt" command. The patterns in this table
            should start with a '^', and be written to be used with the Lua
            string library. Most importantly, '%' is used as the escape
            character instead of '\' as in trigger regex patterns.

        &lt;yellow&gt;custom_exits&lt;reset&gt; - This is a table of custom exit directions and their
            relevant extra pieces of info. Each entry should have the short
            direction as the keyword for a table containing first the long
            direction, then the long direction of the reverse of this
            direction, and then the x, y, and z change in map position
            corresponding to the movement. As an example: us = {'upsouth',
            'downnorth', 0, -1, 1}

        &lt;yellow&gt;custom_name_search&lt;reset&gt; - When this is set, instead of running the default
            function name_search, a user-defined function called
            'mudlet.custom_name_search' is used instead. This may be true or false.

        &lt;yellow&gt;use_translation&lt;reset&gt; - When this is set, the lang_dirs table is used to
            translate movement and status commands in some other language
            into the English used by the script. This may be true or false.

        &lt;yellow&gt;debug&lt;reset&gt; - When this is set, the script will start in debug mode. This
            may be true or false.
]]
map.help.window = [[
    &lt;yellow&gt;Map Window&lt;reset&gt;
        syntax: &lt;yellow&gt;map window &lt;setting&gt; &lt;value&gt;&lt;reset&gt;

        This command changes any of the available configurations listed below,
        which determine the appearance and positioning of the map window when
        the 'map show' command is used. Details of what options are available
        and what each one does are provided.

        &lt;yellow&gt;x&lt;reset&gt; - This is the x position of the map window, and should be a
            positive number of pixels or a percentage of the screen width.

        &lt;yellow&gt;y&lt;reset&gt; - This is the y position of the map window, and should be a
            positive number of pixels or a percentage of the screen height.

        &lt;yellow&gt;w&lt;reset&gt; - This is the width of the map window, and should be a positive
            number of pixels or a percentage of the screen width.

        &lt;yellow&gt;h&lt;reset&gt; - This is the height of the map window, and should be a positive
            number of pixels or a percentage of the screen height.

        &lt;yellow&gt;origin&lt;reset&gt; - This is the corner from which the window position is
            measured, and may be 'topright', 'topleft', 'bottomright', or
            'bottomleft'.

        &lt;yellow&gt;shown&lt;reset&gt; - This determines if the map window is shown immediately upon
            connecting to the game. This may be true or false. If you intend
            to have some other script control the map window, this should be
            set to false.
]]
map.help.translate = [[
    &lt;yellow&gt;Map Translate&lt;reset&gt;
        syntax: &lt;yellow&gt;map translate &lt;english direction&gt; &lt;translated long direction&gt;
            &lt;translated short direction&gt;&lt;reset&gt;

        This command sets direction translations for the script to use, either
        for commands entered to move around, or listed exits the game shows when
        you enter a room. Available directions: north, south, east, west,
        northwest, northeast, southwest, southeast, up, down, in, and out.
        Also you can customize special commands sent to mud like 'look'.
]]
map.help.quick_start = [[
    &lt;link: quick_start&gt;map basics&lt;/link&gt; (quick start guide)
    ----------------------------------------

    Mudlet Mapper works in tandem with a script, and this generic mapper script needs
    to know 2 things to work:
      - &lt;dim_grey&gt;room name&lt;reset&gt; $ROOM_NAME_STATUS ($ROOM_NAME)
      - &lt;dim_grey&gt;exits&lt;reset&gt;     $ROOM_EXITS_STATUS ($ROOM_EXITS)

    1. &lt;link: start mapping&gt;start mapping &lt;optional area name&gt;&lt;/link&gt;
       If both room name and exits are good, you can start mapping! Give it the
       area name you're currently in, usually optional but required for the first one.
    2. &lt;link: find prompt&gt;find prompt&lt;/link&gt;
       Room name or exits aren't recognised? Try this command then. It will make
       the script start looking for a prompt using several standard prompt
       patterns. If a prompt is found, you will be notified, if not, you will
       need to set a prompt pattern yourself using &lt;link: prompt&gt;map prompt&lt;/link&gt;.
       Reach out to the &lt;urllink: https://discord.gg/kuYvMQ9&gt;Mudlet community&lt;/urllink&gt; for help, we'd be happy to help
       you figure it out!
    3. &lt;link: debug&gt;map debug&lt;/link&gt;
       This toggles debug mode. When on, messages will be displayed showing what
       information is captured and a few additional error messages that can help
       with getting the script fully compatible with your game.
    4. &lt;link: 1&gt;map help&lt;/link&gt;
       This will bring up a more detailed help file, starting with the available
       help topics.
]]

map.character = map.character or ""
map.prompt = map.prompt or {}
map.save = map.save or {}
map.save.recall = map.save.recall or {}
map.save.prompt_pattern = map.save.prompt_pattern or {}
map.save.ignore_patterns = map.save.ignore_patterns or {}
map.save.move_methods = map.save.move_methods or {}

local oldstring = string
local string = utf8
string.format = oldstring.format
string.trim = oldstring.trim
string.starts = oldstring.starts
string.split = oldstring.split
string.ends = oldstring.ends


local profilePath = getMudletHomeDir()
profilePath = profilePath:gsub("\\","/")

map.defaults = {
    mode = "normal", -- can be lazy, simple, normal, or complex
    stretch_map = true,
    search_on_look = true,
    speedwalk_delay = 1,
    speedwalk_wait = true,
    speedwalk_random = true,
    max_search_distance = 1,
    clear_lines_on_send = true,
    map_window = {
        x = 0,
        y = 0,
        w = "30%",
        h = "40%",
        origin = "topright",
        shown = false,
    },
    prompt_test_patterns = {"^%[?%a*%]?&lt;.*&gt;", "^%[.*%]%s*&gt;", "^%w*[%.?!:]*&gt;", "^%[.*%]", "^[Hh][Pp]:.*&gt;"},
    custom_exits = {},  -- format: short_exit = {long_exit, reverse_exit, x_dif, y_dif, z_dif}
                        -- ex: { us = {"upsouth", "downnorth", 0, -1, 1}, dn = {"downnorth", "upsouth", 0, 1, -1} }
    custom_name_search = false,
    use_translation = true,
    lang_dirs = {n = 'n', ne = 'ne', nw = 'nw', e = 'e', w = 'w', s = 's', se = 'se', sw = 'sw',
        u = 'u', d = 'd', ["in"] = 'in', out = 'out', north = 'north', northeast = 'northeast',
        east = 'east', west = 'west', south = 'south', southeast = 'southeast', southwest = 'southwest',
        northwest = 'northwest', up = 'up', down = 'down', l = 'l', look = 'look',
        ed = 'ed', eu = 'eu', eastdown = 'eastdown', eastup = 'eastup',
        nd = 'nd', nu = 'nu', northdown = 'northdown', northup = 'northup',
        sd = 'sd', su = 'su', southdown = 'southdown', southup = 'southup',
        wd = 'wd', wu = 'wu', westdown = 'westdown', westup = 'westup',
    },
    debug = false,
    download_path = "https://raw.githubusercontent.com/Mudlet/Mudlet/development/src/mudlet-lua/lua/generic-mapper",
}

local move_queue, lines = {}, {}
local find_portal, vision_fail, room_detected, random_move, force_portal, find_prompt, downloading, walking, help_shown
local mt = getmetatable(map) or {}

local exitmap = {
    n = 'north',    ne = 'northeast',   nw = 'northwest',   e = 'east',
    w = 'west',     s = 'south',        se = 'southeast',   sw = 'southwest',
    u = 'up',       d = 'down',         ["in"] = 'in',      out = 'out',
    l = 'look',
    ed = 'eastdown',    eu = 'eastup',  nd = 'northdown',   nu = 'northup',
    sd = 'southdown',   su = 'southup', wd = 'westdown',    wu = 'westup',
}

local short = {}
for k,v in pairs(exitmap) do
    short[v] = k
end

local stubmap = {
    north = 1,      northeast = 2,      northwest = 3,      east = 4,
    west = 5,       south = 6,          southeast = 7,      southwest = 8,
    up = 9,         down = 10,          ["in"] = 11,        out = 12,
    northup = 13,   southdown = 14,     southup = 15,       northdown = 16,
    eastup = 17,    westdown = 18,      westup = 19,        eastdown = 20,
    [1] = "north",  [2] = "northeast",  [3] = "northwest",  [4] = "east",
    [5] = "west",   [6] = "south",      [7] = "southeast",  [8] = "southwest",
    [9] = "up",     [10] = "down",      [11] = "in",        [12] = "out",
    [13] = "northup", [14] = "southdown", [15] = "southup", [16] = "northdown",
    [17] = "eastup", [18] = "westdown", [19] = "westup",    [20] = "eastdown",
}

local coordmap = {
    [1] = {0,1,0},      [2] = {1,1,0},      [3] = {-1,1,0},     [4] = {1,0,0},
    [5] = {-1,0,0},     [6] = {0,-1,0},     [7] = {1,-1,0},     [8] = {-1,-1,0},
    [9] = {0,0,1},      [10] = {0,0,-1},    [11] = {0,0,0},     [12] = {0,0,0},
    [13] = {0,1,1},     [14] = {0,-1,-1},   [15] = {0,-1,1},    [16] = {0,1,-1},
    [17] = {1,0,1},     [18] = {-1,0,-1},   [19] = {-1,0,1},    [20] = {1,0,-1},
}

local reverse_dirs = {
    north = "south", south = "north", west = "east", east = "west", up = "down",
    down = "up", northwest = "southeast", northeast = "southwest", southwest = "northeast",
    southeast = "northwest", ["in"] = "out", out = "in",
    northup = "southdown", southdown = "northup", southup = "northdown", northdown = "southup",
    eastup = "westdown", westdown = "eastup", westup = "eastdown", eastdown = "westup",
}

local wait_echo = {}
local mapper_tag = "&lt;112,229,0&gt;(&lt;73,149,0&gt;mapper&lt;112,229,0&gt;): &lt;255,255,255&gt;"
local debug_tag = "&lt;255,165,0&gt;(&lt;200,120,0&gt;debug&lt;255,165,0&gt;): &lt;255,255,255&gt;"
local err_tag = "&lt;255,0,0&gt;(&lt;178,34,34&gt;error&lt;255,0,0&gt;): &lt;255,255,255&gt;"

local function config()
    local defaults = map.defaults
    local configs = map.configs or {}
    local path = profilePath.."/map downloads"
    if not io.exists(path) then lfs.mkdir(path) end
    -- load stored configs from file if it exists
    if io.exists(path.."/configs.lua") then
        table.load(path.."/configs.lua",configs)
    end
    -- overwrite default values with stored config values
    configs = table.update(defaults, configs)
    map.configs = configs
    map.configs.translate = {}
    for k, v in pairs(map.configs.lang_dirs) do
        map.configs.translate[v] = k
    end
    -- incorporate custom exits
    for k,v in pairs(map.configs.custom_exits) do
        exitmap[k] = v[1]
        reverse_dirs[v[1]] = v[2]
        short[v[1]] = k
        local count = #coordmap + 1
        coordmap[count] = {v[3],v[4],v[5]}
        stubmap[count] = v[1]
        stubmap[v[1]] = count
    end
    -- update to the current download path
    if map.configs.download_path == "https://raw.githubusercontent.com/JorMox/Mudlet/development/src/mudlet-lua/lua/generic-mapper" then
        map.configs.download_path = "https://raw.githubusercontent.com/Mudlet/Mudlet/development/src/mudlet-lua/lua/generic-mapper"
    end

    -- setup metatable to store sensitive values
    local protected = {"mapping", "currentRoom", "currentName", "currentExits", "currentArea",
        "prevRoom", "prevName", "prevExits", "mode", "version"}
    mt = getmetatable(map) or {}
    mt.__index = mt
    mt.__newindex = function(tbl, key, value)
            if not table.contains(protected, key) then
                rawset(tbl, key, value)
            else
                error("Protected Map Table Value")
            end
        end
    mt.set = function(key, value)
            if table.contains(protected, key) then
                mt[key] = value
            end
        end
    setmetatable(map, mt)
    map.set("mode", configs.mode)
    map.set("version", version)

    local saves = {}
    if io.exists(path.."/map_save.dat") then
        table.load(path.."/map_save.dat",saves)
    end
    saves.prompt_pattern = saves.prompt_pattern or {}
    saves.ignore_patterns = saves.ignore_patterns or {}
    saves.move_methods = saves.move_methods or {}
    saves.recall = saves.recall or {}
    map.save = saves

    if map.configs.map_window.shown then
        map.showMap(true)
    end
end

local function parse_help_text(text)
  text = text:gsub("%$ROOM_NAME_STATUS", (map.currentName and map.currentName ~= "") and '✔️' or '❌')
  text = text:gsub("%$ROOM_NAME", map.currentName or '')

  text = text:gsub("%$ROOM_EXITS_STATUS", (not map.currentExits or table.is_empty(map.currentExits)) and '❌' or '✔️')
  text = text:gsub("%$ROOM_EXITS", map.currentExits and table.concat(map.currentExits, ' ') or '')

  return text
end

function map.show_help(cmd)
    if cmd and cmd ~= "" then
        if cmd:starts("map ") then cmd = cmd:sub(5) end
        cmd = cmd:lower():gsub(" ","_")
        if not map.help[cmd] then
            map.echo("No help file on that command.")
        end
    else
        cmd = 1
    end

    for w in parse_help_text(map.help[cmd]):gmatch("[^\n]*\n") do
        local url, target = rex.match(w, [[&lt;(url)?link: ([^&gt;]+)&gt;]])
        -- lrexlib returns a non-capture as 'false', so determine which variable the capture went into
        if target == nil then target = url end
        if target then
            local before, linktext, _, link, _, after, ok = rex.match(w,
                          [[(.*)&lt;((url)?link): [^&gt;]+&gt;(.*)&lt;\/(url)?link&gt;(.*)]], 0, 'm')
            -- could not get rex.match to capture the newline - fallback to string.match
            local _, _, after = w:match("(.*)&lt;u?r?l?link: [^&gt;]+&gt;(.*)&lt;/u?r?l?link&gt;(.*)")

            cecho(before)
            fg("yellow")
            setUnderline(true)
            if linktext == "urllink" then
                echoLink(link, [[openWebPage("]]..target..[[")]], "Open Mudlet Discord", true)
            elseif target ~= "1" then
                echoLink(link,[[map.show_help("]]..target..[[")]],"View: map help " .. target,true)
            else
                echoLink(link,[[map.show_help()]],"View: map help",true)
            end
            setUnderline(false)
            resetFormat()
            if after then cecho(after) end
        else
            cecho(w)
        end
    end
    echo("\n")
end

local bool_configs = {'stretch_map', 'search_on_look', 'speedwalk_wait', 'speedwalk_random',
    'clear_lines_on_send', 'debug', 'custom_name_search', 'use_translation'}
-- function intended to be used by an alias to change config values and save them to a file for later
function map.setConfigs(key, val, sub_key)
    if val == "off" or val == "false" then
        val = false
    elseif val == "on" or val == "true" then
        val = true
    end
    local toggle = false
    if val == nil or val == "" then toggle = true end
    key = key:gsub(" ","_")
    if tonumber(val) then val = tonumber(val) end
    if not toggle then
        if key == "map_window" then
            if map.configs.map_window[sub_key] then
                map.configs.map_window[sub_key] = val
                map.echo(string.format("Map config %s set to: %s", sub_key, tostring(val)))
            else
                map.echo("Unknown map config.",false, true)
            end
        elseif key =="lang_dirs" then
            sub_key = exitmap[sub_key] or sub_key
            if map.configs.lang_dirs[sub_key] then
                local long_dir, short_dir = val[1],val[2]
                if #long_dir &lt; #short_dir then long_dir, short_dir = short_dir, long_dir end
                map.configs.lang_dirs[sub_key] = long_dir
                map.configs.lang_dirs[short[sub_key]] = short_dir
                map.echo(string.format("Direction/command %s, abbreviated as %s, now interpreted as %s.", long_dir, short_dir, sub_key))
                map.configs.translate = {}
                for k, v in pairs(map.configs.lang_dirs) do
                    map.configs.translate[v] = k
                end
            else
                map.echo("Invalid direction/command.", false, true)
            end
        elseif key == "prompt_test_patterns" then
            if not table.contains(map.configs.prompt_test_patterns) then
                table.insert(map.configs.prompt_test_patterns, val)
                map.echo("Prompt pattern added to list: " .. val)
            else
                table.remove(map.configs.prompt_test_patterns, table.index_of(map.configs.prompt_test_patterns, val))
                map.echo("Prompt pattern removed from list: " .. val)
            end
        elseif key == "custom_exits" then
            if type(val) == "table" then
                for k, v in pairs(val) do
                    map.configs.custom_exits[k] = v
                    map.echo(string.format("Custom Exit short direction %s, long direction %s",k,v[1]))
                    map.echo(string.format("    set to: x: %s, y: %s, z: %s, reverse: %s",v[3],v[4],v[5],v[2]))
                end
            else
                map.echo("Custom Exit config must be in the form of a table.", false, true)
            end
        elseif map.configs[key] ~= nil then
            map.configs[key] = val
            map.echo(string.format("Config %s set to: %s", key, tostring(val)))
        else
            map.echo("Unknown configuration.",false,true)
            return
        end
    elseif toggle then
        if (type(map.configs[key]) == "boolean" and table.contains(bool_configs, key)) then
            map.configs[key] = not map.configs[key]
            map.echo(string.format("Config %s set to: %s", key, tostring(map.configs[key])))
        elseif key == "map_window" and sub_key == "shown" then
            map.configs.map_window.shown = not map.configs.map_window.shown
            map.echo(string.format("Map config %s set to: %s", "shown", tostring(map.configs.map_window.shown)))
        else
            map.echo("Unknown configuration.",false,true)
            return
        end
    end
    table.save(profilePath.."/map downloads/configs.lua",map.configs)
    config()
end

local function show_err(msg,debug)
    map.echo(msg,debug,true)
    error(msg,2)
end

local function print_echoes(what, debug, err)
    moveCursorEnd("main")
    local curline = getCurrentLine()
    if curline ~= "" then echo("\n") end
    decho(mapper_tag)
    if debug then decho(debug_tag) end
    if err then decho(err_tag) end
    cecho(what)
    echo("\n")
end

local function print_wait_echoes()
    for k,v in ipairs(wait_echo) do
        print_echoes(v[1],v[2],v[3])
    end
    wait_echo = {}
end

function map.echo(what, debug, err, wait)
    if debug and not map.configs.debug then return end
    what = tostring(what) or ""
    if wait then
        table.insert(wait_echo,{what, debug, err})
        return
    end
    print_wait_echoes()
    print_echoes(what, debug, err)
end

local function set_room(roomID)
    -- moves the map to the new room
    if map.currentRoom ~= roomID then
        map.set("prevRoom", map.currentRoom)
        map.set("currentRoom", roomID)
    end
    if getRoomName(map.currentRoom) ~= map.currentName then
        map.set("prevName", map.currentName)
        map.set("prevExits", map.currentExits)
        map.set("currentName", getRoomName(map.currentRoom))
        map.set("currentExits", getRoomExits(map.currentRoom))
        -- check handling of custom exits here
        for i = 13,#stubmap do
            map.currentExits[stubmap[i]] = tonumber(getRoomUserData(map.currentRoom,"exit " .. stubmap[i]))
        end
    end
    map.set("currentArea", getRoomArea(map.currentRoom))
    centerview(map.currentRoom)
    raiseEvent("onMoveMap", map.currentRoom)
end

local function add_door(roomID, dir, status)
    -- create or remove a door in the designated direction
    -- consider options for adding pickable and passable information
    dir = exitmap[dir] or dir
    if not table.contains(exitmap,dir) then
        error("Add Door: invalid direction.",2)
    end
    if type(status) ~= "number" then
        status = assert(table.index_of({"none","open","closed","locked"},status),
            "Add Door: Invalid status, must be none, open, closed, or locked") - 1
    end
    local exits = getRoomExits(roomID)
    -- check handling of custom exits here
    if not exits[dir] then
        setExitStub(roomID,stubmap[dir],true)
    end
    -- check handling of custom exits here
    if not table.contains({'u','d'},short[dir]) then
        setDoor(roomID,short[dir],status)
    else
        setDoor(roomID,dir,status)
    end
end

local function check_doors(roomID,exits)
    -- looks to see if there are doors in designated directions
    -- used for room comparison, can also be used for pathing purposes
    if type(exits) == "string" then exits = {exits} end
    local statuses = {}
    local doors = getDoors(roomID)
    local dir
    for k,v in pairs(exits) do
        dir = short[k] or short[v]
        if table.contains({'u','d'},dir) then
            dir = exitmap[dir]
        end
        if not doors[dir] or doors[dir] == 0 then
            return false
        else
            statuses[dir] = doors[dir]
        end
    end
    return statuses
end

local function find_room(name, area)
    -- looks for rooms with a particular name, and if given, in a specific area
    local rooms = searchRoom(name)
    if type(area) == "string" then
        local areas = getAreaTable() or {}
        for k,v in pairs(areas) do
            if string.lower(k) == string.lower(area) then
                area = v
                break
            end
        end
        area = areas[area] or nil
    end
    for k,v in pairs(rooms) do
        if string.lower(v) ~= string.lower(name) then
            rooms[k] = nil
        elseif area and getRoomArea(k) ~= area then
            rooms[k] = nil
        end
    end
    return rooms
end

local function getRoomStubs(roomID)
    -- turns stub info into table similar to exit table
    local stubs = getExitStubs(roomID)
    if type(stubs) ~= "table" then stubs = {} end
    -- check handling of custom exits here
    local tmp
    for i = 13,#stubmap do
        tmp = tonumber(getRoomUserData(roomID,"stub "..stubmap[i])) or tonumber(getRoomUserData(roomID,"stub"..stubmap[i])) -- for old version
        if tmp then table.insert(stubs,tmp) end
    end

    local exits = {}
    for k,v in pairs(stubs) do
        exits[stubmap[v]] = 0
    end
    return exits
end

local function connect_rooms(ID1, ID2, dir1, dir2, no_check)
    -- makes a connection between rooms
    -- can make backwards connection without a check
    local match = false
    if not ID1 and ID2 and dir1 then
        error("Connect Rooms: Missing Required Arguments.",2)
    end
    dir2 = dir2 or reverse_dirs[dir1]
    -- check handling of custom exits here
    if stubmap[dir1] &lt;= 12 then
        setExit(ID1,ID2,stubmap[dir1])
    else
        addSpecialExit(ID1, ID2, dir1)
        setRoomUserData(ID1,"exit " .. dir1,ID2)
    end
    if stubmap[dir1] &gt; 12 then
        -- check handling of custom exits here
        setRoomUserData(ID1,"stub "..dir1, stubmap[dir1])
    end
    local doors1, doors2 = getDoors(ID1), getDoors(ID2)
    local dstatus1, dstatus2 = doors1[short[dir1]] or doors1[dir1], doors2[short[dir2]] or doors2[dir2]
    if dstatus1 ~= dstatus2 then
        if not dstatus1 then
            add_door(ID1,dir1,dstatus2)
        elseif not dstatus2 then
            add_door(ID2,dir2,dstatus1)
        end
    end
    if map.mode ~= "complex" then
        local stubs = getRoomStubs(ID2)
        if stubs[dir2] then match = true end
        if (match or no_check) then
            -- check handling of custom exits here
            if stubmap[dir1] &lt;= 12 then
                setExit(ID2,ID1,stubmap[dir2])
            else
                addSpecialExit(ID2, ID1, dir2)
                setRoomUserData(ID2,"exit " .. dir2,ID1)
            end
            if stubmap[dir2] &gt; 12 then
                -- check handling of custom exits here
                setRoomUserData(ID2,"stub "..dir2, stubmap[dir2])
            end
        end
    end
end

local function check_room(roomID, name, exits, onlyName)
    -- check to see if room name or/and exits match expectations
    if not roomID then
        error("Check Room Error: No ID",2)
    end
    -- check with room hash id
    if map.prompt.hash then
        if map.prompt.hash == getRoomHashByID(roomID) then
            return true
        else
            return false
        end
    end

    if name ~= getRoomName(roomID) then return false end

    -- used in mode "lazy" to match only the room name
    if onlyName then return true end

    local t_exits = table.union(getRoomExits(roomID),getRoomStubs(roomID))
    -- check handling of custom exits here
    for i = 13,#stubmap do
        t_exits[stubmap[i]] = tonumber(getRoomUserData(roomID,"exit " .. stubmap[i])) or (tonumber(getRoomUserData(roomID,"stub " .. stubmap[i])) and 0) or (tonumber(getRoomUserData(roomID,"stub" .. stubmap[i])) and 0) -- for old version
    end
    for k,v in ipairs(exits) do
        if short[v] and not table.contains(t_exits,v) then return false end
        t_exits[v] = nil
    end
    return table.is_empty(t_exits) or check_doors(roomID,t_exits)
end

local function stretch_map(dir,x,y,z)
    -- stretches a map to make room for just added room that would overlap with existing room
    local dx,dy,dz
    if not dir then return end
    for k,v in pairs(getAreaRooms(map.currentArea)) do
        if v ~= map.currentRoom then
            dx,dy,dz = getRoomCoordinates(v)
            if dx &gt;= x and string.find(dir,"east") then
                dx = dx + 1
            elseif dx &lt;= x and string.find(dir,"west") then
                dx = dx - 1
            end
            if dy &gt;= y and string.find(dir,"north") then
                dy = dy + 1
            elseif dy &lt;= y and string.find(dir,"south") then
                dy = dy - 1
            end
            if dz &gt;= z and string.find(dir,"up") then
                dz = dz + 1
            elseif dz &lt;= z and string.find(dir,"down") then
                dz = dz - 1
            end
            setRoomCoordinates(v,dx,dy,dz)
        end
    end
end

local function create_room(name, exits, dir, coords)
    -- makes a new room with captured name and exits
    -- links with other rooms as appropriate
    -- links to adjacent rooms in direction of exits if in simple mode
    if map.mapping then
        name = map.sanitizeRoomName(name)
        map.echo("New Room: " .. name,false,false,(dir or find_portal or force_portal) and true or false)
        local newID = createRoomID()
        addRoom(newID)
        setRoomArea(newID, map.currentArea)
        setRoomName(newID, name)
        if map.prompt.hash then
            setRoomIDbyHash(newID, map.prompt.hash)
        end
        for k,v in ipairs(exits) do
            if stubmap[v] then
                if stubmap[v] &lt;= 12 then
                    setExitStub(newID, stubmap[v], true)
                else
                    -- add special char to prompt special exit
                    if string.find(v, "up") or string.find(v, "down") then
                        setRoomChar(newID, "◎")
                    end
                    -- check handling of custom exits here
                    setRoomUserData(newID, "stub "..v,stubmap[v])
                end
            end
        end
        if dir then
            connect_rooms(map.currentRoom, newID, dir)
        elseif find_portal or force_portal then
            addSpecialExit(map.currentRoom, newID, (find_portal or force_portal))
            setRoomUserData(newID,"portals",tostring(map.currentRoom)..":"..(find_portal or force_portal))
        end
        setRoomCoordinates(newID,unpack(coords))
        local pos_rooms = getRoomsByPosition(map.currentArea,unpack(coords))
        if not (find_portal or force_portal) and map.configs.stretch_map and table.size(pos_rooms) &gt; 1 then
            set_room(newID)
            stretch_map(dir,unpack(coords))
        end
        if map.mode == "simple" then
            local x,y,z = unpack(coords)
            local dx,dy,dz,rooms
            for k,v in ipairs(exits) do
                if stubmap[v] then
                    dx,dy,dz = unpack(coordmap[stubmap[v]])
                    rooms = getRoomsByPosition(map.currentArea,x+dx,y+dy,z+dz)
                    if table.size(rooms) == 1 then
                        connect_rooms(newID,rooms[0],v)
                    end
                end
            end
        end
        set_room(newID)
    end
end

local function find_area_limits(areaID)
    -- used to find min and max coordinate limits for an area
    if not areaID then
        error("Find Limits: Missing area ID",2)
    end
    local rooms = getAreaRooms(areaID)
    local minx, miny, minz = getRoomCoordinates(rooms[0])
    local maxx, maxy, maxz = minx, miny, minz
    local x,y,z
    for k,v in pairs(rooms) do
        x,y,z = getRoomCoordinates(v)
        minx = math.min(x,minx)
        maxx = math.max(x,maxx)
        miny = math.min(y,miny)
        maxy = math.max(y,maxy)
        minz = math.min(z,minz)
        maxz = math.max(z,maxz)
    end
    return minx, maxx, miny, maxy, minz, maxz
end

local function find_link(name, exits, dir, max_distance)
    -- search for matching room in desired direction
    -- in lazy mode check_room search only by name
    local x,y,z = getRoomCoordinates(map.currentRoom)
    if map.mapping and x then
        if max_distance &lt; 1 then
            max_distance = nil
        else
            max_distance = max_distance - 1
        end
        if not stubmap[dir] or not coordmap[stubmap[dir]] then return end
        local dx,dy,dz = unpack(coordmap[stubmap[dir]])
        local minx, maxx, miny, maxy, minz, maxz = find_area_limits(map.currentArea)
        local rooms, match, stubs
        if max_distance then
            minx, maxx = x - max_distance, x + max_distance
            miny, maxy = y - max_distance, y + max_distance
            minz, maxz = z - max_distance, z + max_distance
        end
        -- find link from room hash first
        if map.prompt.hash then
            local room = getRoomIDbyHash(map.prompt.hash)
            if room &gt; 0 then
                match = room
            end
        else
            repeat
                x, y, z = x + dx, y + dy, z + dz
                rooms = getRoomsByPosition(map.currentArea,x,y,z)
            until (x &gt; maxx or x &lt; minx or y &gt; maxy or y &lt; miny or z &gt; maxz or z &lt; minz or not table.is_empty(rooms))
            for k,v in pairs(rooms) do
                if check_room(v,name,exits,false) then
                    match = v
                    break
                elseif map.mode == "lazy" and check_room(v,name,exits,true) then
                    match = v
                    break
                end
            end
        end
        if match then
            connect_rooms(map.currentRoom, match, dir)
            set_room(match)
        else
            x,y,z = getRoomCoordinates(map.currentRoom)
            create_room(name, exits, dir,{x+dx,y+dy,z+dz})
        end
    end
end

local function move_map()
    -- tries to move the map to the next room
    local move = table.remove(move_queue,1)
    if move or random_move then
        local exits = (map.currentRoom and getRoomExits(map.currentRoom)) or {}
        -- check handling of custom exits here
        if map.currentRoom then
            for i = 13, #stubmap do
                exits[stubmap[i]] = tonumber(getRoomUserData(map.currentRoom,"exit " .. stubmap[i]))
            end
        end
        local special = (map.currentRoom and getSpecialExitsSwap(map.currentRoom)) or {}
        if move and not exits[move] and not special[move] then
            for k,v in pairs(special) do
                if string.starts(k,move) then
                    move = k
                    break
                end
            end
        end
        if find_portal then
            map.find_me(map.currentName,map.currentExits,move)
            find_portal = false
        elseif force_portal then
            find_portal = false
            map.echo("Creating portal destination")
            create_room(map.currentName, map.currentExits, nil, {getRoomCoordinates(map.currentRoom)})
            force_portal = false
        elseif move == "recall" and map.save.recall[map.character] then
            set_room(map.save.recall[map.character])
        elseif move == map.configs.lang_dirs['look'] and map.currentRoom and not check_room(map.currentRoom, map.currentName, map.currentExits) then
            -- this check isn't working as intended, find out why
            map.find_me(map.currentName,map.currentExits)
        else
            local onlyName
            if map.mode == "lazy" then
              onlyName = true
            else
              onlyName = false
            end
            if exits[move] and (vision_fail or check_room(exits[move], map.currentName, map.currentExits, onlyName)) then
                set_room(exits[move])
            elseif special[move] and (vision_fail or check_room(special[move], map.currentName, map.currentExits, onlyName)) then
                set_room(special[move])
            elseif not vision_fail then
                if map.mapping and move then
                    find_link(map.currentName, map.currentExits, move, map.configs.max_search_distance)
                else
                    map.find_me(map.currentName,map.currentExits, move)
                end
            end
        end
        vision_fail = false
    end
end

local function capture_move_cmd(dir,priority)
    -- captures valid movement commands
    local configs = map.configs
    if configs.clear_lines_on_send then
        lines = {}
    end
    dir = string.lower(dir)
    if dir == "/" then dir = "recall" end
    if dir == configs.lang_dirs['l'] then dir = configs.lang_dirs['look'] end
    if configs.use_translation then
        dir = configs.translate[dir] or dir
    end
    local door = string.match(dir,"open (%a+)")
    if map.mapping and door and (exitmap[door] or short[door]) then
        local doors = getDoors(map.currentRoom)
        if not doors[door] and not doors[short[door]] then
            map.set_door(door,"","")
        end
    end
    for i,v in ipairs(map.save.move_methods) do
    	local str = string.match(dir, v .. " (%a+)")
    	if str then 
    		dir = str
    		break
    	end
    end
    local portal = string.match(dir,"enter (%a+)")
    if map.mapping and portal then
        local portals = getSpecialExitsSwap(map.currentRoom)
        if not portals[dir] then
            map.set_portal(dir, true)
        end
    end
    if table.contains(exitmap,dir) or string.starts(dir,"enter ") or dir == "recall" then
      if dir ~= configs.lang_dirs['look'] then
        if priority then
            table.insert(move_queue,1,exitmap[dir] or dir)
        else
            table.insert(move_queue,exitmap[dir] or dir)
        end
      else
        if configs.search_on_look == true then
          table.insert(move_queue, dir)
        end
    end				
    elseif map.currentRoom then
        local special = getSpecialExitsSwap(map.currentRoom) or {}
        if special[dir] then
            if priority then
                table.insert(move_queue,1,dir)
            else
                table.insert(move_queue,dir)
            end
        end
    end
end

local function deduplicate_exits(exits)
  local deduplicated_exits = {}
  for _, v in ipairs(exits) do
    deduplicated_exits[v] = true
  end

  return table.keys(deduplicated_exits)
end
local function capture_room_info(name, exits)
    -- captures room info, and tries to move map to match
    if (not vision_fail) and name and exits then
        map.set("prevName", map.currentName)
        map.set("prevExits", map.currentExits)
        name = string.trim(name)
        map.set("currentName", name)
        if exits:ends(".") then exits = exits:sub(1,#exits-1) end
        if not map.configs.use_translation then
            exits = string.gsub(string.lower(exits)," and "," ")
        end
        map.set("currentExits", {})
        for w in string.gmatch(exits,"%a+") do
            if map.configs.use_translation then
                local dir = map.configs.translate and map.configs.translate[w]
                if dir then table.insert(map.currentExits,dir) end
            else
                table.insert(map.currentExits,w)
            end
        end
        undupeExits = deduplicate_exits(map.currentExits)
        map.set("currentExits", undupeExits)
        map.echo(string.format("Exits Captured: %s (%s)",exits, table.concat(map.currentExits, " ")),true)
        move_map()
    elseif vision_fail then
        move_map()
    end
end

local function find_area(name)
    -- searches for the named area, and creates it if necessary
    local areas = getAreaTable()
    local areaID
    for k,v in pairs(areas) do
        if string.lower(name) == string.lower(k) then
            areaID = v
            break
        end
    end
    if not areaID then areaID = addAreaName(name) end
    if not areaID then
        show_err("Invalid Area. No such area found, and area could not be added.",true)
    end
    map.set("currentArea", areaID)
end

function map.load_map(address)
    local path = profilePath .. "/map downloads/map.dat"
    if not address then
        loadMap(path)
        map.echo("Map reloaded from local copy.")
    else
        if not string.match(address,"/[%a_]+%.dat$") then
            address = address .. "/map.dat"
        end
        downloading = true
        downloadFile(path, address)
        map.echo(string.format("Downloading map file from: %s.",address))
    end
end

function map.set_exit(dir,roomID)
    -- used to set unusual exits from the room you are standing in
    if map.mapping then
        roomID = tonumber(roomID)
        if not roomID then
            show_err("Set Exit: Invalid Room ID")
        end
        if not table.contains(exitmap,dir) and not string.starts(dir, "-p ") then
            show_err("Set Exit: Invalid Direction")
        end

        if not string.starts(dir, "-p ") then
            local exit
            if stubmap[exitmap[dir] or dir] &lt;= 12 then
                exit = short[exitmap[dir] or dir]
                setExit(map.currentRoom,roomID,exit)
            else
                -- check handling of custom exits here
                exit = exitmap[dir] or dir
                exit = "exit " .. exit
                setRoomUserData(map.currentRoom,exit,roomID)
            end
            map.echo("Exit " .. dir .. " now goes to roomID " .. roomID)
        else
            dir = string.gsub(dir,"^-p ","")
            addSpecialExit(map.currentRoom,roomID,dir)
            map.echo("Special exit '" .. dir .. "' now goes to roomID " .. roomID)
        end
    else
        map.echo("Not mapping",false,true)
    end
end

function map.find_path(roomName,areaName,return_tables)
    areaName = (areaName ~= "" and areaName) or nil
    local rooms = find_room(roomName,areaName)
    local found,dirs = false,{}
    local path = {}
    for k,v in pairs(rooms) do
        found = getPath(map.currentRoom,k)
        if found and (#dirs == 0 or #dirs &gt; #speedWalkDir) then
            dirs = speedWalkDir
            path = speedWalkPath
        end
    end
    if return_tables then
        if table.is_empty(path) then
            path, dirs = nil, nil
        end
        return path, dirs
    else
        if #dirs &gt; 0 then
            map.echo("Path to " .. roomName .. ((areaName and " in " .. areaName) or "") .. ": " .. table.concat(dirs,", "))
        else
            map.echo("No path found to " .. roomName .. ((areaName and " in " .. areaName) or "") .. ".",false,true)
        end
    end
end

function map.export_area(name)
    -- used to export a single area to a file
    local areas = getAreaTable()
    name = string.lower(name)
    for k,v in pairs(areas) do
        if name == string.lower(k) then name = k end
    end
    if not areas[name] then
        show_err("No such area.")
    end
    local rooms = getAreaRooms(areas[name])
    local tmp = {}
    for k,v in pairs(rooms) do
        tmp[v] = v
    end
    rooms = tmp
    local tbl = {}
    tbl.name = name
    tbl.rooms = {}
    tbl.exits = {}
    tbl.special = {}
    local rname, exits, stubs, doors, special, portals, door_up, door_down, coords
    for k,v in pairs(rooms) do
        rname = getRoomName(v)
        exits = getRoomExits(v)
        stubs = getExitStubs(v)
        doors = getDoors(v)
        special = getSpecialExitsSwap(v)
        portals = getRoomUserData(v,"portals") or ""
        coords = {getRoomCoordinates(v)}
        tbl.rooms[v] = {name = rname, coords = coords, exits = exits, stubs = stubs, doors = doors, door_up = door_up,
            door_down = door_down, door_in = door_in, door_out = door_out, special = special, portals = portals}
        tmp = {}
        for k1,v1 in pairs(exits) do
            if not table.contains(rooms,v1) then
                tmp[k1] = {v1, getRoomName(v1)}
            end
        end
        if not table.is_empty(tmp) then
            tbl.exits[v] = tmp
        end
        tmp = {}
        for k1,v1 in pairs(special) do
            if not table.contains(rooms,v1) then
                tmp[k1] = {v1, getRoomName(v1)}
            end
        end
        if not table.is_empty(tmp) then
            tbl.special[v] = tmp
        end
    end
    local path = profilePath.."/"..string.gsub(string.lower(name),"%s","_")..".dat"
    table.save(path,tbl)
    map.echo("Area " .. name .. " exported to " .. path)
end

function map.import_area(name)
    name = profilePath .. "/" .. string.gsub(string.lower(name),"%s","_") .. ".dat"
    local tbl = {}
    table.load(name,tbl)
    if table.is_empty(tbl) then
        show_err("No file found")
    end
    local areas = getAreaTable()
    local areaID = areas[tbl.name] or addAreaName(tbl.name)
    local rooms = {}
    local ID
    for k,v in pairs(tbl.rooms) do
        ID = createRoomID()
        rooms[k] = ID
        addRoom(ID)
        setRoomName(ID,v.name)
        setRoomArea(ID,areaID)
        setRoomCoordinates(ID,unpack(v.coords))
        if type(v.stubs) == "table" then
            for i,j in pairs(v.stubs) do
                setExitStub(ID,j,true)
            end
        end
        for i,j in pairs(v.doors) do
            setDoor(ID,i,j)
        end
        setRoomUserData(ID,"portals",v.portals)
    end
    for k,v in pairs(tbl.rooms) do
        for i,j in pairs(v.exits) do
            if rooms[j] then
                connect_rooms(rooms[k],rooms[j],i)
            end
        end
        for i,j in pairs(v.special) do
            if rooms[j] then
                addSpecialExit(rooms[k],rooms[j],i)
            end
        end
    end
    for k,v in pairs(tbl.exits) do
        for i,j in pairs(v) do
            if getRoomName(j[1]) == j[2] then
                connect_rooms(rooms[k],j[1],i)
            end
        end
    end
    for k,v in pairs(tbl.special) do
        for i,j in pairs(v) do
            addSpecialExit(k,j[1],i)
        end
    end
    map.fix_portals()
    map.echo("Area " .. tbl.name .. " imported from " .. name)
end

function map.set_recall()
    -- assigned the current room to be recall for the current character
    map.save.recall[map.character] = map.currentRoom
    table.save(profilePath .. "/map downloads/map_save.dat",map.save)
    map.echo("Recall room set to: " .. getRoomName(map.currentRoom) .. ".")
end

function map.set_portal(name, is_auto)
    -- creates a new portal in the room
    if map.mapping then
        if not string.starts(name,"-f ") then
            find_portal = name
        else
            name = string.gsub(name,"^-f ","")
            force_portal = name
        end
        move_queue = {name}
        if not is_auto then
            send(name)
        end
    else
        map.echo("Not mapping",false,true)
    end
end

function map.set_mode(mode)
    -- switches mapping modes
    if not table.contains({"lazy","simple","normal","complex"},mode) then
        show_err("Invalid Map Mode, must be 'lazy', 'simple', 'normal' or 'complex'.")
    end
    map.set("mode", mode)
    map.echo("Current mode set to: " .. mode)
end

function map.start_mapping(area_name)
    -- starts mapping, and sets the current area to the given one, or uses the current one
    if not map.currentName then
        show_err("Room detection not yet working, see &lt;yellow&gt;map basics&lt;reset&gt; for guidance.")
    end
    local rooms
    move_queue = {}
    area_name = area_name ~= "" and area_name or nil
    if map.currentArea and not area_name then
        local areas = getAreaTableSwap()
        area_name = areas[map.currentArea]
    end
    if not area_name then
        show_err("You haven't started mapping yet, how should the first area be called? Set it with: &lt;yellow&gt;start mapping &lt;area name&gt;&lt;reset&gt;")
    end
    map.echo("Now mapping in area: " .. area_name)
    map.set("mapping", true)
    find_area(area_name)
    rooms = find_room(map.currentName, map.currentArea)
    if table.is_empty(rooms) then
        if map.currentRoom and getRoomName(map.currentRoom) == map.currentName then
            map.set_area(area_name)
        else
            create_room(map.currentName, map.currentExits, nil, {0,0,0})
        end
    elseif map.currentRoom and map.currentArea ~= getRoomArea(map.currentRoom) then
        map.set_area(area_name)
    end
end

function map.stop_mapping()
    map.set("mapping", false)
    map.echo("Mapping off.")
end

function map.clear_moves()
    local commands_in_queue = #move_queue
    move_queue = {}
    map.echo("Move queue cleared, "..commands_in_queue.." commands removed.")
end

function map.show_moves()
    map.echo("Moves: "..(move_queue and table.concat(move_queue, ', ') or '(queue empty)'))
end

function map.set_area(name)
    -- assigns the current room to the area given, creates the area if necessary
    if map.mapping then
        find_area(name)
        if map.currentRoom and getRoomArea(map.currentRoom) ~= map.currentArea then
            setRoomArea(map.currentRoom,map.currentArea)
            set_room(map.currentRoom)
        end
    else
        map.echo("Not mapping",false,true)
    end
end

function map.set_door(dir,status,one_way)
    -- adds a door on a given exit
    if map.mapping then
        if not map.currentRoom then
            show_err("Make Door: No room found.")
        end
        dir = exitmap[dir] or dir
        if not stubmap[dir] then
            show_err("Make Door: Invalid direction.")
        end
        status = (status ~= "" and status) or "closed"
        one_way = (one_way ~= "" and one_way) or "no"
        if not table.contains({"yes","no"},one_way) then
            show_err("Make Door: Invalid one-way status, must be yes or no.")
        end

        local exits = getRoomExits(map.currentRoom)
        local exit
        -- check handling of custom exits here
        for i = 13,#stubmap do
            exit = "exit " .. stubmap[i]
            exits[stubmap[i]] = tonumber(getRoomUserData(map.currentRoom,exit))
        end
        local target_room = exits[dir]
        if target_room then
            exits = getRoomExits(target_room)
            -- check handling of custom exits here
            for i = 13,#stubmap do
                exit = "exit " .. stubmap[i]
                exits[stubmap[i]] = tonumber(getRoomUserData(target_room,exit))
            end
        end
        if one_way == "no" and (target_room and exits[reverse_dirs[dir]] == map.currentRoom) then
            add_door(target_room,reverse_dirs[dir],status)
        end
        add_door(map.currentRoom,dir,status)
        map.echo(string.format("Adding %s door to the %s", status, dir))
    else
        map.echo("Not mapping",false,true)
    end
end

function map.shift_room(dir)
    -- shifts a room around on the map
    if map.mapping then
        dir = exitmap[dir] or (table.contains(exitmap,dir) and dir)
        if not dir then
            show_err("Shift Room: Exit not found")
        end
        local x,y,z = getRoomCoordinates(map.currentRoom)
        dir = stubmap[dir]
        local coords = coordmap[dir]
        x = x + coords[1]
        y = y + coords[2]
        z = z + coords[3]
        setRoomCoordinates(map.currentRoom,x,y,z)
        centerview(map.currentRoom)
        map.echo("Shifting room",true)
    else
        map.echo("Not mapping",false,true)
    end
end

local function check_link(firstID, secondID, dir)
    -- check to see if two rooms are connected in a given direction
    if not firstID then error("Check Link Error: No first ID",2) end
    if not secondID then error("Check Link Error: No second ID",2) end
    local name = getRoomName(firstID)
    local exits1 = table.union(getRoomExits(firstID),getRoomStubs(firstID))
    local exits2 = table.union(getRoomExits(secondID),getRoomStubs(secondID))
    local exit
    -- check handling of custom exits here
    for i = 13,#stubmap do
        exit = "exit " .. stubmap[i]
        exits1[stubmap[i]] = tonumber(getRoomUserData(firstID,exit))
        exits2[stubmap[i]] = tonumber(getRoomUserData(secondID,exit))
    end
    local checkID = exits2[reverse_dirs[dir]]
    local exits = {}
    for k,v in pairs(exits1) do
        table.insert(exits,k)
    end
    return checkID and check_room(checkID,name,exits)
end

function map.find_me(name, exits, dir, manual)
    -- tries to locate the player using the current room name and exits, and if provided, direction of movement
    -- if direction of movement is given, narrows down possibilities using previous room info
    if move ~= "recall" then move_queue = {} end
    -- find from room hash id - map.find_me(nil, nil, nil, false)
    if map.prompt.hash then
        local room = getRoomIDbyHash(map.prompt.hash)
        if room &gt; 0 then
            set_room(room)
            map.echo("Room found, ID: " .. room, true)
            return
        else
            map.echo("Room not found in map database!", not manual, true)
            return
        end
    end
    local check = dir and map.currentRoom and table.contains(exitmap,dir)
    name = name or map.currentName
    exits = exits or map.currentExits
    if not name and not exits then
        show_err("Room not found, complete room name and exit data not available.")
    end
    local rooms = find_room(name)
    local match_IDs = {}
    for k,v in pairs(rooms) do
        if check_room(k, name, exits) then
            table.insert(match_IDs,k)
        end
    end
    rooms = match_IDs
    match_IDs = {}
    if table.size(rooms) &gt; 1 and check then
        for k,v in pairs(rooms) do
            if check_link(map.currentRoom,v,dir) then
                table.insert(match_IDs,v)
            end
        end
    elseif random_move then
        for k,v in pairs(getRoomExits(map.currentRoom)) do
            if check_room(v,map.currentName,map.currentExits) then
                table.insert(match_IDs,v)
            end
        end
    end
    if table.size(match_IDs) == 0 then
        match_IDs = rooms
    end
    if table.index_of(match_IDs,map.currentRoom) then
        match_IDs = {map.currentRoom}
    end
    if not table.is_empty(match_IDs) and not find_portal then
        set_room(match_IDs[1])
        map.echo("Room found, ID: " .. match_IDs[1],true)
    elseif find_portal then
        if not table.is_empty(match_IDs) then
            map.echo("Found portal destination, linking rooms",false,false,true)
            addSpecialExit(map.currentRoom,match_IDs[1],find_portal)
            local portals = getRoomUserData(match_IDs[1],"portals") or ""
            portals = portals .. "," .. tostring(map.currentRoom)..":"..find_portal
            setRoomUserData(match_IDs[1],"portals",portals)
            set_room(match_IDs[1])
            map.echo("Room found, ID: " .. match_IDs[1],true)
        else
            map.echo("Creating portal destination",false,false,true)
            create_room(map.currentName, map.currentExits, nil, {getRoomCoordinates(map.currentRoom)})
        end
        find_portal = false
    elseif table.is_empty(match_IDs) then
        map.echo("Room not found in map database", not manual, true)
    end
end

function map.fix_portals()
    if map.mapping then
        -- used to clear and update data for portal back-referencing
        local rooms = getRooms()
        local portals
        for k,v in pairs(rooms) do
            setRoomUserData(k,"portals","")
        end
        for k,v in pairs(rooms) do
            for cmd,room in pairs(getSpecialExitsSwap(k)) do
                portals = getRoomUserData(room,"portals") or ""
                if portals ~= "" then portals = portals .. "," end
                portals = portals .. tostring(k) .. ":" .. cmd
                setRoomUserData(room,"portals",portals)
            end
        end
        map.echo("Portals Fixed")
    else
        map.echo("Not mapping",false,true)
    end
end

function map.merge_rooms()
    -- used to combine essentially identical rooms with the same coordinates
    -- typically, these are generated due to mapping errors
    if map.mapping then
        map.echo("Merging rooms")
        local x,y,z = getRoomCoordinates(map.currentRoom)
        local rooms = getRoomsByPosition(map.currentArea,x,y,z)
        local exits, portals, room, cmd, curportals
        local room_count = 1
        for k,v in pairs(rooms) do
            if v ~= map.currentRoom then
                if getRoomName(v) == getRoomName(map.currentRoom) then
                    room_count = room_count + 1
                    for k1,v1 in pairs(getRoomExits(v)) do
                        setExit(map.currentRoom,v1,stubmap[k1])
                        exits = getRoomExits(v1)
                        if exits[reverse_dirs[k1]] == v then
                            setExit(v1,map.currentRoom,stubmap[reverse_dirs[k1]])
                        end
                    end
                    for k1,v1 in pairs(getDoors(v)) do
                        setDoor(map.currentRoom,k1,v1)
                    end
                    for k1,v1 in pairs(getSpecialExitsSwap(v)) do
                        addSpecialExit(map.currentRoom,v1,k1)
                    end
                    portals = getRoomUserData(v,"portals") or ""
                    if portals ~= "" then
                        portals = string.split(portals,",")
                        for k1,v1 in ipairs(portals) do
                            room,cmd = unpack(string.split(v1,":"))
                            addSpecialExit(tonumber(room),map.currentRoom,cmd)
                            curportals = getRoomUserData(map.currentRoom,"portals") or ""
                            if not string.find(curportals,room) then
                                curportals = curportals .. "," .. room .. ":" .. cmd
                                setRoomUserData(map.currentRoom,"portals",curportals)
                            end
                        end
                    end
                    -- check handling of custom exits here for doors and exits, and reverse exits
                    for i = 13,#stubmap do
                        local door = "door " .. stubmap[i]
                        local tmp = tonumber(getRoomUserData(v,door))
                        if tmp then
                            setRoomUserData(map.currentRoom,door,tmp)
                        end
                        local exit = "exit " .. stubmap[i]
                        tmp = tonumber(getRoomUserData(v,exit))
                        if tmp then
                            setRoomUserData(map.currentRoom,exit,tmp)
                            if tonumber(getRoomUserData(tmp, "exit " .. reverse_dirs[stubmap[i]])) == v then
                                setRoomUserData(tmp, exit, map.currentRoom)
                            end
                        end
                    end
                    deleteRoom(v)
                end
            end
        end
        if room_count &gt; 1 then
            map.echo(room_count .. " rooms merged", true)
        end
    else
        map.echo("Not mapping",false,true)
    end
end

function map.findAreaID(areaname, exact)
    local areaname = areaname:lower()
    local list = getAreaTable()

    -- iterate over the list of areas, matching them with substring match.
    -- if we get match a single area, then return its ID, otherwise return
    -- 'false' and a message that there are than one are matches
    local returnid, fullareaname, multipleareas = nil, nil, {}
    for area, id in pairs(list) do
        if (not exact and area:lower():find(areaname, 1, true)) or (exact and areaname == area:lower()) then
            returnid = id
            fullareaname = area
            multipleareas[#multipleareas+1] = area
        end
    end

    if #multipleareas == 1 then
        return returnid, fullareaname
    else
        return nil, nil, multipleareas
    end
end

function map.echoRoomList(areaname, exact)
    local areaid, msg, multiples
    local listcolor, othercolor = "DarkSlateGrey","LightSlateGray"
    if tonumber(areaname) then
        areaid = tonumber(areaname)
        msg = getAreaTableSwap()[areaid]
    else
        areaid, msg, multiples = map.findAreaID(areaname, exact)
    end
    if areaid then
        local roomlist, endresult = getAreaRooms(areaid) or {}, {}

        -- obtain a room list for each of the room IDs we got
        local getRoomName = getRoomName
        for _, id in pairs(roomlist) do
            endresult[id] = getRoomName(id)
        end
        roomlist[#roomlist+1], roomlist[0] = roomlist[0], nil
        -- sort room IDs so we can display them in order
        table.sort(roomlist)

        local echoLink, format, fg, echo = echoLink, string.format, fg, cecho
        -- now display something half-decent looking
        cecho(format("&lt;%s&gt;List of all rooms in &lt;%s&gt;%s&lt;%s&gt; (areaID &lt;%s&gt;%s&lt;%s&gt; - &lt;%s&gt;%d&lt;%s&gt; rooms):\n",
            listcolor, othercolor, msg, listcolor, othercolor, areaid, listcolor, othercolor, #roomlist, listcolor))
        -- use pairs, as we can have gaps between room IDs
        for _, roomid in pairs(roomlist) do
            local roomname = endresult[roomid]
            cechoLink(format("&lt;%s&gt;%7s",othercolor,roomid), 'map.speedwalk('..roomid..')',
                format("Go to %s (%s)", roomid, tostring(roomname)), true)
            cecho(format("&lt;%s&gt;: &lt;%s&gt;%s&lt;%s&gt;.\n", listcolor, othercolor, roomname, listcolor))
        end
    elseif not areaid and #multiples &gt; 0 then
        local allareas, format = getAreaTable(), string.format
        local function countrooms(areaname)
            local areaid = allareas[areaname]
            local allrooms = getAreaRooms(areaid) or {}
            local areac = (#allrooms or 0) + (allrooms[0] and 1 or 0)
            return areac
        end
        map.echo("For which area would you want to list rooms for?")
        for _, areaname in ipairs(multiples) do
            echo("  ")
            setUnderline(true)
            cechoLink(format("&lt;%s&gt;%-40s (%d rooms)", othercolor, areaname, countrooms(areaname)),
                'map.echoRoomList("'..areaname..'", true)', "Click to view the room list for "..areaname, true)
            setUnderline(false)
            echo("\n")
        end
    else
        map.echo(string.format("Don't know of any area named '%s'.", areaname),false,true)
    end
    resetFormat()
end

function map.echoAreaList()
    local totalroomcount = 0
    local rlist = getAreaTableSwap()
    local listcolor, othercolor = "DarkSlateGrey","LightSlateGray"

    -- count the amount of rooms in an area, taking care to count the room in the 0th
    -- index as well if there is one
    -- saves the total room count on the side as well
    local function countrooms(areaid)
        local allrooms = getAreaRooms(areaid) or {}
        local areac = (#allrooms or 0) + (allrooms[0] and 1 or 0)
        totalroomcount = totalroomcount + areac
        return areac
    end

    local getAreaRooms, cecho, fg, echoLink, format = getAreaRooms, cecho, fg, echoLink, string.format
    cecho(format("&lt;%s&gt;List of all areas we know of (click to view room list):\n",listcolor))
    for id = 1,table.maxn(rlist) do
        if rlist[id] then
            cecho(format("&lt;%s&gt;%7d ", othercolor, id))
            fg(listcolor)
            echoLink(format("%-40s (%d rooms)",rlist[id],countrooms(id)), 'map.echoRoomList("'..id..'", true)',
                "View the room list for "..rlist[id], true)
            echo("\n")
        end
    end
    cecho(string.format("&lt;%s&gt;Total amount of rooms in this map: %s\n", listcolor, totalroomcount))
end

function map.search_timer_check()
    if find_prompt then
        map.echo("Prompt not auto-detected, use 'map prompt' to set a prompt pattern.",false,true)
        find_prompt = false
    end
end

function map.find_prompt()
    find_prompt = true
    map.echo("Searching for prompt.")
    send("\n", false)
    tempTimer(5, "map.search_timer_check()")
end

function map.make_prompt_pattern(str)
    if not str:starts("^") then str = "^"..str end
    map.save.prompt_pattern[map.character] = str
    find_prompt = false
    table.save(profilePath .. "/map downloads/map_save.dat",map.save)
    map.echo("Prompt pattern set: " .. str)
end

function map.make_ignore_pattern(str)
    map.save.ignore_patterns = map.save.ignore_patterns or {}
    if not table.contains(map.save.ignore_patterns,str) then
        table.insert(map.save.ignore_patterns,str)
        map.echo("Ignore pattern added: " .. str)
    else
        table.remove(map.save.ignore_patterns, table.index_of(map.save.ignore_patterns, str))
        map.echo("Ignore pattern removed: " .. str)
    end
    table.save(profilePath .. "/map downloads/map_save.dat",map.save)
end

function map.make_move_method(str)
    map.save.move_methods = map.save.move_methods or {}
    if not table.contains(map.save.move_methods,str) then
        table.insert(map.save.move_methods,str)
        map.echo("Move method added: " .. str)
    else
        table.remove(map.save.move_methods, table.index_of(map.save.move_methods, str))
        map.echo("Move method removed: " .. str)
    end
    table.save(profilePath .. "/map downloads/map_save.dat",map.save)
end

local function grab_line()
    table.insert(lines,line)
    if map.save.prompt_pattern[map.character] and string.match(line, map.save.prompt_pattern[map.character]) then
        if map.prompt.exits and map.prompt.exits ~= "" then
            raiseEvent("onNewRoom")
        end
        print_wait_echoes()
        map.echo("Prompt captured",true)
    end
    if find_prompt then
        for k,v in ipairs(map.configs.prompt_test_patterns) do
            if string.match(line,v) then
                map.save.prompt_pattern[map.character] = v
                table.save(profilePath .. "/map downloads/map_save.dat",map.save)
                find_prompt = false
                map.echo("Prompt found")
                break
            end
        end
    end
end

local function name_search()
    local room_name
    if map.configs.custom_name_search then
        room_name = mudlet.custom_name_search(lines)
    else
        local line_count = #lines + 1
        local cur_line, last_line
        local prompt_pattern = map.save.prompt_pattern[map.character]
        if not prompt_pattern then return end
        while not room_name do
            line_count = line_count - 1
            if not lines[line_count] then break end
            cur_line = lines[line_count]
            for k,v in ipairs(map.save.ignore_patterns) do
                cur_line = string.trim(string.gsub(cur_line,v,""))
            end
            if string.find(cur_line,prompt_pattern) then
                cur_line = string.trim(string.gsub(cur_line,prompt_pattern,""))
                if cur_line ~= "" then
                    room_name = cur_line
                else
                    room_name = last_line
                end
            elseif line_count == 1 then
                cur_line = string.trim(cur_line)
                if cur_line ~= "" then
                    room_name = cur_line
                else
                    room_name = last_line
                end
            elseif not string.match(cur_line,"^%s*$") then
                last_line = cur_line
            end
        end
        lines = {}
        room_name = room_name:sub(1,100)
    end
    return room_name
end

local function handle_exits(exits)
    local room = map.prompt.room or name_search()
    room = map.sanitizeRoomName(room)
    exits = map.prompt.exits or exits
    exits = string.lower(exits)
    exits = string.gsub(exits,"%a+", exitmap)
    if room then
        map.echo("Room Name Captured: " .. room, true)
        room = string.trim(room)
        capture_room_info(room, exits)
        map.prompt.room = nil
        map.prompt.exits = nil
    end
end

local continue_walk, timerID
continue_walk = function(new_room)
    if not walking then return end
    -- calculate wait time until next command, with randomness
    local wait = map.configs.speedwalk_delay or 0
    if wait &gt; 0 and map.configs.speedwalk_random then
        wait = wait * (1 + math.random(0,100)/100)
    end
    -- if no wait after new room, move immediately
    if new_room and map.configs.speedwalk_wait and wait == 0 then
        new_room = false
    end
    -- send command if we don't need to wait
    if not new_room then
        --handle script exits
        if string.starts(map.walkDirs[1], "script:") then
          map.walkDirs[1] = string.gsub(map.walkDirs[1], "script:", "")
          loadstring(table.remove(map.walkDirs,1))()
        else
          send(table.remove(map.walkDirs,1))
        end
        -- check to see if we are done
        if #map.walkDirs == 0 then
            walking = false
            speedWalkPath, speedWalkWeight = {}, {}
            raiseEvent("sysSpeedwalkFinished")
        end
    end
    -- make tempTimer to send next command if necessary
    if walking and (not map.configs.speedwalk_wait or (map.configs.speedwalk_wait and wait &gt; 0)) then
        if timerID then killTimer(timerID) end
        timerID = tempTimer(wait, function() continue_walk() end)
    end
end

function map.speedwalk(roomID, walkPath, walkDirs)
    roomID = roomID or speedWalkPath[#speedWalkPath]
    getPath(map.currentRoom, roomID)
    walkPath = speedWalkPath
    walkDirs = speedWalkDir
    if #speedWalkPath == 0 then
        map.echo("No path to chosen room found.",false,true)
        return
    end
    table.insert(walkPath, 1, map.currentRoom)
    -- go through dirs to find doors that need opened, etc
    -- add in necessary extra commands to walkDirs table
    local k = 1
    repeat
        local id, dir = walkPath[k], walkDirs[k]
        if exitmap[dir] or short[dir] then
            local door = check_doors(id, exitmap[dir] or dir)
            local status = door and door[dir]
            if status and status &gt; 1 then
                -- if locked, unlock door
                if status == 3 then
                    table.insert(walkPath,k,id)
                    table.insert(walkDirs,k,"unlock " .. (exitmap[dir] or dir))
                    k = k + 1
                end
                -- if closed, open door
                table.insert(walkPath,k,id)
                table.insert(walkDirs,k,"open " .. (exitmap[dir] or dir))
                k = k + 1
            end
        end
        k = k + 1
    until k &gt; #walkDirs
    if map.configs.use_translation then
        for k, v in ipairs(walkDirs) do
            walkDirs[k] = map.configs.lang_dirs[v] or v
        end
    end
    -- perform walk
    walking = true
    if map.configs.speedwalk_wait or map.configs.speedwalk_delay &gt; 0 then
        map.walkDirs = walkDirs
        continue_walk()
    else
        for _,dir in ipairs(walkDirs) do
           if string.starts(dir, "script:") then
              dir = string.gsub(dir, "script:", "")
              loadstring(dir)()
            else
              send(dir)
           end
        end
        walking = false
        raiseEvent("sysSpeedwalkFinished")
    end
end

function doSpeedWalk()
    if #speedWalkPath ~= 0 then
        raiseEvent("sysSpeedwalkStarted")
        map.speedwalk(nil, speedWalkPath, speedWalkDir)
    else
        map.echo("No path to chosen room found.",false,true)
    end
end

function map.pauseSpeedwalk()
    if #speedWalkDir ~= 0 then
        walking = false
        raiseEvent("sysSpeedwalkPaused")
        map.echo("Speedwalking paused.")
    else
        map.echo("Not currently speedwalking.")
    end
end

function map.resumeSpeedwalk(delay)
    if #speedWalkDir ~= 0 then
        map.find_me(nil, nil, nil, true)
        raiseEvent("sysSpeedwalkResumed")
        map.echo("Speedwalking resumed.")
        tempTimer(delay or 0, function() map.speedwalk(nil, speedWalkPath, speedWalkDir) end)
    else
        map.echo("Not currently speedwalking.")
    end
end

function map.stopSpeedwalk()
    if #speedWalkDir ~= 0 then
        walking = false
        map.walkDirs, speedWalkDir, speedWalkPath, speedWalkWeight = {}, {}, {}, {}
        raiseEvent("sysSpeedwalkStopped")
        map.echo("Speedwalking stopped.")
    else
        map.echo("Not currently speedwalking.")
    end
end

function map.toggleSpeedwalk(what)
    assert(what == nil or what == "on" or what == "off", "map.toggleSpeedwalk wants 'on', 'off' or nothing as an argument")

    if what == "on" or (what == nil and walking) then
        map.pauseSpeedwalk()
    elseif what == "off" or (what == nil and not walking) then
        map.resumeSpeedwalk()
    end
end

local function check_version()
    downloading = false
    local path = profilePath .. "/map downloads/versions.lua"
    local versions = {}
    table.load(path, versions)
    local pos = table.index_of(versions, map.version) or 0
    if pos ~= #versions then
        enableAlias("Map Update Alias")
        map.echo(string.format("The Generic Mapping Script is currently &lt;red&gt;%d&lt;reset&gt; versions behind.",#versions - pos))
        map.echo("To update now, please type: &lt;yellow&gt;map update&lt;reset&gt;")
    end
    map.update_timer = tempTimer(3600, [[map.checkVersion()]])
end

function map.checkVersion()
    if map.update_timer then
        killTimer(map.update_timer)
        map.update_timer = nil
    end
    if not map.update_waiting and map.configs.download_path ~= "" then
        local path, file = profilePath .. "/map downloads", "/versions.lua"
        downloading = true
        downloadFile(path .. file, map.configs.download_path .. file)
        map.update_waiting = true
    end
end

local function update_version()
    downloading = false
    local path = profilePath .. "/map downloads/generic_mapper.xml"
    disableAlias("Map Update Alias")
    map.updatingMapper = true
    uninstallPackage("generic_mapper")
    installPackage(path)
    map.updatingMapper = nil
    map.echo("Generic Mapping Script updated successfully.")
end

function map.updateVersion()
    local path, file = profilePath .. "/map downloads", "/generic_mapper.xml"
    downloading = true
    downloadFile(path .. file, map.configs.download_path .. file)
end

function map.showMap(shown)
    local configs = map.configs.map_window
    shown = shown or not configs.shown
    map.configs.map_window.shown = shown
    local x, y, w, h, origin = configs.x, configs.y, configs.w, configs.h, configs.origin
    if string.find(origin,"bottom") then
        if y == 0 or y == "0%" then
            y = h
        end
        if type(y) == "number" then
            y = -y
        else
            y = "-"..y
        end
    end
    if string.find(origin,"right") then
        if x == 0 or x == "0%" then
            x = w
        end
        if type(x) == "number" then
            x = -x
        else
            x = "-"..x
        end
    end
    local mapper = Geyser.Mapper:new({name = "my_mapper", x = x, y = y, w = w, h = h})
    mapper:resize(w,h)
    mapper:move(x,y)
    if shown then
        mapper:show()
    else
        mapper:hide()
    end
end

-- some games embed an ASCII map on the same line, which messes up the room room name
-- extract the longest continuous piece of text from the line to be the room name
function map.sanitizeRoomName(roomtitle)
  assert(type(roomtitle) == "string", "map.sanitizeRoomName: bad argument #1 expected room title, got "..type(roomtitle).."!")
  if not roomtitle:match("  ") then return roomtitle end

  local parts = roomtitle:split("  ")
  table.sort(parts, function(a,b) return #a &lt; #b end)
  local longestpart = parts[#parts]

  local trimmed = utf8.match(longestpart, "[%w ]+"):trim()
  return trimmed
end

function map.eventHandler(event, ...)
    if event == "onNewRoom" then
        handle_exits(arg[1])
        if walking and map.configs.speedwalk_wait then
            continue_walk(true)
        end
    elseif event == "onPrompt" then
        if map.prompt.exits and map.prompt.exits ~= "" then
            raiseEvent("onNewRoom")
        end
        print_wait_echoes()
        map.echo("Prompt Captured",true)
    elseif event == "onMoveFail" then
        map.echo("onMoveFail",true)
        table.remove(move_queue,1)
    elseif event == "onVisionFail" then
        map.echo("onVisionFail",true)
        vision_fail = true
        capture_room_info()
    elseif event == "onRandomMove" then
        map.echo("onRandomMove",true)
        random_move = true
        move_queue = {}
    elseif event == "onForcedMove" then
        map.echo("onForcedMove",true)
        capture_move_cmd(arg[1],arg[2]=="true")
    elseif event == "onNewLine" then
        grab_line()
    elseif event == "sysDataSendRequest" then
        capture_move_cmd(arg[1])
        -- check to prevent multiple version checks in a row without user intervention
        if map.update_waiting and map.update_timer then
            map.update_waiting = nil
        -- check to ensure version check cycle is started
        elseif not map.update_waiting and not map.update_timer then
            map.checkVersion()
        end
    elseif event == "sysDownloadDone" and downloading then
        local file = arg[1]
        if string.ends(file,"/map.dat") then
            loadMap(file)
            downloading = false
            map.echo("Map File Loaded.")
        elseif string.ends(file,"/versions.lua") then
            check_version()
        elseif string.ends(file,"/generic_mapper.xml") then
            update_version()
        end
    elseif event == "sysDownloadError" and downloading then
        local file = arg[1]
        if string.ends(file,"/versions.lua") and mudlet.translations.interfacelanguage == "zh_CN" then
            -- update to the current download path for chinese user
            if map.configs.download_path == "https://raw.githubusercontent.com/Mudlet/Mudlet/development/src/mudlet-lua/lua/generic-mapper" then
                map.configs.download_path = "https://gitee.com/mudlet/Mudlet/raw/development/src/mudlet-lua/lua/generic-mapper"
                map.checkVersion()
            end
        end
    elseif event == "sysLoadEvent" or event == "sysInstall" then
        config()
    elseif event == "mapOpenEvent" then
        if not help_shown and not map.save.prompt_pattern[map.character or ""] then
            map.find_prompt()
            send(map.configs.lang_dirs['look'], true)
            tempTimer(3, function() map.show_help("quick_start"); help_shown = true end)
        end
    elseif event == "mapStop" then
        map.set("mapping", false)
        walking = false
        map.echo("Mapping and speedwalking stopped.")
    elseif event == "sysManualLocationSetEvent" then
      set_room(arg[1])
    elseif event == "sysUninstallPackage" and not map.updatingMapper and arg[1] == "generic_mapper" then
        for _,id in ipairs(map.registeredEvents) do
            killAnonymousEventHandler(id)
        end
    end
end

map.registeredEvents = {
registerAnonymousEventHandler("sysDownloadDone", "map.eventHandler"),
registerAnonymousEventHandler("sysDownloadError", "map.eventHandler"),
registerAnonymousEventHandler("sysLoadEvent", "map.eventHandler"),
registerAnonymousEventHandler("sysConnectionEvent", "map.eventHandler"),
registerAnonymousEventHandler("sysInstall", "map.eventHandler"),
registerAnonymousEventHandler("sysDataSendRequest", "map.eventHandler"),
registerAnonymousEventHandler("onMoveFail", "map.eventHandler"),
registerAnonymousEventHandler("onVisionFail", "map.eventHandler"),
registerAnonymousEventHandler("onRandomMove", "map.eventHandler"),
registerAnonymousEventHandler("onForcedMove", "map.eventHandler"),
registerAnonymousEventHandler("onNewRoom", "map.eventHandler"),
registerAnonymousEventHandler("onNewLine", "map.eventHandler"),
registerAnonymousEventHandler("mapOpenEvent", "map.eventHandler"),
registerAnonymousEventHandler("mapStop", "map.eventHandler"),
registerAnonymousEventHandler("onPrompt", "map.eventHandler"),
registerAnonymousEventHandler("sysManualLocationSetEvent", "map.eventHandler"),
registerAnonymousEventHandler("sysUninstallPackage", "map.eventHandler")
}
</script>
				<eventHandlerList />
			</Script>
		</ScriptGroup>
		<Script isActive="yes" isFolder="no">
			<name>Nuovo script</name>
			<packageName></packageName>
			<script>function finishedRepositioning(eventName, containerName, width, height, x, y)
  print(f"{containerName}: {x}x, {y}y, {width}x{height}")
end

registerAnonymousEventHandler("AdjustableContainerRepositionFinish", finishedRepositioning)</script>
			<eventHandlerList />
		</Script>
	</ScriptPackage>
	<KeyPackage>
		<KeyGroup isActive="yes" isFolder="yes">
			<name>Lumen et Umbra UI</name>
			<packageName>Lumen et Umbra UI</packageName>
			<script></script>
			<command></command>
			<keyCode>16777236</keyCode>
			<keyModifier>0</keyModifier>
			<KeyGroup isActive="yes" isFolder="yes">
				<name>Keypad</name>
				<packageName></packageName>
				<script></script>
				<command></command>
				<keyCode>-1</keyCode>
				<keyModifier>0</keyModifier>
				<KeyGroup isActive="yes" isFolder="yes">
					<name>Movement (keypad)</name>
					<packageName></packageName>
					<script></script>
					<command></command>
					<keyCode>-1</keyCode>
					<keyModifier>0</keyModifier>
					<Key isActive="yes" isFolder="no">
						<name>keypad 2 (south)</name>
						<packageName></packageName>
						<script></script>
						<command>s</command>
						<keyCode>50</keyCode>
						<keyModifier>536870912</keyModifier>
					</Key>
					<Key isActive="yes" isFolder="no">
						<name>keypad 4 (west)</name>
						<packageName></packageName>
						<script></script>
						<command>w</command>
						<keyCode>52</keyCode>
						<keyModifier>536870912</keyModifier>
					</Key>
					<Key isActive="yes" isFolder="no">
						<name>keypad 3 (down)</name>
						<packageName></packageName>
						<script></script>
						<command>d</command>
						<keyCode>49</keyCode>
						<keyModifier>536870912</keyModifier>
					</Key>
					<Key isActive="yes" isFolder="no">
						<name>keypad 6 (east)</name>
						<packageName></packageName>
						<script></script>
						<command>e</command>
						<keyCode>54</keyCode>
						<keyModifier>536870912</keyModifier>
					</Key>
					<Key isActive="yes" isFolder="no">
						<name>keypad 8 (north)</name>
						<packageName></packageName>
						<script></script>
						<command>n</command>
						<keyCode>56</keyCode>
						<keyModifier>536870912</keyModifier>
					</Key>
					<Key isActive="yes" isFolder="no">
						<name>keypad 9 (up)</name>
						<packageName></packageName>
						<script></script>
						<command>u</command>
						<keyCode>57</keyCode>
						<keyModifier>536870912</keyModifier>
					</Key>
				</KeyGroup>
			</KeyGroup>
		</KeyGroup>
		<KeyGroup isActive="yes" isFolder="yes">
			<name>Varie</name>
			<packageName></packageName>
			<script></script>
			<command></command>
			<keyCode>33554431</keyCode>
			<keyModifier>0</keyModifier>
			<Key isActive="yes" isFolder="no">
				<name>keypad 0 (group)</name>
				<packageName></packageName>
				<script></script>
				<command>group</command>
				<keyCode>48</keyCode>
				<keyModifier>536870912</keyModifier>
			</Key>
			<Key isActive="yes" isFolder="no">
				<name>keypad 5 (look)</name>
				<packageName></packageName>
				<script></script>
				<command>look</command>
				<keyCode>53</keyCode>
				<keyModifier>536870912</keyModifier>
			</Key>
			<Key isActive="yes" isFolder="no">
				<name>get all cad</name>
				<packageName></packageName>
				<script>expandAlias("ll")</script>
				<command></command>
				<keyCode>49</keyCode>
				<keyModifier>671088640</keyModifier>
			</Key>
			<KeyGroup isActive="yes" isFolder="yes">
				<name>Look at direction  (control + keypad)</name>
				<packageName></packageName>
				<script></script>
				<command></command>
				<keyCode>-1</keyCode>
				<keyModifier>0</keyModifier>
				<Key isActive="yes" isFolder="no">
					<name>control keypad 1</name>
					<packageName></packageName>
					<script></script>
					<command>look down</command>
					<keyCode>49</keyCode>
					<keyModifier>603979776</keyModifier>
				</Key>
				<Key isActive="yes" isFolder="no">
					<name>control keypad 2</name>
					<packageName></packageName>
					<script></script>
					<command>look south</command>
					<keyCode>50</keyCode>
					<keyModifier>603979776</keyModifier>
				</Key>
				<Key isActive="yes" isFolder="no">
					<name>control keypad 4</name>
					<packageName></packageName>
					<script></script>
					<command>look west</command>
					<keyCode>52</keyCode>
					<keyModifier>603979776</keyModifier>
				</Key>
				<Key isActive="yes" isFolder="no">
					<name>control keypad 6</name>
					<packageName></packageName>
					<script></script>
					<command>look east</command>
					<keyCode>54</keyCode>
					<keyModifier>603979776</keyModifier>
				</Key>
				<Key isActive="yes" isFolder="no">
					<name>control keypad 8</name>
					<packageName></packageName>
					<script></script>
					<command>look north</command>
					<keyCode>56</keyCode>
					<keyModifier>603979776</keyModifier>
				</Key>
				<Key isActive="yes" isFolder="no">
					<name>control keypad 9</name>
					<packageName></packageName>
					<script></script>
					<command>loo up</command>
					<keyCode>57</keyCode>
					<keyModifier>603979776</keyModifier>
				</Key>
			</KeyGroup>
		</KeyGroup>
	</KeyPackage>
	<VariablePackage>
		<HiddenVariables />
	</VariablePackage>
</MudletPackage>
