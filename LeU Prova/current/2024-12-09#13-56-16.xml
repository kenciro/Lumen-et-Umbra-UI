<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE MudletPackage>
<MudletPackage version="1.001">
	<HostPackage>
		<Host autoClearCommandLineAfterSend="no" HighlightHistory="yes" printCommand="yes" USE_IRE_DRIVER_BUGFIX="no" mUSE_FORCE_LF_AFTER_PROMPT="no" mUSE_UNIX_EOL="no" mNoAntiAlias="no" mEchoLuaErrors="yes" runAllKeyMatches="no" AmbigousWidthGlyphsToBeWide="no" mRawStreamDump="no" mIsLoggingTimestamps="no" logDirectory="" logFileName="" logFileNameFormat="yyyy-MM-dd" mAlertOnNewData="no" mFORCE_NO_COMPRESSION="no" mFORCE_GA_OFF="no" mFORCE_SAVE_ON_EXIT="yes" mEnableGMCP="yes" mEnableMSSP="yes" mEnableMSDP="no" mEnableMSP="yes" mEnableMTTS="yes" mEnableMNES="yes" mMapStrongHighlight="no" mEnableSpellCheck="yes" mEnableUserDictionary="yes" mUseSharedDictionary="yes" mAcceptServerGUI="yes" mAcceptServerMedia="yes" mMapperUseAntiAlias="yes" mMapperShowRoomBorders="yes" mFORCE_MXP_NEGOTIATION_OFF="no" mFORCE_CHARSET_NEGOTIATION_OFF="no" forceNewEnvironNegotiationOff="no" enableTextAnalyzer="no" mRoomSize="0.8" mLineSize="20.0" mBubbleMode="no" mMapViewOnly="no" mShowRoomIDs="yes" mShowPanel="yes" mHaveMapperScript="yes" mEditorAutoComplete="no" mEditorShowBidi="no" mEditorTheme="super" mEditorThemeFile="super.tmTheme" mThemePreviewItemID="4" mThemePreviewType="trigger" mSearchEngineName="DuckDuckGo" mTimerSupressionInterval="00:00:00.000" mUseProxy="no" mProxyAddress="" mProxyPort="0" mProxyUsername="" mProxyPassword="" mSslTsl="no" mSslIgnoreExpired="no" mSslIgnoreSelfSigned="no" mSslIgnoreAll="no" mAskTlsAvailable="yes" mDiscordAccessFlags="2495" mRequiredDiscordUserName="" mRequiredDiscordUserDiscriminator="" mSGRCodeHasColSpaceId="no" mServerMayRedefineColors="yes" playerRoomPrimaryColor="#ffffffff" playerRoomSecondaryColor="#ffff5500" playerRoomStyle="3" playerRoomOuterDiameter="150" playerRoomInnerDiameter="80" CompactInputLine="no" CommandLineHistorySaveSize="50" mDoubleClickIgnore="&quot;'" EditorSearchOptions="0" DebugShowAllProblemCodepoints="no" announceIncomingText="yes" advertiseScreenReader="no" caretShortcut="Tab" blankLineBehaviour="Show" NetworkPacketTimeout="10" ShowIDsInEditor="no" Large2DMapAreaExitArrows="yes">
			<name>LeU Prova</name>
			<mInstalledPackages>
				<string>Telegram Connector</string>
				<string>luogotenenti_aliases</string>
				<string>Luogotenenti_scripts</string>
				<string>Luogotenenti_triggers</string>
				<string>Invasioni</string>
				<string>LeU_UI</string>
			</mInstalledPackages>
			<url>new-leu.leu.it</url>
			<serverPackageName>nothing</serverPackageName>
			<serverPackageVersion>-1</serverPackageVersion>
			<port>6667</port>
			<borderTopHeight>0</borderTopHeight>
			<borderBottomHeight>0</borderBottomHeight>
			<borderLeftWidth>316</borderLeftWidth>
			<borderRightWidth>391</borderRightWidth>
			<wrapAt>100</wrapAt>
			<wrapIndentCount>0</wrapIndentCount>
			<mFgColor>#c0c0c0</mFgColor>
			<mBgColor>#000000</mBgColor>
			<mCommandFgColor>#717100</mCommandFgColor>
			<mCommandBgColor>#000000</mCommandBgColor>
			<mCommandLineFgColor>#808080</mCommandLineFgColor>
			<mCommandLineBgColor>#000000</mCommandLineBgColor>
			<mBlack>#000000</mBlack>
			<mLightBlack>#808080</mLightBlack>
			<mRed>#800000</mRed>
			<mLightRed>#ff0000</mLightRed>
			<mBlue>#000080</mBlue>
			<mLightBlue>#0000ff</mLightBlue>
			<mGreen>#008000</mGreen>
			<mLightGreen>#00ff00</mLightGreen>
			<mYellow>#808000</mYellow>
			<mLightYellow>#ffff00</mLightYellow>
			<mCyan>#008080</mCyan>
			<mLightCyan>#00ffff</mLightCyan>
			<mMagenta>#800080</mMagenta>
			<mLightMagenta>#ff00ff</mLightMagenta>
			<mWhite>#c0c0c0</mWhite>
			<mLightWhite>#ffffff</mLightWhite>
			<mDisplayFont>Cascadia Code,13,-1,5,50,0,0,0,1,0</mDisplayFont>
			<mCommandLineFont>Bitstream Vera Sans Mono,14,-1,5,50,0,0,0,0,0</mCommandLineFont>
			<mCommandSeparator>;</mCommandSeparator>
			<commandLineMinimumHeight>25</commandLineMinimumHeight>
			<mFgColor2>#c0c0c0</mFgColor2>
			<mBgColor2>#1e1818</mBgColor2>
			<mRoomBorderColor>#c0c0c0</mRoomBorderColor>
			<mMapInfoBg alpha="127">#3c3030</mMapInfoBg>
			<mBlack2>#000000</mBlack2>
			<mLightBlack2>#808080</mLightBlack2>
			<mRed2>#800000</mRed2>
			<mLightRed2>#ff0000</mLightRed2>
			<mBlue2>#000080</mBlue2>
			<mLightBlue2>#0000ff</mLightBlue2>
			<mGreen2>#008000</mGreen2>
			<mLightGreen2>#00ff00</mLightGreen2>
			<mYellow2>#808000</mYellow2>
			<mLightYellow2>#ffff00</mLightYellow2>
			<mCyan2>#008080</mCyan2>
			<mLightCyan2>#00ffff</mLightCyan2>
			<mMagenta2>#800080</mMagenta2>
			<mLightMagenta2>#ff00ff</mLightMagenta2>
			<mWhite2>#c0c0c0</mWhite2>
			<mLightWhite2>#ffffff</mLightWhite2>
			<mSpellDic>it_IT</mSpellDic>
			<mLineSize>20.0</mLineSize>
			<mRoomSize>0.8</mRoomSize>
			<mapInfoContributor>User data</mapInfoContributor>
			<mapInfoContributor>Short</mapInfoContributor>
			<mapInfoContributor>Room</mapInfoContributor>
			<profileShortcut key="Script editor">Alt+E</profileShortcut>
			<profileShortcut key="Show Map">Alt+M</profileShortcut>
			<profileShortcut key="Compact input line">Alt+L</profileShortcut>
			<profileShortcut key="Preferences">Alt+P</profileShortcut>
			<profileShortcut key="Notepad">Alt+N</profileShortcut>
			<profileShortcut key="Package manager">Alt+O</profileShortcut>
			<profileShortcut key="Module manager">Alt+I</profileShortcut>
			<profileShortcut key="MultiView">Alt+V</profileShortcut>
			<profileShortcut key="Mute all media">Alt+K</profileShortcut>
			<profileShortcut key="Play">Alt+C</profileShortcut>
			<profileShortcut key="Disconnect">Alt+D</profileShortcut>
			<profileShortcut key="Reconnect">Alt+R</profileShortcut>
			<profileShortcut key="Close profile">Alt+W</profileShortcut>
			<stopwatches />
		</Host>
	</HostPackage>
	<TriggerPackage>
		<TriggerGroup isActive="yes" isFolder="yes" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
			<name>LeU_UI</name>
			<script></script>
			<triggerType>0</triggerType>
			<conditonLineDelta>0</conditonLineDelta>
			<mStayOpen>0</mStayOpen>
			<mCommand></mCommand>
			<packageName>LeU_UI</packageName>
			<mFgColor>#ff0000</mFgColor>
			<mBgColor>#ffff00</mBgColor>
			<mSoundFile></mSoundFile>
			<colorTriggerFgColor>#000000</colorTriggerFgColor>
			<colorTriggerBgColor>#000000</colorTriggerBgColor>
			<regexCodeList />
			<regexCodePropertyList />
			<TriggerGroup isActive="yes" isFolder="yes" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>Communications</name>
				<script></script>
				<triggerType>0</triggerType>
				<conditonLineDelta>99</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList />
				<regexCodePropertyList />
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>Personal communications</name>
					<script>ui.fDebug("[trig] Personal communications")
--
local from = copy2decho(matches[2])
local to = copy2decho(matches[3])
local message = copy2decho(matches[4])
local m
--
if (matches[2] == "["..ui.player.name.."]") then
  from = string.gsub(from, ui.player.name, "Tu")
  from = string.gsub(from, "]\&lt;r\&gt;", "]")
  from = from.." a "..matches[3].."\&lt;r\&gt;"
elseif (matches[2] == "Mandi") or (matches[2] == "Tu") then
  local color = string.gsub(from, matches[2].."\&lt;r\&gt;", "")
  from = color.."[\&lt;255,255,255:0,0,0\&gt;Tu"..color.."]".." a \&lt;255,255,255:0,0,0\&gt;"..matches[3].."\&lt;r\&gt;"
else
  --
  -- Save who Reply
  ui.reply = matches[2];
  ui.reply = string.gsub(ui.reply, "%[", "")
  ui.reply = string.gsub(ui.reply, "%]", "")
  ui.reply = string.gsub(ui.reply, ",", "")
  ui.reply = ui.fRemoveArticle(ui.reply)
  ui.reply = string.sub(ui.reply, 1, string.find(ui.reply, " "))
end
--
-- Private Chat
if (ui.previous.fromPrivate) and (ui.previous.fromPrivate == from) then
  m = "  "..message.."\n"
else
  m = "\n"..from.." &lt;128,128,128:"..ui.colors.wBackground.."&gt;"..os.date("%H:%M:%S").."\n  "..message.."\n"
  ui.previous.fromPrivate = from
end
--
m = string.gsub(m, ":0,0,0&gt;", ":"..ui.colors.wBackground.."&gt;")
m = string.gsub(m, "&lt;0,0,255:", "&lt;128,128,255:")
--
GUI.Chat.Main.Private:decho(m)
--
-- "All" Chat
if (ui.previous.fromAll) and (ui.previous.fromAll == from) then
  m = "  "..message.."\n"
else
  m = "\n"..from.." &lt;128,128,128:"..ui.colors.wBackground.."&gt;"..os.date("%H:%M:%S").."\n  "..message.."\n"
  ui.previous.fromAll = from
end
--
m = string.gsub(m, ":0,0,0&gt;", ":"..ui.colors.wBackground.."&gt;")
m = string.gsub(m, "&lt;0,0,255:", "&lt;128,128,255:")
--
GUI.Chat.Main.All:decho(m)
--
-- Sound
playSoundFile(ui.files.sounds.path..[[message.wav]], 10)</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>^(Mandi) a (.*) il (?:pensiero|messaggio) (\'.*\')$</string>
						<string>^(Tu) (?:chiedi|dici|sussurri) (?:a|ai|al|alla|alle|agli) (.*) (\'.*\')$</string>
						<string>^(\[.*\]) (ti) (?:manda il messaggio|manda il pensiero|chiede|dice|sussurra) (\'.*\')$</string>
						<string>^(\[.*\]) dice (?:a |ai |al |all'|alla |alle |agli )(.*) (\'.*\')$</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
						<integer>1</integer>
						<integer>1</integer>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>Public  communication</name>
					<script>ui.fDebug("[trig] Public communication")
--
local str = copy2decho(matches[1])
local color = copy2decho(matches[2])
local from = copy2decho(matches[3])
local message = copy2decho(matches[4])
local m
-- Color
color = string.gsub(color, 'Tu&lt;r&gt;', '')
color = string.gsub(color, '%[&lt;r&gt;', '')
--
from = ui.fRemoveArticle(from)
--
-- Public Chat
if (ui.previous.fromPublic) and (ui.previous.fromPublic == from) then
  m = "  "..message.."\n"
  m = string.gsub(m, ":0,0,0&gt;",    ":"..ui.colors.wBackground.."&gt;")
else
  m = str
  m = string.gsub(m, "&gt;Tu",      "&gt;[Tu]")
  m = string.gsub(m, "] grida ",   "]")
  m = string.gsub(m, "] esclama ", "]")
  m = string.gsub(m, "] mormora ", "]")
  m = string.gsub(m, "] vi dice ", "]")
  m = string.gsub(m, "] dice ",    "]")
  m = string.gsub(m, "] dici ",    "]")
  m = string.gsub(m, "] risuona ", "]")
  --
  m = string.gsub(m, "]",          "] &lt;128,128,128:"..ui.colors.wBackground.."&gt;"..os.date("%H:%M:%S").."\n  "..color)
  m = string.gsub(m, ":0,0,0&gt;",    ":"..ui.colors.wBackground.."&gt;")
  m = "\n"..m.."\n"
  ui.previous.fromPublic = from
end
--
GUI.Chat.Main.Public:decho(m)
--
-- "All" Chat
if (ui.previous.fromAll) and (ui.previous.fromAll == from) then
  m = "  "..message.."\n"
  m = string.gsub(m, ":0,0,0&gt;",    ":"..ui.colors.wBackground.."&gt;")
else
  m = str
  m = string.gsub(m, "&gt;Tu",      "&gt;[Tu]")
  m = string.gsub(m, "] grida ",   "]")
  m = string.gsub(m, "] esclama ", "]")
  m = string.gsub(m, "] mormora ", "]")
  m = string.gsub(m, "] vi dice ", "]")
  m = string.gsub(m, "] dice ",    "]")
  m = string.gsub(m, "] dici ",    "]")
  m = string.gsub(m, "] risuona ", "]")
  --
  m = string.gsub(m, "]",          "] &lt;128,128,128:"..ui.colors.wBackground.."&gt;"..os.date("%H:%M:%S").."\n  "..color)
  m = string.gsub(m, ":0,0,0&gt;",    ":"..ui.colors.wBackground.."&gt;")
  m = "\n"..m.."\n"
  ui.previous.fromAll = from
end
--
GUI.Chat.Main.All:decho(m)</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>(^\[)(.*)\] (?:grida|esclama|mormora|vi dice|dice|risuona) (\'.*\')$</string>
						<string>(^(Tu)) (?:gridi|dici) (\'.*\')$</string>
						<string>(^\[)(.*)\] (\'.*\')$</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
						<integer>1</integer>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
			</TriggerGroup>
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>Equipment</name>
				<script>ui.fDebug("[trig] Equipment start")
--
local preDefinitedEquipment = {
  ["come luce"]         = { slot = "Luce",      short = "LUC", used = false },
  ["mano destra"]       = { slot = "Mano",      short = "MAN", used = false },
  ["mano sinistra"]     = { slot = "Mano",      short = "MAN", used = false },
  ["al collo 1"]        = { slot = "Collo",     short = "COL", used = false },
  ["al collo 2"]        = { slot = "Collo",     short = "COL", used = false },
  ["sul corpo"]         = { slot = "Corpo",     short = "COR", used = false },
  ["in testa"]          = { slot = "Testa",     short = "TES", used = false },
  ["sulle gambe"]       = { slot = "Gambe",     short = "GAM", used = false },
  ["ai piedi"]          = { slot = "Piedi",     short = "PIE", used = false },
  ["sulle mani"]        = { slot = "Mani",      short = "MAN", used = false },
  ["sulle braccia"]     = { slot = "Braccia",   short = "BRA", used = false },
  ["come scudo"]        = { slot = "Scudo",     short = "SCU", used = false },
  ["attorno al corpo"]  = { slot = "Attorno",   short = "ATT", used = false },
  ["alla vita"]         = { slot = "Vita",      short = "VIT", used = false },
  ["polso destro"]      = { slot = "Polso",     short = "POL", used = false },
  ["polso sinistro"]    = { slot = "Polso",     short = "POL", used = false },
  ["impugnato"]         = { slot = "Arma",      short = "IMP", used = false },
  ["afferrato"]         = { slot = "Afferrato", short = "AFF", used = false },
  ["sulla schiena"]     = { slot = "Schiena",   short = "SCH", used = false },
  ["orecchio destro"]   = { slot = "Orecchie",  short = "ORE", used = false },
  ["orecchio sinistro"] = { slot = "Orecchie",  short = "ORE", used = false },
  ["sul viso"]          = { slot = "Viso",      short = "VIS", used = false },
  ["incoccato"]         = { slot = "Incoccato", short = "INC", used = false },
  ["come aura"]         = { slot = "Aura",      short = "AUR", used = false },}
--
ui.equipment = ui.equipment or {}
ui.equipment = table.update(ui.equipment, preDefinitedEquipment)
--
enableTrigger("equipment_valid")
enableTrigger("equipment_end")
</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>1</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>^Stai usando:$</string>
					<string>^.* sta usando:$</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>1</integer>
					<integer>1</integer>
				</regexCodePropertyList>
				<Trigger isActive="no" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>equipment_valid</name>
					<script>-- (?:\[(.*)\] )?\&lt;(.*)\&gt;.*\[(.*)\] (?:\|(.*)\| )?(.*)
-- match[1] = [2:numero] &lt;3:locazione&gt; [4:livello] |5:tipo| 6:descrizione
ui.fDebug("[trig] Equipment_valid")
--
local location  = string.trim(matches[3])
local slot = {}
--
if (location == "al collo") then
  if (not ui.equipment["al collo 1"].used) then
    location = "al collo 1"
  else
    location = "al collo 2"
  end
end
--
if (ui.equipment[location]) then
  --
  slot.number   = tonumber(string.trim(matches[2]))
  --
  -- Con il comando "eq manc" il numero e "X"
  if (slot.number) then
    slot.type     = string.gsub(copy2decho(matches[4]), ":0,0,0&gt;", ":"..ui.colors.wBackground.."&gt;")
    slot.level    = tonumber(string.trim(matches[5]))
    slot.status   = string.trim(matches[6])
    --
    if (matches[7] == "") then
      slot.name = ""
    else
      slot.name,
      slot.good,
      slot.evil,
      slot.bright,
      slot.noisy,
      slot.brittle  = ui.fParsingItem(copy2decho(matches[7]))
    end
    --
    ui.equipment[location].number = slot.number 
    ui.equipment[location].type = slot.type 
    ui.equipment[location].level = slot.level
    --
    slot.name = string.gsub(slot.name, ":0,0,0&gt;", ":"..ui.colors.wBackground.."&gt;")
    if (ui.fIsStatistics(slot.name)) then
      ui.equipment[location].name = ui.equipment[location].name or ui.equipment[location].slot
      ui.equipment[location].stat = slot.name;
    elseif(ui.equipment[location].name == nil) or (slot.name ~= ui.equipment[location].name) then
      ui.equipment[location].name = slot.name;
      ui.equipment[location].stat = nil;
    end
    --
    ui.equipment[location].status = slot.status
    ui.equipment[location].used = true;
  end
end
--
setTriggerStayOpen("Equipment", 1)
</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>\[(.*)\] \&lt;(.*)\&gt;.*\[(.*)\|(.*)\|(.*)\] (.*)</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="no" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>equipment_end</name>
					<script>ui.fDebug("[trig] Equipment_end")
--
ui.parameters.widgets.endowment.type = "equip"
ui.fUpdateEndowment()
--
disableTrigger("equipment_valid")
disableTrigger("equipment_invalid")
disableTrigger("equipment_end")</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>^Il livello di potenza medio del tuo equipaggiamento e' .*$</string>
						<string>^    Nulla.$</string>
						<string>^$</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
						<integer>1</integer>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
			</Trigger>
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>Identification</name>
				<script>ui.fDebug("[trig] Identification")
--
ui.identification = {}
ui.identification.name = matches[2]
ui.identification.type = matches[3]
--
enableTrigger("identification_valid")
enableTrigger("identification_invalid")
enableTrigger("identification_end")</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>1</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#00aaff</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>^(.+) \(.+\), Tipologia: (.+).$</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>1</integer>
				</regexCodePropertyList>
				<Trigger isActive="no" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>identification_valid</name>
					<script>ui.fDebug("[trig] identification_valid")
--
if (matches[2] == "Indossabilita") then
  ui.identification.slot = string.trim(matches[3])
  if (ui.identification.slot == "") then ui.identification.slot = ui.identification.type end
elseif (matches[2] == "bonus all'Armatura") then
  ui.identification.bonus = ui.identification.bonus or {}
  ui.identification.bonus[#ui.identification.bonus+1] = string.trim(matches[3]).." Classe Armatura"
elseif (matches[2] == "Causa") then
  ui.identification.bonus = ui.identification.bonus or {}
  ui.identification.bonus[#ui.identification.bonus+1] = string.trim(matches[3]).." Danno ("..string.trim(matches[4])..")"
else
  ui.identification.bonus = ui.identification.bonus or {}
  ui.identification.bonus[#ui.identification.bonus+1] = string.trim(matches[3]).." ("..string.trim(matches[2])..")"
end
--
setTriggerStayOpen("Identification", 1)</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#000000</mFgColor>
					<mBgColor>#00ff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>^(Indossabilita)` : ?(.+).$</string>
						<string>^Garantisce un (bonus all'Armatura) di (.+).$</string>
						<string>^(Causa) (.+) danni \(Media: .+\) di tipologia (.+).$</string>
						<string>^\[.+\]\[(.+)\] (.+)$</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
						<integer>1</integer>
						<integer>1</integer>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="no" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>identification_invalid</name>
					<script>ui.fDebug("[trig] identification_invalid")
--
setTriggerStayOpen("Identification", 1)</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#000000</mFgColor>
					<mBgColor>#ff5500</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>^$</string>
						<string>Contribuisce .+ al limite per gli oggetti indossabili.</string>
						<string>Percorso .+ \(.+\/.+\): .+ </string>
						<string>Pesa .+ etti e vale .+ monete d'oro.</string>
						<string>Indice di danneggiamento: .+\/100</string>
						<string>Conferisce i Poteri:</string>
						<string>Richiede .+ per essere utilizzato.</string>
						<string>Guadagna .+\% del danno fisico e .+\% del potere magico.</string>
						<string>Con il tuo equipaggiamento, questo corrisponde a .+ danni aggiuntivi.</string>
						<string>Puo` essere utilizzato solo da .+.</string>
						<string>Puo` contenere .+ etti.</string>
						<string>Indice di danneggiamento: .+.</string>
						<string>Causa i seguenti effetti con potenza .+:</string>
						<string>  .+</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
						<integer>1</integer>
						<integer>1</integer>
						<integer>1</integer>
						<integer>1</integer>
						<integer>1</integer>
						<integer>1</integer>
						<integer>1</integer>
						<integer>1</integer>
						<integer>1</integer>
						<integer>1</integer>
						<integer>1</integer>
						<integer>1</integer>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="no" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>identification_end</name>
					<script>ui.fDebug("[trig] identification_end")
--
ui.identification.level = matches[2]
ui.fUpdateEndowment()
--
disableTrigger("identification_valid")
disableTrigger("identification_invalid")
disableTrigger("identification_end")</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#000000</mFgColor>
					<mBgColor>#0000ff</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>^Il livello di potenza complessivo di questo oggetto e` (.+).$</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
			</Trigger>
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>Track</name>
				<script>ui.fDebug("[trig] Track")
--
if (matches[2]) and (ui.validExit[string.lower(matches[2])])then
  ui.track = ui.validExit[string.lower(matches[2])].short
else
  ui.track = ""
end
--
ui.fUpdateRoom()</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>^Vedi una traccia della tua preda che va verso (?:l'|il )?(.*).$</string>
					<string>^Vedi una debole traccia verso (?:l'|il )?(.*)$</string>
					<string>^Cio' che cerchi e' gia' qui!$</string>
					<string>^Non riesci a trovare tracce.$</string>
					<string>^Hai trovato la tua preda!$</string>
					<string>^Hai perso la traccia.$</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>1</integer>
					<integer>1</integer>
					<integer>1</integer>
					<integer>1</integer>
					<integer>1</integer>
					<integer>1</integer>
				</regexCodePropertyList>
			</Trigger>
		</TriggerGroup>
		<TriggerGroup isActive="yes" isFolder="yes" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
			<name>Varie</name>
			<script></script>
			<triggerType>0</triggerType>
			<conditonLineDelta>0</conditonLineDelta>
			<mStayOpen>0</mStayOpen>
			<mCommand></mCommand>
			<packageName></packageName>
			<mFgColor>#ff0000</mFgColor>
			<mBgColor>#ffff00</mBgColor>
			<mSoundFile></mSoundFile>
			<colorTriggerFgColor>#000000</colorTriggerFgColor>
			<colorTriggerBgColor>#000000</colorTriggerBgColor>
			<regexCodeList />
			<regexCodePropertyList />
			<TriggerGroup isActive="yes" isFolder="yes" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>Apertura porte</name>
				<script></script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList />
				<regexCodePropertyList />
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>Porta chiusa</name>
					<script>ui.direction = ui.direction or ""
ui.door = {
  name = matches[2],
  pick = true,
  doorbash = true,
}
--
expandAlias("open "..ui.door.name.." "..ui.direction)</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>^(?:Il|Lo|La|I|Gli|Le) (\S*) (?:e`|sono) chius[aeio].</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>Chiave, Doorbash or Pick</name>
					<script>if (matches[2] == "scassinarla") then
  ui.door.pick = false;
elseif  (matches[2] == "sfondata") then
  ui.door.doorbash = false;
else
  ui.door.key = matches[2];
end</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>E` impossibile (scassinarla).</string>
						<string>E` troppo robusta per essere (sfondata).</string>
						<string>Il meccanismo di chiusura sembra adatto a (.*)\.</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
						<integer>1</integer>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>Porta chiusa a chiave</name>
					<script>ui.direction = ui.direction or ''
expandAlias("unlock "..matches[2].." "..ui.direction)</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>^(?:Il|Lo|La|I|Gli|Le) (\S*) sembra(?:no) serrat(?:a|e|i|o)</string>
						<string>^(?:Il|Lo|La|I|Gli|Le) (\S*) (?:e`|sono) serrat(?:a|e|i|o)</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>Non hai la chiave giusta.</name>
					<script>ui.direction = ui.direction or ''
if (ui.door.pick) then
  expandAlias("pick "..ui.door.name.." "..ui.direction) 
elseif (ui.door.doorbash) then
  expandAlias("doorbash "..ui.door.name.." "..ui.direction) 
else
  setDoor(ui.room.id, ui.direction, 3)
  echo("\n")
  ui.fEchon("Impossibile da scassinare o sfondare (&lt;white&gt;"..(ui.door.key or "&lt;orange&gt;Non esiste chiave").."&lt;r&gt;)")
end</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>Non hai la chiave giusta.</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>Comandi speciali per aprire uscite</name>
					<script>local actions = {
  ['abbassi'] = 'abbassa',
  ['apri']    = 'apri',
  ['giri']    = 'gira',
  ['ruoti']   = 'ruota',  
  ['scavi']   = 'scava',
  ['sollevi'] = 'solleva',
  ['spingi']  = 'spingi',
  ['tagli']   = 'taglia',
  ['tiri']    = 'tira',
}
local action    = string.lower(ui.fRemoveArticle(matches[2]))
local object    = string.lower(ui.fRemoveArticle(matches[3]))
local direction = string.lower(ui.fRemoveArticle(matches[4]))
--
echo('\n')
if (actions[action]) then
  action = actions[action]; 
  if (ui.validExit[direction]) then
    direction = ui.validExit[direction].short;
    setRoomUserData(ui.room.id, direction, action..' '..object..' '..direction)
    setDoor(ui.room.id, direction, 2)
    ui.fEcho2n('Aggiornata uscita &lt;yellow&gt;'..direction..'&lt;r&gt; = &lt;green&gt;'..action..' '..object..' '..direction..'&lt;r&gt;')
  else
    ui.fError('&lt;green&gt;'..direction..'&lt;r&gt; non è un uscita valida')
  end
else
  ui.fError('&lt;green&gt;'..action..'&lt;r&gt; non è un azione riconosciuta. Aggiornare la tabella del trigger')
end</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>^(\S*) (.*), liberando il percorso verso (.*).$</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
			</TriggerGroup>
			<TriggerGroup isActive="yes" isFolder="yes" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>Loot</name>
				<script></script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList />
				<regexCodePropertyList />
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>Mangia\Conserva Ethereum</name>
					<script>expandAlias("p eth")</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>^Prendi Un frammento di Ethereum cristallizzato(.*)</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>Raccogli Ethereum a terra</name>
					<script>send("get all.framm")
</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>Un curioso frammento di qualcosa(.*)</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>Raccogli Monete a terra</name>
					<script>send("get all.monete")</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>Un mucchio di monete d'oro(.*)</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
			</TriggerGroup>
			<TriggerGroup isActive="yes" isFolder="yes" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>Luogotenenti</name>
				<script></script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList />
				<regexCodePropertyList />
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>Turbine</name>
					<script>--[[
Questo Luogotenente ha come special skill un turbine di energia che lancia ogni 4 round.
Basta semplicemente essere nella stessa location in cui lancia il turbine.
Dovete spostarvi perché tra il lancio del turbine e la special passa solo 1 round. 
Se al lancio del turbine non sarete nella giusta posizione perdete 1500 hp.
]]
local direzione = matches[2]
cecho("\n&lt;white:red&gt; * TURBINE * &lt;r&gt; Muoversi a "..direzione.."\n")
sposta(getPosition(direzione))
</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>crea un turbine di energia presso l'angolo (.*) della stanza.</string>
						<string>crea un turbine di energia presso il lato (.*) della stanza</string>
						<string>crea un turbine di energia presso il (.*) della stanza.</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
						<integer>1</integer>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>Raggio</name>
					<script>--[[
Questo Luogotenente ha come special skill un raggio di energia pura che va evitato (toglie 2500 hp). 
Per evitarlo basta essere in un positioning diverso da quello dove indirizza il raggio. 
]]
local direction = getPosition(matches[2])
local actualPosition = ui.player.roomPos or 5
cecho("\n&lt;white:red&gt; * RAGGIO * &lt;r&gt; Spostarsi da "..matches[2].." ("..direction..") (se uguale)\n")
if (actualPosition == direction) then
  if (actualPosition == 5) then
    sposta(1)
  else
    sposta(5)
  end
end</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>sembra guardare verso il lato (.*) della stanza.</string>
						<string>sembra guardare verso l'angolo (.*) della stanza.</string>
						<string>sembra guardare verso il (.*) della stanza.</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
						<integer>1</integer>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>Tremore</name>
					<script>--[[
Questo Luogotenente ha come special skill un doppio turbine di energia che lancia ogni 4 round. 
Il principio é lo stesso del turbine singolo, solo che essendo un turbine bidirezionale (va in due direzioni diverse), 
occorre coordinarsi col resto del gruppo in modo che un player vada sempre nel primo positioning. 
Il secondo player (o resto del gruppo) vada sempre nella seconda posizione in modo da evitare completamente i danni della special (1500 hp).
A differenza del turbine singolo, qui il Luogotenente vi concede due round per spostarvi correttamente nei giusti positioning. 
In pratica lancia il turbine bidirezionale, poi ci sarà un round bonus in cui avete ancora tempo per essere nei giusti positioning, 
infine lancia a special skill. E via cosi.
]]
local direzioneA = matches[2]
local direzioneB = matches[2]
cecho("\n&lt;white:red&gt; * TREMORE (doppio turbine) * &lt;r&gt; Muoversi a "..direzioneA.."\n")
sposta(getPosition(direzioneA))</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>un tremore scuote il lato (.*) e l'angolo (.*) della stanza</string>
						<string>un tremore scuote il lato (.*) e il lato (.*) della stanza</string>
						<string>un tremore scuote il (.*) e l'angolo (.*) della stanza</string>
						<string>un tremore scuote il (.*) e il lato (.*) della stanza</string>
						<string>un tremore scuote l'angolo (.*) e l'angolo (.*) della stanza</string>
						<string>un tremore scuote l'angolo (.*) e il lato (.*) della stanza</string>
						<string>un tremore scuote l'angolo (.*) e il (.*) della stanza</string>
						<string>un tremore scuote il lato (.*) e il (.*) della stanza</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
						<integer>1</integer>
						<integer>1</integer>
						<integer>1</integer>
						<integer>1</integer>
						<integer>1</integer>
						<integer>1</integer>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>Unione</name>
					<script>--[[
Questo Luogotenente ha come special skill un incantesimo che vi toglie hp se il gruppo é nella stessa positioning. 
Se si é da soli basta semplicemente restare immobili e fare quanto piu danno possibile e a ogni fine special perdete solo 250 hp, 
ampiamente gestibili. 
Se siete un gruppo da tre\quattro basta dividersi il positioning e poi restare immobili, continuando a fare dps.
]]
cecho("\n&lt;white:red&gt; * UNIONE * &lt;r&gt; Posizione diversa dal resto del gruppo (settata a 9)\n")
sposta(9)</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string> ride sguaiatamente, mentre l'intera stanza inizia a tremare</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>0</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>Aura</name>
					<script>--[[
Questo Luogotenente ha come special skill un aura con cui si autocura gli hp. 
Come prima cosa é fondamentale farsi castare da un mago lo spell shield che protegge dai magic missile che spara il Luogotenente. 
Quando poi durante il combat vedete questa scritta:

- Falthken, Luogotenente del Caos dice 'rxaccozglieyreyte moltzo pxiyu` di qyuanto xavete zseymiznyato

Dovete stoppare il combat immediatamente e smettere di fare dps in qualsiasi modo, idem chi sta tankando, bisogna stoppare. 
Quando poi vedrete questa scritta:

- Falthken, Luogotenente del Caos emette suoni di soddisfazione nel vedere le sue ferite rimarginarsi

Potete riprendere a fare dps in modo massiccio. Il combat va via cosi.
Se c'é un healer in gruppo, quando il Luogotenente casta l'aura di assorbimento (e solo in quel round) tirategli un heal/miracle/seeds, 
In questo modo avrà un malus il round successivo e perderà hp in base a quanti hp lo curate. 
]]
cecho("\n&lt;white:red&gt; * AURA * &lt;r&gt; Ferma il combattimento\n")
send("stop")</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>\[(.*), (.*)\] dice 'R</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>Ritorna centro</name>
					<script>--Sbattendo i piedi, riesci a placare il tremore prima che esploda!
cecho("\n&lt;white:red&gt;Ritorno al centro&lt;r&gt;\n")
sposta(5)</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>Per fortuna, il luogo d'origine non sembra essere stato colpito!</string>
						<string>I venti del caos ti investono</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>0</integer>
						<integer>0</integer>
					</regexCodePropertyList>
				</Trigger>
			</TriggerGroup>
			<TriggerGroup isActive="yes" isFolder="yes" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>Stand (Automatico)</name>
				<script></script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList />
				<regexCodePropertyList />
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="yes" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>Stand (automatico)</name>
					<script>echo("\n")
ui.fEchon("Trig Auto stand")
--
if (not ui.wasCmdStandSended) then
  expandAlias("stand")
  ui.wasCmdStandSended = true;
else
  ui.fEchon("Command stand already sended")
end</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#000000</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>Prima forse dovresti alzarti, non credi?</string>
						<string>Ti devi alzare per lanciare quest'incantesimo.</string>
						<string>Nah... Sei troppo rilassato...</string>
						<string>Tramortito dagli eventi, avrai bisogno di qualche momento per riprenderti. </string>
						<string>Tramortito dagli eventi, avrai bisogno di del tempo per riprenderti. </string>
						<string>Hai bisogno di alzarti in piedi per usare le tue abilita`!</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>3</integer>
						<integer>3</integer>
						<integer>3</integer>
						<integer>3</integer>
						<integer>3</integer>
						<integer>3</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>Ti alzi.</name>
					<script>if (ui.wasCmdStandSended) then
  ui.wasCmdStandSended = nil;
end</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>Ti alzi.</string>
						<string>Sei gia` in piedi.</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>3</integer>
						<integer>3</integer>
					</regexCodePropertyList>
				</Trigger>
			</TriggerGroup>
			<Trigger isActive="no" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>Invasioni</name>
				<script>local t1 = matches[2] * 60 * 60 + matches[3] * 60 + matches[4]
local t2 = os.date("%H") * 60 * 60 + os.date("%M") * 60 + os.date("%S")
local location = matches[5]

t1 = t2 - t1
if (t1&gt;=1800) then -- 30 minuti
  t1 = t1 - 1800;
  t2 = math.floor(t1/60)
  t1 = t1 - t2*60
  cecho(" &lt;red&gt;... (CONCLUSA da "..t2..":"..t1.." min)")
else
  t1 = 1800 - t1
  t2 = math.floor(t1/60)
  t1 = t1 - t2*60
  cecho(" &lt;green&gt;... -"..t2..":"..t1.." min alla fine")
  --
  --sendToDiscordWebhook("Invasione in corso ["..location.."] -"..t2..":"..t1.." min alla fine")
end
setTriggerStayOpen("Invasioni", 1)</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>1</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>^\[.*\] \[Invasione\] \[(.*)\:(.*)\:(.*)\] Il velo tra le realta' si e' assottigliato a \[(.*)\]</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>1</integer>
				</regexCodePropertyList>
			</Trigger>
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>Flee (automatico)</name>
				<script>send("flee", false)</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>Sei paralizzato dal panico! Non puoi fuggire!</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>3</integer>
				</regexCodePropertyList>
			</Trigger>
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>Movimento MOB</name>
				<script>local str = matches[1]
local name = ui.fRemoveArticle(matches[2])
local dir = string.trim(string.lower(matches[3] or ""))
selectString(str, 1)
replace("")
dir = ui.validExit[dir].short
if (string.find(str, "arriva da")) or
   (string.find(str, "arriva volando da")) then
  if (dir == "w") or (dir == "d") or (dir == "s") then
    cecho("&lt;red&gt;"..ui.validExit[ui.validExit[dir].reverse].tokenOpen.." &lt;orange&gt;"..name)
  else
    cecho("&lt;orange&gt;"..name.." &lt;red&gt;"..ui.validExit[ui.validExit[dir].reverse].tokenOpen)
  end
elseif (string.find(str, "va verso")) or
       (string.find(str, "vola verso")) then
  if (dir == "w") or (dir == "d") or (dir == "s") then
    cecho("&lt;green&gt;"..ui.validExit[dir].tokenOpen.." &lt;ForestGreen&gt;"..name)
  else
    cecho("&lt;ForestGreen&gt;"..name.." &lt;green&gt;"..ui.validExit[dir].tokenOpen)
  end
elseif (string.find(str, "si alza")) then
  cecho("&lt;red&gt;↑↑↑ &lt;orange&gt;"..name.." &lt;red&gt;↑↑↑")
else --if (string.find(str, "appare")) then
  cecho("&lt;red&gt;*** &lt;orange&gt;"..name.." &lt;red&gt;***")
end</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>^(.*) arriva.*( est|ovest|nord|sud|alto|basso)$</string>
					<string>^(.*) (?:va|vola) verso.*( est|ovest|nord|sud|alto|basso)$</string>
					<string>^(.*) appare improvvisamente.$</string>
					<string>^(.*) si alza lentamente.$</string>
					<string>^(.*) esce dal passaggio che si richiude alle sue spalle.$</string>
					<string>^(.*) viene fuori dal portale.$</string>
					<string>^(.*) si alza velocemente.$</string>
					<string>^(.*) si materializza con uno spruzzo di acqua colorata.</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>1</integer>
					<integer>1</integer>
					<integer>1</integer>
					<integer>1</integer>
					<integer>1</integer>
					<integer>1</integer>
					<integer>1</integer>
					<integer>1</integer>
				</regexCodePropertyList>
			</Trigger>
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="yes" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>Fallimento lancio incantesimo</name>
				<script>cecho("\n&lt;white&gt;&lt;"..command.."&gt;\n");</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff5500</mFgColor>
				<mBgColor>#000000</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>Su cosa vuoi lanciare quest'incantesimo?</string>
					<string>Non c'e' nessuno qui con questo nome.</string>
					<string>C'e` troppa pace qui per essere violenti.</string>
					<string>Non riesci a concentrarti abbastanza in questo posto.</string>
					<string>Impossibile! Non riesci a concentrarti abbastanza.</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>3</integer>
					<integer>3</integer>
					<integer>3</integer>
					<integer>3</integer>
					<integer>3</integer>
				</regexCodePropertyList>
			</Trigger>
			<Trigger isActive="no" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>Inversione descrizione &lt;-&gt; danni</name>
				<script>local des = copy2decho(matches[2])
local dam = copy2decho(matches[3])
if (string.find(dam, "&lt;128,0,0:")) then
  -- Danno inferto
  dam = string.gsub(dam, "&lt;128,0,0:", "&lt;128,255,255:") -- &lt;255,164,32:
  dam = "|       "..dam
else
  -- Danno subito
  dam = dam.."       |"
end
for i=1, 7-(matches[3]):len() do
  dam = string.gsub(dam, '%[', '[ ')
end
dam = string.gsub(dam, '%[', '| ')
dam = string.gsub(dam, '%]', ' |')
deleteLine()
decho("\n"..dam.." "..des)
</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>(.*)(\[[+|-]\d*\])$</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>1</integer>
				</regexCodePropertyList>
			</Trigger>
			<Trigger isActive="no" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>Inversione Mob &lt;-&gt; Livello</name>
				<script>local str, liv, qtt
--
str = copy2decho(matches[2])
liv = copy2decho(matches[3])
liv = string.gsub(liv, "%&gt;(%d)%&lt;", "&gt; %1&lt;")
liv = string.gsub(liv, "%]%[", "] [")
--
if (matches[4]) then
  qtt = string.trim(copy2decho(matches[4]))
else
  qtt = "&lt;192,192,192:0,0,0&gt;[&lt;r&gt;&lt;0,255,0:0,0,0&gt;1&lt;r&gt;&lt;192,192,192:0,0,0&gt;]&lt;r&gt;"
end
--
selectCaptureGroup(1)
dreplace(qtt.." " ..liv.." "..str)</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>^(.*) (\[Liv \d*\])(\[Elite\])?( \[\d*\])?$</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>1</integer>
				</regexCodePropertyList>
			</Trigger>
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="yes" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>Aure</name>
				<script>local aura = matches[2]
deleteLine()
if (aura == "luce") then
  cecho(" &lt;white&gt;(&lt;r&gt;o&lt;white&gt;)&lt;r&gt;")
elseif (aura == "ghiaccio") then
  cecho(" &lt;cyan&gt;(&lt;r&gt;o&lt;cyan&gt;)&lt;r&gt;")
elseif (aura == "elettric") then
  cecho(" &lt;blue&gt;(&lt;r&gt;o&lt;blue&gt;)&lt;r&gt;")
elseif (aura == "fiammeggiante") then
  cecho(" &lt;red&gt;(&lt;r&gt;o&lt;red&gt;)&lt;r&gt;")
elseif (aura == "oscurita") then
  cecho(" &lt;DimGrey&gt;(&lt;r&gt;o&lt;DimGrey&gt;)&lt;r&gt;")
elseif (aura == "copie") then
  cecho(" &lt;purple&gt;(&lt;r&gt;o&lt;purple&gt;)&lt;r&gt;")
end</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>.* brilla di (luce) propria!</string>
					<string>.* e` avvolt[oa] da un\'aura (elettric)a.</string>
					<string>.* e` avvolt[oa] in una luce (fiammeggiante)!</string>
					<string>.* e` avvolt[oa] nell'(oscurita)`!</string>
					<string>La pelle di .* ha la consistenza del (ghiaccio)!</string>
					<string>L'aria attorno a .* e` carica di (elettric)ita`!</string>
					<string>.* e` accompagnat[oa] da diverse (copie) di se stess[oa]!</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>1</integer>
					<integer>1</integer>
					<integer>1</integer>
					<integer>1</integer>
					<integer>1</integer>
					<integer>1</integer>
					<integer>1</integer>
				</regexCodePropertyList>
			</Trigger>
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>Cristalli di Ethereum</name>
				<script>local str = string.lower(matches[2] or "") 
if (str == "affilato") then
  str = "+1 a Tiro per Colpire - Max +2";
elseif (str == "appuntito") then
  str = "+1 a Danno Fisico - Max +1";
elseif (str == "brillante") then
  str = "+1 a Colpire e Potere Magico - Max +1";
elseif (str == "concentrato") then
  str = "+1% a Focus Magico - Max +3";
elseif (str == "contundente") then
  str = "+1 a Riduzione da Impatto - Max +2";
elseif (str == "flessibile") then
  str = "+2 a Recupero Mana - Max +10";
elseif (str == "fluorescente") then
  str = "+6 a Punti Mana - Max +30"
elseif (str == "frastagliato") then
  str = "+1 a Colpire e Danno Fisico - Max +1";
elseif (str == "irrequieto") then
  str = "+1% ad Attacco Extra - Max +3";
elseif (str == "luminoso") then
  str = "+1 a Potere Magico - Max +1";
elseif (str == "pungente") then
  str = "+1 a Riduzione da Punta - Max +2";
elseif (str == "rigenerante") then
  str = "+4 a Recupero Ferita - Max +20";
elseif (str == "robusto") then
  str = "+3 a Punti Ferita - Max +45";
elseif (str == "tagliente") then
  str = "+1 a Riduzione da Taglio - Max +2";
end
str = ".[&lt;cyan&gt;"..str.."&lt;r&gt;]"
for i = matches[1]:len(), 70 do
  str = "."..str;
end
cecho(str)</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>.*cristallo di Ethereum (\w*).*</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>1</integer>
				</regexCodePropertyList>
			</Trigger>
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>Eldorado</name>
				<script>local msg = string.lower(matches[2])
if (msg == "una fitta foresta dominata da una sagoma imponente") then
  msg = "da alma civitas : .s10ws9w3n10wusws2ws2wn (n giungla)"

elseif (msg == "tutto il globo, ma su niente") then
  msg = "da alma civitas : .s9e3n4es2e2d18e2n4e3s7e;open ea;.8e3s8e;open ea;.6e6n;open north;.7ne10ne3ne5ne7nw3n8en (d;run n giungla)"

elseif (msg == "una piccola valle dormiente tra i monti") then
  msg = "da alma civitas : .s9e3n4es2e2d18e2n4e3s7e;open ea;.8e3s6e2sue2sw (n giungla)"

elseif (msg == "una imponente foresta di quercie") then
  msg = "da alma civitas : .s9e3n4es2e2d18e2n4e3s7e;open ea;.8e3s8e;open ea;.6e6n;open north;.7ne10ne3ne2n (e sorgente)"

elseif (msg == "una spiaggetta in un bosco") then
  msg = "da alma civitas : .s9e3n4es2e2d18e2n4e3s7e;open ea;.8e3s8e;open ea;.6e6n;open north;.7ne5n3e5n (n giungla)"

elseif (msg == "una grotta che ospita presenze maligne") then
  msg = "da alma civitas : .8s2e2s2ws2es2w3swsws2en3e2n2e2n3n2wn3wden;.2e4sen2w (w necropoli)"

elseif (msg == "l'ansa di un fiume tropicale") then
  msg = "da alma civitas : .s9e3n4es2e2d18e2n4e3s7e;open ea;.8e3s8e;open ea;.6e6s;ope sou;.sd2sw5se (s laguna)"

elseif (msg == "degli orti ben coltivati") then
  msg = "da alma civitas : .s9e3n4es2e2d18e2n4e3s7e;open ea;.8e3s8e;open ea;.6e6s;open sou;.sd2sw5s2wsw (s contadini)"

elseif (msg == "una piccola radura su un altipiano") then
  msg = "da alma civitas ad alpes oppidum: .10ne3nw5nw3nw; (solo se chiuso verso north: lift grata) .4n oppure\n"
  msg = msg.."da alpes oppidum a una stradina nel sottobosco: .w2nesu2nueuen2w3nw3ue (s sorgente)"

elseif (msg == "un boschetto con un gazebo") then
  msg = "da alma civitas : .s10ws9w3n4w3s3ws3ese3s (lycantropia) .s2es3e3nw3s (w radura)"

elseif (msg == "un umido tunnel dove aleggia un odore di belve") then
  msg = "da alma civitas : .s9e12nd3e4s (s fossa belve)"

elseif (msg == "un luogo sotterraneo abitato, da strani rettili") then
  msg = "da alma civitas : .s9en2e3s7en;cut liana;d (n miniera)"

elseif (msg == "un'enorme belva di marmo") then
  msg = "da alma civitas .2s4w; kill tarquinio; .wn2edne (east fossa belve)"

elseif (msg == "delle potenti scariche di elettricità") then
  msg = "da alma civitas : .s9e3n4es2e2de2u2nuse2nwu (la fortezza!) .nwnw3n (solo se chiuso verso west: pull torcia) .wde2s2e (solo se chiuso verso est: push masso) .e2s2e4n (w drago blu)(.2w radura)"

elseif (msg == "draghi e cavalieri, ma sono immobili") then
  msg = "da alma civitas : .s9e3n4es2e2d18e2n4e3s7e;open ea;.8e3s8e;open ea;.6e6n;open north;.7ne10ne3ne5ne7n3w (run s miniera)"

elseif (msg == "vari simboli di morte") then
  msg = "da alma civitas a la piazza principale: .s9e3n4es2e2d18e2n4e3s6e\n"
  msg = msg.."da la piazza principale: knock/pick south poi open south;.2s;kill nahaz;get chia naha;unlock botola;lift botola;.d (d necropoli)"

elseif (msg == "un animale incerto tra mangiare o bere") then
  msg = "da alma civitas : .s9e3n4es2e2d18e2n4e3s7e;open ea;.8e3s8e;open ea;.6e6n;open north;.7ne10ne3ne5ne7nw3nw2nene (e fossa belve)"

elseif (msg == "un'intricato labirinto") then
  msg = "Portalare Hoeur ed entrare con stringa (ent port;e) .2d (n Miniere)\n"
  msg = msg.."Se Hoeur non c'è da alma civitas: .s10ws9w3n9w6s8w5s3w (spaventapasseri) .n3e5n4e2s3w4sd\n"
  msg = msg..".d;kill guerrieri;get chiave cad;unlo east;open east;\n"
  msg = msg.."unlo east;open east;e;open east;e;open east;.e4d3e\n"
  msg = msg.."Qui si spiega comunque cosa c'e' e cosa fanno.\n"
  msg = msg.."e;kill 4 o 5 drow;open east;e;open east;kill 14 minotauri hide;.4d3e (Hoeur);ent port;e(??);.2d (n Miniere)"

elseif (msg == "un enorme smeraldo intagliato") then
  msg = "andare alla pool per torre magia (.unwn;ent spe), poi andare .3s2u5n e siete a la sala delle udienze (d;run n giungla)"

elseif (msg == "un fiume che scorre") then
  msg = "il fiume el'azahred:\n"
  msg = msg.."        da tania:.dw5s;open sou;.2se3s8e;open east;.6e5s7e (s giungla .uw;run n)\n"
  msg = msg.."        da il centro della piazza del mercato .5s7e (s giungla .uw;run n)\n"
  msg = msg.."\n"
  msg = msg.."    fiume lys\n"
  msg = msg.."        da alma civitas .4se2s6w (d sorgente)\n"
  msg = msg.."\n"
  msg = msg.."    fiume oscuro\n"
  msg = msg.."        da alma civitas .4se2se;ope grata;.7en4e (n giungla .uw;run n)\n"
  msg = msg.."\n"
  msg = msg.."    fiume ara-raven\n"
  msg = msg.."        da tania:.dw5s;open sou;.2se3s8e;open east;.6e5s14w2n (d giungla .uw;run n)\n"
  msg = msg.."        da il centro della piazza del mercato:.5s14w2n (d giungla .uw;run n)"
else
  msg = '"'..msg..'" non trovato'
end

echo("\n"..msg.."\n")</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>^\[la chiromante\] dice \'(.*) \'</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>1</integer>
				</regexCodePropertyList>
			</Trigger>
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>Dare per avere</name>
				<script>local str = copy2decho(matches[1] or "")
str = string.gsub(str, ":0,0,0&gt;", ":"..ui.colors.wBackground.."&gt;")
str = string.gsub(str, "&lt;0,0,255:", "&lt;128,128,255:")
ui.fLog(str)</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>^(.*) ti da['`] (.*)$</string>
					<string>^Dai (.*) a (.*).$</string>
					<string>^(.*) ti restituisce (.*)$</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>1</integer>
					<integer>1</integer>
					<integer>1</integer>
				</regexCodePropertyList>
			</Trigger>
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>Lingotti</name>
				<script>local str = string.lower(matches[2] or "")
str = string.trim(str);
--
if (str == "celestiale") or (str == "della natura") or (str == "infernale") or (str == "di vibranio") or (str == "dragonite") or (str == "ithildin") then
  str = "Fascia A (7)"
elseif (str == "runiche") or (str == "di palladio") or (str == "di titanio") or (str == "elementale") then
  str = "Fascia B (6)"
elseif (str == "di adamantio") or (str == "di ebanite") or (str == "di oricalco") or (str == "di mithril") then
  str = "Fascia C (5)"
elseif (str == "d'oro") or (str == "di platino") then
  str = "Fascia D (4)"
elseif (str == "d'argento") or (str == "di ossidiana") then
  str = "Fascia E (3)"
elseif (str == "d'acciaio") or (str == "di bronzo") or (str == "di rame") then
  str = "Fascia F (2)"
elseif (str == "di piombo") or (str == "di ottone") or (str == "di ferro") then
  str = "Fascia G (1)"
end

cecho(" [&lt;cyan&gt;"..str.."&lt;r&gt;] ")</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>.*(?:frammento|lingotto) (.*) \(Componente\).*</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>1</integer>
				</regexCodePropertyList>
			</Trigger>
			<Trigger isActive="no" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>Send all vie Telegram</name>
				<script>local str = matches[1]
ui.telegramMessage = ui.telegramMessage or ""
if (rex.match(matches[1], [[^\[.*\].*]])) then
  expandAlias("#telegram tell KenCiro78 "..ui.telegramMessage, false)
  ui.telegramMessage = ""
else
  ui.telegramMessage = ui.telegramMessage.."\r\n"..str
end
</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>.*</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>1</integer>
				</regexCodePropertyList>
			</Trigger>
		</TriggerGroup>
	</TriggerPackage>
	<TimerPackage />
	<AliasPackage>
		<AliasGroup isActive="yes" isFolder="yes">
			<name>LeU_UI</name>
			<script></script>
			<command></command>
			<packageName>LeU_UI</packageName>
			<regex></regex>
			<Alias isActive="yes" isFolder="no">
				<name>UI Aliases</name>
				<script>local alias = matches[2] or ""
local value = matches[3] or ""
--
-- Mostra tutti gli aliases
if (alias == "") then
  ui.fShowAllAliases()
--
-- Rimuove tutti gli aliases
elseif (alias == "remove_all") then
  ui.fRemoveAllAliases()
  ui.fEcho2n("Tutti gli alias sono stati rimossi.")
--
-- Mostra il singolo alias
elseif (value == "") then
  if (ui.aliases[alias]) then
    ui.fEcho2n(ui.fGetAliasFormattedText(alias))
  else
    ui.fError("L'alias "..ui.fGetAliasNameFormattedText(alias).." non esiste.")
  end
--
-- Rimuove il singolo alias
elseif value == "remove" then
  if (ui.fRemoveAlias(alias)) then
    ui.fEcho2n("L'alias "..ui.fGetAliasNameFormattedText(alias).." e' stato rimosso.")
  else
    ui.fError("L'alias "..ui.fGetAliasNameFormattedText(alias).." non esiste.")
  end
--
-- Crea o modifica l'alias
else
  local alreadyExist = ui.aliases[alias];
  local result, output = ui.fAddAlias(alias, value)
  if (result == -1) then
    ui.fError("L'alias "..ui.fGetAliasNameFormattedText(alias).." non è stato creato/modificato. La variabile "..ui.fGetVarNameFormattedText(output).." non esiste.")
  elseif (result == 1) then
    if (alreadyExist) then
      ui.fEcho2n("L'alias "..ui.fGetAliasNameFormattedText(alias).." è stato modificato: "..output..".")
    else
      ui.fEcho2n("L'alias "..ui.fGetAliasNameFormattedText(alias).." è stato creato: "..output..".")
    end
  else
    ui.fError("Errore non previsto.")
  end
end
--
ui.fSaveFileAliases()
ui.fUpdateAliasButton()
</script>
				<command></command>
				<packageName></packageName>
				<regex>^(?i)(?:uia(?:l(?:i(?:a(?:s(?:e(?:s)?)?)?)?)?)?)(?:\s+(\w*)\s*(.*))?$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>UI Buttons (configurazione)</name>
				<script>local button = matches[2] or ""
local alias = matches[3] or ""
--
-- Mostra tutti gli alias button
if (button == "") then
  ui.fShowAllAliasButtons()
--
-- Rimuove tutti gli alias buttons
elseif (button == "remove_all") then
  ui.fRemoveAllAliasButtons()
  ui.fEcho2n("Tutti i pulsanti alias sono stati rimossi.")
--
-- Mostra il singolo alias button
elseif (alias == "") then
  local type, number = ui.fExpandButton(button)
  if (type == "a") or (type == "b") or (type == "c") then
    button = type..number
    local alias = ui.fSearchAliasButton(button)
    if (alias) then
      ui.fEcho("")
      ui.fLinkAliasButton(button)
      echo("\n\n")
    else
      ui.fEcho2n("Nessun alias associato al pulsante "..ui.fGetAliasButtonFormattedText(button)..".")
    end
  else
    ui.fError(ui.fGetAliasButtonFormattedText(button).." non è un pulsante valido.")
  end
--
-- Rimuove il singolo alias button
elseif (alias == "remove") then
  local result = ui.fRemoveAliasButton(button)
  if (result == -2) then
    ui.fEcho2n("Nessun alias da rimuovere per il pulsante "..ui.fGetAliasButtonFormattedText(button)..".")
  elseif (result == -1) then
    ui.fError(ui.fGetAliasButtonFormattedText(button).." non è un pulsante valido.")
  elseif (result == 1) then
    ui.fEcho2n("L'alias associato al pulsante "..ui.fGetAliasButtonFormattedText(button).." è stato rimosso.")
  else
    ui.fError("Errore non previsto.")
  end
--
-- Crea o modifica l'alias button
else
  local result = ui.fAssignAliasButton(button, alias)
  if (result == -2) then
    ui.fError("L'alias "..ui.fGetAliasNameFormattedText(alias).." non esiste.")
  elseif (result == -1) then
    ui.fError(ui.fGetAliasButtonFormattedText(button).." non è un pulsante valido.")
  elseif (result == 1) then
    ui.fEcho2n("Il pulsante "..ui.fGetAliasButtonFormattedText(button).." è stato associato all'alias "..ui.fGetAliasNameFormattedText(alias)..".")
  else
    ui.fError("Errore non previsto.")
  end
end
--
ui.fSaveFileAliases()
ui.fUpdateAliasButton()</script>
				<command></command>
				<packageName></packageName>
				<regex>^(?i)(?:uib(?:u(?:t(?:t(?:o(?:n(?:s)?)?)?)?)?)?)(?:\s+(\w*)\s*(.*))?$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>UI Buttons (esecuzione)</name>
				<script>ui.fExecuteAliasButton(matches[2])</script>
				<command></command>
				<packageName></packageName>
				<regex>^(?i)([abc]\d)$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>UI Colors</name>
				<script>cecho(ui.fTitle("Colori disponibili:"))
ui.fDisplayColors({justText = false, removeDupes = true})</script>
				<command></command>
				<packageName></packageName>
				<regex>^(?i)(?:uic(?:o(?:l(?:o(?:r(?:s)?)?)?)?)?)$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>UI Font size</name>
				<script>local windows = string.lower(matches[2] or "")
local fontsize = tonumber(matches[3] or -1)
--
if (matches[3]) then
  if (fontsize &gt;= 1) and (fontsize &lt;= 30) then
    if (windows == "all") then
      -- Chat
      GUI.Chat.Main.All:setFontSize(fontsize)
      GUI.Chat.Main.Public:setFontSize(fontsize)
      GUI.Chat.Main.Private:setFontSize(fontsize)
      ui.parameters.widgets.chat.fontSize = fontsize
      -- Endowment
      GUI.Endowment.Main.Equipment:setFontSize(fontsize)
      ui.parameters.widgets.endowment.fontSize = fontsize
      -- Help
      GUI.Help.Main.Console:setFontSize(fontsize)
      ui.parameters.widgets.help.fontSize = fontsize
      -- Overland
      GUI.Mapper.Main.Overland:setFontSize(fontsize)
      ui.parameters.widgets.overland.fontSize = fontsize
      -- Room
      GUI.Room.Main.Console:setFontSize(fontsize)
      ui.parameters.widgets.room.fontSize = fontsize
      --
    elseif (windows == "chat") then
      GUI.Chat.Main.All:setFontSize(fontsize)
      GUI.Chat.Main.Public:setFontSize(fontsize)
      GUI.Chat.Main.Private:setFontSize(fontsize)
      ui.parameters.widgets.chat.fontSize = fontsize
    elseif (windows == "endowment") then
      GUI.Endowment.Main.Equipment:setFontSize(fontsize)
      ui.parameters.widgets.endowment.fontSize = fontsize
    elseif (windows == "help") then
      GUI.Help.Main.Console:setFontSize(fontsize)
      ui.parameters.widgets.help.fontSize = fontsize
    elseif (windows == "overland") then
      GUI.Mapper.Main.Overland:setFontSize(fontsize)
      ui.parameters.widgets.overland.fontSize = fontsize
    elseif (windows == "room") then
      GUI.Room.Main.Console:setFontSize(fontsize)
      ui.parameters.widgets.room.fontSize = fontsize
    else
      fontsize = 0
      ui.fError("Nome widget errato: Usare "..ui.fGetCommandFormattedText("All")..", "
                                            ..ui.fGetCommandFormattedText("Chat")..", "
                                            ..ui.fGetCommandFormattedText("Endowment")..", "
                                            ..ui.fGetCommandFormattedText("Help")..", "
                                            ..ui.fGetCommandFormattedText("Overland")..", "
                                            ..ui.fGetCommandFormattedText("Room")..".")
    end
    --
    if (fontsize &gt; 0) then
      if (windows == "all") then
        ui.fEcho2n("La dimensione del font di tutti i widget e' stata impostata a "..ui.fGetCommandFormattedText(fontsize)..".")
      else
        ui.fEcho2n("La dimensione del font del widget "..ui.fGetCommandFormattedText(windows).." e' stata impostata a "..ui.fGetCommandFormattedText(fontsize)..".")
      end 
      ui.fSaveFileParameters()
    end
  else
    ui.fError("La dimensione del font e' errata: Usare un valore compreso tra "..ui.fGetCommandFormattedText("1").." e "..ui.fGetCommandFormattedText("30")..".")
  end
else
  cecho(ui.fTitle("Dimensioni font"))
  cecho(ui.fGetNumberFormattedText(1)..ui.fGetCommandFormattedText(" Chat")..ui.fGetOperatorFormattedText(" = ")..ui.fGetVarValueFormattedText(ui.parameters.widgets.chat.fontSize).."\n");
  cecho(ui.fGetNumberFormattedText(2)..ui.fGetCommandFormattedText(" Endowment")..ui.fGetOperatorFormattedText(" = ")..ui.fGetVarValueFormattedText(ui.parameters.widgets.endowment.fontSize).."\n");
  cecho(ui.fGetNumberFormattedText(3)..ui.fGetCommandFormattedText(" Help")..ui.fGetOperatorFormattedText(" = ")..ui.fGetVarValueFormattedText(ui.parameters.widgets.help.fontSize).."\n");
  cecho(ui.fGetNumberFormattedText(5)..ui.fGetCommandFormattedText(" Overland")..ui.fGetOperatorFormattedText(" = ")..ui.fGetVarValueFormattedText(ui.parameters.widgets.overland.fontSize).."\n");
  cecho(ui.fGetNumberFormattedText(7)..ui.fGetCommandFormattedText(" Room")..ui.fGetOperatorFormattedText(" = ")..ui.fGetVarValueFormattedText(ui.parameters.widgets.room.fontSize).."\n\n");
  ui.fEcho2n("Usare "..ui.fGetCommandFormattedText("uisetf[ontsize] &lt;nome_finestra&gt; ")..ui.fGetVarValueFormattedText("&lt;dimensione_font&gt;"))
end</script>
				<command></command>
				<packageName></packageName>
				<regex>^(?i)(?:uif(?:o(?:n(?:t(?:s(?:i(?:z(?:e)?)?)?)?)?)?)?)(?:\s*(\w+)?|$)(?:\s*(\w+)?|$)</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>UI Go To Room</name>
				<script>local room = matches[2] or ""
--
if (room == "") then
  ui.fEcho2n("Specificare il nome o l'ID della stanza da raggiungere")   
else
  local result = searchRoom(room)
  local count = 0
  local roomId = 0
  --
  if (type(result) == 'string') then
    -- 
    -- Search for ID: Convert search from ID in search from text (validate ID)
    result = searchRoom(result, true, true)
    if (not table.is_empty(result)) then
      roomId = tonumber(room)    
    end
  else
    --
    -- Search for Name: 
    for k, v in pairs(result) do
      count = count + 1
      if (count == 1) then
        roomId = tonumber(k)
      end
    end
  end
  --
  -- Multiple results
  if (count &gt; 1) then
    ui.fShowRooms(result)
    ui.fEcho2n("Troppi risultati. Specificare il nome o l'ID di una stanza")
  --
  -- Single result
  elseif (roomId) and (roomId &gt; 0) then  
    local walkPath = {}
    local walkDirs = {}
    --
    if getPath(getPlayerRoom(), roomId) then
      walkPath, walkDirs = ui.fPrepareSpeedWalk(speedWalkPath, speedWalkDir)
      doSpeedWalk()
    else
      -- Remove last SpeedWalk 
      ui.fHighlightSpeedWalk(walkPath)
      ui.fError("Impossibile da raggiungere")
    end
  --
  -- Zero result
  else
    ui.fError("La stanza non esiste o non è stata ancora esplorata.")
  end
end</script>
				<command></command>
				<packageName></packageName>
				<regex>^(?i)(?:uig(?:o)?)(?:\s+(.*))?$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>UI Help</name>
				<script>local helpselect = string.lower(matches[2] or "")
--
if (helpselect == "") then
  ui.fHelp()
elseif (rex.match(helpselect, [[(?i)(?:uia(?:l(?:i(?:a(?:s(?:e(?:s)?)?)?)?)?)?)$]])) then
  ui.fHelp("alias")
elseif (rex.match(helpselect, [[(?i)(uib(?:u(?:t(?:t(?:o(?:n(?:s)?)?)?)?)?)?)$]])) then
  ui.fHelp("button")
elseif (rex.match(helpselect, [[(?i)(?:uic(?:o(?:l(?:o(?:r(?:s?)?)?)?)?)?)$]])) then
  ui.fHelp("color")
elseif (rex.match(helpselect, [[(?i)(?:uif(?:o(?:n(?:t(?:s(?:i(?:z(?:e)?)?)?)?)?)?)?)$]])) then
  ui.fHelp("fontsize")
elseif (rex.match(helpselect, [[(?i)(?:uihi(?:g(?:h(?:l(?:i(?:g(?:h(?:t(?:s)?)?)?)?)?)?)?)?)$]])) then
  ui.fHelp("highlight")
elseif (rex.match(helpselect, [[(?i)(?:uik(?:e(?:y(?:b(?:i(?:n(?:d)?)?)?)?)?)?)$]])) then
  ui.fHelp("keybind")
elseif (rex.match(helpselect, [[(?i)(?:t(?:a(?:r(?:g(?:e(?:t(?:s)?)?)?)?)?)?)$]])) then
  ui.fHelp("target")
elseif (rex.match(helpselect, [[(?i)(?:uip(?:r(?:o(?:f(?:i(?:l(?:(?:e)?s)?)?)?)?)?)?)$]])) then
  ui.fHelp("profile")
elseif (rex.match(helpselect, [[(?i)(?:uiv(?:a(?:r(?:i(?:a(?:b(?:l(?:e)?)?)?)?)?)?)?|]]..ui.varID..[[)$]])) then
  ui.fHelp("variable")
elseif (rex.match(helpselect, [[^\.(?:\.)?$]])) then
  ui.fHelp("walk")
elseif (rex.match(helpselect, [[(?i)(?:uiw(?:i(?:d(?:g(?:e(?:t?)?)?)?)?)?)$]])) then
  ui.fHelp("widget")
else
  ui.fHelp(helpselect)
end</script>
				<command></command>
				<packageName></packageName>
				<regex>^(?i)(?:uih(?:e(?:l(?:p)?)?)?)(?:\s+(.*))?$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>UI Info room</name>
				<script>local room = matches[2] or ""
--
if (room == "") then
  ui.fRoomInfo()
else
  local result = searchRoom(room)
  local count = 0
  local roomId = 0
  --
  if (type(result) == 'string') then
    -- 
    -- Search for ID: Convert search from ID in search from text (validate ID)
    result = searchRoom(result, true, true)
    if (not table.is_empty(result)) then
      roomId = tonumber(room)    
    end
  else
    --
    -- Search for Name: 
    for k, v in pairs(result) do
      count = count + 1
      if (count == 1) then
        roomId = tonumber(k)
      end
    end
  end
  --
  -- Multiple results
  if (count &gt; 1) then
    ui.fShowRooms(result)
    ui.fEcho2n("Troppi risultati. Specificare il nome o l'ID di una stanza")
  --
  -- Single result
  elseif (roomId) and (roomId &gt; 0) then  
    ui.fRoomInfo(roomId)
  --
  -- Zero result
  else
    ui.fError("La stanza non esiste o non è stata ancora esplorata.")
  end
end</script>
				<command></command>
				<packageName></packageName>
				<regex>^(?i)(?:uii(?:n(?:f(?:o)?)?)?)(?:\s+(.*))?$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>UI Reply</name>
				<script>if (ui.reply) then
  local msg = matches[2] or ""
  expandAlias("telep "..ui.reply.." "..msg)
end</script>
				<command></command>
				<packageName></packageName>
				<regex>^(?i)(?:uir(?:e(?:p(?:l(?:y)?)?)?)?)(?:\s+(.*))?$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>UI Highlights</name>
				<script>--
local text = string.trim(matches[2] or "")
local color = string.trim(matches[3] or "")
--
if (color ~= "") and (color ~= "remove") then
  if (text == "") and (color == "remove_all") then
    text = "remove_all"
    color = ""
  elseif (text == "") and (color ~= "") then
    text = color
    color = ""
  elseif (text ~= "") and (not ui.fColorCheck(color)) then
    text = text.." "..color
    color = ""
  end
end
-- Mostra tutti gli highlights
if (text == "") and (color == "") then
  ui.fShowAllHighlights()
-- Rimuove tutti gli highlights
elseif (text == "remove_all") then
  ui.fRemoveAllHighlights()
  ui.fEcho2n("Tutti gli highlight sono stati eliminati.")
-- Rimuove il singolo highlight
elseif (color == "remove") then
  if (ui.fRemoveHighlight(text)) then
    ui.fEcho2n("L'highlight e' stato rimosso.")
  else
    ui.fError("L'highlight '"..text.."' non esiste.")
  end
-- Mostra il singolo highlight
elseif (color == "") then
  if (ui.highlights[text]) then
    ui.fEcho2n(ui.fGetHighlightFormattedText(text))
  else
    ui.fError("L'highlight '"..text.."' non esiste.")
  end
-- Crea o modifica l'Highlight
else
  local alreadyExist = ui.highlights[text];
  local result = ui.fAddHighlight(text, color)
  if (result == -2) then
    ui.fError("L'highlight '"..text.."' non è stato creato/modificato. Il colore '"..color.."' non è valido. Usare il comando "..ui.fGetCommandFormattedText("uicolor").." per l'elenco dei colori disponibili.")
  elseif (result == -1) then
    ui.fError("L'highlight '"..text.."' non è stato creato/modificato. Specificare un testo valido.")
  elseif (result == 1) then
    if (alreadyExist) then
      ui.fEcho2n("L'highlight &lt;"..color.."&gt;"..text.."&lt;r&gt; è stato modificato.")
    else
      ui.fEcho2n("L'highlight &lt;"..color.."&gt;"..text.."&lt;r&gt; è stato creato.")
    end
  else
    ui.fError("Errore non previsto.")
  end
end
--
ui.fSaveFileHighlights()</script>
				<command></command>
				<packageName></packageName>
				<regex>^(?i)(?:uihi(?:g(?:h(?:l(?:i(?:g(?:h(?:t(?:s)?)?)?)?)?)?)?)?)(?:\s?(.*)\s?( \w+))?$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>UI Keybind</name>
				<script>local element = matches[2] or ""
local key1 = matches[3] or ""
local key2 = matches[4] or ""
local key3 = matches[5] or ""
local isValid, mod1, mod2, key, keybind = ui.fGetKeyb(key1, key2, key3)
-- Mostra tutti i keybind associati a targetselement e aliases
if (element == "") then
  ui.fShowAllKeyb()
-- Rimuove tutti i keybind associati a argets e aliases
elseif (element == "remove_all") then
  ui.fRemoveAllKeyb()
  ui.fEcho2n("Tutti i tasti rapidi sono stati rimossi.")
-- Mostra il singolo keybind
elseif (key1 == "") then
  -- Target
  if (ui.targets[element]) then
    if (ui.targets[element].keybId) then
      ui.fEcho2n(ui.fGetTargetFormattedText(element))
    else
      ui.fEcho2n("Nessun tasto rapido è assegnato al target "..ui.fGetTargetFormattedText(element)..".")
    end
  -- Alias
  elseif (ui.aliases[element]) then
    if (ui.aliases[element].keybId) then
      ui.fEcho2n(ui.fGetAliasFormattedText(element))
    else
      ui.fEcho2n("Nessun tasto rapido è assegnato all'alias "..ui.fGetAliasNameFormattedText(element)..".")
    end
  else
    ui.fError("L'alias "..ui.fGetAliasNameFormattedText(element).." non esiste.")
  end
-- Rimuove il singolo keybind
elseif key1 == "remove" then
  local result
  -- Target
  if (ui.targets[element]) then
    keybind = ui.targets[element].keybind
    result = ui.fRemoveKeyb(ui.targets[element])
    if (result == -2) then
      ui.fError("Il target non esiste.")
    elseif (result == -1) then
      ui.fEcho2n("Nessun tasto rapido assegnato al target "..ui.fGetTargetFormattedText(element).." da rimuovere.")
    elseif (result == 1) then
      ui.fEcho2n("Il tasto rapido "..ui.fGetKeybFormattedText(keybind)..", associato al target "..ui.fGetTargetFormattedText(element)..", e' stato rimosso.")
    else
      ui.fError("Errore non previsto.")
    end
  -- Alias
  elseif (ui.aliases[element]) then
    keybind = ui.aliases[element].keybind
    result = ui.fRemoveKeyb(ui.aliases[element])
    if (result == -2) then
      ui.fError("L'alias non esiste.")
    elseif (result == -1) then
      ui.fEcho2n("Nessun tasto rapido assegnato all'alias "..ui.fGetAliasNameFormattedText(element).." da rimuovere.")
    elseif (result == 1) then
      ui.fEcho2n("Il tasto rapido "..ui.fGetKeybFormattedText(keybind)..", associato all'alias "..ui.fGetAliasNameFormattedText(element)..", e' stato rimosso.")
    else
      ui.fError("Errore non previsto.")
    end
  else
    ui.fError("L'alias "..ui.fGetAliasNameFormattedText(element).." non esiste o non è associato a nessun tasto rapido.")
  end
-- Crea o modifica il keybind
else
  local result, keybind, isTarget
  if (ui.targets[element]) then
    isTarget = true
    result, keybind = ui.fSetKeyb(ui.targets, element, [[ui.fExecuteTargetButton("]]..element..[[")]], key1, key2, key3)
  else
    isTarget = false
    result, keybind = ui.fSetKeyb(ui.aliases, element, ui.aliases[element].code, key1, key2, key3)
  end
  --
  if (result == -4) then
    ui.fError("Il tasto rapido non è stato assegnato. La combinazione di tasti "..ui.fGetKeybFormattedText(keybind).." è già utilizzata in un alias.")
  elseif (result == -3) then
    ui.fError("Il tasto rapido non è stato assegnato. La combinazione di tasti "..ui.fGetKeybFormattedText(keybind).." è già utilizzata in un target.")
  elseif (result == -2) then
    ui.fError("Il tasto rapido non è stato assegnato. La combinazione di tasti "..ui.fGetKeybFormattedText(keybind).." non è valida.")
  elseif (result == -1) then
    ui.fError("Il tasto rapido non è stato assegnato. L'alias "..ui.fGetAliasNameFormattedText(element).." non esiste.")
  elseif (result == 1) and (isTarget) then
    ui.fEcho2n("Il tasto rapido è stato assegnato al target "..ui.fGetTargetFormattedText(element)..".")
  elseif (result == 1) and (not isTarget) then
    ui.fEcho2n("Il tasto rapido è stato assegnato all'alias "..ui.fGetAliasNameFormattedText(element)..".")
  elseif (result == 2) and (isTarget) then
    ui.fEcho2n("Il tasto rapido associato al target "..ui.fGetTargetFormattedText(element).." è stato rimosso.")
  elseif (result == 2) and (not isTarget) then
    ui.fEcho2n("Il tasto rapido associato all'alias "..ui.fGetAliasNameFormattedText(element).." è stato rimosso.")
  end
end
--
ui.fSaveFileAliases()
ui.fUpdateAliasButton()
--
ui.fUpdateAllTargetButton()

</script>
				<command></command>
				<packageName></packageName>
				<regex>^(?i)(?:uik(?:e(?:y(?:b(?:i(?:n(?:d)?)?)?)?)?)?)(?:\s*(\w+)?|$)(?:\s*(\w+)?|$)(?:\s*(\w+)?|$)(?:\s*(\w+)?|$)</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>UI Profiles</name>
				<script>local subCommand = matches[2] or ""
local profile = matches[3] or ""
-- Mostra tutti i profiles
if (subCommand == "") then
  ui.fShowAllProfiles()
-- Carica il Profile
elseif (subCommand == "load") then
  if (ui.fLoadProfile(profile)) then
    ui.fEcho2n("Il profilo "..ui.fGetProfileNameFormattedText(profile).." e' stato caricato.")
  else
    ui.fError("Il profilo "..ui.fGetProfileNameFormattedText(profile).." non e' stato caricato.")
  end
-- Save Profile
elseif (subCommand == "save") then
  if (ui.fSaveProfile(profile)) then
    ui.fEcho2n("Il profilo "..ui.fGetProfileNameFormattedText(profile).." e' stato salvato.")
  else
    ui.fError("Il profilo "..ui.fGetProfileNameFormattedText(profile).." non e' stato salvato.")
  end
-- Rimuove il singolo Profile
elseif (subCommand == "remove") then
  if (ui.fRemoveProfile(profile)) then
    ui.fEcho2n("Il profilo "..ui.fGetProfileNameFormattedText(profile).." e' stato rimosso.")
  else
    ui.fError("Il profilo "..ui.fGetProfileNameFormattedText(profile).." non e' stato rimosso.")
  end
-- Rimuove tutti i Profiles
elseif (subCommand == "remove_all") then
  ui.fRemoveAllProfiles()
  ui.fEcho2n("Tutti i profili sono stati rimossi.")
--
else
  ui.fError("Parametro non previsto.")
end</script>
				<command></command>
				<packageName></packageName>
				<regex>^(?i)(?:uip(?:r(?:o(?:f(?:i(?:l(?:e(?:s)?)?)?)?)?)?)?)(?:\s+(\w*)\s*(.*))?$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>UI Search Room</name>
				<script>local room = matches[2] or ""
--
if (room == "") then
  ui.fEcho2n("Specificare il nome o l'ID della stanza da cercare")   
else
  local result = searchRoom(room)
  --
  if (type(result) == 'string') then
    -- 
    -- Search for ID: Convert search from ID in search from text (validate ID)
    result = searchRoom(result, true, true)
    if (not table.is_empty(result)) then
      roomId = tonumber(room)    
    end
  end
  --
  ui.fShowRooms(result)
end</script>
				<command></command>
				<packageName></packageName>
				<regex>^(?i)(?:uis(?:e(?:a(?:r(?:c(?:h)?)?)?)?)?)(?:\s+(.*))?$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>UI Speedwalk (./..)</name>
				<script>ui.fDebug("[alias] UI Speedwalk")
--
local in_path = string.lower(matches[3] or "")
local out_path = ""
local backwards = (matches[2] == ".")
--
local function ui_fGetNextNumber(text, index)
  local number = ""
  --
  ui.fDebug("[&lt;cyan&gt;call&lt;r&gt;] ui_fGetNextNumber("..(text or "nil")..", "..(index or "nil")..")")
  --
  index = tonumber(index or 1)
  while (index&lt;=text:len()) and (string.match(string.lower(text:sub(index, index)), "[0123456789]")) do
    number = number..string.lower(text:sub(index, index))
    index = index + 1
  end
  if (number == "") then
    number = "1"
  end
  number = tonumber(number)
  --
  return number, index
end
--
if (in_path == "") then
  ui.fEcho2n("Specificare un percorso.")
else
  -- Speedwalk
  local number
  local idx = 1
  while (idx&lt;=in_path:len()) do
    number, idx = ui_fGetNextNumber(in_path, idx)
    if (idx&lt;=in_path:len()) then
      local char = string.lower(in_path:sub(idx, idx))
      for j=1, number do
        if (backwards) then
          out_path = ui.dirReverse[char]..out_path
        else
          out_path = out_path..char
        end
      end
      idx = idx + 1
    end
  end
end
--
if (backwards) then
  ui.fDebug("[alias] UI Speedwalk (Back) - in: "..in_path.." - out: "..out_path)
else
  ui.fDebug("[alias] UI Speedwalk (Forward) - in: "..in_path.." - out: "..out_path)
end
-- Execute out path
for j=1, out_path:len() do
  -- Execute Ui Direction alias
  expandAlias(out_path:sub(j, j), false); 
end</script>
				<command></command>
				<packageName></packageName>
				<regex>^\.(\.)?(?i)([nsewdu\d]+)?$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>UI Target</name>
				<script>local button_type = string.upper(matches[2])
local button_number = tonumber(matches[3])
local value = matches[4] or ""
local button = button_type..button_number
--
-- G buttons
if (button_type == "G") then
  if (button_number&lt;0) or (button_number&gt;9) then
    ui.fError(ui.fGetTargetFormattedText(button).." non valido. Usare un target compreso tra "..ui.fGetTargetFormattedText("G0").." e "..ui.fGetTargetFormattedText("G9"))
  elseif (value ~= "") then
    ui.fError(ui.fGetTargetFormattedText(button).." non è possibile assegnare o rimuovere un valore al target avversario "..ui.fGetTargetFormattedText(button))
  else
    ui.fExecuteTargetButton(button)
  end
--
-- O button
elseif (button_type == "O") then
  if (button_number~=0)  then
    ui.fError(ui.fGetTargetFormattedText(button).." non valido. Usare "..ui.fGetTargetFormattedText("T0"))
  elseif (value ~= "") then
    ui.fError(ui.fGetTargetFormattedText(button).." non è possibile assegnare o rimuovere un valore al target di gruppo "..ui.fGetTargetFormattedText(button))
  else
    ui.fExecuteTargetButton(button)
  end
--
-- T buttons
elseif (button_type == "T") then
  if (button_number&lt;1) or (button_number&gt;4) then
    ui.fError(ui.fGetTargetFormattedText(button).." non valido. Usare "..ui.fGetTargetFormattedText("T1")..", "..ui.fGetTargetFormattedText("T2")..", "..ui.fGetTargetFormattedText("T3").." oppure "..ui.fGetTargetFormattedText("T4"))
  elseif (value == "") then
    ui.fExecuteTargetButton(button)
  elseif (value == "remove") then
    if (ui.fAssignTargetButton(button, nil)) then
      ui.fUpdateAllTargetButton()
      --
      ui.fEcho2n(ui.fGetTargetFormattedText(button).." valore rimosso.")
    else
      ui.fError(ui.fGetTargetFormattedText(button).." errore durante la rimozione del valore.")
    end
  else
    if (ui.fAssignTargetButton(button, value)) then
      ui.fEcho2n(ui.fGetTargetFormattedText(button).." valore impostato "..ui.fGetVarValueFormattedText(value)..".")
    else
      ui.fUpdateAllTargetButton()
      --
      ui.fError(ui.fGetTargetFormattedText(button).." errore durante il cambio di valore.")
    end
  end
end</script>
				<command></command>
				<packageName></packageName>
				<regex>^(?i)([got])(\d)(?:\s+(.*))?$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>UI Track Room</name>
				<script>local room = matches[2] or ""
--
if (room == "") then
  ui.fEcho2n("Specificare il nome o l'ID della stanza da tracciare")   
else
  local result = searchRoom(room)
  local count = 0
  local roomId = 0
  --
  if (type(result) == 'string') then
    -- 
    -- Search for ID: Convert search from ID in search from text (validate ID)
    result = searchRoom(result, true, true)
    if (not table.is_empty(result)) then
      roomId = tonumber(room)    
    end
  else
    --
    -- Search for Name: 
    for k, v in pairs(result) do
      count = count + 1
      if (count == 1) then
        roomId = tonumber(k)
      end
    end
  end
  --
  -- Multiple results
  if (count &gt; 1) then
    ui.fShowRooms(result)
    ui.fEcho2n("Troppi risultati. Specificare il nome o l'ID di una stanza")
  --
  -- Single result
  elseif (roomId) and (roomId &gt; 0) then  
    local walkPath = {}
    local walkDirs = {}
    --
    if getPath(getPlayerRoom(), roomId) then
      walkPath, walkDirs = ui.fPrepareSpeedWalk(speedWalkPath, speedWalkDir)
      -- 
      ui.fHighlightSpeedWalk(walkPath)
      ui.fEcho2n("Un nuovo sentiero è stato tracciato")
    else
      -- Remove last SpeedWalk 
      ui.fHighlightSpeedWalk(walkPath)
      ui.fError("Impossibile da raggiungere")
    end
  --
  -- Zero result
  else
    ui.fError("La stanza non esiste o non è stata ancora esplorata.")
  end
end</script>
				<command></command>
				<packageName></packageName>
				<regex>^(?i)(?:uit(?:r(?:a(?:c(?:k)?)?)?)?)(?:\s+(.*))?$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>UI Variables</name>
				<script>local variable = matches[2]
local value = matches[3]
-- Mostra tutte le variabili
if variable == nil or variable == "" then
  ui.fShowAllVar()
-- Rimuove tutte le variabili
elseif variable == "remove_all" then
  ui.fRemoveAllVariables();
  ui.fEcho2n("Tutte le variabili sono state eliminate.")
-- Mostra la singola variabile
elseif value == nil or value == "" then
  if ui.variables[variable] then
    ui.fEcho2n(ui.fGetVarFormattedText(variable))
  else
    ui.fEcho2n("La variabile "..ui.fGetVarNameFormattedText(variable).." non esiste.")
  end
-- Rimuove la singola variabile
elseif value == "remove" then
  if not ui.variables[variable] then
    ui.fEcho2n("La variabile "..ui.fGetVarNameFormattedText(variable).." non esiste.")
  elseif table.contains(ui.fGetPreDefinitedVariables(), variable) then
    ui.variables[variable] = ""
    ui.fEcho2n("La variabile predefinita "..ui.fGetVarNameFormattedText(variable).." è stata pulita.")
  else
    ui.variables[variable] = nil
    ui.fEcho2n("La variabile "..ui.fGetVarNameFormattedText(variable).." e' stata rimossa.")
  end
-- Crea o modifica la variabile
else
  if (ui.variables[variable])then
    ui.variables[variable] = value
    ui.fEcho2n('La variabile è stata aggiornata: '..ui.fGetVarFormattedText(variable))
  else
    ui.variables[variable] = value
    ui.fEcho2n('La variabile è stata creata: '..ui.fGetVarFormattedText(variable))
  end
end
--
if (variable and variable == "target") then
  ui.fUpdateAllTargetButton()
end
--
ui.fSaveFileVariables()</script>
				<command></command>
				<packageName></packageName>
				<regex>^(?i)(?:uiv(?:a(?:r(?:i(?:a(?:b(?:l(?:e)?)?)?)?)?)?)?|&amp;)(?:\s*&amp;?(\w+)(?:\s*)?(.*))?$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>UI Widget</name>
				<script>local widgets = {
  ["affects"]       = GUI.Affects,
  ["buttons"]       = GUI.AliasButtons,
  ["chat"]          = GUI.Chat,
  ["cooldowns"]     = GUI.Cooldowns,
  ["endowment"]     = GUI.Endowment,
  ["group"]         = GUI.Group,
  ["help"]          = GUI.Help,
  ["room"]          = GUI.Room,
  ["mapper"]        = GUI.Mapper,
  ["opponent"]      = GUI.Opponent,
  ["player"]        = GUI.Player,
  ["target"]        = GUI.TargetButtons
}
local widget = string.lower(matches[2] or "")
--
if (widget == "") then
  ui.fEcho("Usare ")
  cechoLink(ui.cLink("all"), [[expandAlias("uiw all")]], "uiwidget all", true);
  for k, _ in pairs(widgets) do
    cecho(", ")
    cechoLink(ui.cLink(k), [[expandAlias("uiw ]]..k..[[")]], "uiwidget "..k, true);
  end
  cecho("\n")
--
elseif (widget == "all") then
  for _, w in pairs(widgets) do
    w:restore();
    w:show();
  end
  ui.fEcho2n("Tutti i widget sono stati ripristinati.")
--
elseif (widgets[widget]) then
  widgets[widget]:restore();
  widgets[widget]:show();
  ui.fEcho2n("Il widget "..ui.fGetCommandFormattedText(widget).." e' stato ripristinato.")
--
else
  ui.fEcho("Nome widget errato. Usare: ")
  cechoLink(ui.cLink("all"), [[expandAlias("uiw all")]], "uiwidget all", true);
  for k, _ in pairs(widgets) do
    cecho(", ")
    cechoLink(ui.cLink(k), [[expandAlias("uiw ]]..k..[[")]], "uiwidget "..k, true);
  end
  cecho("\n")  
end
</script>
				<command></command>
				<packageName></packageName>
				<regex>^(?i)(?:uiw(?:i(?:d(?:g(?:e(?:t)?)?)?)?)?)(?:\s+(.*))?$</regex>
			</Alias>
		</AliasGroup>
		<AliasGroup isActive="yes" isFolder="yes">
			<name>Directiones</name>
			<script></script>
			<command></command>
			<packageName></packageName>
			<regex></regex>
			<AliasGroup isActive="yes" isFolder="yes">
				<name>Eldorado</name>
				<script>--[[	
Eldorado: Ingressi
Eldorado e' nosummon, quindi ci si arriva solo a piedi conoscendo l'ingresso.
Mappa Eldorado
Attenzione: è pressoché completa, ma potrebbe contenere imprecisioni/inesattezze. Nel caso, segnalatele qui per piacere.
Indice
    1 Note per chi entra da solo
    2 Rooms di Eldo da cui si puo' astralare/portalare/recallare
    3 Una fitta foresta dominata da una sagoma imponente
    4 Tutto il globo, ma su niente
    5 Una piccola valle dormiente tra i monti
    6 Una imponente foresta di quercie
    7 Una spiaggetta in un bosco
    8 Una grotta che ospita presenze maligne
    9 L'ansa di un fiume tropicale
    10 Degli orti ben coltivati
    11 Una piccola radura su un altipiano
    12 Un boschetto con un gazebo
    13 Un umido tunnel dove aleggia un odore di belve
    14 Un luogo sotterraneo abitato, da strani rettili
    15 Un'enorme belva di marmo
    16 Delle potenti scariche di elettricità
    17 Draghi e cavalieri, ma sono immobili
    18 Vari simboli di morte
    19 Un animale incerto tra mangiare o bere
    20 Un intricato labirinto
    21 Un enorme smeraldo intagliato
    22 Un fiume che scorre
Note per chi entra da solo
Giungla: negli ingressi alla giungla l'ideale e' entrare e fare subito run w;run nord (si finisce in una locazione tranquilla). Occhio che vedono sneak.
Fossa belve: negli ingressi alla fossa delle belve l'ideale e' entrare di run sud;w;s;open sou;s
Laguna: negli ingressi alla laguna l'ideale e' entrare di s;w;2s;w (locazione nomob)
Miniera: l'ingresso alla miniera e' sicuro (non ci sono mob aggressivi, bisogna poi diggare a est)
Sorgente: negli ingressi alla sorgente l'ideale e' entrare di e;n;u (mob non aggressivi)
Contadini: l'ingresso dai contadini e' tranquillo, ma le contadine rubano coin
Se si e' da soli e non si conosce bene Eldorado, sempre meglio farsi venire a prendere all'ingresso (DENTRO l'area).
Rooms di Eldo da cui si puo' astralare/portalare/recallare
Presso una sorgente
La grande piazza della statua
La strada delle fiere (questa l'ho recuperata da http://it.groups.yahoo.com/group/leu/message/24095)
Una fitta foresta dominata da una sagoma imponente
Zona : Vulcano
/ Piedi /
Da ALMA CIVITAS : .s10ws9w3n10wusws2ws2wn (n Giungla)
Tutto il globo, ma su niente
Zona : Sala Giochi Karkas (I corridoi dell'infinito)
/ Portal /
Raggiungere Il centro della piazza del mercato tramite Portale su Turista (w fino a piazza) Da Il centro della piazza del mercato : .6n;open north;.7ne10ne3ne5ne7nw3n8en (d;run n Giungla)
/ Astral /
Raggiungere Il centro della piazza del mercato tramite Piano Astrale (.unwwnuw;ent spe;.s16w) Da Il centro della piazza del mercato : .6n;open north;.7ne10ne3ne5ne7nw3n8en (d;run n Giungla)
/ Piedi /
Da Tania: .dw5s;open sou;.2se3s8e;open east;.6e6n;open north;.7ne10ne3ne5ne7nw3n8en (d;run n Giungla)
Da ALMA CIVITAS : .s9e3n4es2e2d18e2n4e3s7e;open ea;.8e3s8e;open ea;.6e6n;open north;.7ne10ne3ne5ne7nw3n8en (d;run n Giungla)
oppure
Raggiungere Il centro della piazza del mercato tramite Aviani (da Alma .s7e3s, scendere alla PRIMA fermata, poi .13e fino a piazza)
Da Tania a Il centro della piazza del mercato: .dw5s;open sou;.2se3s8e;open east;.6e
Da Il centro della piazza del mercato : .6n;open north;.7ne10ne3ne5ne7nw3n8en (d;run n Giungla)
Se vi becca il troll e vi introia la path: .5ne3ne5ne7nw3n8en
Se vi becca ANCHE il cava-azzurro e vi introia la path: .3nw3n8en
Una piccola valle dormiente tra i monti
Zona : Picchi di Raven
/ Portal /
Raggiungere Il centro della piazza del mercato tramite Portale su Turista (w fino a piazza) Da Il centro della piazza del mercato : .8w2sue2sw (n Giungla)
/ Astral /
Raggiungere Il centro della piazza del mercato tramite Piano Astrale (.unwwnuw;ent spe;.s16w) Da Il centro della piazza del mercato : .8w2sue2sw (n Giungla)
/ Piedi /
Da Tania: .dw5s;open sou;.2se3s6e2sue2sw (n Giungla)
Da ALMA CIVITAS : .s9e3n4es2e2d18e2n4e3s7e;open ea;.8e3s6e2sue2sw (n Giungla)
oppure
Raggiungere Accesso ad una piccola valle tramite Aviani (da Alma .s7e3s, scendere alla PRIMA fermata, poi .5e2sue2sw)
Da Il centro della piazza del mercato : .8w2sue2sw (n Giungla)
Una imponente foresta di quercie
Zona : Foresta Rhowyn
/ Portal /
Raggiungere Il centro della piazza del mercato tramite Portale su Turista (w fino a piazza) Da Il centro della piazza del mercato : .6n;open north;.7ne10ne3ne2n (e Sorgente)
/ Astral /
Raggiungere Il centro della piazza del mercato tramite Piano Astrale (.unwwnuw;ent spe;.s16w) Da Il centro della piazza del mercato : .6n;open north;.7ne10ne3ne2n (e Sorgente)
/ Piedi /
Da Tania: .dw5s;open sou;.2se3s8e;open east;.6e6n;open north;.7ne10ne3ne2n (e Sorgente)
Da ALMA CIVITAS : .s9e3n4es2e2d18e2n4e3s7e;open ea;.8e3s8e;open ea;.6e6n;open north;.7ne10ne3ne2n (e Sorgente)
oppure
Raggiungere Il centro della piazza del mercato tramite Aviani (da Alma .s7e3s, scendere alla PRIMA fermata, poi .13e fino a piazza)
Da Tania a Il centro della piazza del mercato: .dw5s;open sou;.2se3s8e;open east;.6e
Da Il centro della piazza del mercato : .6n;open north;.7ne10ne3ne2n (e Sorgente)
Se vi becca il troll e vi introia la path: .5ne3ne2n
Una spiaggetta in un bosco
Zona : Foresta Rhowyn
/ Portal /
Raggiungere Il centro della piazza del mercato tramite Portale su Turista (w fino a piazza) Da Il centro della piazza del mercato : .6n;open north;.7ne5n3e5n (n Giungla)
/ Astral /
Raggiungere Il centro della piazza del mercato tramite Piano Astrale (.unwwnuw;ent spe;.s16w) Da Il centro della piazza del mercato : .6n;open north;.7ne5n3e5n (n Giungla)
/ Piedi /
Da Tania: .dw5s;open sou;.2se3s8e;open east;.6e6n;open north;.7ne5n3e5n (n Giungla)
Da ALMA CIVITAS : .s9e3n4es2e2d18e2n4e3s7e;open ea;.8e3s8e;open ea;.6e6n;open north;.7ne5n3e5n (n Giungla)
oppure
Raggiungere Il centro della piazza del mercato tramite Aviani (da Alma .s7e3s, scendere alla PRIMA fermata, poi .13e fino a piazza)
Da Tania a Il centro della piazza del mercato: .dw5s;open sou;.2se3s8e;open east;.6e
Da Il centro della piazza del mercato : .6n;open north;.7ne5n3e5n (n Giungla)
Se vi becca il troll e vi introia la path: .3e5n
Una grotta che ospita presenze maligne
Zona : Moria
/ Astral /
Raggiungere La caverna dorata tramite Piano Astrale (.unwws;ent spe) Da La caverna dorata : .2e4sen2w (w Necropoli)
/ Piedi /
Raggiungere La caverna dorata da ALMA CIVITAS : .8s2e2s2ws2es2w3swsws2en3e2n2e2n3n2wn3wden Da La caverna dorata : .2e4sen2w (w Necropoli)
L'ansa di un fiume tropicale
Zona : Aborigeni (Roo)
/ Astral /
Raggiungere La cima di una grande collina tramite Piano Astrale (.unwwnuwuw;ent spe) Da La cima di una grande collina : .n4w5se (s Laguna)
/ Piedi /
Da Tania: .dw5s;open sou;.2se3s8e;open east;.6e6s;ope sou;.sd2sw5se (s Laguna)
Da ALMA CIVITAS : .s9e3n4es2e2d18e2n4e3s7e;open ea;.8e3s8e;open ea;.6e6s;ope sou;.sd2sw5se (s Laguna)
oppure
Raggiungere Il centro della piazza del mercato tramite Aviani (da Alma .s7e3s, scendere alla PRIMA fermata, poi .13e fino a piazza)
Da Tania a Il centro della piazza del mercato: .dw5s;open sou;.2se3s8e;open east;.6e
Da Il centro della piazza del mercato : .6s;ope sou;.sd2sw5se (s Laguna)
Degli orti ben coltivati
Zona : Aborigeni (Roo)
/ Astral /
Raggiungere La cima di una grande collina tramite Piano Astrale (.unwwnuwuw;ent spe)
Da La cima di una grande collina : .n4w5s2wsw (s Contadini)
/ Piedi /
Da Tania: .dw5s;open sou;.2se3s8e;open east;.6e6s;open sou;.sd2sw5s2wsw (s Contadini)
Da ALMA CIVITAS : .s9e3n4es2e2d18e2n4e3s7e;open ea;.8e3s8e;open ea;.6e6s;open sou;.sd2sw5s2wsw (s Contadini)
oppure
Raggiungere Il centro della piazza del mercato tramite Aviani (da Alma .s7e3s, scendere alla PRIMA fermata, poi .13e fino a piazza)
Da Tania a Il centro della piazza del mercato: .dw5s;open sou;.2se3s8e;open east;.6e
Da Il centro della piazza del mercato : .6s;open sou;.sd2sw5s2wsw (s Contadini)
Una piccola radura su un altipiano
Zona : Altopiano dannati
/ Piedi /
Da Alma Civitas ad Alpes Oppidum: .10ne3nw5nw3nw; (solo se chiuso verso north: lift grata) .4n oppure
Raggiungere Alpes Oppidum tramite Aviani (da Alma .s7e2se e scendere alla PRIMA fermata, poi n)
Da Alpes Oppidum a Una stradina nel sottobosco: .w2nesu2nueuen2w3nw3ue (s Sorgente)
(attenzione perche' la path contiene delle private con dentro Alkiria e/o scorpione)
Un boschetto con un gazebo
Zona : Lycantropia
/ Portal /
Raggiungere Un boschetto tramite portal su Giovane Conte Boarish (giova-boarish) (w Radura)
/ Astral /
Raggiungere La Taverna dell'Umano Squartato tramite Piano Astrale (.unwwnuwun;ent spe) Da La Taverna dell'Umano Squartato : .s2en2es3e3nw3s (w Radura)
/ Piedi /
Da ALMA CIVITAS : .s10ws9w3n4w3s3ws3ese3s (L' ingresso di Lycantropia) .s2es3e3nw3s (w Radura)
oppure
Raggiungere Piazza Trionfo tramite Aviani (da Alma .s7e2sw e scendere alla PRIMA fermata) Da Piazza Trionfo : .es4wnw5s2es3e3nw3s (w Radura)
Un umido tunnel dove aleggia un odore di belve
Zona : Anfiteatro
/ Portal /
Raggiungere Ingresso all'Anfiteatro tramite Portale su Flaminio Da Ingresso all'Anfiteatro : .8nd3e4s (s Fossa Belve)
/ Piedi /
Da ALMA CIVITAS : .s9e12nd3e4s (s Fossa Belve)
Un luogo sotterraneo abitato, da strani rettili
Zona : Foresta di Alma
/ Portal /
Portale su Anaconda, ent port;n;cut liana;d (n Miniera)
/ Piedi /
Da ALMA CIVITAS : .s9en2e3s7en;cut liana;d (n Miniera)
Un'enorme belva di marmo
Zona : Colosseo
/ Astral /
Dal bordo del vuoto astrale allo specchio cangiante .unw;ent spe poi .2d3edne (east Fossa Belve)
/ Portal /
Portal su "golem-armatura" (exa portal dovrebbe dirvi: L'antro dei Golem), sperando che nessuno abbia avuto bisogno impellente di riallineare/praccare coi rescue, poi .dne
/ Piedi /
Da Alma Civitas .2s4w; kill tarquinio; .wn2edne (east Fossa Belve)
Delle potenti scariche di elettricità
Zona : Pennina
/ Portal /
Raggiungere Ingresso all'Anfiteatro tramite Portale su Flaminio
Da Ingresso all'Anfiteatro : .s4es2e2de2u2nuse2nwu (La fortezza!) .nwnw3n (solo se chiuso verso west: pull torcia) .wde2s2e (solo se chiuso verso est: push masso) .e2s2e4n (w Drago Blu)(.2w Radura)
/ Piedi /
Da ALMA CIVITAS : .s9e3n4es2e2de2u2nuse2nwu (La fortezza!) .nwnw3n (solo se chiuso verso west: pull torcia) .wde2s2e (solo se chiuso verso est: push masso) .e2s2e4n (w Drago Blu)(.2w Radura)
Draghi e cavalieri, ma sono immobili
Zona : Vingaard
/ Portal /
Raggiungere Frank tramite Portale su Frank .2e (run s Miniera)
/ Astral /
Raggiungere Il centro della piazza del mercato tramite Piano Astrale (.unwwnuw;ent spe;.s16w)
Da Il centro della piazza del mercato : .6n;open north;.7ne10ne3ne5ne7n3w (run s Miniera)
/ Piedi /
Da Tania: .dw5s;open sou;.2se3s8e;open east;.6e6n;open north;.7ne10ne3ne5ne7n3w (run s Miniera)
Da ALMA CIVITAS : .s9e3n4es2e2d18e2n4e3s7e;open ea;.8e3s8e;open ea;.6e6n;open north;.7ne10ne3ne5ne7n3w (run s Miniera)
oppure
Raggiungere Il centro della piazza del mercato tramite Aviani (da Alma .s7e3s, scendere alla PRIMA fermata, poi .13e fino a piazza)
Da Tania a Il centro della piazza del mercato: .dw5s;open sou;.2se3s8e;open east;.6e
Da Il centro della piazza del mercato : .6n;open north;.7ne10ne3ne5ne7n3w (run s Miniera)
Se vi becca il troll e vi introia la path: .5ne3ne5ne7n3w
Se vi becca ANCHE il cava-azzurro e vi introia la path: .3n3w
Vari simboli di morte
Zona : Villaggio Lorgae (Nahaz)
/ Portal /
Raggiungere La piazza principale tramite portale per Albergatore Gitano e poi .w5s;open sou;.2s6w;open wes;.2w oppure portal su Urgord e poi .ds
Da La piazza principale: knock/pick south poi open south;.2s;kill nahaz;get chia naha;unlock botola;lift botola;.d (d Necropoli)
/ Astral /
Raggiungere Il centro della piazza del mercato tramite Piano Astrale (.unwwnuw;ent spe;.s16w)
Da Il centro della piazza del mercato a La piazza principale: .5w;open wes;.9w3n7w;open wes;.2w
Da La piazza principale: knock/pick south poi open south;.2s;kill nahaz;get chia naha;unlock botola;lift botola;.d (d Necropoli)
/ Piedi /
Da Tania a La piazza principale: .dw5s;open sou;.2s6w;open wes;.2w
Da ALMA CIVITAS a La piazza principale: .s9e3n4es2e2d18e2n4e3s6e
oppure
Raggiungere La piazza principale tramite Aviani (da Alma .s7e3s, scendere alla PRIMA fermata, poi .w3n7w;ope wes;.2w)
Da La piazza principale: knock/pick south poi open south;.2s;kill nahaz;get chia naha;unlock botola;lift botola;.d (d Necropoli)
Un animale incerto tra mangiare o bere
Zona : Elminster (Archimedes)
/ Portal /
Raggiungere Mini torre di Elminster tramite Portale su Archimedes, il gufo di Elminster.
Se Elminster e' no init, raggiungere Il centro della piazza del mercato tramite Portale su Turista (w fino a piazza)
Da Il centro della piazza del mercato ad Archimedes : .6n;open north;.7ne10ne3ne5ne7nw3nw2nene (e Fossa Belve)
/ Astral /
Raggiungere Il centro della piazza del mercato tramite Piano Astrale (.unwwnuw;ent spe;.s16w)
Da Il centro della piazza del mercato ad Archimedes : .6n;open north;.7ne10ne3ne5ne7nw3nw2nene (e Fossa Belve)
/ Piedi /
Da Tania: .dw5s;open sou;.2se3s8e;open east;.6e6n;open north;.7ne10ne3ne5ne7nw3nw2nene (e Fossa Belve)
Da ALMA CIVITAS : .s9e3n4es2e2d18e2n4e3s7e;open ea;.8e3s8e;open ea;.6e6n;open north;.7ne10ne3ne5ne7nw3nw2nene (e Fossa Belve)
oppure
Raggiungere Il centro della piazza del mercato tramite Aviani (da Alma .s7e3s, scendere alla PRIMA fermata, poi .13e fino a piazza)
Da Tania a Il centro della piazza del mercato: .dw5s;open sou;.2se3s8e;open east;.6e
Da Il centro della piazza del mercato ad Archimedes : .6n;open north;.7ne10ne3ne5ne7nw3nw2nene (e Fossa Belve)
Se vi becca il troll e vi introia la path: .5ne3ne5ne7nw3nw2nene
Se vi becca ANCHE il cava-azzurro e vi introia la path: .3nw3nw2nene
Un intricato labirinto
Zona : Hoeur
/ Piedi /
Da Alma Civitas a Spaventapasseri: .s10ws9w3n9w6s8w5s3ws
Da Spaventapasseri: .n3e5n4e2s3w4sd
/ Portal /
Portalare Spaventapasseri (se Hoeur non c'e') poi .n3e5n4e2s3w4sd.
.d ci sono 2 guerrieri elfi sancati con chiave elfica, che apre ad est (fanno blunt ma si prendono di tutto e sono moscilli) unlo east;open east;
I mob successivi si possono skippare se si fa rapidamente questo appena presa la chiave: unlo east;open east;e;open east;e;open east;.e4d3e
Qui si spiega comunque cosa c'e' e cosa fanno.
Al primo east ci sono 4 o 5 drow guerrieri, un po' piu' tosti dei primi 2 (fanno blunt ma si prendono di acid/slash/pierce/blunt) open east;e;open east; ad east ci sono 14 minotauri hide (fanno slash, ma sono moscilli e sono solo resi fire elec) .4d3e e sei oltre il Hoeur! .2d (n Miniere)
Portalare Hoeur ed entrare con stringa (ent port;e) .2d (n Miniere)
Attenzione: il .2d finale porta in silence e non si puo' piu' tornare indietro! (per prudenza, prendete prima le pozioni argentee dai cadaveri dei drow guerrieri, fanno astral!)
Un enorme smeraldo intagliato
Zona : Torre Magia
Se non l'hanno già fatta prima, bisogna fare la quest per arrivare dalla Signora della Magia.
Se la questina di cui sopra è gia' stata fatta e non è ancora ripoppata, allora....
/ Astral /
Andare alla pool per Torre Magia (.unwn;ent spe), poi andare .3s2u5n e siete a La sala delle Udienze, dove c'è la Signora della magia, da qui (d;run n giungla)
/ Piedi /
Fate prima a farvi dare uno strappo in astral, comunque le path pedonali sono nella pagina della quest di cui sopra :)
Un fiume che scorre
Puo' essere una di queste entrate:
    Il Fiume El'Azahred:
        / Astral / .unwwnuw;ent spe;.s16w5s7e (s giungla .uw;run n per non crepare come un jamal nella giungla)
        / Piedi /
        Da Tania:.dw5s;open sou;.2se3s8e;open east;.6e5s7e (s giungla .uw;run n)
        Da Il centro della piazza del mercato .5s7e (s giungla .uw;run n)
    Fiume Lys
        / Portal / Portal su Skipper, poi .s6w (d sorgente)
        / Piedi / Da Alma Civitas .4se2s6w (d sorgente)
    Fiume Oscuro
        / Portal / Portal su Skipper, poi .se;ope grata;.7en4e (n giungla .uw;run n)
        / Piedi /
        Da Alma Civitas .4se2se;ope grata;.7en4e (n giungla .uw;run n)
        Da Tania: .dw5s;open sou;.2se3s8e;open east;.22en5en2de;kill cerbero (noscrap);get chia cada;unlo ea;open ea;.e2n2w2e (n giungla .uw;run n)
        Da Il centro della piazza del mercato: .16en5en2de;kill cerbero (noscrap);get chia cada;unlo ea;open ea;.e2n2w2e (n giungla .uw;run n)
        / Astral / .unwwnuw;ent spe;.4e fino a ciliegio, poi .2en2de;kill cerbero (noscrap);get chia cada;unlo ea;open ea;.e2n2w2e (n giungla .uw;run n)
    Fiume Ara-Raven
        / Piedi /
        Da Tania:.dw5s;open sou;.2se3s8e;open east;.6e5s14w2n (d giungla .uw;run n)
        Da Il centro della piazza del mercato:.5s14w2n (d giungla .uw;run n)
        / Astral / .unwwnuw;ent spe;.s16w5s14w2n (d giungla .uw;run n)
]]</script>
				<command></command>
				<packageName></packageName>
				<regex></regex>
				<Alias isActive="yes" isFolder="no">
					<name>Eldorado</name>
					<script>local path = {
  "dw assassino-gitano",
  ".enw;ask chiromante eldorado",
}
ui.fExecutePath(path, matches[2])</script>
					<command></command>
					<packageName></packageName>
					<regex>^(?i)eldorado(?:\s+(.*))?$</regex>
				</Alias>
			</AliasGroup>
			<AliasGroup isActive="yes" isFolder="yes">
				<name>Scatole</name>
				<script>--[[
Si prega tutti di contribuire fornendo nome mob, dir e caratteristiche. Insomma qualunque cosa possa essere utile a prenderle prima degli altri.
Inserite anche quelli nuovi che non conoscete, l'importante e' ampliare la lista, magari altri sanno dove sta...
= Elenco =
== una scatola nera laccata dentro un altare ==
'''PATH''': altare nella quest BoscoVerde .... Uccidere GUT , gettare chiave , andare nella stanza ANTICA CAPPELLA e aprire l'altare
== una scatola nera laccata trasportata da Alu-Fiend ==
'''PATH''': Si trova dentro la Torre della zona del Portale dove si editava Epico .. si uccide prima Molybienus , si getta chiave nera e si apre la Torre ... il mob si trova a nord ovest mi pare nella Room chiamata Sala-Dolore
== una scatola nera laccata trasportata da Amon ==
'''PATH''': Miniquest di Amon
== una scatola nera laccata dentro un antico forziere ==
'''PATH''': quest Ecate
== una scatola nera laccata trasportata da Ashark, lo sciamano ==
'''PATH''': da Platea Quadrata 9e3n4es2e2de2unue2nwun;e2ne3n2e; knock north;n (Bee, re dei giganti); turn dipinto; sta a west
== una scatola nera laccata trasportata da Ashura, il dio della Guerra ==
'''PATH''': Boss finale quest Regni
== una scatola nera laccata trasportata da Aslam l'evocatore ==
'''PATH''': mob intermedio della quest Tarrasque
== una scatola nera laccata trasportata da Asmodeo, Signore degli Incendiari ==
'''PATH''': mob della quest Oltre il Portale
== una scatola nera laccata trasportata da Avatar del Guardiano ==
'''PATH''': Boss finale quest Sottomondo di Zodak
== una scatola nera laccata trasportata da l'Avatar di Amharb. ==
'''PATH''': Boss finale quest Tempio dei Dannati
== una scatola nera laccata trasportata da Balrog ==
'''PATH''': Mob finale della nuova moria - dalla pool di moria (unwws) si segano gli orchi, uno ha la chiave di mithril che apre il portale dove sta l'orco nero. Si scende di sotto e si dà di stringa (se non si vuole fare xp) run n;sd2s e ci si ritrova una room prima del cimitero dove girano una quarantina di nani evanescenti. Uno ha la chiave arrugginita che apre verso il balrog. All'estremo sud c'e' il capo fantasma che è caster ma si dispa e muore bene. Poi 2s il Balrog: Mu over 50
== una scatola nera laccata dentro una bara d'ebano ==
'''PATH''': Raven , room del primo Stradh
== una scatola nera laccata trasportata da un Bar-Igura ==
'''PATH''': mob della quest Oltre il Portale
== una scatola nera laccata trasportata da una Banshee urlante ==
'''PATH''': mob della quest Sithicus
== una scatola nera laccata dentro un baule intarsiato d'argento ==
'''PATH''': Camera di Kelepho (ucciderlo e gettare chiavi per aprirlo) a Villa Kelepho
== una scatola nera laccata trasportata da Belak ==
'''PATH''': Penultimo Boss quest Cittadella
== una scatola nera laccata trasportata da Belial ==
'''PATH''' : Portalare ENN poi UP - NORD - WEST - NORD
== una scatola nera laccata trasportata da Biakko, il generale dell'esercito bianco ==
'''PATH''': campi di battaglia sotto quest Regni
== una scatola nera laccata trasportata da Il Bianco Sire ==
'''PATH''': Boss finale della quest Monte Celestia
== una scatola nera laccata trasportata da il Boia Infernale ==
'''PATH''': Mob che si trova dentro la zona di Ade
== una scatola nera laccata in Un buco pieno di melma fetida ==
'''PATH''': ???
== una scatola nera laccata trasportata da Calcryx ==
'''PATH''': Boss intermedio quest Cittadella
== una scatola nera laccata dentro le Carie ==
'''PATH''': Situata nella Room Bocca del Drago di Ancadalor , una delle prime Room 
== una scatola nera laccata trasportata da Il Cavaliere della forza ==
'''PATH''': (aka '''Darth Vader''') (ex '''ET''') - mob finale della quest Villa delle feste
== una scatola nera laccata trasportata da Cavaliere Della Morte ==
'''PATH''': dalla pool blu mezzanotte (fiume delle anime perdute, unww) 3e2sesed - aspettare teleport - d;pull naso;d;open ecorc;ds - castarsi wb o swimmare e aspettare doppia teleport, finché non esce un'uscita down - d4swdn2wdwddwnwun
== una scatola nera laccata trasportata da Un grosso cavernicolo ==
'''PATH''': mob intermedio della quest El Quebbar
== una scatola nera laccata trasportata da un chipmunk dai denti a sciabola ==
'''PATH''': mob della quest Giardini Infiniti
== una scatola nera laccata trasportata da Il Cuore di Ashardalon == 
'''PATH''': mob finale della quest Torre Notturna
== una scatola nera laccata trasportata da Dama morte ==
'''PATH''': boss finale Cattedrale
== una scatola nera laccata trasportata da Demogorgo ==
'''PATH''': da Efesto (room La Fucina degli Dei) knock south;s;turn vendetta;d
== una scatola nera laccata trasportata da Il demone del dolore ==
'''PATH''': alla Cittadella delle Nuvole (si sale la catena al centro del parco di Alma)
== una scatola nera laccata trasportata da un demone d'oro ==
'''PATH''': quest Ecate
== una scatola nera laccata trasportata dalla Devozione ==
'''PATH''': mob di Celestia del sesto girone
== una scatola nera laccata trasportata da l'incarnazione del Dio della Guerra ==
'''PATH''': mob di Eldorado Mappa Eldorado Ingressi Eldo
== una scatola nera laccata trasportata da DoomHammer ==
'''PATH''': Fortezza Pennina , nella camera degli ospiti
== una scatola nera laccata trasportata da Drago d'Acciaio ==
'''PATH''': da inserire... (è dalle parti della caverna SirGris&amp;gigante) - E' portalabile comunque
== una scatola nera laccata trasportata da Drago Astrale ==
'''PATH''': mob corsa quest Tarrasque
== una scatola nera laccata trasportata da Un Vecchio Drago Blu ==
'''PATH''': Il drago elettrico della fortezza pennina - da Platea Quadrata 9e3n4es2e2de2unue2nwunwnw3n;pull torcia;wde2s2e;push masso;2e - aspettare teleport - nw
== una scatola nera laccata trasportata da il Drago Nero ==
'''PATH''': da inserire
== una scatola nera laccata trasportata da il Drago di Ottone ==
'''PATH''': Drago policromatico quest Drow
== una scatola nera laccata trasportata da Il Drow Lich ==
'''PATH''': dalla pool blu mezzanotte (fiume delle anime perdute, unww) 3e2sesed - aspettare teleport - d;pull naso;d;open ecorc;ds - castarsi wb o swimmare e aspettare doppia teleport, finché non esce un'uscita down - d4s2ws si arriva a Un isolotto - dig tomba - d - segare spettro immu fisici - knock south oppure chiave-antica dello spettro - s (è immu cold, resi magici)
== una scatola nera laccata trasportata da Dugan il capofabbro ==
'''PATH''': mob della quest BoscoVerde
== una scatola nera laccata trasportata da Efesto ==
'''PATH''': Pool Grecia (.unwwnwu), .ws2w7nuneueuwu2e3de; push muro; ad east c'e' spia (hide) che ha punteruolo.
Con la chiave: west;down;unlock lastrone;lift lastrone;.2ed
== una scatola nera laccata trasportata da Elminster ==
'''PATH''': miniquest "Elminster". Si prende la chiave d'ombra da una delle 4 ombre guardiane hide tra la foresta di Rhowyn e Vingaard e poi si va da Elmi dove è sempre stato 
== una scatola nera laccata dentro un enorme forziere nero ==
'''PATH''': forziere finale quest Rhyodin
== una scatola nera laccata trasportata da Epheros l'angelo in disgrazia ==
'''PATH''': mob intermedio quest Tarrasque
== una scatola nera laccata dentro un espositore di vetro ==
'''PATH''': Villa di Kelepho
== una scatola nera laccata trasportata da Ethergaunt bianco ==
'''PATH''': Boss finale quest Dimora degli Incubi
== una scatola nera laccata trasportata da Eucropio ==
'''PATH''': mob finale quest Ancalador
== una scatola nera laccata trasportata da la Fede Cieca ==
'''PATH''': mob di Celestia del sesto girone
== una scatola nera laccata dentro una fonte mistica ==
'''PATH''': premio finale della quest Giardini Infiniti
== una scatola nera laccata dentro un forziere dei Premi ==
'''PATH''': Forziere finale della quest Polipo
== una scatola nera laccata dentro un forziere di legno ==
'''PATH''': forziere che si trova dentro la cassaforte nella dimora di Redferne ( chiave ce l'hanno Redferne e Naonyel )
== una scatola nera laccata dentro un forziere di ottone ==
'''PATH''': forziere sotto Aziz mob intermedio della quest Tarrasque
== una scatola nera laccata dentro il forziere del tempo ==
'''PATH''': forziere finale quest Vate del Caos
== una scatola nera laccata trasportata da Frosty ==
'''PATH''': dalla piazza di Talonia: 6n;open porta n;7ne10ne3ne5ne7nw3n6e5n2
== una scatola nera laccata trasportata da la Guardiana del Magazzino ==
'''PATH''': quest Ennaheg
== una scatola nera laccata trasportata da Genbu, il generale dell'esercito nero ==
'''PATH''': campi di battaglia sotto quest Regni
== una scatola nera laccata trasportata da Sir Ghalad ==
'''PATH''': Si trova ad Abyss. A west della seconda coppia di guerrieri nel corridoio a L (key pulsante). Ghalad sta 2wn in una cella (key macerie, da scavare). Attenzione che decapita senza pietà al primo bash cannato.
== una scatola nera laccata trasportata da Gog il Milleanime ==
'''PATH''': Si trova a Rhyodin. Dalla sala stravagante prendere chiave nello scrittoio. Quindi west e aprire a sud. Secret down key "anima" dopo teleport aprire a nord e li si trova Gog. E' un wa che menicchia e prende fireshield. In 2 si fa abbastanza agile
== una scatola nera laccata trasportata da Grenl ==
'''PATH''': mob della quest Cittadella
== una scatola nera laccata trasportata da Gritz la strega ==
'''PATH''': mob nella stessa room di Heli alla quest Ravenloft
== una scatola nera laccata trasportata da il Guardiano delle Armature ==
'''PATH''': Mob dentro Ennaheg
== una scatola nera laccata trasportata da il Guardiano delle Armi ==
'''PATH''': Mob dentro Ennaheg
== una scatola nera laccata trasportata da Gulthias ==
'''PATH''': Boss finale quest Cittadella
== una scatola nera laccata trasportata da Gut'la Has il Re dei Tiefling ==
'''PATH''': mob intermedio quest BoscoVerde
== una scatola nera laccata trasportata da Heli la fatucchiera ==
'''PATH''': mob intermedio quest Raven
== una scatola nera laccata trasportata da Hoeur ==
'''PATH''': a piedi: da Alma Civitas a spaventapasseri: .s10ws9w3n9w6s8w5s3ws poi da spaventapasseri: .n3e5n4e2s3w4sd
'''PATH''': con portal: portalare spaventapasseri (se Hoeur non c'e') poi .n3e5n4e2s3w4sd. 
== una scatola nera laccata trasportata da l'Incarnazione della Malvagita' (Stremadil) ==
'''PATH''': mob intermedio della quest El Quebbar
== una scatola nera laccata trasportata da Infirana ==
'''PATH''': Boss finale omonima Quest
== una scatola nera laccata trasportata da Inverno == 
'''PATH''': dalla piazza di Talonia: 6n;open porta n;7ne10ne3ne5ne7nw3n6e5nw
== una scatola nera laccata trasportata da Jeenyas ==
'''PATH''': mob della quest Sottomondo di Zodak
== una scatola nera laccata trasportata da Kalas ==
'''PATH''': mob intermedio della quest Abyss
== una scatola nera laccata trasportata da Kirin, il generale dell'esercito dei mercenari ==
'''PATH''': campi di battaglia sotto quest Regni
== una scatola nera laccata trasportata da La locusta regina ==
'''PATH''': boss finale della quest Locuste
== una scatola nera laccata trasportata da Magma ==
'''PATH''': dalla pool per Plutarco...
== una scatola nera laccata trasportata da La matrice abissale ==
'''PATH''': dalla pool per Plutarco est, nord ... si aspetta teleport, si killa. è wa sega e prende iceshield.
== una scatola nera laccata trasportata da Maya ==
'''PATH''': mob intermedio di El Quebbar
== una scatola nera laccata trasportata da Malinda ==
'''PATH''': mob intermedio di Ancadalor
== una scatola nera laccata trasportata da Melibis il fondatore della setta ==
'''PATH''': uno dei due mob finali della quest Polipo
== una scatola nera laccata trasportata da Milbolas, il primo console di Mordilnia ==
'''PATH''': mob intermedio della quest Polipo
== una scatola nera laccata trasportata da Mordenkainen il Negromante == 
'''PATH''': dalla pool oro (torre della magia, unwn) 2n2ed3s;open east;e2n sta con altri mob pippa, l'importante e' basharlo per non beccarsi un inutile disint ...
== una scatola nera laccata trasportata da Nadir ==
'''PATH''': mob della quest Sottomondo di Zodak
== una scatola nera laccata trasportata da NERO ==
'''PATH''': sotto il tribunale, mob intermedio della quest Polipo
== una scatola nera laccata trasportata da Nelle cantine ==
'''PATH''': DA SCOPRIRE 
== una scatola nera laccata trasportata da Nug ==
'''PATH''': si trova nella room La tana del Capro Nero che si trova nel Boschetto accanto l'ingresso di Dunwich verso est
== una scatola nera laccata trasportata da Nyarlathotep ==
'''PATH''': Boss finale quest Dunwich
== una scatola nera laccata trasportata da Osborne l'oste ==
'''PATH''': mob della quest Dunwich
== una scatola nera laccata trasportata da Paz'Rael il Signore dei Vrock == 
'''PATH''': penultimo mob della quest Oltre il Portale
== una scatola nera laccata trasportata da Periast il fondatore della setta ==
'''PATH''': uno dei due mob finali della quest Polipo
== una scatola nera laccata trasportata da Un Phaerimm == 
'''PATH''': mob della quest BoscoVerde
== una scatola nera laccata trasportata da Poseidone ==
'''PATH''': da pool verde smeraldo (Grecia, unwwnuw) nnwnn - swim o wb - ddenensue
== una scatola nera laccata trasportata da Il Primo Albero ==
'''PATH''': Da Alma Civitas: .8s2e2s2ws2es2w3se
== una scatola nera laccata trasportata da Il Primo Mandragora ==
'''PATH''': (a piedi) da Alma Civitas 10ne3nw5nw3nw;lift grata;4n (Alpes Oppidum) w2nesu2nue (da qui attenti alle private) d2es2en;turn girevole;2nwn2d2ndn2enen;open tela (qui veloci per non farsi beccare da Pietro il Ragno che paralizza d'arma) n;open libricino;d - aspettare teleport lunga - turn pagina;e;open diamante;e;bash spettro (se non ricordo male la key esatta è spettro, ma è da controllare ... comunque è spettro o spirito)
'''PATH''': (via astral) pool marrone (Drow, unwwn) _chilosaloscrive_
== una scatola nera laccata dentro il pungiglione dello scorpione gigante ==
'''PATH''': ???
== una scatola nera laccata trasportata da Pursan il possente ==
'''PATH''': mob intermedio della quest Dimora degli Incubi
== una scatola nera laccata trasportata da Quivalen Sath ==
'''PATH''': dal Alma Civitas .8s2e2s2enwn
== una scatola nera laccata trasportata da Rampicante vampiro ==
'''PATH''': mob intermedio della quest Giardini infiniti
== una scatola nera laccata trasportata da il Re ==
'''PATH''': Mob della Sala del trono di una delle 4 torri di Regni
== una scatola nera laccata trasportata da il Re Fantasma ==
'''PATH''': Boss finale di Rhyodin
== una scatola nera laccata trasportata da la Regina ==
'''PATH''': Mob della sala del trono di una delle 4 torri di Regni
== una scatola nera laccata trasportata da la Regina bianca ==
'''PATH''': Dal secondo piamo della libreria push pulsante, west, ent portale, ope parete, we, ent shadowdale, do, ent scacchiera. Da li muoversi tutto sud e la si trova tra il Re ed il Vescovo. Scacchiera
== una scatola nera laccata trasportata da la Regina nera ==
'''PATH''': Dal secondo piamo della libreria push pulsante, west, ent portale, ope parete, we, ent shadowdale, do, ent scacchiera. Da li muoversi tutto nord e la si trova tra il Re ed il Vescovo. Scacchiera
== una scatola nera laccata trasportata da Remiel l'Arcilich ==
'''PATH''': mob intermedio quest Infirana
== una scatola laccata dentro il ricordo del Paladino che fu
'''PATCH''': Room Finale quest LORD SOTH ---&gt; Turn scheggia -- Down
== una scatola nera laccata trasportata da Il leggendario Roc == 
'''PATH''': da Alma Civitas 10ne3nw5nw3nw;lift grata;4n (Alpes Oppidum) w2nesu2nued2es2e3se; pick south;s; pull arazzo;s;lift scala;u;dig spazzatura;nu4ndnn; lo troviamo a west ... va bashato fisso in quanto ha procedura speciale
== una scatola nera laccata trasportata da Sacrifice, la regina squalo ==
'''PATH''': mob intermedio della quest Dimora degli Incubi
== una scatola nera laccata trasportata da Santo del Fiume ==
'''PATH''': Chi lo sa lo posti ...
== una scatola nera laccata dentro un sarcofago d'oro ==
'''PATH''': Sarcofago di Abyss , accanto room di Arawn e Abisso
== una scatola nera laccata dentro un sarcofago nero ==
'''PATH''': Nella tomba nascosta del Generale a Rhyodin
== una scatola nera laccata trasportata da Scaglia Notturna == 
'''PATH''': mob finale (finto drago) della quest Khundrukar
== una scatola nera laccata trasportata da Sciamano Aborigeno ==
'''PATH''': dalla pool verde scuro (Roo, unwwnuwuw) run w; run s; 2w5s2wse
oppure dalla piazza di Talonia run s; d; sss; wsswwsssssssswwsee
== una scatola nera laccata dentro uno scrigno antico ==
'''PATH''': quest BoscoVerde (ha anche i cofanetti smeraldi, rubini e zaffiri)
== una scatola nera laccata trasportata da Seiryu, il generale dell'esercito azzurro ==
'''PATH''': campi di battaglia sotto quest Regni
'''Trovati''': per ora nessuno
== una scatola nera laccata trasportata da Siemel ==
'''PATH''': mob intermedio della quest El Quebbar
'''Trovati''': per ora nessuno
== una scatola nera laccata trasportata da Signora della Magia ==
'''PATH''': mob finale di Torre Magia
'''Trovati''': per ora nessuno
== una scatola nera laccata trasportata da Sin ==
'''PATH''': mob intermedio della quest Dimora degli Incubi
'''Trovati''': per ora nessuno
== una scatola nera laccata trasportata da Sommo Chierico ==
'''PATH''': mob di Vingaard
'''Trovati''': un lingotto d''''acciaio'''
== una scatola nera laccata trasportata da Lord Soth ==
'''PATH''': mob finale quest Lord Soth
'''Trovati''': per ora nessuno
== una scatola nera laccata trasportata da Lo Spirito di Huma ==
'''PATH''':  mob di Vingaard
'''Trovati''': un lingotto d''''argento'''
== una scatola nera laccata trasportata da La Statua di Benem == 
'''PATH''': Museo dei patroni a Talonia
'''Trovati''': un lingotto di '''ottone'''
== una scatola nera laccata trasportata da La statua di Limean ==
'''PATH''': da Piazza dell'Occhio ad Allania west sud
'''Trovati''': un lingotto di '''oricalco''' (a volte), un frammento di '''oricalco''' (fisso)
== una scatola nera laccata trasportata da La statua di Kazzuya ==
'''PATH''': Tempio dei dannati
'''Trovati''': un lingotto di '''ebanite''', un lingotto d''''acciaio'''
== una scatola nera laccata trasportata da La statua di Maabrash ==
'''PATH''': Tempio dei dannati
'''Trovati''': un lingotto di '''adamantio''', un lingotto d''''acciaio'''
== una scatola nera laccata trasportata da La Statua di Turambar ==
'''PATH''': Museo dei patroni a Talonia
'''Trovati''': un lingotto di '''mithril''' (a volte) , un frammento di '''mithril''' (fisso)
== una scatola nera laccata trasportata da Stohned, il Re ==
'''PATH''': da Platea Quadrata 9e3n4es2e2d2sen2d2swse2nw - uccidere Sandslab e prendergli chiave - e; pick east; e; unlock north;n;bash stoh
'''Trovati''': un lingotto di '''rame''', un lingotto di '''ferro''', un lingotto di '''ottone'''
== una scatola nera laccata trasportata da Suzaku, il generale dell'esercito rosso ==
'''PATH''': campi di battaglia sotto quest Regni
'''Trovati''': per ora nessuno
== una scatola nera laccata trasportata da Uey-Tlatoani ==
'''PATH''': mob di Eldorado Mappa EldoradoIngressi Eldo
'''Trovati''': una pietra '''runica''', un lingotto d''''oro''', un lingotto di '''platino'''
== una scatola nera laccata trasportata da la veggente ==
'''PATH''': mob intermedio della quest Villa delle feste
'''Trovati''': per ora nessuno
== una scatola nera laccata trasportata da Xibalba' ==
'''PATH''': mob di Eldorado Mappa Eldorado Ingressi Eldo
'''Trovati''': un lingotto d''''acciaio'''
== una scatola nera laccata trasportata da Xues Var ==
'''PATH''': Drago acido quest Drow
== una scatola nera laccata trasportata da Ymir ==
'''PATH''': cercasi volontario per scriverla...
== una scatola nera laccata trasportata da Zenith ==
'''PATH''': mob della quest Sottomondo di Zodak
== una scatola nera laccata trasportata da Erky Timbers ==
'''PATH''': Mob intermedio quest Cittadella
== una scatola nera laccata trasportata da Glasya, duchessa infernale ==
'''PATH''': Mob intermedio quest Dimora degli incubi
== una scatola nera laccata in Il ricordo del Paladino che fu ==
'''PATH''': Segreto down di Lord Soth, si apre con TURN SCHEGGIA e si trova anche la Spada Sacra (slash only-pa RARA 2d8 -2hit&amp;dam slay neutral) Sithicus
]]</script>
				<command></command>
				<packageName></packageName>
				<regex></regex>
			</AliasGroup>
			<Alias isActive="yes" isFolder="no">
				<name>Specchio bianco latte, Alma</name>
				<script>local path = {
  "astral",
  ".n;es",
}
ui.fExecutePath(path, matches[2])</script>
				<command></command>
				<packageName></packageName>
				<regex>^(?i)(?:biancolatte|alma)(?:\s+(.*))?$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>Specchio blu mezzanotte, Anime perdute</name>
				<script>local path = {
  "astral",
  ".un2w;es",
}
ui.fExecutePath(path, matches[2])</script>
				<command></command>
				<packageName></packageName>
				<regex>^(?i)blumezzanotte|animeperdute(?:\s+(.*))?$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>Specchio cangiante, Colosseo</name>
				<script>local path = {
  "astral",
  ".unw;es",
}
ui.fExecutePath(path, matches[2])</script>
				<command></command>
				<packageName></packageName>
				<regex>^(?i)cangiante|colosseo(?:\s+(.*))?$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>Specchio giallo e verde, Necrofagi</name>
				<script>local path = {
  "astral",
  ".un2wnue;es",
}
ui.fExecutePath(path, matches[2])</script>
				<command></command>
				<packageName></packageName>
				<regex>^(?i)gialloeverde|necrofagi(?:\s+(.*))?$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>Specchio granito, Mani</name>
				<script>local path = {
  "astral",
  ".un2w2n;es",
}
ui.fExecutePath(path, matches[2])</script>
				<command></command>
				<packageName></packageName>
				<regex>^(?i)granito|nani(?:\s+(.*))?$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>Specchio grigio, Abisso, Manticore</name>
				<script>local path = {
  "astral",
  ".un2wnuw2u;es",
}
ui.fExecutePath(path, matches[2])</script>
				<command></command>
				<packageName></packageName>
				<regex>^(?i)(?:grigio|abisso|manticore)(?:\s+(.*))?$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>Specchio grigio fumo, Drow</name>
				<script>local path = {
  "astral",
  ".un2wn;es",
}
ui.fExecutePath(path, matches[2])</script>
				<command></command>
				<packageName></packageName>
				<regex>^(?i)(?:grigiofumo|drow)(?:\s+(.*))?$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>Specchio grigio palude, Orshingal, Enfan</name>
				<script>local path = {
  "astral",
  ".une;es",
}
ui.fExecutePath(path, matches[2])</script>
				<command></command>
				<packageName></packageName>
				<regex>^(?i)(?:grigiopalude|orshingal|enfan)(?:\s+(.*))?$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>Specchio grigio scuro, Moria</name>
				<script>local path = {
  "astral",
  ".un2ws;es",
}
ui.fExecutePath(path, matches[2])</script>
				<command></command>
				<packageName></packageName>
				<regex>^(?i)grigioscuro|moria(?:\s+(.*))?$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>Specchio marrone sporco, Lycantropia</name>
				<script>local path = {
  "astral",
  ".un2wnuwun;es",
}
ui.fExecutePath(path, matches[2])</script>
				<command></command>
				<packageName></packageName>
				<regex>^(?i)marronesporco|lycantropia(?:\s+(.*))?$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>Specchio oro, torre, Torremagia</name>
				<script>local path = {
  "astral",
  ".unwn;es",
  ".nneedsssswwwwnnnneeeedssssws"
}
ui.fExecutePath(path, matches[2])</script>
				<command></command>
				<packageName></packageName>
				<regex>^(?i)oro|torremagia(?:\s+(.*))?$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>Specchio rosso bruciato, Old Thalos, Lamie</name>
				<script>local path = {
  "astral",
  ".un2wne;es",
}
ui.fExecutePath(path, matches[2])</script>
				<command></command>
				<packageName></packageName>
				<regex>^(?i)(?:rossobruciato|oldthalos|thalos|lamie)(?:\s+(.*))?$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>Specchio turchese, Deserto, Oasi</name>
				<script>local path = {
  "astral",
  ".un2wnuwus;es",
}
ui.fExecutePath(path, matches[2])</script>
				<command></command>
				<packageName></packageName>
				<regex>^(?i)(?:turchese|deserto|oasi)(?:\s+(.*))?$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>Specchio verde erba, Syracusa</name>
				<script>local path = {
  "astral",
  ".un2wnu;es",
}
ui.fExecutePath(path, matches[2])</script>
				<command></command>
				<packageName></packageName>
				<regex>^(?i)verdeerba|syracusa(?:\s+(.*))?$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>Specchio verde foresta, Barriera, Pilastri</name>
				<script>local path = {
  "astral",
  ".unwwnuwuuwds;es",
}
ui.fExecutePath(path, matches[2])</script>
				<command></command>
				<packageName></packageName>
				<regex>^(?i)(?:verdeforesta|barriera|pilastri)(?:\s+(.*))?$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>Specchio verde scuro, Roo, Aborigeni</name>
				<script>local path = {
  "astral",
  ".un2wnuwuw;es",
}
ui.fExecutePath(path, matches[2])</script>
				<command></command>
				<packageName></packageName>
				<regex>^(?i)(?:verdescuro|roo|aborigeni)(?:\s+(.*))?$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>Specchio verde smeraldo, Grecia</name>
				<script>local path = {
  "astral",
  ".un2wnuw;es",
}
ui.fExecutePath(path, matches[2])</script>
				<command></command>
				<packageName></packageName>
				<regex>^(?i)verdesmeraldo|grecia(?:\s+(.*))?$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>Allania</name>
				<script>local path = {
  "astral",
  ".unwwnuwuuwd4s4wdd",
}
ui.fExecutePath(path, matches[2])</script>
				<command></command>
				<packageName></packageName>
				<regex>^(?i)allania(?:\s+(.*))?$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>Allania (uscita)</name>
				<script>local path = {
  ".wssse;enter portale",
}
ui.fExecutePath(path, matches[2])</script>
				<command></command>
				<packageName></packageName>
				<regex>^(?i)exitallania(?:\s+(.*))?$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>Anaconda</name>
				<script>local path = {
  "dw alma",
  ".wdws;run e;.n2e3s7e",
}
ui.fExecutePath(path, matches[2])</script>
				<command></command>
				<packageName></packageName>
				<regex>^(?i)anaconda(?:\s+(.*))?$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>Banca Alma</name>
				<script>local path = {
  "dw alma",
  ".wdwseees",
}
ui.fExecutePath(path, matches[2])</script>
				<command></command>
				<packageName></packageName>
				<regex>^(?i)banca(?:\s+(.*))?$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>Camelot</name>
				<script>local path = {
  "astral",
  "n;ent spe;.nu;",
  "push pulsante;",
  "w;ent portale;op parete;.2w",
  ".see;bl sace",
  "get chiave cad;.wwn;op w;.wd;bl costrutto",
  "get simbolo cad;op porta s;s;ent portale",
}
ui.fExecutePath(path, matches[2])</script>
				<command></command>
				<packageName></packageName>
				<regex>^(?i)camelot(?:\s+(.*))?$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>Ennaheg</name>
				<script>local path = {
  "astral",
  ".unwwnuwuu;es;.edddnneeesdn",
}
ui.fExecutePath(path, matches[2])</script>
				<command></command>
				<packageName></packageName>
				<regex>^(?i)ennaheg(?:\s+(.*))?$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>Giganti di Montagna</name>
				<script>local path = {
  "dw orsetto",
  ".eeenwnuneddudu",
}
ui.fExecutePath(path, matches[2])</script>
				<command></command>
				<packageName></packageName>
				<regex>^(?i)gigantimontagna(?:\s+(.*))?$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>Giganti del Ghiaccio</name>
				<script>local path = {
  "astral",
  ".n;es;.nu;",
  "push pulsante",
  ".w;ent portale;open parete;.ww;ent shadowdale;.d;run n;op crepa;.n2esdn2e2n",
}
ui.fExecutePath(path, matches[2])</script>
				<command></command>
				<packageName></packageName>
				<regex>^(?i)gigantighiaccio(?:\s+(.*))?$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>Gilda Lame</name>
				<script>local path = {
  "dw cacciatore-_ask",
  ".s2e3ne",
}
ui.fExecutePath(path, matches[2])</script>
				<command></command>
				<packageName></packageName>
				<regex>^(?i)glame(?:\s+(.*))?$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>Magione</name>
				<script>local path = {
  "astral",
  ".n;es;.2se2s;run e;.nnwwwnwnn"
}
ui.fExecutePath(path, matches[2])</script>
				<command></command>
				<packageName></packageName>
				<regex>^(?i)magione(?:\s+(.*))?$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>Olimpo</name>
				<script>local path = {
  "astral",
  ".unwwnuw;es;.6en2u",
}
ui.fExecutePath(path, matches[2])</script>
				<command></command>
				<packageName></packageName>
				<regex>^(?i)olimpo(?:\s+(.*))?$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>Pennina</name>
				<script>local path = {
  "dw flaminio",
  ".s4es2e2de2u2nuse2nwu",
  ".nwnw4nen;pick porta e;op porta e;e;bu",
}
ui.fExecutePath(path, matches[2])</script>
				<command></command>
				<packageName></packageName>
				<regex>^(?i)pennina(?:\s+(.*))?$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>Piattaforma accademia</name>
				<script>local path = {
  "dw velestra",
}
ui.fExecutePath(path, matches[2])</script>
				<command></command>
				<packageName></packageName>
				<regex>^(?i)accademia(?:\s+(.*))?$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>Plutarco</name>
				<script>local path = {
  "astral",
  ".un2wnuw2u;ent spe;.edddnneeeuu",
  "push masso",
  ".eenesddww",
}
ui.fExecutePath(path, matches[2])</script>
				<command></command>
				<packageName></packageName>
				<regex>^(?i)plutarco(?:\s+(.*))?$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>Scacchiera</name>
				<script>local path = {
  "astral",
  ".n;es;.nu;",
  "push pulsante",
  ".w;ent portale;open parete;.ww;ent shadowdale;.dd;ent scacchiera",
}
ui.fExecutePath(path, matches[2])</script>
				<command></command>
				<packageName></packageName>
				<regex>^(?i)scacchiera(?:\s+(.*))?$</regex>
			</Alias>
			<Alias isActive="no" isFolder="no">
				<name>Spaventapasseri</name>
				<script>local path = {
  "dw alma",
  ".wdws10ws9w3n9w6s8w5s3ws",
}
ui.fExecutePath(path, matches[2])</script>
				<command></command>
				<packageName></packageName>
				<regex>^(?i)spaventa|spaventapasseri(?:\s+(.*))?$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>Tesoro Re Greylin</name>
				<script>send("get chiave re")
send("tira tenda")
expandAlias("w")
send("unlock forziere")
send("open forziere")
send("get lapislazuli forziere")</script>
				<command></command>
				<packageName></packageName>
				<regex>^(greylin)$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>Tesoro Re Shik</name>
				<script>expandAlias("get chia shik")
expandAlias("tira arazzo")
expandAlias("s")
expandAlias("get ninnoli")
expandAlias("unlock cassa")
expandAlias("open cassa")
expandAlias("get monete cassa")</script>
				<command></command>
				<packageName></packageName>
				<regex>^(shik)$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>Scatole Nere</name>
				<script>local path = {
  "dw gitana-_ask",
  ".w2s;ask vecchietto ingredienti",
}
ui.fExecutePath(path, matches[2])</script>
				<command></command>
				<packageName></packageName>
				<regex>^(?i)scatole(?:\s+(.*))?$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>Deadhame</name>
				<script>local path = {
  "astral",
  ".n;es;.nu;",
  "push pulsante",
  ".w;ent portale;open parete;.ww;ent shadowdale;.de",
}
ui.fExecutePath(path, matches[2])</script>
				<command></command>
				<packageName></packageName>
				<regex>^(?i)deadhame(?:\s+(.*))?$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>Thor</name>
				<script>local path = {
  "dw topo-deserto;.3n5e3ued2e",
  "get chiave cad;op fessura;.e;op stalagmite;.n",
  "say raido",
}
ui.fExecutePath(path, matches[2])</script>
				<command></command>
				<packageName></packageName>
				<regex>^(?i)thor(?:\s+(.*))?$</regex>
			</Alias>
		</AliasGroup>
		<AliasGroup isActive="yes" isFolder="yes">
			<name>Quests</name>
			<script></script>
			<command></command>
			<packageName></packageName>
			<regex></regex>
			<Alias isActive="yes" isFolder="no">
				<name>Ancalador</name>
				<script>local path = {
  "portal turista;",
  "run w;",
  "op porta w;run w;",
  ".6essueessess5edd7e;bl guardiano-pietrificato",
  "ga cad;op portone e;e;op fessura;.seds;bl necromante",
  "get chiave cadavere;.ue;bu",
  "ga cad;.wwd;op portone w;w;bl malinda",
  "get chiave cadavere;op grata;d;op cancello d",
  "ga cadavere;.uuenun;",
}
ui.fExecutePath(path, matches[2])</script>
				<command></command>
				<packageName></packageName>
				<regex>^(?i)ancalador(?:\s+(.*))?$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>Cattedrale - Dama Morte</name>
				<script>local path = {
  "dw 11.saggio",
  "run w;run n;.w;enter vegetazione;open cancellata n;.n", -- cercare glifo su mob hide
  ".needswwses",
  "get chiave cad;unlock tessera;push tessera;.sesesws",
  ".5d;unlock schermo;push schermo",
  ".d;aa",
}
ui.fExecutePath(path, matches[2])</script>
				<command></command>
				<packageName></packageName>
				<regex>^(?i)dama(?:\s+(.*))?$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>Elminster</name>
				<script>local path = {
  "portal frank",
  ".4ennwnne;op n",
  ".n",
}
ui.fExecutePath(path, matches[2])</script>
				<command></command>
				<packageName></packageName>
				<regex>^(?i)elminster(?:\s+(.*))?$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>Infirama</name>
				<script>-- Necessita di atrezzi da scasso e pergamena trasucida in borsa per disarmare trapola al passo 5
local path = {
  "dw ironhome",  --&gt; cercare e psizionarsi su "La strada principale" e poi proseguire con passo 2
  "run s;.ddwwun;bl kedar;",
  "ga cad;op forziere;ga forziere;.dseeuueeusuuws;op porta s;.4swwn;bl gram;",
  "ga cad;.swsdw;op porta w;w;bl butc",
  "ga cad;ga;.eeueuess;op portone s;.ssesww;gg traslucida;tt traslucida;reci pergamena;gg scasso;tt scasso;use scasso rune;rr scasso;pp scasso;u;turn braccio;w;bl kru;",
  "ga cad;ga 2.cad;ga 3.cad;push pulsante;s;op baule;ga baule;.ned;op porta s;s;bu",
  "ga cad;ga 2.cad;op porta e;e;bl remi",
  "ga cad;op scrigno;get dente scrigno;.wneenw4nene;op porta e",
  "e;", --&gt; attendere telport
  "bu", --&gt; drago piccolo da stanare
  "n",  --&gt; infirana
  "ga cad;ga;op portale;.2e", --&gt; uscita
}
ui.fExecutePath(path, matches[2])</script>
				<command></command>
				<packageName></packageName>
				<regex>^(?i)infirama(?:\s+(.*))?$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>Locuste</name>
				<script>local path = {
  "astral",
  ".unwwnu;es;.eswwssed",
  ".dn;unlock grata;open grata;.nuue;run d ",
  "...da finire..."
}
ui.fExecutePath(path, matches[2])
--[[
Andate a Syracusa.
Astral
.unwwnu
enter specchio
.eswwssed
Cercate le Murene (partono hide) e killatele fino a trovare quella con la Testa di un pesce con dentro la chiave arruginita che da diritto alla quest.
Cercate la Grata, che dopo il primo Down si troverà a
.dn
unlock grata 
.nuue
run d 
Spostatevi sull'asse west, killate Aharnikx, Miirnihkx e gettate la chiave dal cadavere.
.wuusswss
disarm botola 
.w
Killate lo Sciamano, Guardiano e gettate la chiave dal cadavre.
unlock porta n
open porta n
Tirare lo Stregone e pulire a nord gli eventuali mobbetti ('Servi e Accoliti).
.n
Killate le 4 Monache, il Sacerdote e gettare la chiave dal cadavere.
unlock n
Pulire verso nord' eventuali Servi e Accoliti e da Altare delle Locuste
.3n
unlock east
open east
.e
Killate Uomo, Regina e gettate le 2 chiavi dal cadavere.
unlock forno
open forno
get all forno
.w3s
unlock lucchetto
open lucchetto
.d
Killate Ombra e gettate i premi dalla Cesta.
.u
astral
]]</script>
				<command></command>
				<packageName></packageName>
				<regex>^(?i)locuste(?:\s+(.*))?$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>Oltre il portale</name>
				<script>local path = {
  "dw Paktos",
  ".3n;pick chiavistello;open chiavistello;.w;",
  "spingi sarcofago;",
  ".2d2se2s2e;dig terra;.s;dig terra;.s;open portale;.w",
  "op barriera;enter barriera;",
  ".n2en8e",
  "ga molydeus;.8w2nw;",
  "op n;.2n",
}
ui.fExecutePath(path, matches[2])
</script>
				<command></command>
				<packageName></packageName>
				<regex>^(?i)oltre(?:\s+(.*))?$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>Tempio dannati</name>
				<script>local path = {
  "dw cane-famelico;.ues2ne4dnw4n",
}
ui.fExecutePath(path, matches[2])</script>
				<command></command>
				<packageName></packageName>
				<regex>^(?i)tempiodannati(?:\s+(.*))?$</regex>
			</Alias>
		</AliasGroup>
		<AliasGroup isActive="yes" isFolder="yes">
			<name>Varie</name>
			<script></script>
			<command></command>
			<packageName></packageName>
			<regex></regex>
			<Alias isActive="yes" isFolder="no">
				<name>Attacco automatico</name>
				<script>local opt = matches[2] or ""
local attack = false
local perc = tonumber(ui.player.hp) / (tonumber(ui.player.maxhp) / 100.0) 
--
if (opt == "+") then
  ui.parameters.autoAttack = true;
elseif (opt == "-") then
  ui.parameters.autoAttack = false;
elseif (opt == "a") then
  ui.parameters.autoAttackArea = true;
elseif (opt == "s") then
  ui.parameters.autoAttackArea = false;
else
  attack = true
end
--
if (attack) then
  local opponent = '';
  local attack = 'bl';
  --
  -- Fuori dal combattimento...
  if (ui.opponent.name == '') then
    -- .. primo mob a tiro
    for _, mob in pairs(ui.room.mobs) do
      opponent = string.gsub(mob.key, " ", "-")
      --
      -- Mano di energia attiva
      if (ui.affects["mano di energia"]) and (ui.cooldowns["Mano Di Energia"] == nil) then
        attack = 'bash';
      end
      --
      break 
    end
  --
  -- In combattimento
  else
    opponent = ui.opponent.name
  end
  --
  --
  ui.echoed = nil
  --
  if (opponent == '') then
    cecho(" "..ui.fGetOperatorFormattedText("»").." &lt;white&gt;Non ci sono mob da attaccare\n")  
    if (ui.affects["velocita` della luce"]) then
      if (ui.affects["mantello di fiamme"] == nil) then
        expandAlias("flame", false)
      elseif (perc &lt;= 80) then
        expandAlias("cel", false)
      end
    end
  else
    --
    cecho(" "..ui.fGetOperatorFormattedText("»").." &lt;red&gt;"..opponent)  
    --
    -- LightSpeed
    if (ui.affects["velocita` della luce"]) then
      cecho("&lt;green&gt; (LightSpeed)\n")
      --
      -- Hp sotto l'70%
      if (perc &lt;= 65) then
        expandAlias("cel", false)
      --
      -- Scudo di fiamme scaduto
      elseif (ui.affects["mantello di fiamme"] == nil) then
        expandAlias("flame", false)
      --
      -- ripristino energia
      elseif (ui.player.pow &lt;= 80) then
        expandAlias("cani 1", false)      
      --
      -- Lame Psioniche attive
      elseif (ui.affects["lame psioniche"]) then
        expandAlias("as "..opponent, false)
      --
      -- Mano di energia attiva, ma in cooldowns
      -- elseif (ui.affects["mano di energia"]) and (ui.cooldowns["Mano Di Energia"]) then
      --   expandAlias("lampo "..opponent, false)
      --
      -- Mano di energia attiva e sono in combattimento
      -- elseif (ui.affects["mano di energia"]) and (attack == 'bl') then 
      --   expandAlias("pugno "..opponent, false)
      --
      -- 
      else
        expandAlias("lampo "..opponent, false)
      end
    end
    echo("\n") 
    --
    -- Super cura
    if (ui.affects["velocita` della luce"]) and (perc &lt;= 20) then
      expandAlias("cel", false)
    --
    -- Crush
    elseif (ui.player.pow &lt; 40) then
      expandAlias("cr "..opponent, false)
    --
    -- Normal attack
    else
      expandAlias(attack.." "..opponent, false)
    end
    echo("\n") 
    --
    send("l")
  end
end</script>
				<command></command>
				<packageName></packageName>
				<regex>^aa([\+\-as])?$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>Esecuzione codice LUA da prompt comandi</name>
				<script>local f, e = loadstring("return "..matches[2])
--
if not f then
  f, e = assert(loadstring(matches[2]))
end
--
local r = function(...)
            if not table.is_empty({...}) then
              display(...)
            end
          end
--
r(f())</script>
				<command></command>
				<packageName></packageName>
				<regex>^lua (.*)$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>Explorer</name>
				<script>local steps = {
 "d", "e", "n", "w", "s", "u", 
}
--
local function nextStep(origin)
  for s, step in ipairs(steps) do
    if step == origin then
      local cnt = #steps
      local idx = s
      --
      while (cnt &gt; 0) do
        if (idx &gt;= #steps) then
          idx = 1
        else
          idx = idx + 1
        end
        --
        if (table.contains(ui.room.exits, ui.validExit[steps[idx]].long)) then
          return idx
        end
        cnt = cnt - 1
      end
    end
  end
  --
  return 1
end
--
expandAlias(steps[nextStep(ui.origins[1])])

--if (table.contains(ui.origins, "e")) then
--  if (table.contains(ui.room.exits, "south")) then dirTo = "s"
--  elseif (table.contains(ui.room.exits, "west")) then dirTo = "w"
--  elseif (table.contains(ui.room.exits, "north")) then dirTo = "n"
--  else dirTo = "e"
--  end
--elseif (table.contains(ui.origins, "s")) then
--  if (table.contains(ui.room.exits, "west")) then dirTo = "w"
--  elseif (table.contains(ui.room.exits, "north")) then dirTo = "n"
--  elseif (table.contains(ui.room.exits, "east")) then dirTo = "e"
--  else dirTo = "s"
--  end
--elseif (table.contains(ui.origins, "w")) then
--  if (table.contains(ui.room.exits, "north")) then dirTo = "n"
--  elseif (table.contains(ui.room.exits, "east")) then dirTo = "e"
--  elseif (table.contains(ui.room.exits, "south")) then dirTo = "s"
--  else dirTo = "w"
--  end
--else
--  if (table.contains(ui.room.exits, "east")) then dirTo = "e"
--  elseif (table.contains(ui.room.exits, "south")) then dirTo = "s"
--  elseif (table.contains(ui.room.exits, "west")) then dirTo = "w"
--  else dirTo = "n"
--  end
--end
-- echo("Arrivi da "..ui.dirToken[dirFrom].." e vai verso "..ui.dirToken[dirTo]..".")
</script>
				<command></command>
				<packageName></packageName>
				<regex>^ee$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>Moltiplicatore di comandi</name>
				<script>local rpt = matches[2]
local command = matches[3]
local commands, varNameError = ui.fExpandVariables(command)
--
if (not varNameError) then
  local commands = ui.fExpandCommand(command);
  for i = 1, rpt do
    for _, command in ipairs(commands) do
      command = ui.fExpandVariables(command)
      expandAlias(command)
    end
  end
end</script>
				<command></command>
				<packageName></packageName>
				<regex>^(\d+)\*\s*(.*)</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>Multi loot</name>
				<script>local obj = matches[2] or "all"
local cntCad = 0;
local cntTes = 0;
local cntPol = 0;
--
for _, object in pairs(ui.room.objects) do
  local lot = ""
  local tot = 0
  local cnt = 0
  --
  if (string.find(object.key, "cadavere")) then
    lot = "cadavere"
    cnt = cntCad
    tot = object.counter
  elseif (string.find(object.key, "testa")) then
    lot = "testa"
    cnt = cntTes
    tot = object.counter
  elseif (string.find(object.key, "polvere")) then
    lot = "polvere"
    cnt = cntPol
    tot = object.counter
  end
  --
  for i=1, tot do
    cnt = cnt + 1;
    send("get "..obj.." "..cnt.."."..lot)
  end
  --
  if (lot == "cadavere")  then
    cntCad = cnt
  elseif (lot == "testa")  then
    cntTes = cnt
  elseif (lot == "polvere")  then
    cntPol = cnt
  end    
end
--
if  (cntCad == 0) and (cntTes == 0) then
  ui.fEchon('Nessun cadavere da sciacallare')
end</script>
				<command></command>
				<packageName></packageName>
				<regex>^(?i)(?:ll)(?:\s+(.*))?$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>mygo</name>
				<script>local vNum = tonumber((matches[2] or "-1"))
if (vNum &lt; 0) then
  vNum = lst_vNum
end

for i=vNum, vNum+100 do
  send("go "..i)
end
lst_vNum = vNum+100</script>
				<command></command>
				<packageName></packageName>
				<regex>^(?i)(?:mygo)(?:\s+(.*))?$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>myprompt</name>
				<script>send("set prompt %K $c0009%h$c0015:$c0001%H $c0012%m$c0015:$c0004%M $c0010%v$c0015:$c0002%V $c0011%e$c0015:$c0003%E $c0015[%S$c0015] %n:%c $c0009%N$c0015:$c0009%C $c0014%x$c0015&gt;")</script>
				<command></command>
				<packageName></packageName>
				<regex>myprompt</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>Navigator</name>
				<script>ui.direction = ui.validExit[string.lower(matches[2])].short;
local userData = getAllRoomUserData(ui.room.id)
--
if (not table.is_empty(userData)) and (userData[ui.direction]) then
  send(userData[ui.direction])
end
send(ui.direction, false)</script>
				<command></command>
				<packageName></packageName>
				<regex>^(?i)(a|alto|b|basso|d|down|e|est|east|n|nord|north|o|ovest|s|sud|south|u|up|w|west)$</regex>
			</Alias>
		</AliasGroup>
	</AliasPackage>
	<ActionPackage />
	<ScriptPackage>
		<ScriptGroup isActive="yes" isFolder="yes">
			<name>LeU_UI</name>
			<packageName>LeU_UI</packageName>
			<script></script>
			<eventHandlerList />
			<ScriptGroup isActive="yes" isFolder="yes">
				<name>Functions</name>
				<packageName></packageName>
				<script>ui = ui or {}</script>
				<eventHandlerList />
				<Script isActive="yes" isFolder="no">
					<name>Affects</name>
					<packageName></packageName>
					<script>--
function ui.fUpdateAffects()
  ui.fDebug("[&lt;cyan&gt;call&lt;r&gt;] ui.fUpdateAffects()")
  --
  local distance = 2; 
  local min_w = 100;
  local max_w = 150;
  local w_h = GUI.Affects.Main:get_height() - distance;
  local w_w = GUI.Affects.Main:get_width() -  distance;
  local h = distance + 28;
  local w = distance + min_w;
  local x = 0
  local y = 0
  local r = 1
  local c = 1
  local tot_r, tot_c, total
  local orderTable = {}
  --
  -- Pre defined affect 
  local pre_defined_affects = {
    ["velocita` della luce"]        = {                        BGcolor = "cyan" },
  --  ["[CD] Nuovo Dungeon"]        = {icon = "skill_115.png", color = "blue", shortName = "CD Dung" },
  --  ["[CD] Nuova Missione"]       = {icon = "skill_115.png", color = "blue", shortName = "CD Miss" },  
  --  ["avvelena"]                  = {icon = nil,             color = "YellowGreen", shortName = "Vel" },
  --  ["chiaroveggenza"]            = {icon = nil,             color = "magenta", shortName = "Chiaro" },  
  --  ["colpo psichico"]            = {icon = nil,             color = "magenta", shortName = "Colpo PSI" },  
  --  ["forza psichica"]            = {icon = "skill_9.png",   color = "OrangeRed", shortName = "PSI Str" },
  --  ["individua il magico"]       = {icon = 'Skill_322.png', color = "DarkOrchid", shortName = "Ind. mag." },
  --  ["individua il male"]         = {icon = 'skill_72.png',  color = "DarkOrchid", shortName = "Ind. mal." },
  --  ["individua invisibile"]      = {icon = "Skill_312.png", color = "DarkOrchid", shortName = "Ind. inv." },
  --  ["levitazione"]               = {icon = "skill_156.png", color = "blue", shortName = "Lev" },
  --  ["nuotare (cooldown)"]        = {icon = "skill_110.png", color = "blue", shortName = "Swim" },
  --  ["percepisci vita"]           = {icon = "skill_44.png",  color = "DarkOrchid", shortName = "True Live" },
  --  ["primo soccorso"]            = {icon = nil,             color = "green", shortName = "First AID" },  
  --  ["santuario"]                 = {icon = "Skill_243.png", color = "white", shortName = "Sanc" },
  --  ["scarica di adrenalina"]     = {icon = "Skill_472.png", color = "yellow", shortName = "PSI Dro" },
  --  ["scopri le trappole"]        = {icon = "skill_166.png", color = "brown", shortName = "Det. trap" },
  --  ["mantello di fiamme"]        = {icon = "fireshield.png", BGcolor = "firebrick", FGcolor = "yellow", shortName = "PSI Fire" },
  --  ["scudo psichico"]            = {icon = "skill_168.png", color = "cyan", shortName = "PSI Shield" },
  --  ["vera vista"]                = {icon = "Skill_264.png", color = "DarkOrchid", shortName = "Vera Vista" },
  }
  --
  -- Fast affect
  local fastAffects = {
    ["In Combattimento"] = '&lt;span style="font-size:10px"&gt;⚔&lt;/span&gt;',
    ["Panico!"]          = '&lt;span style="font-size:10px"&gt;🏃&lt;/span&gt;',
  }
  --
  ui.affects = {}
  ui.fastAffects = ""
  --
  -- Simulation (for debug)
  if (ui.enDebug &gt;= 2) then
    for i=1, math.random(1, 30) do
      local name = "Affect "..i 
      --
      ui.affects[name] = {} 
      ui.affects[name].category   = math.random(0, 100)
      if (i&lt;10)then
        ui.affects[name].color    = "$c000"..(i)
      else
        ui.affects[name].color    = "$c00"..(i)
      end
      ui.affects[name].dispelResistance = math.random(0, 100)
      ui.affects[name].duration         = math.random(0, 15) - 10
      ui.affects[name].isNegative       = math.random(0, 100)
      if (math.random(0, 1) == 0) then ui.affects[name].isRound = true else ui.affects[name].isRound = false end;
      ui.affects[name].stacks           = math.random(0, 100)
      ui.affects[name].type             = math.random(0, 100)
      --
      orderTable[#orderTable+1] = name
    end
  elseif (gmcp) and (gmcp.char) and (gmcp.char.affects) then
    --
    -- GMCP
    for affect in pairs(gmcp.char.affects) do
      local name = gmcp.char.affects[affect].name 
      --
      ui.affects[name] = {}
      ui.affects[name].category         = gmcp.char.affects[affect].category
      ui.affects[name].color            = gmcp.char.affects[affect].color
      ui.affects[name].dispelResistance = gmcp.char.affects[affect].dispelResistance
      ui.affects[name].duration         = gmcp.char.affects[affect].duration
      ui.affects[name].isNegative       = gmcp.char.affects[affect].isNegative
      ui.affects[name].isRound          = gmcp.char.affects[affect].isRound
      ui.affects[name].stacks           = gmcp.char.affects[affect].stacks
      ui.affects[name].type             = gmcp.char.affects[affect].type
      --
      orderTable[#orderTable+1] = name
    end
  end
  --
  -- Order Affects
  table.sort(orderTable, function (affect1, affect2)
                           if (ui.affects[affect1].duration &lt; 0) then
                             return false
                           elseif(ui.affects[affect2].duration &lt; 0) then
                             return true
                           elseif (ui.affects[affect1].isRound) and (not ui.affects[affect2].isRound) then
                             return true
                           elseif (not ui.affects[affect1].isRound) and (ui.affects[affect2].isRound) then
                             return false
                           else 
                             return ui.affects[affect1].duration &lt; ui.affects[affect2].duration
                           end
                         end )
  --
  total = math.min(#orderTable, 20);
  tot_r = math.max(1, math.min(math.floor(w_h / h), total));
  tot_c = math.max(1, math.min(math.floor(w_w / w), total));
  --
  -- Recalc w
  w = math.min(w_w / tot_c, distance + max_w)
  --
  for i = 1, 20 do
    --
    -- Show if inside box
    if (r &gt; tot_r) or (i &gt; total) then
      GUI.Affects.Main["Affect"..i]:hide();
    else
      local duration = ""
      local affect = orderTable[i]
      local durationColor = "green"
      --
      -- Permanent
      if (ui.affects[affect].duration &lt; 0) then
        durationColor = "white"
        ui.affects[affect].duration = "&lt;b&gt;P&lt;/b&gt;"
        duration = "Permanente"
      else
        --
        if (ui.affects[affect].duration &lt; 1) then
          durationColor = "red"
        elseif (ui.affects[affect].duration &lt; 3) then
          durationColor = "orange"
        elseif  (ui.affects[affect].duration &lt; 5) then
          durationColor = "yellow"
        end
        --
        -- In round or  tick
        if (ui.affects[affect].isRound) then
          duration = ui.affects[affect].duration.." round"
          ui.affects[affect].duration = ui.affects[affect].duration.."r"
        else
          duration = ui.affects[affect].duration.." tick"
          ui.affects[affect].duration = ui.affects[affect].duration.."T"
        end
      end
      --
      -- Fast Affects
      if (table.contains(fastAffects, affect)) then
        ui.fastAffects = ui.fastAffects.." - "..fastAffects[affect]..":"..ui.affects[affect].duration;
      --
      -- Normal Affects
      else
        local icon = nil
        local BGColor = nil
        local FGColor = "black";
        local shortName = nil
        local CCS = GUI.CSS.ItemText
        --
        -- Pre-load icon, BG volor and short name form predefinited table (if exists)
        if table.contains(pre_defined_affects, affect) then
          --
          -- Pre-ShortName
          if (pre_defined_affects[affect].shortName) then
            shortName = pre_defined_affects[affect].shortName
          end
          --
          -- Pre-FG Color
          if (pre_defined_affects[affect].FGcolor) then
            FGColor = pre_defined_affects[affect].FGcolor
          end
          --
          -- Pre-Icon
          if (pre_defined_affects[affect].icon) and (io.exists(ui.files.icons.path..pre_defined_affects[affect].icon)) then
            icon = ui.files.icons.path..pre_defined_affects[affect].icon;
          end
          --
          -- Pre-BG Color
          if (pre_defined_affects[affect].BGcolor) then
            BGColor = pre_defined_affects[affect].BGcolor
          end
        end
        --
        -- Short Name
        if (not shortName) then
          shortName = ui.fRemoveArticle(affect);
        end
        GUI.Affects.Main["Affect"..i].text:setFgColor(FGColor)
        GUI.Affects.Main["Affect"..i].text:echo("&lt;center&gt;"..string.gsub(shortName, "(%a)([%w_']*)", ui.fTitleCase))
        --
        -- Icon
        if (icon) then
          CCS = CCS..[[
                  border-image: url("]]..icon..[[") 0px stretch;
                ]]
        end
        --
        -- BG color
        if (not BGColor) then
          if (ui.affects[affect].color) then
            BGColor = ui.fGetColor(ui.affects[affect].color)
          else
  		      local R = 9 * ((string.byte(shortName, 1) or 0x0) - 0x61) -- Primo carattere o 0 se la frase è vuota
  		      local G = 9 * ((string.byte(shortName, 2) or 0x0) - 0x61) -- Secondo carattere o 0 se la frase ha meno di 2 caratteri
  		      local B = 9 * ((string.byte(shortName, 3) or 0x0) - 0x61) -- Terzo carattere o 0 se la frase ha meno di 3 caratteri
  		      --
            BGColor = string.format("#%02X%02X%02X", R, G, B)
          end
        end
        --
        CCS = CCS..[[
                background-color: ]]..BGColor..[[;
              ]]
        GUI.Affects.Main["Affect"..i].text:setStyleSheet(CCS)
        --
        GUI.Affects.Main["Affect"..i]:setStyleSheet([[QLabel{
          ]]..GUI.CSS.Item..[[
          background-color: ]]..BGColor..[[;
        }]])
        --
        GUI.Affects.Main["Affect"..i].duration:setFgColor(durationColor)
        GUI.Affects.Main["Affect"..i].duration:echo("&lt;center&gt;"..ui.affects[affect].duration)
        --
        -- Dispel Resistance
        GUI.Affects.Main["Affect"..i].dispelResistance:echo("&lt;center&gt;"..ui.affects[affect].dispelResistance)
        --
        -- Stack
        GUI.Affects.Main["Affect"..i].stacks:echo("&lt;center&gt;"..ui.affects[affect].stacks)
        --
        -- ToolTip
        local toolTip = ""
        --
        if ui.fHasbit(ui.affects[affect].type, 1) then toolTip = toolTip.."Aura " end
        if ui.fHasbit(ui.affects[affect].type, 2) then toolTip = toolTip.."Affliction " end
        if ui.fHasbit(ui.affects[affect].type, 3) then toolTip = toolTip.."Control " end
        if ui.fHasbit(ui.affects[affect].type, 4) then toolTip = toolTip.."Hinder " end
        if ui.fHasbit(ui.affects[affect].type, 5) then toolTip = toolTip.."Immunity " end
        if ui.fHasbit(ui.affects[affect].type, 6) then toolTip = toolTip.."Arcane " end
        if ui.fHasbit(ui.affects[affect].type, 7) then toolTip = toolTip.."Divine " end
        if ui.fHasbit(ui.affects[affect].type, 8) then toolTip = toolTip.."Elemental " end
        if ui.fHasbit(ui.affects[affect].type, 9) then toolTip = toolTip.."Physical " end
        if (toolTip == "") then toolTip = "-" else toolTip = "&amp;lt;"..string.trim(toolTip).."&amp;gt;" end
        --
        toolTip = '&lt;p style="text-align: center;"&gt;&lt;b&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;'..string.upper(affect)..'&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/b&gt;&lt;br&gt;'..
                        '&lt;i&gt;'..toolTip..'&lt;/i&gt;&lt;/p&gt;'..
                        '&lt;lu&gt;'..
                        '&lt;li&gt;▷ '..ui.affects[affect].dispelResistance.. ' resistenza&lt;/li&gt;'..
                        '&lt;li&gt;▷ '..ui.affects[affect].stacks..' stack&lt;/li&gt;'..
                        '&lt;/lu&gt;'..
                        --stat..
                        '&lt;p style="text-align: right;"&gt;&lt;i&gt;'..duration..'&lt;/i&gt;'
        GUI.Affects.Main["Affect"..i]:setToolTip(toolTip, 10)
        --
        --
        GUI.Affects.Main["Affect"..i]:move(distance + (c-1)*w, distance + (r-1)*h)
        GUI.Affects.Main["Affect"..i]:resize(w - distance, h - distance)
        GUI.Affects.Main["Affect"..i]:show();
        --
        c = c + 1
        if (c &gt; tot_c) then
          c = 1;
          r = r + 1
        end
      end
    end
  end
end
--
-- Debug simulation
if (ui.enDebug) and (ui.enDebug &gt;= 2) then
  ui.fUpdateAffects()
end</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>Alias buttons</name>
					<packageName></packageName>
					<script>local bgColor = {
  ["a"] = "75,0,0",
  ["b"] = "0,75,0",
  ["c"] = "0,0,75",
}
--
local bgColorHover = {
  ["a"] = "150,0,0",
  ["b"] = "0,200,0",
  ["c"] = "0,0,150",
}
--
-- Expand button name. Es. ui.fExpandButton("T5") -&gt; "t", 5
function ui.fExpandButton(button)
  local val = 0
  --
  button = string.lower(button or "")
  if (string.find(button, "^[abcgot]%d$")) then
    return string.sub(button, 1, 1), tonumber(string.sub(button, 2, 2))
  end
  --
  return nil, nil
end
--
function ui.fGetAliasButtonFormattedText(button)
  local cColor = {
    ["a"] = "&lt;red&gt;",
    ["b"] = "&lt;green&gt;",
    ["c"] = "&lt;blue&gt;",
  }
  local b, n = ui.fExpandButton(button)
  if (cColor[b]) then
    return ui.cLink(cColor[b]..button)
  else
    return ui.colors.aliasButton.."["..button.."]".."&lt;r&gt;"
  end
end
--
function ui.fSearchAliasButton(button)
  local type, number = ui.fExpandButton(button)
  --
  if (type == "a") or (type == "b") or (type == "c") then
    button = type..number
    for alias in pairs(ui.aliases) do
      if (ui.aliases[alias].button) and (ui.aliases[alias].button==button) then
        return alias
      end
    end
  end
  --
  return nil
end
--
-- Cecho Alias with link
function ui.fLinkAliasButton(button)
  local alias = ui.fSearchAliasButton(button)
  cechoLink(ui.fGetAliasButtonFormattedText(button), [[expandAlias("]]..button..[[")]], "Esegui '"..button.."'", true)
  cecho(" "..ui.fGetOperatorFormattedText("»").." ")
  if (alias) then
    ui.fLinkAlias(alias)
  else
    cecho("&lt;r&gt;non configurato")
  end
end
--
-- List all alias buttons
function ui.fShowAllAliasButtons()
  local i = 0
  --
  ui.fDebug("[&lt;cyan&gt;call&lt;r&gt;] ui.fShowAllAliasButtons()")
  --
  cecho(ui.fTitle("Pulsanti alias"))
  local button = {"a", "b", "c"}
  for b=1, 3 do
    for i=0, 9 do
      cecho(ui.fGetNumberFormattedText((b-1)*10 + i +1).." ")
      cechoLink(ui.cLink("X"), [[expandAlias("uibuttons ]]..button[b]..i..[[ remove")]], "Rimuovi l'alias associato a '"..button[b]..i.."'", true)
      cecho(" ")
      ui.fLinkAliasButton(button[b]..i)
      cecho("\n")
    end
  end
end
--
-- Remove alias button
function ui.fRemoveAliasButton(button)
  local ret = 0;
  local type, number = ui.fExpandButton(button)
  --
  ui.fDebug("[&lt;cyan&gt;call&lt;r&gt;] ui.fRemoveAliasButton("..(button or "nil")..")")
  --
  if (type == "a") or (type == "b") or (type == "c") then
    button = type..number 
    local alias = ui.fSearchAliasButton(button)
    --
    if (alias) then
      ui.aliases[alias].button = nil
      --
      return 1
    end
    --
    return -2 -- Not alias assigned
  end
  --
  return -1 -- Invaid button
end
--
-- Remove all alias button
function ui.fRemoveAllAliasButtons()
  ui.fDebug("[&lt;cyan&gt;call&lt;r&gt;] ui.fRemoveAllAliasButtons()")
  --
  for alias in pairs(ui.aliases) do
    if (ui.aliases[alias].button) then
      ui.aliases[alias].button = nil
    end
  end
end
--
-- Assign alias button
function ui.fAssignAliasButton(button, alias)
  local ret = 0;
  local type, number = ui.fExpandButton(button)
  --
  ui.fDebug("[&lt;cyan&gt;call&lt;r&gt;] ui.fAssignAliasButton("..(button or "nil")..", "..(alias or "nil")..")")
  --
  if (type == "a") or (type == "b") or (type == "c") then
    button = type..number
    if (ui.aliases[alias]) then
      ui.fRemoveAliasButton(button)
      ui.aliases[alias].button = button
      --
      return 1
    end
    --
    return -2 -- Alias not exist
  end
  --
  return -1 -- Invaid button
end
--
function ui.fExecuteAliasButton(button)
  local alias = nil;
  local type, number = ui.fExpandButton(button)
  --
  ui.fDebug("[&lt;cyan&gt;call&lt;r&gt;] ui.fExecuteAliasButton("..(button or "nil")..")")
  --
  if (type == "a") or (type == "b") or (type == "c") then
    button = type..number
    alias = ui.fSearchAliasButton(button)
    if (alias) then
      expandAlias(alias, false)
    else
      ui.fEcho2n(ui.fGetAliasButtonFormattedText(button).." non configurato. Usare il comanto "..ui.fGetCommandFormattedText(button.." &lt;alias&gt;").." per configurare.")
    end
  end
  --
  return alias
end
--
function ui.fUpdateAliasButton()
  local distance = 3; 
  local w_h = GUI.AliasButtons.Main:get_height() - distance;
  local w_w = GUI.AliasButtons.Main:get_width() -  distance;
  local h = distance + 25
  local w = distance + 80;
  local x = 0
  local y = 0
  local r = 1
  local c = 1
  local tot_r, tot_c
  local total = 10
  --
  ui.fDebug("[&lt;cyan&gt;call&lt;r&gt;] ui.fUpdateAliasButton()")
  --
  tot_c = math.max(1, math.min(math.floor(w_w / w), total));
  -- When working with negative numbers math.floor() returns the closest integer less than or equal to a given value
  tot_r = -math.floor(-total/tot_c);
  --
  -- Recalc w if possible
  w = w_w / tot_c
  --
  -- Recalc h if possible
  h = w_h / tot_r
  --
  for i = 0, 9 do
    if (r &gt; tot_r) then
      GUI.AliasButtons.Main["Button"..i]:hide();
    else
      local title = ""
      local keybind = ""
      local button = ui.parameters.page..i
      --
      for alias in pairs(ui.aliases) do
        if (ui.aliases[alias].button) and (ui.aliases[alias].button==button) then
          title = alias
          keybind = ui.aliases[alias].keybind or ""
          break
        end
      end
      --
      GUI.AliasButtons.Main["Button"..i].index:echo("&lt;center&gt;"..ui.parameters.page..i)
      --
      GUI.AliasButtons.Main["Button"..i].icon:setStyleSheet(GUI.CSS.ButtonsIcon)
      GUI.AliasButtons.Main["Button"..i].icon:echo("&lt;center&gt;"..title)
      --
      GUI.AliasButtons.Main["Button"..i].keybind:echo("&lt;p align=right&gt;"..keybind.."&lt;/p&gt;")
      --
      GUI.AliasButtons.Main["Button"..i]:setStyleSheet([[
        QLabel{
          ]]..GUI.CSS.Button..[[
          background-color: rgb(]]..bgColor[ui.parameters.page]..[[);
        }
        QLabel::hover{
          background-color: rgb(]]..bgColorHover[ui.parameters.page]..[[);
        }
      ]])
      --
      GUI.AliasButtons.Main["Button"..i]:resize(w - distance, h - distance)
      GUI.AliasButtons.Main["Button"..i]:move(distance + (c-1)*w, distance + (r-1)*h)
      GUI.AliasButtons.Main["Button"..i]:show();
      --
      c = c + 1
      if (c &gt; tot_c) then
        c = 1;
        r = r + 1
      end
    end
  end
end
--
function ui.fClickAliasButton(number)
  local button = ui.parameters.page..number
  --
  ui.fDebug("[&lt;cyan&gt;call&lt;r&gt;] ui.fClickAliasButton("..(number or "nil")..")")
  --
  ui.fExecuteAliasButton(button)
end
--
function ui.fOptionButton(buttonName)
  -- Aliases Buttons
  ui.fDebug("[&lt;cyan&gt;call&lt;r&gt;] ui.fOptionButton("..(buttonName or "nil")..")")
  --
  ui.parameters.page = buttonName;
  ui.fUpdateAliasButton()
end
--
-- Debug simulation
if (ui.enDebug) and (ui.enDebug &gt;= 2) then
  ui.fUpdateAliasButton()
end</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>Aliases</name>
					<packageName></packageName>
					<script>--
function ui.fExpandVariables(value, toAlias)
  if (toAlias) then
    value = string.gsub(value, "#", '"..__mtchs2__.."')
    value = string.gsub(value, "["..ui.varID.."@](%w+)", '"..ui.variables.%1.."')
  else
    value = string.gsub(value, "["..ui.varID.."@](%w+)", "ui.variables.%1")
  end
  --
  for varName in string.gfind(value, "ui.variables%.(%w+)") do
    if (not ui.variables[varName]) then
      return nil, varName
    elseif (not toAlias) then
      value = string.gsub(value, "ui.variables%.(%w+)", ui.variables[varName])
    end
  end
  --
  return value, nil
end
--
function ui.fGetAliasNameFormattedText(alias)
  return ui.colors.aliasName..alias.."&lt;r&gt;"
end
--
function ui.fGetAliasOutputFormattedText(command, input)
  if (command) then
    input = input or ""
    --
    -- Add same spaces between commands
    command = string.gsub(command, "(%s*/%s*)", " / ")
    command = string.gsub(command, "(%s*;%s*)", "; ")
    --
    -- Format Aliases
    command = string.gsub(command, "^(%w+)", function(str)
                                               if ui.aliases[str] then
                                                 return ui.fGetAliasNameFormattedText(str)..ui.colors.aliasOutput
                                               end
                                             end)
    command = string.gsub(command, "/ (%w+)", function(str)
                                                if ui.aliases[str] then
                                                  return "/ "..ui.fGetAliasNameFormattedText(str)..ui.colors.aliasOutput
                                                end
                                              end)
    command = string.gsub(command, "; (%w+)", function(str)
                                                if ui.aliases[str] then
                                                  return "; "..ui.fGetAliasNameFormattedText(str)..ui.colors.aliasOutput
                                                end
                                              end)
    --
    -- Format Variables
    command = string.gsub(command, "["..ui.varID.."@](%w+)", function(str)
                                                        if not ui.variables[str] then
                                                          return ui.fGetVarNameFormattedText(str)..ui.fGetOperatorFormattedText("(")..ui.colors.error.."Variabile non trovata!"..ui.fGetOperatorFormattedText(")")..ui.colors.aliasOutput
                                                        else
                                                          return ui.fGetVarFormattedText(str)..ui.colors.aliasOutput
                                                        end
                                                      end)
    --
    -- Format commands separator
    command = string.gsub(command, ";", ui.colors.separator..";"..ui.colors.aliasOutput)
    command = string.gsub(command, "/", ui.colors.separator.."/"..ui.colors.aliasOutput)
    --
    -- Format input command
    command = string.gsub(command, "#", ui.fGetInputFormattedText("#"..input)..ui.colors.aliasOutput)
    --
    return ui.colors.aliasOutput..command.."&lt;r&gt;"
  end
  --
  return ""
end
--
function ui.fGetAliasFormattedText(alias)
  local ret = ""
  --
  if (ui.aliases[alias]) then
    ret = ui.fGetAliasNameFormattedText(alias)
    --
    if (ui.aliases[alias].keybId) then
      ret = ret.." "..ui.fGetOperatorFormattedText("or").." "..ui.fGetKeybFormattedText(ui.aliases[alias].keybind)
    end
    --
    if (ui.aliases[alias].button) then
      ret = ret.." "..ui.fGetOperatorFormattedText("or").." "..ui.fGetAliasButtonFormattedText(ui.aliases[alias].button)
    end
    --
    ret = ret.." "..ui.fGetOperatorFormattedText("»").." "..ui.fGetAliasOutputFormattedText(ui.aliases[alias].text)
  end
  --
  return ret
end
--
-- Cecho Alias with link
function ui.fLinkAlias(alias)
  if (ui.aliases[alias]) then
    cechoLink(ui.cLink(ui.fGetAliasNameFormattedText(alias)), [[expandAlias("]]..alias..[[")]], "Esegui l'alias '"..alias.."'", true)
    cecho(" "..ui.fGetOperatorFormattedText("»").." "..ui.fGetAliasOutputFormattedText(ui.aliases[alias].text))
  end
end
--
-- List all aliases
function ui.fShowAllAliases()
  ui.fDebug("[&lt;cyan&gt;call&lt;r&gt;] ui.fShowAllAliases()")
  --
  cecho(ui.fTitle("Aliases"))
  --
  if (table.is_empty(ui.aliases)) then
    cecho("Per maggiori info "..ui.fGetCommandFormattedText("uihelp uialias").."\n\n")
  else
    local idx = 0
    for alias in ui.fOrderedPairs(ui.aliases) do
      idx = idx + 1
      cecho(ui.fGetNumberFormattedText(idx).." ")
      cechoLink(ui.cLink("X"), [[expandAlias("uialias ]]..alias..[[ remove")]], "Cancella l'alias '"..alias.."'", true)
      cecho(" ")
      ui.fLinkAlias(alias)
      echo("\n")
    end
    echo("\n")
  end
end
--
function ui.fRemoveAlias(alias)
  ui.fDebug("[&lt;cyan&gt;call&lt;r&gt;] ui.fRemoveAlias("..(alias or "nil")..")")
  --
  if (ui.aliases[alias]) then
    ui.fRemoveKeyb(ui.aliases[alias]);
    if (ui.aliases[alias]["id"]) then
      killAlias(ui.aliases[alias]["id"])
    end
    ui.aliases[alias] = nil
    --
    return true
  end
  --
  return false
end
--
function ui.fRemoveAllAliases()
  ui.fDebug("[&lt;cyan&gt;call&lt;r&gt;] ui.fRemoveAllAliases()")
  --
  for alias in pairs(ui.aliases) do
    ui.fRemoveAlias(alias)
  end
  ui.aliases = {}
end
--
function ui.fExpandAlias(alias, value, mtchs, command)
  if (ui.echoed == "") then
    ui.echoed = ui.fGetAliasNameFormattedText(alias).." "..ui.fGetOperatorFormattedText("»").." "..ui.fGetAliasOutputFormattedText(value, mtchs);
    ui.fEcho(ui.echoed);
  else
    cecho(" "..ui.fGetOperatorFormattedText("»").." "..ui.fGetAliasOutputFormattedText(value, mtchs));
    ui.echoed = ui.echoed.." "..ui.fGetOperatorFormattedText("»").." "..ui.fGetAliasOutputFormattedText(value, mtchs)
  end
  expandAlias(command, false);
end
--
function ui.fExpandMultiAlias(idx, alias, value, mtchs, command)
  if (ui.echoed == "") then
    ui.echoed = ui.fGetAliasNameFormattedText(alias)..ui.fGetNumberFormattedText(idx).." "..ui.fGetOperatorFormattedText("»").." "..ui.fGetAliasOutputFormattedText(value, mtchs);
    if (idx &gt; 1) then echo("\n") end
    ui.fEcho(ui.echoed);
  elseif (idx == 1) then
    cecho(ui.fGetNumberFormattedText(idx).." "..ui.fGetOperatorFormattedText("»").." "..ui.fGetAliasOutputFormattedText(value, mtchs));
    ui.echoed = ui.echoed..ui.fGetNumberFormattedText(idx).." "..ui.fGetOperatorFormattedText("»").." "..ui.fGetAliasOutputFormattedText(value, mtchs);
  else
    local s = ui.echoed
    s = string.gsub(s, "\&lt;%w+\&gt;", "")
    s = string.gsub(s, "»", "x");
    s = string.gsub(s, "%S", " ");
    ui.echoed = s..ui.fGetNumberFormattedText(idx).." "..ui.fGetOperatorFormattedText("»").." "..ui.fGetAliasOutputFormattedText(value, mtchs);
    echo("\n")
    ui.fEcho(ui.echoed);
  end
  expandAlias(command, false);
end
--
function ui.fAddAlias(alias, value)
  local command
  local commands, varNameError = ui.fExpandVariables(value, true)
  --
  ui.fDebug("[&lt;cyan&gt;call&lt;r&gt;] ui.fAddAlias("..(alias or "nil")..", "..(value or "nil")..")")
  --
  if (not varNameError) then
    --
    -- Init alias (if no exist)
    ui.aliases[alias] = ui.aliases[alias] or {}
    --
    -- Remove old alias
    if (ui.aliases[alias].id) then
      killAlias(ui.aliases[alias].id)
    end
    --
    -- Save value in text format
    ui.aliases[alias].text = value
    --
    -- Generate alias code
    local code = [[
--
-- Recursion leval
ui.levelCode = ui.levelCode or 0
if (ui.levelCode &gt;= 20) then
  ui.fError("Recursion protection.")
  ui.levelCode = ui.levelCode - 1
  return
end
ui.levelCode = ui.levelCode + 1
--
-- Init
matches = matches or {}
local __mtchs2__ = matches[2] or ""
ui.echoed = ui.echoed or ""
local lstEchoed = ui.echoed
]]
    commands = ui.fExpandCommand(value)
    if (#commands == 1) then
      --
      -- Single command
      command = ui.fExpandVariables(value, true)
      if (string.match(command, "__mtchs2__")) then
        code = code..[[
--
-- Single command with #
ui.fExpandAlias("]]..alias..[[", 
                "]]..value..[[", 
                __mtchs2__, 
                "]]..command..[[");
]]
      else
        --
        -- Search for variables in command
        local last_variable = ""
        local last_expanded_variable = ""
        for variable in string.gfind(command, "ui.variables%.%w+") do
          last_variable = string.gsub(variable, "ui.variables%.", ui.varID)
          last_expanded_variable = variable
        end
        if (last_variable == "") then
          --
          -- If not variables in comman, add matches[2]
          code = code..[[
--
-- Single command without # and without variables
if (__mtchs2__ == "") then
  ui.fExpandAlias("]]..alias..[[", 
                  "]]..value..[[", 
                  __mtchs2__, 
                  "]]..command..[[");
else
  ui.fExpandAlias("]]..alias..[[", 
                  "]]..value..[[ #", 
                  __mtchs2__, 
                  "]]..command..[[".." "..__mtchs2__);
end
]]
        else
          --
          -- If variables in command, replace last variable with matches[2]
          local command_matches = string.gsub(command, last_expanded_variable, "__mtchs2__")
          code = code..[[
--
-- Single command without # but with variables
if (__mtchs2__ == "") then
  ui.fExpandAlias("]]..alias..[[", 
                  "]]..value..[[", 
                  __mtchs2__, 
                  "]]..command..[[");
else
  ui.fExpandAlias("]]..alias..[[", 
                  "]]..string.gsub(value, last_variable, "#")..[[", 
                  __mtchs2__, 
                  "]]..command_matches..[[");
end
]]
        end
      end
      code = code..[[
--
ui.echoed = lstEchoed;
]]

    else
      --
      -- Multiple commands
      code = code..[[
--
-- Multiple commands
]]
      for idx, cmd in ipairs(commands) do
        command = ui.fExpandVariables(cmd, true)
        code = code..[[
ui.fExpandMultiAlias(]]..idx..[[,
                     "]]..alias..[[",
                     "]]..cmd..[[",
                     __mtchs2__, 
                     "]]..command..[[")
--
ui.echoed = lstEchoed;
]]
      end
    end
    code = code..[[
--
if (ui.levelCode == 1) then echo("\n") end;
ui.levelCode = math.max(0, ui.levelCode - 1)
]]
    --
    -- Save alias code (for debug only)
    ui.aliases[alias].code = code
    --
    -- Assign keybind
    local mod1 = ui.aliases[alias].mod1 or "";
    local mod2 = ui.aliases[alias].mod2 or "";
    local key = ui.aliases[alias].key or "";
    local result, keybind
    --
    if (mod2 ~= "") then
      result, keybind = ui.fSetKeyb(ui.aliases, alias, ui.aliases[alias].code, mod2, mod1, key)
    elseif (mod1 ~= "") then
      result, keybind = ui.fSetKeyb(ui.aliases, alias, ui.aliases[alias].code, mod1, key)
    elseif (key ~= "") then
      result, keybind = ui.fSetKeyb(ui.aliases, alias, ui.aliases[alias].code, key)
    else
      result, keybind = ui.fSetKeyb(ui.aliases, alias, ui.aliases[alias].code)
    end
    --
    -- Remove keybind if not valid (or already used)
    if (result &lt;= 0) then
      ui.fRemoveKeyb(ui.aliases[alias])
    end
    --
    -- Create alias
    ui.aliases[alias].id = tempAlias([[^]]..alias..[[(?: (.*))?$]], code)
    --
    return 1, ui.fGetAliasFormattedText(alias)
  end
  --
  return -1, varNameError  -- Variable not exist
end
--
-- Save aliases data from file
function ui.fSaveFileAliases()
  local file = ui.files.aliases.path..ui.files.aliases.name
  local aliasesDataToSave = {}
  --
  ui.fDebug("[&lt;cyan&gt;call&lt;r&gt;] ui.fSaveFileAliases()")
  --
  for alias in pairs(ui.aliases) do
    aliasesDataToSave[alias] = {}
    aliasesDataToSave[alias].text = ui.aliases[alias].text
    aliasesDataToSave[alias].mod1 = ui.aliases[alias].mod1
    aliasesDataToSave[alias].mod2 = ui.aliases[alias].mod2
    aliasesDataToSave[alias].key = ui.aliases[alias].key
    aliasesDataToSave[alias].button = ui.aliases[alias].button
  end
  table.save(file, aliasesDataToSave)
end
--
-- Read Aliases data from file
function ui.fReadFileAliases()
  local file = ui.files.aliases.path..ui.files.aliases.name
  --
  ui.fDebug("[&lt;cyan&gt;call&lt;r&gt;] ui.fReadFileAliases()")
  --
  -- Remove actual Aliases
  ui.aliases = ui.aliases or {}
  ui.fRemoveAllAliases()
  --
  -- Load Aliases
  if (io.exists(file)) then
    table.load(file, ui.aliases)
  end
  --
  -- Create Aliases
  for alias in pairs(ui.aliases) do
    ui.fAddAlias(alias, ui.aliases[alias].text)
  end
end</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>Chat</name>
					<packageName></packageName>
					<script>--
function ui.fUpdateChat()
  ui.fDebug("[&lt;cyan&gt;call&lt;r&gt;] ui.fUpdateChat()")
  --
  if (ui.parameters.widgets.chat.type == "all") then
    GUI.Chat.Button_split:show();
    --
    if (ui.parameters.widgets.chat.split == "horizontal") then
      GUI.Chat.Main.All:hide()
      --
      GUI.Chat.Main.Private:move(0, 0);
      GUI.Chat.Main.Private:resize("100%", "50%-4")
      GUI.Chat.Main.Private:show()
      --
      GUI.Chat.Split_line:move(0, "50%-2");
      GUI.Chat.Split_line:resize("100%", 4)
      GUI.Chat.Split_line:show()
      --
      GUI.Chat.Main.Public:move(0, "50%+4");
      GUI.Chat.Main.Public:resize("100%", "50%-4")
      GUI.Chat.Main.Public:show()
      --
      GUI.Chat:setTitle("Chat [private - pubblic]")
    --
    elseif (ui.parameters.widgets.chat.split == "vertical") then
      GUI.Chat.Main.All:hide()
      --
      GUI.Chat.Main.Private:move(0, 0);
      GUI.Chat.Main.Private:resize("50%-4", "100%")
      GUI.Chat.Main.Private:show()
      --
      GUI.Chat.Split_line:move("50%-2", 0);
      GUI.Chat.Split_line:resize(4, "100%")
      GUI.Chat.Split_line:show()
      --
      GUI.Chat.Main.Public:move("50%+4", 0);
      GUI.Chat.Main.Public:resize("50%-4", "100%")
      GUI.Chat.Main.Public:show()
      --
      GUI.Chat:setTitle("Chat [private | pubblic]")
    --
    else
      GUI.Chat.Main.All:move(0, 0);
      GUI.Chat.Main.All:resize("100%", "100%")
      GUI.Chat.Main.All:show()
      --
      GUI.Chat.Main.Public:hide()
      --
      GUI.Chat.Split_line:hide()
      --
      GUI.Chat.Main.Private:hide()
      --
      GUI.Chat:setTitle("Chat [private + pubblic]")
    end
  --
  elseif (ui.parameters.widgets.chat.type == "public") then
    GUI.Chat.Button_split:hide();
    --
    GUI.Chat.Main.All:hide()
    --
    GUI.Chat.Main.Public:move(0, 0);
    GUI.Chat.Main.Public:resize("100%", "100%")
    GUI.Chat.Main.Public:show()
    --
    GUI.Chat.Split_line:hide()
    --
    GUI.Chat.Main.Private:hide()
    --
    GUI.Chat:setTitle("Chat [pubblic]")
  else
    GUI.Chat.Button_split:hide();
    --
    GUI.Chat.Main.All:hide()
    --
    GUI.Chat.Main.Public:hide()
    --
    GUI.Chat.Split_line:hide()
    --
    GUI.Chat.Main.Private:move(0, 0);
    GUI.Chat.Main.Private:resize("100%", "100%")
    GUI.Chat.Main.Private:show()
    --
    GUI.Chat:setTitle("Chat [private]")
  end
  --
  GUI.Chat.Button_type:echo("&lt;center&gt;"..ui.parameters.widgets.chat.type);
end
--
function ui.fChatTypeClicked()
  ui.fDebug("[&lt;cyan&gt;call&lt;r&gt;] ui.fChatTypeClicked()")
  --
  if (ui.parameters.widgets.chat.type == "all") then
    ui.parameters.widgets.chat.type = "public"
  elseif (ui.parameters.widgets.chat.type == "public") then
    ui.parameters.widgets.chat.type = "private"
  else
    ui.parameters.widgets.chat.type = "all"
  end
  --
  ui.fUpdateChat()
  --
  ui.fSaveFileParameters()
end
--
function ui.fChatSplitClicked()
  ui.fDebug("[&lt;cyan&gt;call&lt;r&gt;] ui.fChatSplitClicked()")
  --
  if (ui.parameters.widgets.chat.split == "no") then
    ui.parameters.widgets.chat.split = "vertical";
  elseif (ui.parameters.widgets.chat.split == "vertical") then
    ui.parameters.widgets.chat.split = "horizontal";
  else
    ui.parameters.widgets.chat.split = "no"
  end
  --
  ui.fUpdateChat()
  --
  ui.fSaveFileParameters()
end</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>Cooldowns</name>
					<packageName></packageName>
					<script>--
function ui.fRefreshCooldownsWidget()
  ui.fDebug("[&lt;cyan&gt;call&lt;r&gt;] ui.fRefreshCooldownsWidget()")
  --
  local distance = 2; 
  local min_w = 100;
  local max_w = 150;
  local w_h = GUI.Cooldowns.Main:get_height() - distance;
  local w_w = GUI.Cooldowns.Main:get_width() -  distance;
  local h = distance + 20;
  local w = distance + min_w;
  local x = 0
  local y = 0
  local r = 1
  local c = 1
  local tot_r, tot_c, total
  local orderTable = {}
  --
  -- Order Affects
  for cooldown in pairs(ui.cooldowns) do
    orderTable[#orderTable+1] = cooldown;
  end
  table.sort(orderTable, function (cooldown1, cooldown2)
                           return ui.cooldowns[cooldown1].duration &lt; ui.cooldowns[cooldown2].duration
                         end )
  --
  --
  total = math.min(#orderTable, 10);
  tot_r = math.max(1, math.min(math.floor(w_h / h), total));
  tot_c = math.max(1, math.min(math.floor(w_w / w), total));
  --
  -- Recalc w
  w = math.min(w_w / tot_c, distance + max_w)
  --
  for i = 1, 10 do
    --
    -- Show if inside box
    if (r &gt; tot_r) or (i &gt; total) then
      GUI.Cooldowns.Main["Item"..i]:hide();
    else
      local cooldown = orderTable[i]
      local roundToDisplay = math.floor(ui.cooldowns[cooldown].duration);
      --
      if (ui.cooldowns[cooldown].duration - roundToDisplay &gt; 0) then
        roundToDisplay = roundToDisplay + 1;
      end
      --
      GUI.Cooldowns.Main["Item"..i].front:echo("")
      GUI.Cooldowns.Main["Item"..i]:setValue(ui.cooldowns[cooldown].duration, ui.cooldowns[cooldown].maxDuration,"&lt;p align=center&gt;"..cooldown.." "..roundToDisplay.."&lt;/p&gt;")
      --
      GUI.Cooldowns.Main["Item"..i]:move(distance + (c-1)*w, distance + (r-1)*h)
      GUI.Cooldowns.Main["Item"..i]:resize(w - distance, h - distance)
      GUI.Cooldowns.Main["Item"..i]:show()
      --
      c = c + 1
      if (c &gt; tot_c) then
        c = 1;
        r = r + 1
      end
    end
  end
end
--
function ui.fUpdateCooldowns()
  ui.fDebug("[&lt;cyan&gt;call&lt;r&gt;] ui.fUpdateCooldowns()")
  --
  -- GMCP
  if (gmcp) and (gmcp.char) and (gmcp.char.cooldowns) then
    --
    ui.previous.cooldowns = table.deepcopy(ui.cooldowns or {});
    ui.cooldowns = {}
    --
    for cooldown in pairs(gmcp.char.cooldowns) do
      local name = string.gsub(gmcp.char.cooldowns[cooldown].name, "(%a)([%w_']*)", ui.fTitleCase)
      --
      ui.cooldowns[name] = {}
      ui.cooldowns[name].duration = tonumber(gmcp.char.cooldowns[cooldown].duration)
      if (ui.previous.cooldowns[name] == nil) then
        ui.cooldowns[name].maxDuration = ui.cooldowns[name].duration
      else
        ui.cooldowns[name].maxDuration = ui.previous.cooldowns[name].maxDuration
      end
    end
  else
    --
    ui.cooldowns = ui.cooldowns or {}
  end
  --
  ui.fRefreshCooldownsWidget()
end</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>Colors</name>
					<packageName></packageName>
					<script>--
-- Coded by Mudlet community developer demonnic
-- internal sorting function, sorts first by hue, then luminosity, then value
local sortColorsByHue = function(lhs, rhs)
  local lh, ll, lv = unpack(lhs.sort)
  local rh, rl, rv = unpack(rhs.sort)
  --
  if lh &lt; rh then
    return true
  elseif lh &gt; rh then
    return false
  elseif ll &lt; rl then
    return true
  elseif ll &gt; rl then
    return false
  else
    return lv &lt; rv
  end
end
--
-- Internal sorting function, removes _ from snake_case and compares to camelCase
local sortColorsByName = function(a, b)
  local aname = string.gsub(string.lower(a.name), "_", "")
  local bname = string.gsub(string.lower(b.name), "_", "")
  --
  return aname &lt; bname
end
--
-- Internal function used to turn sorted colors table into columns
local chunkify = function(tbl, num_chunks)
  local pop =
    function(t)
      return table.remove(t, 1)
    end
  local tbl = table.deepcopy(tbl)
  local tblsize = #tbl
  local base_chunk_size = tblsize / num_chunks
  local chunky_chunks = tblsize % num_chunks
  local chunks = {}
  --
  for i = 1, num_chunks do
    local chunk_size = base_chunk_size
    if i &lt;= chunky_chunks then
      chunk_size = chunk_size + 1
    end
    local chunk = {}
    for j = 1, chunk_size do
      chunk[j] = pop(tbl)
    end
    chunks[i] = chunk
  end
  --
  return chunks
end
--
-- internal function, converts rgb to hsv
-- found at https://github.com/EmmanuelOga/columns/blob/master/utils/color.lua#L89
local rgbToHsv = function(r, g, b)
  r, g, b = r / 255, g / 255, b / 255
  local max, min = math.max(r, g, b), math.min(r, g, b)
  local h, s, v
  v = max
  local d = max - min
  if max == 0 then
    s = 0
  else
    s = d / max
  end
  if max == min then
    h = 0
    -- achromatic
  else
    if max == r then
      h = (g - b) / d
      if g &lt; b then
        h = h + 6
      end
    elseif max == g then
      h = (b - r) / d + 2
    elseif max == b then
      h = (r - g) / d + 4
    end
    h = h / 6
  end
  --
  return h, s, v
end
--
-- internal stepping function, removes some of the noise for a more pleasing sort
-- cribbed from the python on https://www.alanzucconi.com/2015/09/30/colour-sorting/
local step = function(r, g, b)
  local lum = math.sqrt(.241 * r + .691 * g + .068 * b)
  local reps = 8
  local h, s, v = rgbToHsv(r, g, b)
  local h2 = math.floor(h * reps)
  local lum2 = math.floor(lum * reps)
  local v2 = math.floor(v * reps)
  --
  if h2 % 2 == 1 then
    v2 = reps - v2
    lum2 = reps - lum2
  end
  --
  return h2, lum2, v2
end
--
local function calc_luminosity(r, g, b)
  r = r &lt; 11 and r / (255 * 12.92) or ((0.055 + r / 255) / 1.055) ^ 2.4
  g = g &lt; 11 and g / (255 * 12.92) or ((0.055 + g / 255) / 1.055) ^ 2.4
  b = b &lt; 11 and b / (255 * 12.92) or ((0.055 + b / 255) / 1.055) ^ 2.4
  --
  return (0.2126 * r) + (0.7152 * g) + (0.0722 * b)
end
--
local function include(color, options)
  if options.removeDupes then
    if string.find(color, "_") or string.find(color:lower(), 'gray') then
      return false
    else
      return true
    end
  else
    if string.find(color, "ansi_%d%d%d") then
      return false
    else
      return true
    end
  end
end
--
local function echoColor(color, options)
  local rgb = color.rgb
  local fgc = "white"
  --
  if calc_luminosity(unpack(rgb)) &gt; 0.5 then
    fgc = "black"
  end
  local colorString
  if options.justText then
    colorString = string.format('&lt;%s:%s&gt; %-23s&lt;r&gt; ', color.name, 'black', color.name, spacer)
  else
    colorString = string.format('&lt;%s:%s&gt; %-23s&lt;r&gt; ', fgc, color.name, color.name)
  end
  if options.window == "main" then
    if options.echoOnly then
      cecho(colorString)
    else
      cechoLink(
        colorString, [[appendCmdLine("]]..color.name..[[")]], table.concat(rgb, ", "), true
      )
    end
  else
    if options.echoOnly then
      cecho(options.window, colorString)
    else
      cechoLink(
        options.window,
        colorString,
        [[appendCmdLine("]]..color.name..[[")]],
        table.concat(rgb, ", "),
        true
      )
    end
  end
end
--
function ui.fDisplayColors(options)
  local options = options or {}
  local optionsType = type(options)
  --
  assert(
    optionsType == "table",
    "ui.fDisplayColors(options) argument error: options as table expects, got "..optionsType
  )
  options.cols = options.cols or 4
  options.search = options.search or ""
  options.sort = options.sort or false
  if options.removeDupes == nil then
    options.removeDupes = true
  end
  if options.columnSort == nil then
    options.columnSort = true
  end
  if type(options.window) == "table" then
    options.window = options.window.name
  end
  options.window = options.window or "main"
  local color_table = options.color_table or color_table
  local cols, search, sort = options.cols, options.search, options.sort
  local colors = {}
  for k, v in pairs(color_table) do
    local color = {}
    color.rgb = v
    color.name = k
    color.sort = {step(unpack(v))}
    if include(k, options) and k:lower():find(search) then
      table.insert(colors, color)
    end
  end
  if sort then
    table.sort(colors, sortColorsByName)
  else
    table.sort(colors, sortColorsByHue)
  end
  if options.columnSort then
    local columns_table = chunkify(colors, cols)
    local lines = #columns_table[1]
    for i = 1, lines do
      for j = 1, cols do
        local color = columns_table[j][i]
        if color then
          echoColor(color, options)
        end
      end
      echo(options.window, "\n")
    end
  else
    local i = 1
    for _, k in ipairs(colors) do
      echoColor(k, options)
      if i == cols then
        echo(options.window, "\n")
        i = 1
      else
        i = i + 1
      end
    end
    if i ~= 1 then
      echo(options.window, "\n")
    end
  end
end
--
-- Check color
function ui.fColorCheck(color)
  local color = color:lower()
  --
  color = color:gsub("_", "")
  for color_name, _ in pairs(color_table) do
    if color_name:lower() == color then
      return color_name
    end
  end
  --
  return false
end
</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>Endowment</name>
					<packageName></packageName>
					<script>local replacements = {
	["DAc"] = "Danno Acido",
	["DCh"] = "Danno Caos",
	["DEl"] = "Danno Elettricita'",
	["DEn"] = "Danno Energia",
	["DFr"] = "Danno Freddo",
	["DFu"] = "Danno Fuoco",
	["DIm"] = "Danno Impatto",
	["DLu"] = "Danno Lumen",
	["DNa"] = "Danno Natura",
	["DPe"] = "Danno Perforazione",
	["DPs"] = "Danno Psichico",
	["DTa"] = "Danno Taglio",
	["DTr"] = "Danno Trauma",
	["DUm"] = "Danno Umbra",
	["Dmg"] = "Danno Fisico",

	["EEl"] = "Efficacia Elettricita'",
	["EFr"] = "Efficacia Freddo",
	["EFu"] = "Efficacia Fuoco",

	["RAc"] = "Resistenza Acido",
	["RCh"] = "Resistenza Caos",
	["RDi"] = "Resistenza danni Divini",
	["REl"] = "Resistenza Elettricita'",
	["REm"] = "Resistenza danni Elementali",
	["REn"] = "Resistenza Energia",
	["RFr"] = "Resistenza Freddo",
	["RFs"] = "Resistenza al Fisico",
	["RFu"] = "Resistenza Fuoco",
	["RIm"] = "Resistenza Impatto",
	["RLu"] = "Resistenza Lumen",
	["RMg"] = "Resistenza Magici",
	["RNa"] = "Resistenza Natura",
	["RPe"] = "Resistenza Perforazione",
	["RPs"] = "Resistenza danno Psichico",
	["RTT"] = "Resistenza Tutto",
	["RTa"] = "Resistenza Taglio",
	["RTr"] = "Resistenza Trauma",
	["RUm"] = "Resistenza Umbra",

	["For"] = "Forza",
	["Des"] = "Destrezza",
	["Cos"] = "Costituzione",
	["Int"] = "Intelligenza",
	["Sag"] = "Saggezza",
	["Car"] = "Carisma",

	["Let"] = "Letalita'",
	["Ast"] = "Astuzia",
	["Vit"] = "Vitalità",
	["Per"] = "Percezione",
	["Prc"] = "Precisione",
	["Pen"] = "Penetrazione",

	["Arm"] = "Classe Armatura",
	["Crt"] = "Colpo Critico",
	["CCF"] = "Corpo a Corpo Fisico",
	["CCM"] = "Corpo a Corpo Magico",
	["IsA"] = "Incantesimo su Arma",
	["PdG"] = "Pittura di Guerra",
	["Mag"] = "Potere Magico",
	["Spc"] = "Potere Speciale",
	["BSc"] = "Bloccare con lo Scudo",
	["Nms"] = "Nemesi",

	["PfR"] = "Recupero Punti Ferita",
	["MnR"] = "Recupero Mana",
	["MvR"] = "Recupero Movimento",

	["PF"]	= "Punti Ferita",
	["Mn"]	= "Mana", 
	["Mv"]	= "Movimento", 
}
--
function ui.fIsStatistics(s)
  s = ansi2string(decho2ansi(s))
  --
  for k, i in pairs(replacements) do
    s = string.gsub(s, k, "")       -- statistics
  end
  --
  s = string.gsub(s, "%d+d%d+", "") -- dices
  --
  s = string.gsub(s, "-?%d+", "")   -- values
  --
  s = string.gsub(s, " ", "")       -- white space
  --
  return (string.len(s) == 0)
end
--
function ui.fUpdateEndowment()
  ui.fDebug("[&lt;cyan&gt;call&lt;r&gt;] ui.fUpdateEndowment()")
  --
  local distance = 2; 
  local min_w = 100;
  local max_w = 150;
  local w_h = GUI.Endowment.Main:get_height() - distance;
  local w_w = GUI.Endowment.Main:get_width() -  distance;
  local h = distance + 28;
  local w = distance + min_w;
  local x = 0
  local y = 0
  local r = 1
  local c = 1
  local tot_r, tot_c, total
  local orderTable = {}
  --
  -- Order Items
  for item in pairs(ui.equipment) do
    if (ui.equipment[item].used) then
      orderTable[#orderTable+1] = item
    end
  end
  --
  table.sort(orderTable, function (item1, item2)
                           return (ui.equipment[item1].number &lt; ui.equipment[item2].number)
                         end )
  --
  total = math.min(#orderTable, 25);
  tot_r = math.max(1, math.min(math.floor(w_h / h), total));
  tot_c = math.max(1, math.min(math.floor(w_w / w), total));
  --
  -- Recalc w 
  w = math.min(w_w / tot_c, distance + max_w)
  --
  for i = 1, 25 do
    --
    -- Show if inside box
    if (r &gt; tot_r) or (i &gt; total) then
      GUI.Endowment.Main["Item"..i]:hide();
    else
      local item = orderTable[i]
      --
      -- Number
      GUI.Endowment.Main["Item"..i].Index:echo("&lt;center&gt;"..ui.equipment[item].number)
      --
      -- Status
      GUI.Endowment.Main["Item"..i].Status:echo("&lt;center&gt;"..ui.equipment[item].status)
      --
      -- Name
      GUI.Endowment.Main["Item"..i].Text:echo("&lt;center&gt;"..string.gsub(ui.fRemoveArticle(ui.equipment[item].name), "(%a)([%w_']*)", ui.fTitleCase));
      --
      -- Level
      GUI.Endowment.Main["Item"..i].Level:echo("&lt;center&gt;"..ui.equipment[item].level);
      --
      -- Slot
      GUI.Endowment.Main["Item"..i].Slot:echo("&lt;center&gt;"..ui.equipment[item].short);
      --
      -- Type (determinate color)
      local BGColor = "grey"
      local t = ansi2string(decho2ansi(ui.equipment[item].type))
      --
      -- T = Trash, C = common, U = Uncommon, R = Rare, E = Epic, L = Leggend
      if (t == "C") then
        t = "&lt;color=white&gt;Comune&lt;/color&gt;"
        BGColor = "white"
      elseif (t == "U") then
        t = "Non comune"
        BGColor = "lime"
      elseif (t == "R") then
        t = "Raro"
        BGColor = "rgb(58,120,242)"
      elseif (t == "E") then
        t = "Epico"
        BGColor = "blue"
      elseif (t == "L") then
        t = "Leggendario"
        BGColor = "orange"
      elseif (t == "S") then
        t = "Set astrale"
        BGColor = "yellow"        
      elseif (t == "A") then
        t = "Astrale"
        BGColor = "cyan"        
      else
        t = "Spazzatura"
        BGColor = "grey"
      end
      --
      -- BorderColor
      local borderColor = "rgb("..ui.colors.wBorder..")"
      local status = string.gsub(ui.equipment[item].status, "%%", "")
      --
      status = tonumber(status)
      if (status &lt; 20) then
        borderColor = "brown"
      elseif (status &lt; 40) then
        borderColor = "red"
      elseif (status &lt; 60) then
        borderColor = "orange"
      elseif (status &lt; 80) then
        borderColor = "yellow"
      elseif (status &lt; 100) then
        borderColor = "green"
      end
      --
      -- CSS
      GUI.Endowment.Main["Item"..i].Text:setStyleSheet(GUI.CSS.ItemText..[[
              background-color: ]]..BGColor..[[;
            ]])
      --
      GUI.Endowment.Main["Item"..i]:setStyleSheet([[QLabel{
        ]]..GUI.CSS.Item..[[
        background-color: ]]..BGColor..[[;
        border: 2px outset ]]..borderColor..[[;
      }]])        
      --
      -- Stat for ToolTip
      local stat = ""
      if (ui.equipment[item].stat) and (ui.equipment[item].stat ~= "") then
        stat = "&lt;lu&gt;"..ansi2string(decho2ansi(ui.equipment[item].stat)).."&lt;/lu&gt;"
        stat = string.gsub(stat, "(-?%d+ %S+)", "&lt;li&gt;▷ %1&lt;/li&gt;")      -- Numeric value
        stat = string.gsub(stat, "(%d+d%d+)", "&lt;li&gt;▷ %1 Danno&lt;/li&gt;")  -- Dice ('x'd'y')
        stat = string.gsub(stat, "[a-zA-Z]+", replacements)           -- Stat
      end
      --
      -- ToolTip
      local toolTip = '&lt;p style="text-align: center;"&gt;&lt;br&gt;&lt;b&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;'..string.upper(ansi2string(decho2ansi(ui.equipment[item].name)))..'&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/b&gt;&lt;br&gt;'..
                      '&lt;i&gt;Indossato &amp;lt;'..ui.equipment[item].slot..'&amp;gt;&lt;/i&gt;&lt;/p&gt;'..
                      stat..
                      '&lt;p style="text-align: right;"&gt;&lt;i&gt;'..t..'&lt;/i&gt; [Liv. '..ui.equipment[item].level..']&lt;/p&gt;'
      --
      -- ToolTip identificated object
      if (ui.identification) then
        toolTip = toolTip.."&lt;hr&gt;"..
        '&lt;p style="text-align: center;"&gt;&lt;b&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;'..string.upper(ui.identification.name or "no name")..'&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/b&gt;&lt;br&gt;'..
        '&lt;i&gt;Identificato &amp;lt;'..(ui.identification.slot or '-')..'&amp;gt;&lt;/i&gt;&lt;/p&gt;'
        if (ui.identification.bonus) then
          toolTip = toolTip.."&lt;lu&gt;"
          for _, i in pairs(ui.identification.bonus) do
            toolTip = toolTip.."&lt;li&gt;▷ "..i.."&lt;/li&gt;"
          end
          toolTip = toolTip.."&lt;/lu&gt;"
        end
        toolTip = toolTip..'&lt;p style="text-align: right;"&gt;&lt;i&gt;'..'RARITA'..'&lt;/i&gt; [Liv. '..(ui.identification.level or '-')..']&lt;/p&gt;'              
      end
      --
      GUI.Endowment.Main["Item"..i]:setToolTip(toolTip, 10);
      --
      GUI.Endowment.Main["Item"..i]:resize(w - distance, h - distance)
      GUI.Endowment.Main["Item"..i]:move(distance + (c-1)*w, distance + (r-1)*h)
      GUI.Endowment.Main["Item"..i]:show();
      --
      c = c + 1
      if (c &gt; tot_c) then
        c = 1;
        r = r + 1
      end
    end
  end
end
--
function ui.fEndowmentTypeClicked()
  ui.fDebug("[&lt;cyan&gt;call&lt;r&gt;] ui.fEndowmentTypeClicked()")
  --
  if (ui.parameters.widgets.endowment.type == "equip") then
    ui.parameters.widgets.endowment.type = "inv"
  else
    ui.parameters.widgets.endowment.type = "equip"
  end
  --
  ui.fUpdateEndowment()
  --
  ui.fSaveFileParameters()
end</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>Generic</name>
					<packageName></packageName>
					<script>function ui.fInitDataDirectory()
  local lfs = require("lfs")
  --
  ui.fDebug("[&lt;cyan&gt;call&lt;r&gt;] ui.fInitDataDirectory()")
  --
  if (lfs.chdir(ui.files.data.path)) then
    ui.fDebug("ui.fInitProfiles() - Cartella dati inizializzata correttamente.")
  elseif (lfs.mkdir(ui.files.data.path)) then
    ui.fDebug("ui.fInitProfiles() - Cartella dati creata correttamente.")
  else
    ui.fDebug("ui.fInitProfiles() - Impossibile caricare la cartella dati.")
  end
end
--
function ui.fGenOrderedIndex( t )
  local orderedIndex = {}
  --
  for key in pairs(t) do
    table.insert(orderedIndex, key)
  end
  --
  table.sort(orderedIndex)
  --
  return orderedIndex
end
--
function ui.fOrderedNext(t, state)
  -- Equivalent of the next function, but returns the keys in the alphabetic
  -- order. We use a temporary ordered key table that is stored in the
  -- table being iterated.
  local key = nil
  --
  if (state == nil) then
    --
    -- First time, generate the index
    t.__orderedIndex = ui.fGenOrderedIndex(t)
    key = t.__orderedIndex[1]
  else
    --
    -- Fetch the next value
    for i = 1,table.getn(t.__orderedIndex) do
      if t.__orderedIndex[i] == state then
        key = t.__orderedIndex[i+1]
      end
    end
  end
  --
  if (key) then
    return key, t[key]
  end
  --
  -- No more value to return, cleanup
  t.__orderedIndex = nil
  --
  return
end
--
function ui.fOrderedPairs(t, state)
  -- Equivalent of the pairs() function on tables. Allows to iterate in order
  return ui.fOrderedNext, t, state
end
--
function ui.fFormatEcho(text, level)
  local tab = ""
  --
  if (level) and (level &gt; 0) then 
    for i=2, level do
      tab = tab.."    "
    end
    tab = tab..ui.fGetOperatorFormattedText("  » ")
  end
  --
  return ui.echo..tab..ui.colors.text..text.."&lt;r&gt;"
end
--
function ui.fEcho(text, level)
  cecho(ui.fFormatEcho(text, level))
end
--
function ui.fEchon(text, level)
  cecho(ui.fFormatEcho(text, level).."\n")
end
--
function ui.fEcho2n(text, level)
  cecho(ui.fFormatEcho(text, level).."\n\n")
end
--
function ui.fDecho(text)
  text = copy2decho(ui.echo..ui.colors.text)..text..copy2decho("&lt;r&gt;").."\n\n"
  decho(text)
end
--
function ui.fDebug(text, level)
  level = level or 1
  --
  if (ui.enDebug &gt;= level) then
    ui.fEchon("&lt;orange&gt;[DEBUG ] &lt;white&gt;("..getTime(true, "hh:mm:ss.zzz")..") "..ui.colors.text..text.."&lt;r&gt;")
  end
end
--
function ui.fLog(text)
  text = "\n&lt;128,128,128:"..ui.colors.wBackground.."&gt;"..os.date("%H:%M:%S").." - &lt;255,255,255:"..ui.colors.wBackground.."&gt;"..text.."\n"
  --
  GUI.Chat.Main.All:decho(text)
  GUI.Chat.Main.Private:decho(text)
  --GUI.Chat.Main.Public:decho(text)
end
--
function ui.fError(text)
  text = ui.echo..ui.colors.error.."[ERRORE] "..ui.colors.text..text.."&lt;r&gt;\n\n"
  --
  cecho(text)
end
--
function ui.fTitle(text)
  local title = "\n"..ui.echo..ui.colors.title..text.."\n"
  --
  text = string.gsub(ui.echo..text, "\&lt;%a+\&gt;", "")
  for i=1, text:len() do
    title = title.."-"
  end
  title = title.."\n"
  --uih
  return title
end
--
function ui.fdigitNumber(number, digit)
  number = ""..(number or "")
  digit = tonumber(digit or 2) or 2;
  --
  for i = string.len(number), digit-1 do
    number = " "..number
  end
  --
  return number
end
--
function ui.fGetNumberFormattedText(number, digit)
  return "&lt;ansiMagenta&gt;[&lt;white&gt;"..ui.fdigitNumber(number, digit).."&lt;ansiMagenta&gt;]".."&lt;r&gt;"
end
--
function ui.fRemoveArticle(text)
  text = " "..text.." "
  text = string.gsub(text, "&gt;", "&gt; ")
  text = string.gsub(text, " [aA] ", " ")
  text = string.gsub(text, " [aA][dD] ", " ")
  text = string.gsub(text, " [aA][lL] ", " ")
  text = string.gsub(text, " [cC][oO][nN] ", " ")
  text = string.gsub(text, " [dD]'", " ")
  text = string.gsub(text, " [dD][aA] ", " ")
  text = string.gsub(text, " [dD][iI] ", " ")
  text = string.gsub(text, " [dD][eE][iI] ", " ")
  text = string.gsub(text, " [dD][eE][lL] ", " ")
  text = string.gsub(text, " [dD][eE][lL][lL]'", " ")
  text = string.gsub(text, " [dD][eE][gG][lL][iI] ", " ")
  text = string.gsub(text, " [dD][eE][lL][lL][aA] ", " ")
  text = string.gsub(text, " [dD][eE][lL][lL][eE] ", " ")
  text = string.gsub(text, " [dD][eE][lL][lL][oO] ", " ")
  text = string.gsub(text, " [eE] ", " ")
  text = string.gsub(text, " [gG][lL][iI] ", " ")
  text = string.gsub(text, " [iI] ", " ")
  text = string.gsub(text, " [iI][lL] ", " ")
  text = string.gsub(text, " [iI][nN] ", " ")
  text = string.gsub(text, " [lL]'", " ")
  text = string.gsub(text, " [lL][aA] ", " ")
  text = string.gsub(text, " [lL][eE] ", " ")
  text = string.gsub(text, " [lL][oO] ", " ")
  text = string.gsub(text, " [pP][aA][iA][oOaA] ", " ")
  text = string.gsub(text, " [uU][nN] ", " ")
  text = string.gsub(text, " [uU][nN]'", " ")
  text = string.gsub(text, " [uU][nN][aA] ", " ")
  text = string.gsub(text, " [uU][nN][oO] ", " ")
  text = string.gsub(text, "&gt; ", "&gt;")
  text = string.trim(text)
  --
  return text
end
--
function ui.fParsingItem(text)
  --local status = 8
  --
  text = string.gsub(text, "%.%.%.", "")
  --[[
  if (string.find(text, "indistruttibil")) then
    text = string.gsub(text, "E` indistruttibile!", "")
    text = string.gsub(text, "Sono indistruttibili!", "")
    status = 9
  elseif (string.find(text, "in condizioni eccellenti")) then
    text = string.gsub(text, "E` in condizioni eccellenti", "")
    text = string.gsub(text, "Sono in condizioni eccellenti", "")
    status = 8
  elseif (string.find(text, "in ottime condizioni")) then
    text = string.gsub(text, "E` in ottime condizioni", "")
    text = string.gsub(text, "Sono in ottime condizioni", "")
    status = 7
  elseif (string.find(text, "danni superficiali")) then
    text = string.gsub(text, "Presenta danni superficiali", "")
    text = string.gsub(text, "Presentano danni superficiali", "")
    status = 6
  elseif (string.find(text, "danneggiat")) then
    text = string.gsub(text, "E` danneggiato ed usurato", "")
    text = string.gsub(text, "Sono danneggiati ed usurati", "")
    status = 5
  elseif (string.find(text, "in pessime condizioni")) then
    text = string.gsub(text, "E` in pessime condizioni", "")
    text = string.gsub(text, "Sono in pessime condizioni", "")
    status = 4
  elseif (string.find(text, "bisogno di essere riparat")) then
    text = string.gsub(text, "Ha bisogno di essere riparato", "")
    text = string.gsub(text, "Hanno bisogno di essere riparati", "")
    status = 3
  elseif (string.find(text, "per cadere in pezzi")) then
    text = string.gsub(text, "Sta per cadere in pezzi", "")
    text = string.gsub(text, "Stanno per cadere in pezzi", "")
    status = 2
  elseif (string.find(text, "rompersi da un momento all'altro")) then
    text = string.gsub(text, "Potrebbe rompersi da un momento all'altro!", "")
    text = string.gsub(text, "Potrebbero rompersi da un momento all'altro!", "")
    status = 1
  elseif (string.find(text, "in frantumi. Inutilizzabil")) then
    text = string.gsub(text, "E` in frantumi. Inutilizzabile!", "")
    text = string.gsub(text, "Sono in frantumi. Inutilizzabili!", "")
    status = 0
  end
  ]]
  --
  local good = string.find(text, "luce blu")
  if (good) then
    text = string.gsub(text, "Ha un alone di &lt;r&gt;&lt;[%d,:]+&gt;luce blu", "")
    text = string.gsub(text, "Hanno un alone di &lt;r&gt;&lt;[%d,:]+&gt;luce blu", "")
  end
  --
  local evil = string.find(text, "luce rossa")
  if (evil) then
    text = string.gsub(text, "Ha un alone di &lt;r&gt;&lt;[%d,:]+&gt;luce rossa", "")
    text = string.gsub(text, "Hanno un alone di &lt;r&gt;&lt;[%d,:]+&gt;luce rossa", "")
  end
  --
  local bright = string.find(text, "alone luminoso")
  if (bright) then
    text = string.gsub(text, "Ha un &lt;r&gt;&lt;[%d,:]+&gt;alone luminoso", "")
    text = string.gsub(text, "Hanno un &lt;r&gt;&lt;[%d,:]+&gt;alone luminoso", "")
  end
  --
  local noisy = string.find(text, "forte ronzio")
  if (noisy) then
    text = string.gsub(text, "Emette un &lt;r&gt;&lt;[%d,:]+&gt;forte ronzio", "")
    text = string.gsub(text, "Emettono un &lt;r&gt;&lt;[%d,:]+&gt;forte ronzio", "")
  end
  --
  local brittle = string.find(text, "molto fragil")
  if (brittle) then
    text = string.gsub(text, "Sembra molto fragile", "")
    text = string.gsub(text, "Sembrano molto fragili", "")
  end
  --
  text = string.gsub(text, "&lt;[%d,:]+&gt;&lt;r&gt;", "")
  --text = ui.fRemoveArticle(text)
  --
  return text, --[[status,]] good, evil, bright, noisy, brittle
end
--
function ui.fGetCommandFormattedText(command)
  return ui.colors.command..command.."&lt;r&gt;"
end
--
function ui.fGetOperatorFormattedText(operator)
  return ui.colors.operator..operator.."&lt;r&gt;"
end
--
function ui.fGetInputFormattedText(input)
  return ui.colors.input..input.."&lt;r&gt;"
end
--
function ui.fExpandCommand(value)
  if string.match(value, "/") then
    return string.split(value, "%s*/%s*")
  end
  --
  return string.split(value, "%s*;%s*")
end
--
function ui.fTitleCase(first, rest)
   return first:upper()..rest:lower()
end
--
function ui.fExecutePath(table, option)
  if (not option) then
    --
    -- execute all
    for i = 1, #table do
      expandAlias(table[i])
    end
  else
    local itemNumber = tonumber(option)
    if (itemNumber) then
      if (itemNumber == 0) then
        --
        -- Show all
        for i = 1, #table do
          cecho(ui.fGetNumberFormattedText(i).." "..ui.fGetAliasOutputFormattedText(table[i]).."\n")
        end
      elseif (itemNumber &gt;= 1) and (itemNumber &lt;= #table) then
        expandAlias(table[itemNumber])
      else
        ui.fError("Indice non valido.")
      end
    else
      --
      -- execute command for all (es. tell Pippo)
      for i = 1, #table do
        send(option.." "..i..") "..table[i]:gsub("(%s*;%s*)", " | "))
      end    
    end
  end
end
--
function ui.fDeleteDirectory(dir)
  local lfs = require('lfs')
  --
  local function deletedir(dir)
    for file in lfs.dir(dir) do
      local file_path = dir..'/'..file
      --
      if (file ~= ".") and (file ~= "..") then
        if (lfs.attributes(file_path, 'mode') == 'file') then
          os.remove(file_path)
        elseif (lfs.attributes(file_path, 'mode') == 'directory') then
          deletedir(file_path)
        end
      end
    end
    lfs.rmdir(dir)
  end
  --
  deletedir(dir)
end
--
function ui.fCopyFile(old_path, new_path)
  local old_file = io.open(old_path, "rb")
  local new_file = io.open(new_path, "wb")
  local old_file_sz, new_file_sz = 0, 0
  --
  if (not old_file) or (not new_file) then
    return false
  end
  --
  local block = old_file:read(2^13)
  while block do
    new_file:write(block)
    block = old_file:read(2^13)
  end
  --
  old_file_sz = old_file:seek("end")
  old_file:close()
  --
  new_file_sz = new_file:seek("end")
  new_file:close()
  --
  return new_file_sz == old_file_sz
end
--
-- Return true if t1 == t2
function ui.fTableCompare(o1, o2, ignore_mt)
  local o1Type = type(o1)
  local o2Type = type(o2)
  --
  -- Same object
  if (o1 == o2) then
    return true
  end
  --
  -- Different type
  if (o1Type ~= o2Type) then 
    return false 
  end
  --
  -- Same type but not table, already compared above
  if (o1Type ~= 'table') then 
    return false 
  end
  --
  -- Use metatable method
  if (not ignore_mt) then
    local mt1 = getmetatable(o1)
    --
    if mt1 and mt1.__eq then
      -- Compare using built in method
      return o1 == o2
    end
  end
  --
  -- Iterate over o1
  for key1, value1 in pairs(o1) do
    local value2 = o2[key1]
    --
    if (value2 == nil) or (ui.fTableCompare(value1, value2, ignore_mt) == false) then
      return false
    end
  end
  --
  -- check keys in o2 but missing from o1
  for key2, _ in pairs(o2) do
    if (o1[key2] == nil) then 
      return false 
    end
  end
  --
  return true
end
--
function ui.fHasbit(x, p)
  x = tonumber(x)
  p = tonumber(p)
  --
  p = 2 ^ (p - 1)
  --
  return (x % (p + p) &gt;= p)
  --return (math.mod(x, p+p) &gt;= p)       
end
--
function ui.fGetColor(color)
  local tabColor = {
    ["$c0000"] = "#080808", -- Nero 
    ["$c0001"] = "#870000", -- Rosso scuro 
    ["$c0002"] = "#008700", -- Verde scuro 
    ["$c0003"] = "#878700", -- Marrone 
    ["$c0004"] = "#000087", -- Blu 
    ["$c0005"] = "#870087", -- Viola 
    ["$c0006"] = "#008787", -- Cyan 
    ["$c0007"] = "#a8a8a8", -- Grigio (default)        
    ["$c0008"] = "#767676", -- Grigio scuro
    ["$c0009"] = "#ff0000", -- Rosso chiaro
    ["$c0010"] = "#00ff00", -- Verde chiaro
    ["$c0011"] = "#ffff00", -- Giallo
    ["$c0012"] = "#0000ff", -- Blu chiaro
    ["$c0013"] = "#ff00ff", -- Viola chiaro
    ["$c0014"] = "#00ffff", -- Celeste chiaro
    ["$c0015"] = "#ffffff", -- Bianco
  }
  --
  -- $chfRRGGBB
  if (string.find(color, "$chf")) then
    color = string.gsub(color, "$chf", "#")
  --
  -- $cXXXX
  elseif (string.find(color, "$c")) then
    color = tabColor[color] or tabColor["$c0007"]
  end
  --
  return color
end
--
function ui.fConvertColorString(s)
  local tabColor = {
    ["$c0000"] = "&lt;black&gt;", -- Nero 
    ["$c0001"] = "&lt;ansiRed&gt;", -- Rosso scuro 
    ["$c0002"] = "&lt;DarkGreen&gt;", -- Verde scuro 
    ["$c0003"] = "&lt;brown&gt;", -- Marrone 
    ["$c0004"] = "&lt;ansiBlue&gt;", -- Blu 
    ["$c0005"] = "&lt;purple&gt;", -- Viola 
    ["$c0006"] = "&lt;ansiCyan&gt;", -- Cyan 
    ["$c0007"] = "&lt;r&gt;", -- Grigio (default)        
    ["$c0008"] = "&lt;DimGrey&gt;", -- Grigio scuro
    ["$c0009"] = "&lt;red&gt;", -- Rosso chiaro
    ["$c0010"] = "&lt;green&gt;", -- Verde chiaro
    ["$c0011"] = "&lt;yellow&gt;", -- Giallo
    ["$c0012"] = "&lt;blue&gt;", -- Blu chiaro
    ["$c0013"] = "&lt;violet&gt;", -- Viola chiaro
    ["$c0014"] = "&lt;cyan&gt;", -- Celeste chiaro
    ["$c0015"] = "&lt;white&gt;", -- Bianco
  }
  local codes = s:gmatch("$c%d%d%d%d")
  --
  for code in codes do
    local val = tabColor[code] or tabColor["$c0007"]
    --
    s = s:gsub(code, val)
  end
  s = s:gsub("$crk%d%d%d%d%d%d%d%d", "")
  --
  return s
end
--
function ui.fAddMain(sender, CSS_Border, CSS_Main)
  if (sender) then
    sender.Border = Geyser.Label:new2({
      name = sender.name..".Border",
      x = 4,
      y = 24,
      width = "100%-8",
      height = "100%-28",
    }, sender)
    sender.Border:enableClickthrough()
    sender.Border:setStyleSheet(CSS_Border);
    
    sender.Main = Geyser.Label:new2({
      name = sender.name..".Main",
      x = 5,
      y = 5,
      width = "100%-10",
      height = "100%-10",
    }, sender.Border)
    sender.Main:enableClickthrough()
    sender.Main:setStyleSheet(CSS_Main);
  end
end
--
function ui.fAddSpace(s, l, mode)
  local sl
  --
  s = s or "";
  mode = mode or "c"
  sl = s:len()
  --
  if (sl &lt; l) then
    for i = sl+1, l do
      if (mode == "l") then
        s = " "..s
      elseif (mode == "r") then
        s = s.." "
      elseif (i%2==0) then
        s = s.." "
      else
        s = " "..s        
      end
    end
  end
  --
  return s
end
--
function ui.fWindowResize(eventName, containerName)
  ui.fUpdateAffects()
  ui.fUpdateAliasButton()
  ui.fUpdateCooldowns()
  ui.fUpdateEndowment()
  ui.fUpdateGroup()
  ui.fUpdateTargetButtons()
end
--
function ui.fSetBorderMode(sender, mode)
  --
  -- Transparent (Mode = true)
  if (mode) then
    --
    -- Widget
    sender.adjLabelstyle = GUI.CSS.WidgetTransparent
    sender.adjLabel:setStyleSheet(sender.adjLabelstyle) 
    --
    -- Internal border
    sender.Border:setStyleSheet(GUI.CSS.BorderTransparent);
  --
  -- Solid (Mode = false)
  else
    --
    -- Widget
    sender.adjLabelstyle = GUI.CSS.Widget
    sender.adjLabel:setStyleSheet(sender.adjLabelstyle) 
    --
    -- Internal border
    sender.Border:setStyleSheet(GUI.CSS.Border);
  end
end
--
function ui.cLink(s)
  s = s or ""
  return "&lt;gold&gt;[&lt;LightYellow&gt;"..s.."&lt;gold&gt;]&lt;r&gt;"
end
--
-- Connection Event
function ui.fConnection()
  ui.fEcho("&lt;orange&gt; - Caricamento 'Lumen et Umbra UI' (rel. "..ui.release..") completato.&lt;r&gt;\n")
  ui.fEcho("&lt;orange&gt; - Digitare ");
  cechoLink(ui.cLink("uihelp"), [[expandAlias("uihelp")]], "Esegui i comando 'uihelp'", true) 
  cecho("&lt;orange&gt; per iniziare...&lt;r&gt;\n")
end
--
function ui.fLevelColor(opponentLevel, playerLevel)
  --
  -- Level color
  local levelDif = tonumber(opponentLevel) - tonumber(playerLevel or 0)
  local color = "grey"
  --
  if (levelDif &lt; -5) then
    color = "grey"
  elseif (levelDif &lt; 0) then
    color = "green"
  elseif (levelDif == 0) then
    color = "white"
  elseif (levelDif &lt; 10) then
    color = "yellow"
  else
    color = "red"
  end
  --
  return color
end
</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>GMCP</name>
					<packageName></packageName>
					<script>--
function ui.fUpdateGMCP(event, ...)
  --
  ui.fDebug("[&lt;cyan&gt;call&lt;r&gt;] ui.fUpdateGMCP(&lt;white&gt;"..event.."&lt;r&gt;)", 3)
  --
  if (gmcp) then
    ui.previous = ui.previous or {}
    ui.previous.gmcp = ui.previous.gmcp or {}
    --
    -- CHAR
    if (event == "gmcp.char") then
      ui.previous.gmcp.char = ui.previous.gmcp.char or {}
      --
      -- Affects
      if (gmcp.char.affects) then
        ui.previous.gmcp.char.affects = ui.previous.gmcp.char.affects or {}
        --
        if (not ui.fTableCompare(gmcp.char.affects, ui.previous.gmcp.char.affects)) then
          ui.fUpdateAffects();
          --
          ui.previous.gmcp.char.affects = {}
          ui.previous.gmcp.char.affects = table.deepcopy(gmcp.char.affects);
        end
      end
      --
      -- Base
      if (gmcp.char.base) then
        ui.previous.gmcp.char.base = ui.previous.gmcp.char.base or {}
        --
        if (not ui.fTableCompare(gmcp.char.base, ui.previous.gmcp.char.base)) then
          ui.fUpdatePlayer();
          --
          -- Gold
          if (ui.previous.gmcp.char.base.gold) and (gmcp.char.base.gold) then
            local dif = gmcp.char.base.gold - ui.previous.gmcp.char.base.gold
            --if (dif &gt; 0) then
            --  ui.fLog("&lt;0,255,0:"..ui.colors.wBackground.."&gt;+"..dif.." mo")    
            --else
            if (dif &lt; 0) then
              ui.fLog("&lt;255,0,0:"..ui.colors.wBackground.."&gt;"..dif.." mo")
            end 
          end
          --
          ui.previous.gmcp.char.base = {}
          ui.previous.gmcp.char.base = table.deepcopy(gmcp.char.base);
        end
      end
      --
      -- Group
      if (gmcp.char.group) then
        ui.previous.gmcp.char.group = ui.previous.gmcp.char.group or {}
        --
        if (not ui.fTableCompare(gmcp.char.group, ui.previous.gmcp.char.group)) then
          ui.fUpdateGroup();
          --
          ui.previous.gmcp.char.group = {}
          ui.previous.gmcp.char.group = table.deepcopy(gmcp.char.group);
        end
      end
      --
      -- Vitalis
      if (gmcp.char.vitals) then
        ui.previous.gmcp.char.vitals = ui.previous.gmcp.char.vitals or {}
        --
        if (not ui.fTableCompare(gmcp.char.vitals, ui.previous.gmcp.char.vitals)) then
          --
          -- Player
          ui.fUpdatePlayer();
          --
          -- Opponent
          if (not ui.fTableCompare(gmcp.char.vitals.fighting, ui.previous.gmcp.char.vitals.fighting)) then
            ui.fUpdateOpponent();
          end
          --
          -- Player position
          if (gmcp.char.vitals.roomPos ~= ui.previous.gmcp.char.vitals.roomPos) then
            ui.player.roomPos = gmcp.char.vitals.roomPos or 5 
            ui.fUpdateRoom()
          end
          --
          ui.previous.gmcp.char.vitals = {}
          ui.previous.gmcp.char.vitals = table.deepcopy(gmcp.char.vitals);
        end
      end
      --
      -- Cooldowns
      if (gmcp.char.cooldowns) then
        ui.previous.gmcp.char.cooldowns = ui.previous.gmcp.char.cooldowns or {}
        --
        if (not ui.fTableCompare(gmcp.char.cooldowns, ui.previous.gmcp.char.cooldowns)) then
          ui.fUpdateCooldowns()
          ui.previous.gmcp.char.cooldowns = {}
          ui.previous.gmcp.char.cooldowns = table.deepcopy(gmcp.char.cooldowns);
        end
      end
    --
    -- ROOM
    elseif (event == "gmcp.room") then
      ui.previous.gmcp.room = ui.previous.gmcp.room or {}
      --
      -- Room and Mapper
      if (not ui.fTableCompare(gmcp.room, ui.previous.gmcp.room)) then
        ui.previous.gmcp.room.info = ui.previous.gmcp.room.info or {}
        ui.previous.gmcp.room.info.exits = ui.previous.gmcp.room.info.exits or {}
        --
        -- Room
        ui.player.roomPos = gmcp.room.info.roomPos or gmcp.char.vitals.roomPos or 5
        ui.fUpdateRoom()
        --
        -- Mapper (only if change room or exits (ex secret found))
        if (gmcp.room.info.num ~= ui.previous.gmcp.room.info.num) or
           (not ui.fTableCompare(gmcp.room.info.exits, ui.previous.gmcp.room.info.exits))then
          ui.fUpdateMapper()
        end
        --
        ui.previous.gmcp.room = {}
        ui.previous.gmcp.room = table.deepcopy(gmcp.room);
      end
    --
    -- OVERLAND
    elseif (event == "gmcp.overland") then
      ui.previous.gmcp.overland = ui.previous.gmcp.overland or {}
      --
      -- Overland
      if (not ui.fTableCompare(gmcp.overland, ui.previous.gmcp.overland)) then
        ui.fUpdateOverand();
        --
        ui.previous.gmcp.overland = {}
        ui.previous.gmcp.overland = table.deepcopy(gmcp.overland);
      end
    end
    --
  end
end</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>Group</name>
					<packageName></packageName>
					<script>--
function ui.fUpdateGroup()
  local distance = 2;
  local min_w = 150;
  local max_w = 250;
  local w_h = GUI.Group.Main:get_height() - distance;
  local w_w = GUI.Group.Main:get_width() -  distance;
  local h = distance + 50;
  local w = distance + min_w;
  local x = 0
  local y = 0
  local r = 1
  local c = 1
  local tot_r, tot_c, total
  --
  ui.fDebug("[&lt;cyan&gt;call&lt;r&gt;] ui.fUpdateGroup()")
  --
  ui.group = {}
  --
  if (ui.enDebug &gt;= 2) then
    total = math.random(1, 10)
    local leader = math.random(0, total)
    for member=1, total do
      ui.group[member] = {
        name     = "Player "..member,
        isLeader = (member == leader),
        hp       = math.random(0, 100),
        maxhp    = 100,
        mana     = math.random(0, 100),
        maxmana  = 100,
        mov      = math.random(0, 100),
        maxmov   = 100,
        pov      = math.random(0, 100),
        maxpov   = 100,
        roomPos  = math.random(1, 9),
      }  
    end
  elseif (gmcp) and (gmcp.char) and (gmcp.char.group) then
    for member in pairs(gmcp.char.group) do
      local name = (gmcp.char.group[member].name or "")
      --
      if (name ~= ui.player.name) then
        ui.group[#ui.group+1] = {
          name     = gmcp.char.group[member].name or "",
          isLeader = gmcp.char.group[member].isLeader or false,
          hp       = gmcp.char.group[member].hp or 0,
          maxhp    = gmcp.char.group[member].maxhp or 0,
          mana     = gmcp.char.group[member].mana or 0,
          maxmana  = gmcp.char.group[member].maxmana or 0,
          mov      = gmcp.char.group[member].mov or 0,
          maxmov   = gmcp.char.group[member].maxmov or 0,
          pow      = gmcp.char.group[member].pow or 0,
          maxpow   = gmcp.char.group[member].maxpow or 0,
          roomPos  = gmcp.char.group[member].roomPos or 0,
        }
      end
    end
  end
  --
  total = math.min(#ui.group, 10);
  tot_r = math.max(1, math.min(math.floor(w_h / h), total));
  tot_c = math.max(1, math.min(math.floor(w_w / w), total));
  --
  -- Recalc w if possible
  w = math.min(w_w / tot_c, distance + max_w)
  --
  for i = 1, 10 do
    mod = i % 10
    if (r &gt; tot_r) or (i &gt; total) then
      GUI.Group.Main["g"..mod]:hide()
      ui.fAssignTargetButton("g"..mod, nil)
    else
      --
      GUI.Group.Main["g"..mod]:resize(w - distance, h - distance)
      GUI.Group.Main["g"..mod]:move(distance + (c-1)*w, distance + (r-1)*h)
      --
      if (ui.group[i].isLeader) then
        GUI.Group.Main["g"..mod].Member:echo("&lt;center&gt;".."👑 "..ansi2string(ui.group[i].name.." 👑"))
      else
        GUI.Group.Main["g"..mod].Member:echo("&lt;center&gt;"..ansi2string(ui.group[i].name))
      end
      --
      GUI.Group.Main["g"..mod].Health:setValue(math.max(0, ui.group[i].hp), ui.group[i].maxhp, "&lt;p align=right&gt;"..ui.group[i].hp.."/"..ui.group[i].maxhp.."&lt;/p&gt;")
      GUI.Group.Main["g"..mod].Mana:setValue(math.max(0, ui.group[i].mana), ui.group[i].maxmana)
      GUI.Group.Main["g"..mod].Stamina:setValue(math.max(0, ui.group[i].mov), ui.group[i].maxmov)
      --
      GUI.Group.Main["g"..mod]:show();
      ui.fAssignTargetButton("g"..mod, ui.group[i].name)
      --
      c = c + 1
      if (c &gt; tot_c) then
        c = 1;
        r = r + 1
      end
    end
  end
  --
  ui.fUpdateAllTargetButton()
  --
  GUI.Group:setTitle("Gruppo ["..total.."]")
end
--
-- Debug simulation
if (ui.enDebug) and (ui.enDebug &gt;= 2) then
  ui.fUpdateGroup()
end</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>Help</name>
					<packageName></packageName>
					<script>--
function ui.fHelp(cmd)
  local line
  --
  ui.fDebug("[&lt;cyan&gt;call&lt;r&gt;] ui.fHelp("..(cmd or "nil")..")")
  --
  -- Restore widget
  clearWindow("GUI.Help.Main.Console")
  --
  -- Command
  if cmd and cmd ~= "" then
    cmd = cmd:lower():gsub(" ","_")
    if not ui.help[cmd] then
      cmd = "error"
    end
  else
    cmd = "help"
  end
  --
  -- Pharse lines
  for line in ui.help[cmd]:gmatch("([^\n]*)\n") do
    local str_match, end_match = rex.find(line, [[\&lt;(?&lt;tag&gt;[^&gt;\s]+)(?&lt;argument&gt;\s*[^&gt;]*)\&gt;(?&lt;inside&gt;.*?)\&lt;\/\k&lt;tag&gt;\&gt;]])
    while (str_match) do
      local before = ""
      local match  = string.sub(line, str_match, end_match);
      local after  = ""
      local tag, argument, inside = rex.match(match, [[\&lt;(?&lt;tag&gt;[^&gt;\s]+)(?&lt;argument&gt;\s*[^&gt;]*)\&gt;(?&lt;inside&gt;.*?)\&lt;\/\k&lt;tag&gt;\&gt;]])
      --
      if (str_match &gt; 1) then
        before = string.sub(line, 1, str_match-1);
      end
      --
      if (end_match &lt; string.len(line)) then
        after = string.sub(line, end_match+1, string.len(line));
      end
      --
      -- Before
      GUI.Help.Main.Console:cecho(before)
      --
      -- Match
      tag = tag:lower()
      --
      if (tag == "alias") then
        inside = ui.fGetAliasFormattedText(inside)          
        GUI.Help.Main.Console:cecho(inside)
      --
      elseif (tag == "aliasname") then
        inside = ui.fGetAliasNameFormattedText(inside)
        GUI.Help.Main.Console:cecho(inside)
      --
      elseif (tag == "aliasoutput") then
        inside = ui.fGetAliasOutputFormattedText(inside)
        GUI.Help.Main.Console:cecho(inside)
      --
      elseif (tag == "button") then
        inside = ui.colors.aliasButton..inside.."&lt;r&gt;"          
        GUI.Help.Main.Console:cecho(inside)
      --
      elseif (tag == "command") then
        inside = ui.fGetCommandFormattedText(inside)
        GUI.Help.Main.Console:cecho(inside)
      --
      elseif (tag == "exec") then
        local fgColor = string.gsub(ui.colors.link, "[\&lt;\&gt;]", "");
        argument = string.trim(argument);
        GUI.Help.Main.Console:cechoLink(ui.cLink(inside), [[expandAlias("]]..argument..[[")]], argument, true)
      --
      elseif (tag == "input") then
        inside = ui.fGetInputFormattedText(inside)          
        GUI.Help.Main.Console:cecho(inside)
      --
      elseif (tag == "keybind") then
        inside = ui.colors.keybind..inside.."&lt;r&gt;"          
        GUI.Help.Main.Console:cecho(inside)        
      --
      elseif (tag == "link") then
        local fgColor = string.gsub(ui.colors.link, "[\&lt;\&gt;]", "");
        argument = string.trim(argument);
        GUI.Help.Main.Console:cechoLink(ui.cLink(inside), [[ui.fHelp("]]..argument..[[")]], argument, true)
      --
      elseif (tag == "profile") then
        inside = ui.fGetProfileNameFormattedText(inside)
        GUI.Help.Main.Console:cecho(inside)
      --
      elseif (tag == "title") then
        inside = ui.fTitle(inside)
        GUI.Help.Main.Console:cecho(inside)
      --
      elseif (tag == "var") then
        inside = ui.fGetVarFormattedText(inside)
        GUI.Help.Main.Console:cecho(inside)
      --
      elseif (tag == "varname") then
        inside = ui.colors.varID..ui.varID..ui.colors.varName..inside.."&lt;r&gt;"
        GUI.Help.Main.Console:cecho(inside)
      --
      elseif (tag == "varvalue") then
        inside = ui.fGetVarValueFormattedText(inside)          
        GUI.Help.Main.Console:cecho(inside)
      else
        -- Match non riconosciuto
        GUI.Help.Main.Console:cecho(match)
      end
      --
      line = after
      str_match, end_match = rex.find(line, [[\&lt;(?&lt;tag&gt;[^&gt;\s]+)(?&lt;argument&gt;\s*[^&gt;]*)\&gt;(?&lt;inside&gt;.*?)\&lt;\/\k&lt;tag&gt;\&gt;]])
    end
    --
    -- line\after
    GUI.Help.Main.Console:cecho(line.."\n")
  end
  GUI.Help:show()
  GUI.Help.Main.Console:enableScrolling ()
  GUI.Help.Main.Console:scrollTo(1)
end
--
function ui.fHelp_links(htext, hlinktext, hurl, hcaption)
  --
  ui.fDebug("[&lt;cyan&gt;call&lt;r&gt;] ui.fHelp_links(...)")
  --
  if (htext ~= nil) and (hlinktext ~= nil) and (hurl ~= nil) and (hcaption ~= nil) then
    --
    GUI.Help:cecho(ui.colors.text..htext.." ")
    --
    GUI.Help:cechoLink(ui.colors.link..hlinktext..ui.colors.text.."\n",
                       [[openWebPage("https://]]..hurl..[[")]],
                       hcaption,
                       true)
  end
end</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>Highlights</name>
					<packageName></packageName>
					<script>--
function ui.fGetHighlightFormattedText(highlight)
  if (ui.highlights[highlight]) then
    return "&lt;"..ui.highlights[highlight].color.."&gt;"..highlight.."&lt;r&gt;"
  end
  --
  return ""
end
--
function ui.fShowAllHighlights()
  local i = 0
  local num
  --
  ui.fDebug("[&lt;cyan&gt;call&lt;r&gt;] ui.fShowAllHighlights()")
  --
  cecho(ui.fTitle("Highlights"))
  for highlight in pairs(ui.highlights) do
    i = i + 1
    cecho(ui.fGetNumberFormattedText(i).." "..ui.fGetHighlightFormattedText(highlight).."\n")
  end
  if (i&gt;0) then
    echo("\n")
  else
    cecho("Per maggiori info "..ui.fGetCommandFormattedText("uihelp uihighlights").."\n\n")
  end
end
--
function ui.fRemoveHighlight(highlight)
  ui.fDebug("[&lt;cyan&gt;call&lt;r&gt;] ui.fRemoveHighlight("..(highlight.."nil")..")")
  --
  if (ui.highlights[highlight]) then
    if (ui.highlights[highlight].id) then
      killTrigger(ui.highlights[highlight].id)
    end
    ui.highlights[highlight] = nil
    --
    return true
  end
  --
  return false
end
--
function ui.fRemoveAllHighlights()
  ui.fDebug("[&lt;cyan&gt;call&lt;r&gt;] ui.fRemoveAllHighlights()")
  --
  for highlight in pairs(ui.highlights) do
    ui.fRemoveHighlight(highlight)
  end
  ui.highlights = {}
end
--
function ui.fAddHighlight(highlight, color)
  ui.fDebug("[&lt;cyan&gt;call&lt;r&gt;] ui.fRemoveHighlight("..(highlight.."nil")..", "..(color.."nil")..")")
  --
  if ui.fColorCheck(color) then
    highlight = highlight or "" 
    if (highlight ~= "") then
      --
      -- Init highlight (if not exist)
      ui.highlights[highlight] = ui.highlights[highlight] or {}
      --
      -- Remove old highlight
      if (ui.highlights[highlight].id) then
        killTrigger(ui.highlights[highlight].id)
      end
      --
      -- Create trigger
      ui.highlights[highlight].id = tempRegexTrigger([[(?i)(?:^|\W|\s)(]]..highlight..[[)(?:\W|$|\s)]], function()
                                                                                                          selectString(matches[2], 1)
                                                                                                          fg(color)
                                                                                                          resetFormat()
                                                                                                        end)
      ui.highlights[highlight].color = color
      --
      return 1
    end
    --
    return -1 -- Invaid text
  end
  --
  return -2 -- Invalid color
end
--
-- Save Highlights data from file
function ui.fSaveFileHighlights()
  local file = ui.files.highlights.path..ui.files.highlights.name
  local highlightsDataToSave = {}
  --
  ui.fDebug("[&lt;cyan&gt;call&lt;r&gt;] ui.fSaveFileHighlights()")
  --
  for highlight in pairs(ui.highlights) do
    highlightsDataToSave[highlight] = {}
    highlightsDataToSave[highlight].color = ui.highlights[highlight].color
  end
  table.save(file, highlightsDataToSave)
end
--
-- Read Highlights data from file
function ui.fReadFileHighlights()
  local file = ui.files.highlights.path..ui.files.highlights.name
  --
  ui.fDebug("[&lt;cyan&gt;call&lt;r&gt;] ui.fReadFileHighlights()")
  --
  -- Remove actual Highlights
  ui.highlights = ui.highlights or {}
  ui.fRemoveAllHighlights()
  --
  -- Load Highlights
  if (io.exists(file)) then
    table.load(file, ui.highlights)
  end
  --
  -- Create Highlights
  for highlight in pairs(ui.highlights) do
    ui.fAddHighlight(highlight, ui.highlights[highlight].color)
  end
end</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>Keybind</name>
					<packageName></packageName>
					<script>--
function ui.fGetKeybFormattedText(keybind)
  if (keybind) then
    return ui.colors.keybind.."&lt;"..keybind.."&gt;".."&lt;r&gt;"
  end
  return ""
end
--
-- Validate 3 keys for keybind (order: mod1 mod2 key)
function ui.fGetKeyb(key1, key2, key3)
  local isValid = false;
  local mod1 = "";
  local mod2 = "";
  local key = "";
  local keybind = ""
  --
  key1 = string.upper(key1 or "")
  key2 = string.upper(key2 or "")
  key3 = string.upper(key3 or "")
  if (key3 ~= "") then  -- es: key1=CTRL key2=ALT key3=F1
    if (key1 ~= key2) and
       (table.contains(ui.keyb_modifier, key1)) and
       (table.contains(ui.keyb_modifier, key2)) and
       (table.contains(ui.keyb_single,   key3)) then
      local idx1 = table.index_of(table.keys(ui.keyb_modifier), key1)
      local idx2 = table.index_of(table.keys(ui.keyb_modifier), key2)
      mod1 = idx1 &lt; idx2 and key2 or key1
      mod2 = idx1 &lt; idx2 and key1 or key2
      key = key3
      isValid = true
    end
  elseif (key2 ~= "") then  -- es: key1=CTRL key2=F1
    if (table.contains(ui.keyb_modifier, key1) and table.contains(ui.keyb_single, key2))then
      mod1 = key1
      mod2 = ""
      key = key2
      isValid = true
    end
  elseif (key1~= "") then -- es: key1=F1
    if (table.contains(ui.keyb_single, key1)) then
      mod1 = ""
      mod2 = ""
      key = key1
      isValid = true
    end
  else
    mod1 = ""
    mod2 = ""
    key = ""
    isValid = true
  end
  --
  if (mod2 ~= "") then
    keybind = string.gsub(mod1 or "", "(%a)([%w_']*)", ui.fTitleCase).."+"..
              string.gsub(mod2 or "", "(%a)([%w_']*)", ui.fTitleCase).."+"..
              string.gsub( key or "", "(%a)([%w_']*)", ui.fTitleCase)
  elseif (mod1 ~= "") then
    keybind = string.gsub(mod1 or "", "(%a)([%w_']*)", ui.fTitleCase).."+"..
              string.gsub( key or "", "(%a)([%w_']*)", ui.fTitleCase)
  elseif (key ~= "") then
    keybind = string.gsub( key or "", "(%a)([%w_']*)", ui.fTitleCase)
  end
  --
  return isValid, mod1, mod2, key, keybind
end
--
function ui.fSearchKeyb(table, keybind, excludeKey)
  keybind = keybind or ""
  excludeKey = excludeKey or ""
  if (keybind ~= "") and (table) then
    for key in pairs(table) do
      if (key ~= excludeKey) and (table[key].keybind == keybind) then
        return key
      end
    end
  end
  --
  return nil
end
--
function ui.fShowAllKeyb()
  local orderTable = {}
  --
  ui.fDebug("[&lt;cyan&gt;call&lt;r&gt;] ui.fShowAllKeyb()")
  --
  -- Order Target keybind
  for target in pairs(ui.targets) do
    orderTable[#orderTable+1] = target
  end
  table.sort(orderTable, function (target1, target2) 
                           keybind1 = ui.targets[target1].keybind or ""
                           keybind2 = ui.targets[target2].keybind or ""                  
                           if (rex.match(keybind1, [[F\d$]])) then
                             keybind1 = keybind1:gsub("F%w", "F0%1")                             
                           end
                           if (rex.match(keybind2, [[F\d$]])) then
                             keybind2 = keybind2:gsub("F%w", "F0%1")                             
                           end
                           return keybind1 &lt; keybind2
                         end )
  --
  -- Show Target keybind
  cecho(ui.fTitle("Keybind associati ai Target"))
  for i,target in ipairs(orderTable) do
    if (ui.targets[target].keybId) then
      cecho(ui.fGetNumberFormattedText(i).." ")
      cechoLink(ui.cLink("X"), [[expandAlias("uikeybind ]]..target..[[ remove")]], "Rimuovi il keybind associato al target '"..target.."'", true)
      cecho(" "..ui.fGetTargetFormattedText(target, true)..ui.fGetOperatorFormattedText(" » "))
      if (ui.targets[target].target) then
        cecho(ui.fGetVarNameFormattedText("target")..ui.fGetOperatorFormattedText(" = ")..ui.fGetVarValueFormattedText(ui.targets[target].target))
      else
        cecho("&lt;r&gt;non configurato")
      end
      cecho("\n")
    end
  end
  --
  -- Order Aliases keybind
  orderTable = {}
  for alias in pairs(ui.aliases) do
    if (ui.aliases[alias].keybId) then
      orderTable[#orderTable+1] = alias
    end
  end
  table.sort(orderTable, function (alias1, alias2) 
                           keybind1 = ui.aliases[alias1].keybind
                           keybind2 = ui.aliases[alias2].keybind                           
                           if (rex.match(keybind1, [[F\d$]])) then
                             keybind1 = keybind1:gsub("F%w", "F0%1")                             
                           end
                           if (rex.match(keybind2, [[F\d$]])) then
                             keybind2 = keybind2:gsub("F%w", "F0%1")                             
                           end
                           return keybind1 &lt; keybind2
                         end )
  --
  -- Show Aliases keybind
  cecho(ui.fTitle("Keybind associati agli Aliases"))
  for i,alias in ipairs(orderTable) do
      cecho(ui.fGetNumberFormattedText(i).." ")
      cechoLink(ui.cLink("X"), [[expandAlias("uikeybind ]]..alias..[[ remove")]], "Rimuovi il keybind associato all'alias '"..alias.."'", true)
      cecho(" "..ui.fGetKeybFormattedText(ui.aliases[alias].keybind)..ui.fGetOperatorFormattedText(" » "))
    ui.fLinkAlias(alias)
    cecho("\n")
  end
  if (#orderTable==0) then
    cecho("Per maggiori info "..ui.fGetCommandFormattedText("uihelp uikeybind").."\n\n")
  else
    echo("\n")
  end
end
--
-- Delete keybind from a table
function ui.fRemoveKeyb(element)
  if (element) then
    if (element.mod1) then
      element.mod1 = nil
    end
    if (element.mod2) then
      element.mod2 = nil
    end
    if (element.key) then
      element.key = nil
    end
    if (element.keybind) then
      element.keybind = nil
    end
    if (element.keybId) then
      killKey(element.keybId)
      element.keybId = nil
      --
      return 1 -- keyb removed
    end
    --
    return -1 -- Not keyb to remove
  end
  --
  return -2 -- Invalid element
end
--
function ui.fRemoveAllKeyb()
  ui.fDebug("[&lt;cyan&gt;call&lt;r&gt;] ui.fRemoveAllKeyb()")
  --
  for element in pairs(ui.aliases) do
    ui.fRemoveKeyb(ui.aliases[element])
  end
  --
  for element in pairs(ui.targets) do
    ui.fRemoveKeyb(ui.targets[element])
  end
end
--
-- Set, modify or delete a keybind
function ui.fSetKeyb(table, tKey, code, key1, key2, key3)
  local isValid, mod1, mod2, key, keybind = ui.fGetKeyb(key1, key2, key3)
  --
  if (table[tKey]) then
    if (isValid) then
      if (ui.fSearchKeyb(ui.targets, keybind, tKey) == nil) then
        if (ui.fSearchKeyb(ui.aliases, keybind, tKey) == nil) then
          --
          -- Remove old keybind
          ui.fRemoveKeyb(table[tKey]);
          --
          -- Create new keybind
          if (mod2 ~= "") then
            table[tKey].keybId = tempKey(ui.keyb_modifier[mod1] + ui.keyb_modifier[mod2], ui.keyb_single[key], code)
          elseif (mod1 ~= "") then
            table[tKey].keybId = tempKey(ui.keyb_modifier[mod1], ui.keyb_single[key], code)
          elseif (key ~= "") then
            table[tKey].keybId = tempKey(ui.keyb_single[key], code)
          else
            return 2, keybind -- keybind removed
          end
          --
          -- Save data
          table[tKey].mod1 = mod1
          table[tKey].mod2 = mod2
          table[tKey].key = key
          table[tKey].keybind = keybind
          --
          return 1, keybind -- keybind changed or created
        end
        --
        return -4, keybind -- keybind already used in an alias
      end
      --
      return -3, keybind -- keybind already used in a target
    end
    --
    return -2, keybind -- Not valid keys
  end
  --
  return -1, keybind -- Alias not exist
end
</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>Map \ Mapper</name>
					<packageName></packageName>
					<script>-- Based upon "generic GMCP mapping script for Mudlet" by Blizzard. https://worldofpa.in
-- based upon an MSDP script from the Mudlet forums in the generic mapper thread
-- with pieces from the generic mapper script and the mmpkg mapper by breakone9r
--
mudlet = mudlet or {}; 
mudlet.mapper_script = true
--
local iColor = {
  ["area"]      = '&lt;yellow&gt;',
  ["room"]      = '&lt;cyan&gt;',
  ["text"]      = '&lt;ansiMagenta&gt;',
  ["special"]   = '&lt;orange&gt;',
  
}
--
local terrain_types = {
  -- Used to make rooms of different terrain types have different colors
  -- add a new entry for each terrain type, and set the color with RGB values
  -- each id value must be unique, terrain types not listed here will use mapper default color
  -- not used if you define these in a map XML file
  ["Acque Basse"]      = {id =  18, r =   0, g = 153, b = 153 },
  ["Acque Profonde"]   = {id =  19, r =   0, g =   0, b = 153 },
  ["Costa"]            = {id =  20, r = 153, g = 153, b =   0 },
  ["Ghiacci"]          = {id =  21, r = 255, g = 255, b = 255 },
  ["Palude"]           = {id =  22, r =  64, g =  64, b =  64 },
  ["Sott'acqua"]       = {id =  23, r =   0, g =   0, b = 255 },
  ["Spiaggia"]         = {id =  24, r = 255, g = 255, b =   0 },
  ["Foresta"]          = {id =  25, r =   0, g = 255, b =   0 },
  ["Giungla"]          = {id =  26, r =   0, g = 153, b =   0 },
  ["Prato"]            = {id =  27, r =   0, g = 255, b =   0 },
  ["Taiga"]            = {id =  28, r =   0, g = 153, b = 153 },
  ["Tra gli Alberi"]   = {id =  29, r =   0, g = 153, b =   0 },
  ["Deserto"]          = {id =  30, r = 255, g =   0, b =   0 },
  ["Savana"]           = {id =  31, r = 255, g = 255, b =   0 },
  ["Steppa"]           = {id =  32, r = 153, g = 153, b =   0 },
  ["Tundra"]           = {id =  33, r =   0, g = 255, b = 255 },
  ["Collina"]          = {id =  34, r = 255, g = 255, b =   0 },
  ["Montagna"]         = {id =  35, r = 153, g = 153, b =   0 },
  ["Pianura"]          = {id =  36, r = 255, g = 255, b = 255 },
  ["Strada"]           = {id =  37, r = 128, g = 128, b = 128 },
  ["Citta'"]           = {id =  38, r = 128, g = 128, b = 128 },
  ["Citta' oscura"]    = {id =  39, r = 153, g =   0, b = 153 },
  ["Al chiuso"]        = {id =  40, r =  64, g =  64, b =  64 },
  ["Castello"]         = {id =  41, r = 128, g = 128, b = 128 },
  ["Cripta"]           = {id =  42, r =  64, g =  64, b =  64 },
  ["Maniero"]          = {id =  43, r = 128, g = 128, b = 128 },
  ["Negozio"]          = {id =  44, r = 153, g =   0, b = 153, c = "$" },
  ["Prigione"]         = {id =  45, r = 153, g =   0, b =   0 },
  ["Tempio"]           = {id =  46, r = 128, g = 128, b = 128 },
  ["Caverna"]          = {id =  47, r =  64, g =  64, b =  64 },
  ["Dungeon"]          = {id =  48, r =  64, g =  64, b =  64 },
  ["Sottosuolo"]       = {id =  49, r = 153, g =   0, b = 153 },
  ["Piano Astrale"]    = {id =  50, r =   0, g = 255, b = 255 },
  ["Piano Esterno"]    = {id =  51, r = 255, g = 255, b = 255 },
  ["Teletrasporto"]    = {id =  52, r = 255, g = 205, b = 255 },
  ["Vuoto cosmico"]    = {id =  53, r =  64, g =  64, b =  64 },
  ["Sconosciuto"]      = {id =  54, r =  64, g =  64, b =  64 },
  ["Sigil"]            = {id =  55, r = 255, g =   0, b =   0 },
  ["[Zona di Guerra]"] = {id =  56, r = 255, g =   0, b =   0 },
  ["A mezz'aria"]      = {id =  57, r =   0, g = 255, b = 255 },
  ["Veicolo"]          = {id =  58, r = 153, g = 153, b =   0 },
  ["Imbarcazione"]     = {id =  59, r = 153, g = 153, b =   0 },
}
--
local move_vectors = {
  --         X   Y   Z
  north = {  0,  1,  0},
  south = {  0, -1,  0},
  east  = {  1,  0,  0},
  west  = { -1,  0,  0},
  up    = {  1,  1,  0},
  down  = { -1, -1,  0}
}
--
-- Show a list of rooms
function ui.fShowRooms(rooms)
  ui.fDebug("[&lt;cyan&gt;call&lt;r&gt;] ui.fShowRooms(...)")
  --
  cecho(ui.fTitle("Stanze"))
  --
  if (table.is_empty(rooms)) then
    cecho("Non ci sono stanze da mostrare\n\n")
  else
    local counter = 0;
    for k, v in ui.fOrderedPairs(rooms) do
      cecho(ui.fGetNumberFormattedText(k, 5).." ")
      cechoLink(ui.cLink("I"), [[expandAlias("uiinfo ]]..k..[[")]], "Info su '"..v.."'", true)
      echo(" ") 
      cechoLink(ui.cLink("T"), [[expandAlias("uitrack ]]..k..[[")]], "Traccia un sentiero per '"..v.."'", true)
      echo(" ") 
      cechoLink(ui.cLink("G"), [[expandAlias("uigo ]]..k..[[")]], "Vai a '"..v.."'", true)
      cecho(" "..iColor["room"]..ui.fConvertColorString(v).." "..iColor["text"].."Area: "..iColor["area"]..getRoomAreaName(getRoomArea(k)).."\n")
      counter = counter + 1;
    end
    echo("\n")
    ui.fEchon(iColor["text"].."Trovate &lt;white&gt;"..counter..iColor["text"].." stanze");
  end
end
--
-- Create a room and try to place it in a valid position
local function fUpdateRoom(room, prev)
  local coords = { 0, 0, 0 }
  local areas = getAreaTable()
  local areaID = areas[string.trim(room.area)]
  --
  ui.fDebug("[&lt;cyan&gt;call&lt;r&gt;] fUpdateRoom(..)")
  --
  -- Create Room
  addRoom(room.id)
  --
  -- Set room name (remove colors)
  local name = string.gsub(room.name, "$C", "$c")
  name = string.gsub(name, "$c%d%d%d%d", "")
	setRoomName(room.id, name)
  --
  if (not areaID) then
    -- Create Area if not exist
    areaID = addAreaName(room.area)
  end
  --
  -- Positions
  if (ui.map[room.id] ~= nil ) then
    --
    -- Get room positions among pre-stored positions
    coords = { 
      ui.map[room.id].x or 0,
      ui.map[room.id].y or 0,
      ui.map[room.id].z or 0
    }
  --
  elseif (room.area == prev.area) then
    --
    -- Determinate room position (if last room is from same area)
    coords = {getRoomCoordinates(prev.id)}
    local shift = {0,0,0}
    for k,v in pairs(room.exits) do
      if v == prev.id and move_vectors[k] then
        --
        -- C'è almeno un collegamento con la staza di provenienza a "..k.."... ricalcolo shift
        for n = 1,3 do
          shift[n] = shift[n] + move_vectors[k][n]
        end
      end
    end
    --
    -- Shift = 0 0 0
    if (shift[1] == 0) and (shift[2] == 0) and (shift[3] == 0)then
      --
      -- Aggiungo direzione di provenienza = ui.origins
      if (#ui.origins &gt; 0) then
        for _, dir in pairs(ui.origins) do
          if (exitValid[dir]) then
            shift[1] = shift[1] + move_vectors[dir][1]
            shift[2] = shift[2] + move_vectors[dir][2]
            shift[3] = shift[3] + move_vectors[dir][3]
          end
        end
      --else
        -- Non c'è direzione di provenienza. Possibile teleport.
        --setRoomChar(prev.id, "T")     
      end
    end
    --
    -- Again Shift = 0 0 0
    if (shift[1] == 0) and (shift[2] == 0) and (shift[3] == 0)then
      --
      -- Force top-right position
      shift = {-1,-1,0} 
    end
    --
    coords[1] = coords[1] - shift[1]
    coords[2] = coords[2] - shift[2]
    coords[3] = coords[3] - shift[3]
    --
    -- map stretching
    local overlap = getRoomsByPosition(areaID,coords[1],coords[2],coords[3])
    if not table.is_empty(overlap) then
      local rooms = getAreaRooms(areaID)
      local rcoords
      for _,id in ipairs(rooms) do
        rcoords = {getRoomCoordinates(id)}
        for n = 1,3 do
          if shift[n] ~= 0 and (rcoords[n] - coords[n]) * shift[n] &lt;= 0 then
            rcoords[n] = rcoords[n] - shift[n]
          end
        end
        setRoomCoordinates(id,rcoords[1],rcoords[2],rcoords[3])
      end
    end
  end
  --
  -- Associate area to room
  setRoomArea(room.id, areaID)
  --
  -- Set coordinates
  setRoomCoordinates(room.id, coords[1], coords[2], coords[3])
end
--
-- Returns colored text based on door type
local function getDoorStatus(status)
  status = tonumber(status)
  --
  if (status == 1) then
    return "&lt;green&gt;Aperta&lt;r&gt;"
  elseif (status == 2) then
    return "&lt;yellow&gt;Chiusa&lt;r&gt;"
  elseif (status == 3) then
    return "&lt;red&gt;Chiusa a chiave&lt;r&gt;"
  end
  --
  return "&lt;white&gt;Non definita ("..status..")&lt;r&gt;"
end
--
-- Returns room information
function ui.fRoomInfo(id, infoType, onlyReturn)
  local outString = ""
  --
  -- id rom or map selected room or actual room
  id = id or getMapSelection()["center"] or getPlayerRoom()
  --
  if (not onlyReturn) then
    if (id == getMapSelection()["center"]) then
      outString = ui.fTitle("Informazioni &lt;yellow&gt;stanza selezionata sulla mappa&lt;r&gt; "..iColor["text"].."#"..iColor["room"]..id..iColor["text"])
    elseif (id == getPlayerRoom()) then
      outString = ui.fTitle("Informazioni &lt;green&gt;stanza attuale&lt;r&gt; "..iColor["text"].."#"..iColor["room"]..id..iColor["text"])
    else
      outString = ui.fTitle("Informazioni stanza "..iColor["text"].."#"..iColor["room"]..id..iColor["text"])
    end
  end
  --
  id = tonumber(id)
  --
  if (id) then
    local name = getRoomName(id)
    infoType = infoType or "all"
    onlyReturn = onlyReturn or false;
    --
    if (name) then
      local idAarea = getRoomArea(id)
      local nameAarea = getRoomAreaName(idAarea)
      local x, y, z = getRoomCoordinates(id)
      local exits = getRoomExits(id)
      local specialExits = getSpecialExits(id)
      local doors = getDoors(id)
      local entrances = getAllRoomEntrances(id)
      local userData = getAllRoomUserData(id)
      --
      if (infoType == "room") or (infoType == "all") then
        outString = outString..iColor["text"].."Room: "..iColor["room"]..name.." "..iColor["text"].."#"..iColor["room"]..id.." "..iColor["text"].."(x:&lt;white&gt;"..x..", "..iColor["text"].."y:&lt;white&gt;"..y..iColor["text"]..")\n" -- [&lt;white&gt;"..getRoomWeight(id).." - "..(roomLocked(id) and "Chiusa" or "Aperta")..iColor["text"].."]
      end
      --
      if (infoType == "area") or (infoType == "all") then
        outString = outString..iColor["text"].."Area: "..iColor["area"]..nameAarea.." "..iColor["text"].."#"..iColor["area"]..idAarea.."\n"
      end
      --
      if (infoType == "exit") or (infoType == "all") then
        if (table.is_empty(exits)) then
          outString = outString..iColor["text"].."Non ci sono uscite.\n"
        else
          outString = outString..iColor["text"].."Uscite:\n"
          for k,v in pairs(exits) do
            local exitIdArea = getRoomArea(v)
            outString = outString.."  "..ui.validExit[k].color..ui.validExit[k].tokenOpen.." "..ui.validExit[k].long
            -- Doors
            if (doors[ui.validExit[k].short]) then
              outString = outString.." "..iColor["text"].."["..getDoorStatus(doors[ui.validExit[k].short])..iColor["text"].."]"
            end
            -- Name and ID
            outString = outString.." "..iColor["room"]..getRoomName(v).." "..iColor["text"].."#"..iColor["room"]..v            
            -- User Data
            if (userData[ui.validExit[k].short]) then
              outString = outString.." "..iColor["text"].."("..ui.validExit[k].color..userData[ui.validExit[k].short]..iColor["text"]..")"
            end
            -- Destination to different area
            if (exitIdArea ~= idAarea) then
              outString = outString.." "..iColor["text"].."Area: "..iColor["area"]..getRoomAreaName(exitIdArea).." "..iColor["text"].."#"..iColor["area"]..exitIdArea
            end      
            outString = outString.."\n"
          end
        end
      end 
      --
      if (infoType == "otherexit") or (infoType == "all") then
        if (table.is_empty(specialExits)) then
          outString = outString..iColor["text"].."Non ci sono uscite speciali.\n"
        else
          outString = outString..iColor["text"].."Uscite speciali:\n"
          for k,v in pairs(specialExits) do
            local exitIdArea = getRoomArea(k)
            for n, d in pairs(v) do
              outString = outString.."  "..iColor["text"].."'"..iColor["special"]..n..iColor["text"].."'"
              -- Door
              if (tonumber(d) &gt; 0) then
                outString = outString.." "..iColor["text"].."["..getDoorStatus(d)..iColor["text"].."]"
              end
              -- Name and ID
              outString = outString.." "..iColor["room"]..getRoomName(k).." "..iColor["text"].."#"..iColor["room"]..k
              -- Destination to different area
              if (exitIdArea ~= idAarea) then
                outString = outString.." "..iColor["text"].."Area: "..iColor["area"]..getRoomAreaName(exitIdArea).." "..iColor["text"].."#"..iColor["area"]..exitIdArea
              end      
              outString = outString.."\n"
            end
          end
        end
      end
      --
      if (infoType == "door") then
        if (table.is_empty(doors)) then
          outString = outString..iColor["text"].."Non ci sono porte.\n"
        else
          outString = outString..iColor["text"].."Porte:\n"
          for k,v in pairs(doors) do
            outString = outString.."  "..ui.validExit[k].color..ui.validExit[k].tokenOpen.." "..ui.validExit[k].long
            if (v == 1) then
              outString = outString.." "..iColor["text"].."(&lt;green&gt;Aperta"..iColor["text"]..")\n"
            elseif (v == 2) then
              outString = outString.." "..iColor["text"].."(&lt;yellow&gt;Chiusa"..iColor["text"]..")\n"
            elseif (v == 3) then
              outString = outString.." "..iColor["text"].."(&lt;red&gt;Chiusa a chiave"..iColor["text"]..")\n"
            else
              outString = outString.." "..iColor["text"].."(&lt;orange&gt;Non definita"..iColor["text"]..") (&lt;white&gt;"..v..iColor["text"]..")\n"
            end     
          end
        end
      end
      --
      if (infoType == "entrance") or (infoType == "all") then
        if (table.is_empty(entrances)) then
          outString = outString..iColor["text"].."Non ci sono entrate.\n"
        else
          outString = outString..iColor["text"].."Entrate:\n"
          for k,v in pairs(entrances) do
            local entranceExits = getRoomExits(v)
            local entranceSpecialExits = getSpecialExits(v)
            local sEntrance = ""
            --
            if (not table.is_empty(entranceExits)) then
              for k2,v2 in pairs(entranceExits) do
                if (v2 == id) then
                  sEntrance = sEntrance..ui.validExit[k2].color..ui.validExit[k2].tokenOpen.." "..ui.validExit[k2].long.." "
                end      
              end
            end 
            --
            if (not table.is_empty(entranceSpecialExits)) then
              for k2,v2 in pairs(entranceSpecialExits) do
                if (k2 == id) then
                  for n, d in pairs(v2) do
                    sEntrance = sEntrance.."&lt;orange&gt;▷ "..n.." "
                  end
                end
              end
            end
            --
            local entranceIdArea = getRoomArea(v)
            sEntrance = sEntrance..iColor["text"].."da "..iColor["room"]..getRoomName(v).." "..iColor["text"].."#"..iColor["room"]..v
            if (entranceIdArea ~= idAarea) then
              sEntrance = sEntrance.." "..iColor["text"].."Area: "..iColor["area"]..getRoomAreaName(entranceIdArea).." "..iColor["text"].."#"..iColor["area"]..entranceIdArea
            end
            outString = outString.."  "..sEntrance.."\n"
          end
        end
      end
      --
      if (infoType == "data") then
        if (table.is_empty(userData)) then
          outString = outString..iColor["text"].."Non ci sono note.\n"
        else
          outString = outString..iColor["text"].."Note:\n"
          for k,v in pairs(userData) do
            outString = outString.."  "..iColor["room"]..k..iColor["text"].." = &lt;white&gt;"..v.."&lt;r&gt;\n"
          end
        end
      end
    else
      outString = outString..iColor["text"].."La stanza (&lt;white&gt;"..(id or "nil")..iColor["text"]..") non esiste o non è stata ancora esplorata.\n"
    end
  else
    outString = outString..iColor["text"].."L'indice della stanza non è valido.\n"
  end
  --
  if (onlyReturn) then
    return string.gsub(outString, "\&lt;%w+\&gt;", "")
  else
    cecho(ui.fConvertColorString(outString.."\n"))
  end
end
--
-- Performs speedwalk recursively checking for individual rooms reached
function ui.fSpeedWalk(path, dirs)
  local roomId = ui.room.id or getPlayerRoom()
  --
  ui.fDebug("[&lt;cyan&gt;call&lt;r&gt;] ui.fSpeedWalk(..)")
  --
  if (ui.handlers.fSpeedWalk) then 
    killTimer(ui.handlers.fSpeedWalk)
    ui.handlers.fSpeedWalk = nil; 
  end
  --
  -- if arrive at next room
  if (tonumber(path[1]) == tonumber(roomId)) then
    --
    -- Go to next room
    if (#dirs &gt; 0) then
      local dir = dirs[1];
      --
      if (ui.validExit[dir]) then
        ui.fEchon("Prosegui lungo il percorso andando verso "..ui.validExit[dir].color..ui.validExit[dir].long)
      else
        -- May be special exit or door
        ui.fEchon(dir)
      end
      -- Send command
      send(dir, false)
      --
      table.remove(dirs, 1)
      table.remove(path, 1)
      --
      -- Recall to check time out and send next command if necessary
      ui.speedwalk.timer = 0
      ui.handlers.fSpeedWalk = tempTimer(ui.speedwalk.delay, function() ui.fSpeedWalk(path, dirs) end)
    else
      ui.fEchon("Sei arrivato alla fine del percorso")    
    end
  --
  -- Recall if not time out
  elseif (ui.speedwalk.timer &lt; ui.speedwalk.timeOut) then
    ui.speedwalk.timer = ui.speedwalk.timer + ui.speedwalk.delay;
    ui.handlers.fSpeedWalk = tempTimer(ui.speedwalk.delay, function() ui.fSpeedWalk(path, dirs) end)
  --
  -- Time out
  else
    ui.fEchon("Speedwalk interrotto.")
  end
end
--
-- Highlight a single room
function ui.fHighlightRoom(roomId, HighlightPath)
  local specialExits = getSpecialExits(roomId)
  --
  roomId = tonumber(roomId)
  --
  if (HighlightPath) and (table.contains(ui.speedwalk.path, roomId)) then
    --
    -- Highlight speedWalk path...
    if (table.is_empty(specialExits)) then
      --
      -- ... without special exits
      highlightRoom(roomId, 255,255,0, 255,255,0, 1.2, 64, 64)
    else
      --
      -- ... with special exits
      highlightRoom(roomId, 255,255,0, 0,255,255, 1.2, 64, 128)
    end
  elseif (not table.is_empty(specialExits)) then
    --
    -- Highlight rooms with special exits
    highlightRoom(roomId, 0,255,255, 0,255,255, 0.6, 64, 128)
  else
    --
    -- Unhighlight rooms
    unHighlightRoom(roomId)
  end
end
--
-- Highlight new path
function ui.fHighlightSpeedWalk(path)
  ui.fDebug("[&lt;cyan&gt;call&lt;r&gt;] ui.fHighlightSpeedWalk(..)")
  --
  ui.speedwalk.path = ui.speedwalk.path or {}
  path = path or {}
  --
  -- Unhighlight old path
  for _, id in pairs(ui.speedwalk.path) do
    ui.fHighlightRoom(id, false)
  end
  --
  ui.speedwalk.path = {}
  ui.speedwalk.path = table.deepcopy(path)
  --
  -- Highlight new path
  for _, id in pairs(ui.speedwalk.path) do
    ui.fHighlightRoom(id, true)
  end
end
--
-- Pharse speedwalk
function ui.fPrepareSpeedWalk(path, dirs)
  local roomId = ui.room.id or getPlayerRoom()
  local p = table.deepcopy(path) or {}
  local d = table.deepcopy(dirs) or {}
  --
  ui.fDebug("[&lt;cyan&gt;call&lt;r&gt;] ui.fPrepareSpeedWalk(..)")
  --
  roomId = tonumber(roomId)
  --
  if (#p ~= 0) then
    --
    -- Insert actual\start position
    table.insert(p, 1, roomId)
    --
    -- Go through dirs to find doors that need opened, etc
    -- add in necessary extra commands to dirs table
    local k = 1
    while (k &lt;= #d) do
      local id, dir = p[k], d[k]
      if (ui.validExit[dir]) then
        local userData = getAllRoomUserData(id)
        --
        if (userData[ui.validExit[dir].short]) then
          table.insert(p, k, id)
          table.insert(d, k, userData[ui.validExit[dir].short])
          k = k + 1
        end
      end
      k = k + 1
      p[k] = tonumber(p[k])
    end
  end
  --
  return p, d
end
--
-- System function called when double-click on a single map room 
function doSpeedWalk()
  local path, dirs = ui.fPrepareSpeedWalk(speedWalkPath, speedWalkDir)
  --
  ui.fDebug("[&lt;cyan&gt;call&lt;r&gt;] doSpeedWalk()")
  --
  -- Highlight new speedWalk (and unhighlight oldest)
  ui.fHighlightSpeedWalk(path)
  --
  -- Execute speedwalk
  if (#path ~= 0) then
    ui.speedwalk.timer = 0;
    ui.fSpeedWalk(path, dirs)
  end
end
--
--
function ui.fExpandArea(areaName)
  local areas = getAreaTable()
  local areaId = areas[areaName] 
  --
  if (areaId) then
    local rooms = getAreaRooms(areaId)
    local min_x, min_y, max_x, max_y = getAreaDimension(areaId)
    --
    local x = (max_x - min_x)
    --
    for i = max_x, min_x, -1 do
      local y = (max_y - min_y)
      for j = max_y, min_y, -1 do
        roomsByPosition = getRoomsByPosition(areaId, i, j, 0)
        for _, roomId in pairs(roomsByPosition) do
          setRoomCoordinates(roomId, x*2, y*2, 0)
        end
        y = y - 1
      end
      x = x - 1
    end
    --
    ui.fDebug('Area expanded ('..areaName..')')
  else
    ui.fDebug('Area non trovata ('..areaName..')')
  end
end
--
function ui.fCreateRoomSpace(areaId, roomId, x, y, entry)
  local min_x, min_y, max_x, max_y = getAreaDimension(areaId)
  --
  -- OverLap
  local overlap = not table.is_empty(getRoomsByPosition(areaId, x, y, 0))
  local is_path = false;
  --
  if (entry == "north") or (entry == "south") then
    local lRoomId
    local lr_x = x-1
    --
    -- Cerco prima room a sinistra sulla linea
    while (lr_x &gt;= min_x) and (lRoomId == nil) do
      local RoomsByPosition = getRoomsByPosition(areaId, lr_x, y, 0)
      if (not table.is_empty(RoomsByPosition)) then
        lRoomId = RoomsByPosition[0]
      end
      lr_x = lr_x - 1;
    end
    -- Se trovo una room
    if (lRoomId) then
      -- verifico se ha un uscita a est
      local exits = getRoomExits(lRoomId)
      if (exits["east"]) then
        local rr_x, rr_y, rr_z = getRoomCoordinates(exits["east"])
        if rr_x &gt; x then
          -- Il percorso tra le due stanze è sul punto di inserimento
          is_path = true;
        end
      end
    end
  elseif (entry == "west") or (entry == "east") then
    local bRoomId
    local br_y = y-1
    --
    -- Cerco prima room sopra la linea
    while (br_y &gt;= min_y) and (yRoomId == nil) do
      local RoomsByPosition = getRoomsByPosition(areaId, x, br_y, 0)
      if (not table.is_empty(RoomsByPosition)) then
        bRoomId = RoomsByPosition[0]
      end
      br_y = br_y - 1;
    end
    -- Se trovo una room
    if (bRoomId) then
      -- verifico se ha un uscita a est
      local exits = getRoomExits(bRoomId)
      if (exits["north"]) then
        local rr_x, rr_y, rr_z = getRoomCoordinates(exits["north"])
        if rr_y &gt; y then
          -- Il percorso tra le due stanze è sul punto di inserimento
          is_path = true;
        end
      end
    end
  end
  -- 
  -- Se la posizione è già occupata da un altra stanza
  if (overlap) or (is_path) then
    -- TODO: convertire ui.fEchon in ui.fDebug
    if (overlap) then
      ui.fEchon("&lt;orange&gt;Room "..roomId.." (from "..(entry or "&lt;red&gt;nil&lt;orange&gt;")..") OVERLAP")
    else
      ui.fEchon("&lt;orange&gt;Room "..roomId.." (from "..(entry or "&lt;red&gt;nil&lt;orange&gt;")..") IS ON PATH")
    end
    -- Se la room ha una direzione di entrata valida...
    if (entry ~= nil) and (table.contains(ui.validExit, entry)) then
      -- ... sposto la mappa già disegnata nel lato opposto al lato di entrata di una posizione per creare lo spazio 
      for rd_id in pairs(roomDrawed) do
        local rd_x, rd_y, rd_z = getRoomCoordinates(rd_id)
        --
        if (entry == "north") and (rd_y &lt;= y) then
          ui.fEchon("  &lt;magenta&gt;Muovo "..rd_id.." in giu'")          
          setRoomCoordinates(rd_id, rd_x, rd_y-1, 0)
        elseif (entry == "south") and (rd_y &gt;= y) then -- ok
          ui.fEchon("  &lt;magenta&gt;Muovo "..rd_id.." in su")          
          setRoomCoordinates(rd_id, rd_x, rd_y+1, 0)
        elseif (entry == "west") and (rd_x &lt;= x) then -- ok
          ui.fEchon("  &lt;magenta&gt;Muovo "..rd_id.." a destra")          
          setRoomCoordinates(rd_id, rd_x-1, rd_y, 0)
        elseif (entry == "east") and (rd_x &gt;= x) then
          ui.fEchon("  &lt;magenta&gt;Muovo "..rd_id.." a sinistra")          
          setRoomCoordinates(rd_id, rd_x+1, rd_y, 0)
        end
      end
      --
      ui.fDebug("&lt;magenta&gt;Moved sub-area to "..ui.validExit[entry].reverse)
    else
      -- ... altrimenti posto la stanza verso sud-est, fino a trovare una posizione libera.
      x = max_x + 1
      y = max_y + 1
      ui.fDebug("&lt;yellow&gt;Sub-Area started to S-E")
    end
  end
  --
  return x, y
end
--
function ui.fDrawRoom(areaId, roomId, x, y, entry, maxLevel)
  if (maxLevel ~= nil) then
    if (level &lt; maxLevel) then    
      ui.fDebug(ui.fAddSpace(""..(level+1)..") ", level+4, 'l'));
    else
      return
    end
  end
  --
  -- Se la stanza non è già stata disegnata...
  if (roomDrawed[roomId] == nil) then
    local roomAreaId = getRoomArea(roomId)
    --
    if (roomAreaId == areaId) then
      x, y = ui.fCreateRoomSpace(areaId, roomId, x, y, entry)
      --
      setRoomCoordinates(roomId, x, y, 0)
      roomDrawed[roomId] = true;
      level = level + 1;
      ui.fDebug("&lt;green&gt;Room "..roomId.." (from &lt;red&gt;"..(entry or "nil").."&lt;green&gt;) drowed in pos(x:"..x..", y:"..y..")");
      --
      -- Disegno le stanza adiacenti alle uscite
      local exits = getRoomExits(roomId)
      if (exits["east"]) and (exits["east"] ~= roomId) then
        ui.fDrawRoom(areaId, exits["east"], x+1, y, "west", maxLevel)
      end
      --
      if (exits["west"]) and (exits["west"] ~= roomId) then
        ui.fDrawRoom(areaId, exits["west"], x-1, y, "east", maxLevel)
      end
      --
      if (exits["north"]) and (exits["north"] ~= roomId) then
        ui.fDrawRoom(areaId, exits["north"], x, y+1, "south", maxLevel)
      end
      --
      if (exits["south"]) and (exits["south"] ~= roomId) then
        ui.fDrawRoom(areaId, exits["south"], x, y-1, "north", maxLevel)
      end
      --
      -- Disegno le stanza adiacenti alle entrate alla room
      local entrances = getAllRoomEntrances(roomId)
      for _,entranceId in pairs(entrances) do
        if (roomDrawed[entranceId] == nil) then
          local entranceAreaId = getRoomArea(entranceId)
          --
          if (entranceAreaId == areaId) then
            local entranceExits = getRoomExits(entranceId)
            --
            if (entranceExits["east"]) and (entranceExits["east"] == roomId) then
              ui.fDrawRoom(areaId, entranceId, x-1, y, "east", maxLevel)
            end
            --
            if (entranceExits["west"]) and (entranceExits["west"] == roomId) then
              ui.fDrawRoom(areaId, entranceId, x+1, y, "west", maxLevel)
            end
            --
            if (entranceExits["north"]) and (entranceExits["north"] == roomId) then
              ui.fDrawRoom(areaId, entranceId, x, y-1, "north", maxLevel)
            end
            --
            if (entranceExits["south"]) and (entranceExits["south"] == roomId) then
              ui.fDrawRoom(areaId, entranceId, x, y+1, "south", maxLevel)
            end
          end
        end
      end   
    end
--  else
    -- verifica le coordinate
    
  end
end
--
function ui.fRedrawArea(areaName, expand, maxLevel)
  local areas = getAreaTable()
  local areaId = areas[areaName] 
  --
  if (areaId) then
    local rooms = getAreaRooms(areaId)
    --
    -- Sposto tutte le stanze sul livello 1
    for _, roomId in pairs(rooms) do
      local x, y, z = getRoomCoordinates(roomId)
      setRoomCoordinates(roomId, x, y, 1)
    end
    --
    -- Riposiziono maxLevel room sul livello 0
    level = 0
    roomDrawed = {}
    for _, roomId in pairs(rooms) do
      ui.fDrawRoom(areaId, roomId, 0, 0, nil, maxLevel)
    end
    --
    if (expand) then
      ui.fExpandArea(areaName)
    end
    --
    ui.fDebug('Area redrawed ('..areaName..')')
  else
    ui.fDebug('Area non trovata ('..areaName..')')
  end
end
--
function ui.fUpdateMapper()
  --
  ui.fDebug("[&lt;cyan&gt;call&lt;r&gt;] ui.fUpdateMapper(..)")
  --
  if (ui.room) and (not ui.room.isOnMap) then
    --
    -- Invalid ui.room
    if (ui.room.id == nil) or (ui.room.id &lt;= 0) then
      return
    end
    --
    -- if area changed...
    if (ui.room.area ~= ui.previous.room.area) then
      -- 
      -- ... and area mutable.
      if (ui.room.area == 'Il Dungeon di Bosco Verde ') or
         (ui.room.area == 'Instancing') or
         (ui.room.area == 'Random Dungeons') then 
        --
        -- Clear area
        local areas = getAreaTable()
        local areaId = areas[string.trim(ui.room.area)]
        local rooms = getAreaRooms(areaId)
        --
        for _, roomId in pairs(rooms) do
          deleteRoom(roomId)
        end
      end
    end
    --
    -- Create new room if not exist
    if (not getRoomName(ui.room.id)) then
      fUpdateRoom(ui.room, ui.previous.room)
    end
    --
    -- Update color and character from terrain
    setRoomChar(ui.room.id, "");
    if (terrain_types[ui.room.terrain]) then
      setRoomEnv(ui.room.id, tonumber(terrain_types[ui.room.terrain].id))
      -- Assign a char if available
      if (terrain_types[ui.room.terrain].c) then
        setRoomChar(ui.room.id, terrain_types[ui.room.terrain].c)
      end
    end
    --
    -- Update exits
    for dir, id in pairs(ui.room.exits) do
      setExitStub(ui.room.id, dir, true)
      if getRoomName(id) then
        setExit(ui.room.id, id, dir)
      end
    end
    --
    -- Update exit to prew
    for _, dir in pairs(ui.origins or {}) do
      if (ui.validExit[dir]) then
        setExit(ui.previous.room.id, ui.room.id, ui.validExit[dir].reverse)
      end
    end
    --
    -- Update special exits
    if not (table.is_empty(ui.room.otherExits)) then
      for dir, id in pairs(ui.room.otherExits) do
        addSpecialExit(ui.room.id, id, "ent "..dir)
        if (ui.enDebug&gt;=1) then
          ui.fLog(ui.room.area..": "..dir.." per "..(getRoomName(id) or "???").." ("..id..")")
        end
      end
    end
    --
    -- if area changed...
    if (ui.room.area ~= ui.previous.room.area) then
      local areas = getAreaTable()
      local areaID = areas[string.trim(ui.room.area)]
      local rooms = getAreaRooms(areaID)
      --
      for _,id in ipairs(rooms) do
        ui.fHighlightRoom(id, true)
      end
    end
    -- 
    -- Redraw Area
    if (ui.room.area == 'Random Dungeons') then 
      --
      -- redraw area
      ui.fRedrawArea(ui.room.area, true)
    end
    --
    centerview(ui.room.id)
    --
    GUI.Mapper:setTitle(ui.room.area.." - "..ui.room.name)
    --
    if (ui.enDebug&gt;=1) then
      ui.fLog("&lt;255,255,0:"..ui.colors.wBackground.."&gt;"..ui.room.area.."\n".."&lt;255,255,255:"..ui.colors.wBackground.."&gt;"..ui.room.id.." &lt;0,255,255:"..ui.colors.wBackground.."&gt;"..ui.room.name)
    end
  end
end
--
function ui.fInitMapper()
  local file = ui.files.map.path..ui.files.map.name
  --
  ui.fDebug("[&lt;cyan&gt;call&lt;r&gt;] ui.fInitMapper()")
  --
  -- Load pre-stored rooms positions
  if (io.exists(file)) then
    table.load(file, ui.map)
  end
  --
  -- Load terrain colors
  for k,v in pairs(terrain_types) do
    setCustomEnvColor(tonumber(v.id), v.r, v.g, v.b, 255)
  end
  --
  -- Special mapper room info
  registerMapInfo("Area",          function(...) return ui.fRoomInfo(nil,      "area", true) --[[ Text ]], false --[[ Bold ]], false --[[ Italic ]], 255, 255, 255 --[[ RGB text color ]]; end)
  registerMapInfo("Room",          function(...) return ui.fRoomInfo(nil,      "room", true) --[[ Text ]], false --[[ Bold ]], false --[[ Italic ]], 255, 255, 255 --[[ RGB text color ]]; end)
  registerMapInfo("Exits",         function(...) return ui.fRoomInfo(nil,      "exit", true) --[[ Text ]], false --[[ Bold ]], false --[[ Italic ]], 255, 255, 255 --[[ RGB text color ]]; end)
  registerMapInfo("Special exits", function(...) return ui.fRoomInfo(nil, "otherexit", true) --[[ Text ]], false --[[ Bold ]], false --[[ Italic ]], 255, 255, 255 --[[ RGB text color ]]; end)
  registerMapInfo("Doors",         function(...) return ui.fRoomInfo(nil,      "door", true) --[[ Text ]], false --[[ Bold ]], false --[[ Italic ]], 255, 255, 255 --[[ RGB text color ]]; end)
  registerMapInfo("Entrance",      function(...) return ui.fRoomInfo(nil,  "entrance", true) --[[ Text ]], false --[[ Bold ]], false --[[ Italic ]], 255, 255, 255 --[[ RGB text color ]]; end)
  registerMapInfo("User data",     function(...) return ui.fRoomInfo(nil,      "data", true) --[[ Text ]], false --[[ Bold ]], false --[[ Italic ]], 255, 255, 255 --[[ RGB text color ]]; end)
  --
end</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>Map \ Overland</name>
					<packageName></packageName>
					<script>function ui.fUpdateOverand()
  --
  ui.fDebug("[&lt;cyan&gt;call&lt;r&gt;] ui.fUpdateOverand()")
  --
  if (gmcp.overland) and (gmcp.overland.map) and (gmcp.overland.map.size) then
    --
    local fw, fh = calcFontSize("GUI.Mapper.Main.Overland")
    local size = tonumber(gmcp.overland.map.size)
    local maxChar = math.floor(GUI.Mapper.Main.Overland:get_width() / fw)
    local spacesCnt = math.floor(maxChar / 2) - size
    local spaces = "" -- white spaces
    --
    clearWindow("GUI.Mapper.Main.Overland")
    --
    for i = 1, spacesCnt do
      spaces = spaces.." "
    end 
    --
    GUI.Mapper.Main.Overland:cecho("&lt;white&gt;"..ui.fAddSpace(ui.room.subArea, maxChar).."\n"..
                                   "&lt;cyan&gt;"..ui.fAddSpace(ui.room.name, maxChar).."\n\n")
    --
    for i = 0, size do
      if gmcp.overland.map["r"..i] then
        GUI.Mapper.Main.Overland:decho(spaces..ansi2decho(gmcp.overland.map["r"..i]).."\n")
      end
    end
    --
    -- Room name
    GUI.Mapper:setTitle(ui.room.area.." - "..ui.room.terrain);
  end
end</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>Opponent</name>
					<packageName></packageName>
					<script>--
function ui.fDifTimerOpponent(time_left)
  ui.fDebug("[&lt;cyan&gt;call&lt;r&gt;] ui.fDifTimerOpponent(&lt;white&gt;"..(time_left or "nil").."&lt;r&gt;)", 3)
  --
  if (ui.handlers.fDifTimerOpponent) then
    killTimer(ui.handlers.fDifTimerOpponent)
    ui.handlers.fDifTimerOpponent = nil;
  end
  --
  if (time_left &gt; 0) then
    ui.handlers.fDifTimerOpponent = tempTimer(time_left, function() ui.fDifTimerOpponent(0.0) end)
    GUI.Opponent.Main.Health.dif:show()
  else
    GUI.Opponent.Main.Health.dif:hide()
  end
end
--
function ui.fUpdateOpponent()
  local title
  local hpGaugeWidthDif = GUI.Opponent.Main.Health.front:get_width()
  --
  ui.fDebug("[&lt;cyan&gt;call&lt;r&gt;] ui.fUpdateOpponent()")
  --
  -- init
  ui.opponent       = {}
  ui.opponent.hp    = 0
  ui.opponent.hpmax = 100
  ui.opponent.level = 0
  ui.opponent.name  = ""
  ui.opponent.desc  = ""
  --
  if (ui.enDebug &gt;= 2) then
    ui.opponent.hp         = math.random(0, 100)
    ui.opponent.level      = math.random(1, 60)
    ui.opponent.name       = "C4tt1v0ne"
    ui.opponent.desc       = "Il C4tt1v0ne di d3bug"
  elseif (gmcp) and (gmcp.char) and (gmcp.char.vitals) and (gmcp.char.vitals.fighting) then
    ui.opponent.hp         = gmcp.char.vitals.fighting.hp or ui.opponent.hp
    ui.opponent.level      = gmcp.char.vitals.fighting.level or ui.opponent.level
    ui.opponent.name       = gmcp.char.vitals.fighting.name or ui.opponent.name
    ui.opponent.desc       = gmcp.char.vitals.fighting.desc or ui.opponent.desc
  end
  --
  if (hpGaugeWidthDif == 0) and (ui.opponent.hp &gt; 0) then
    -- Engage
    hpGaugeWidthDif = GUI.Opponent.Main.Health.back:get_width()
  end
  --
  ui.opponent.hp = tonumber(ui.opponent.hp) or 0
  --
  if (ui.opponent.name ~= "") then
    --
    -- Showed name
    title = ui.opponent.name;
    --
    -- Name
    ui.opponent.name = string.gsub(ui.opponent.name, "(\$c%d+)", "")
    ui.opponent.name = ui.fRemoveArticle(ui.opponent.name)
    ui.opponent.name = string.gsub(ui.opponent.name, " ", "-")
    --
    GUI.Opponent.Main.Health.front:echo(ui.opponent.name)
    --
    -- Level
    GUI.Opponent.Level:setFgColor(ui.fLevelColor(ui.opponent.level, ui.player.level))
    GUI.Opponent.Level:echo("&lt;center&gt;"..ui.opponent.level)
    GUI.Opponent.Level:show()
    --
    -- HP
    GUI.Opponent.Main.Health:setValue(math.max(0, ui.opponent.hp), ui.opponent.hpmax, "&lt;p align=right&gt;"..ui.opponent.hp.."%  &lt;/p&gt;")
    --
    -- Keybind
    ui.fAssignTargetButton("o0", ui.opponent.name)    
  else
    --
    -- reset showed name
    title = "* nessuno *"    --
    --
    -- Remove name
    GUI.Opponent.Main.Health.front:echo("")
    --
    -- Hide level
    GUI.Opponent.Level:hide()
    --
    -- Reset HP
    GUI.Opponent.Main.Health:setValue(0, 100, "")
    --
    -- Remove Keybind
    ui.fAssignTargetButton("o0", nil)
  end
  --
  ui.fUpdateAllTargetButton()
  --
  -- Diff. hp
  hpGaugeWidthDif = GUI.Opponent.Main.Health.front:get_width() - hpGaugeWidthDif
  --
  if (hpGaugeWidthDif ~= 0) then
    local x, y, w, h, txt, CSS
    --
    if (hpGaugeWidthDif &lt; 0) then
      x = GUI.Opponent.Main.Health.front:get_x() - GUI.Opponent.Main:get_x() + GUI.Opponent.Main.Health.front:get_width() - 3
      y = GUI.Opponent.Main.Health.front:get_y() - GUI.Opponent.Main:get_y()
      w = -hpGaugeWidthDif
      h = GUI.Opponent.Main.Health.front:get_height()
      txt = "- -"
      CSS = GUI.CSS.GaugeFront..[[
        qproperty-alignment: 'AlignRight';
        border: 1px solid rgba(255, 0, 0, 0.8);
        background-color: rgba(255, 0, 0, 0.4);
      ]]
    else
      x = GUI.Opponent.Main.Health.front:get_x() - GUI.Opponent.Main:get_x() + GUI.Opponent.Main.Health.front:get_width() - hpGaugeWidthDif
      y = GUI.Opponent.Main.Health.front:get_y() - GUI.Opponent.Main:get_y()
      w = hpGaugeWidthDif
      h = GUI.Opponent.Main.Health.front:get_height()
      txt = "++"
      CSS = GUI.CSS.GaugeFront..[[
        qproperty-alignment: 'AlignRight';
        border: 1px solid rgba(0, 255, 0, 0.8);
        background-color: rgba(0, 255, 0, 0.4);
      ]]
    end
    --
    x = math.max(0, x);
    --
    GUI.Opponent.Main.Health.dif:move(x, y);
    GUI.Opponent.Main.Health.dif:resize(w, h)
    GUI.Opponent.Main.Health.dif:echo(txt)
    GUI.Opponent.Main.Health.dif:setStyleSheet(CSS)
    --
    ui.fDifTimerOpponent(1.5)
  end
  --
  -- Target on title
  if (ui.variables.target) and (ui.variables.target ~= "") then
    title = title.." (T:"..ui.variables.target..")"
  end
  GUI.Opponent:setTitle(title)
end</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>Options</name>
					<packageName></packageName>
					<script>-- Read Variables data from file
function ui.fReadFileOptions()
  local file = ui.files.options.path..ui.files.options.name
  --
  ui.fDebug("[&lt;cyan&gt;call&lt;r&gt;] ui.fReadFileOptions()")
  --
  -- Remove actual Variables
  ui.options = {}
  --
  -- Load Variables
  if (io.exists(file)) then
    table.load(file, ui.options)
  end
  --
  -- Merge pre defined variables
  ui.options = table.update(ui.pre_defined_options, ui.options)
  --
  -- Save
  table.save(file, ui.options)
end</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>Parameters</name>
					<packageName></packageName>
					<script>--
function ui.fGetPreDefinitedParameters()
  return {
    widgets = {
      affects = {
        transparent = false,
      },
      aliasButton ={
        transparent = false,
      },
      chat = {
        type = "all",
        split = false,    
        fontSize = 8,
      },
      cooldowns = {
        transparent = false,
      },
      endowment = {
        transparent = false,
      },
      group = {
        transparent = false,
      },
      help = {
        fontSize = 8,
      },
      keybind = {
        fontSize = 6,
      },
      mapper = {
        transparent = false,
      },
      opponent = {
        transparent = false,
      },
      overland = {
        fontSize = 8,
      },
      player = {
        transparent = false,
      },
      room = {
        fontSize = 7,
        transparent = false,
      },
      targets = {
        transparent = false,
      },
    },
    page = "a",
  }
end
--
-- Save Parameters data to file
function ui.fSaveFileParameters()
  local file = ui.files.parameters.path..ui.files.parameters.name
  --
  ui.fDebug("[&lt;cyan&gt;call&lt;r&gt;] ui.fSaveFileParameters()")
  --
  table.save(file, ui.parameters)
end
--
-- Read Parameters data from file
function ui.fReadFileParameters()
  local file = ui.files.parameters.path..ui.files.parameters.name
  --
  ui.fDebug("[&lt;cyan&gt;call&lt;r&gt;] ui.fReadFileParameters()")
  --
  -- Load parameters
  ui.parameters = ui.parameters or {}
  if (io.exists(file)) then
    table.load(file, ui.parameters)
  end
  ui.parameters = table.update(ui.fGetPreDefinitedParameters(), ui.parameters)
  --
  ui.fSaveFileParameters()
end</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>Player</name>
					<packageName></packageName>
					<script>--
function ui.fSoftenRound(time_left)
  ui.fDebug("[&lt;cyan&gt;call&lt;r&gt;] ui.fSoftenRound(&lt;white&gt;"..(time_left or "nil").."&lt;r&gt;)", 3)
  --
  if (ui.handlers.fSoftenRound) then
    killTimer(ui.handlers.fSoftenRound);
    ui.handlers.fSoftenRound = nil;
  end
  --
  -- Elapsed time
  ui.epoch = getEpoch();
  ui.previous.epoch = ui.previous.epoch or ui.epoch;
  ui.elapsed = ui.epoch - ui.previous.epoch;
  ui.previous.epoch = ui.epoch;
  --
  -- Round soften
  GUI.Player.Main.Round:setValue(math.max(0, time_left), ui.player.roundMax + 1, "")
  time_left = math.max(0, time_left - ui.elapsed);
  --
  ui.handlers.fSoftenRound = tempTimer(0.10, function() ui.fSoftenRound(time_left) end)
end
--
function ui.fDifTimerPlayer(time_left)
  ui.fDebug("[&lt;cyan&gt;call&lt;r&gt;] ui.fDifTimerPlayer(&lt;white&gt;"..(time_left or "nil").."&lt;r&gt;)", 3)
  --
  if (ui.handlers.fDifTimerPlayer) then
    killTimer(ui.handlers.fDifTimerPlayer)
    ui.handlers.fDifTimerPlayer = nil;
  end
  --
  if (time_left &gt; 0) then
    ui.handlers.fDifTimerPlayer = tempTimer(time_left, function() ui.fDifTimerPlayer(0.0) end)
    GUI.Player.Main.Health.dif:show()
  else
    GUI.Player.Main.Health.dif:hide()
  end
end
--
function ui.fUpdatePlayer()
  local hpGaugeWidthDif = GUI.Player.Main.Health.front:get_width()
  --
  ui.fDebug("[&lt;cyan&gt;call&lt;r&gt;] ui.fUpdatePlayer()")
  --
  -- init vars
  ui.player = {
    class          = "",
    experience     = 1,
    gold           = 0,
    level          = 0,
    name           = "",
    race           = "",
    toNext         = 1,

    hp             = 1,
    maxhp          = 1,
    mana           = 1,
    maxmana        = 1,
    mov            = 1,
    maxmov         = 1,
    pow            = 1,
    maxpow         = 1,
    
    roundMax       = 4,
    roundTicker    = 0,
    
    secsToTick     = 0,
  }
  --
  ui.previous.player = ui.previous.player or ui.player;
  ui.previous.fastAffects = ui.previous.fastAffects or ui.fastAffects;
  --
  -- for debug
  if (ui.enDebug &gt;= 2) then
    ui.player.class          = "debugger"
    ui.player.experience     = math.random(0, 100000000)
    ui.player.gold           = math.random(0, 100000000)
    ui.player.level          = math.random(0, 60)
    ui.player.name           = "D3Bu4 M0D3"
    ui.player.race           = "bot"
    ui.player.toNext         = math.random(0, ui.player.experience)
  
    ui.player.hp             = math.random(0, 100)
    ui.player.maxhp          = 100
    ui.player.mana           = math.random(0, 100)
    ui.player.maxmana        = 100
    ui.player.mov            = math.random(0, 100)
    ui.player.maxmov         = 100
    ui.player.pow            = math.random(0, 100)
    ui.player.maxpow         = 100
    
    ui.player.roundMax       = 5
    ui.player.roundTicker    = math.random(0, ui.player.roundMax)
    
    ui.player.secsToTick     = math.random(0, 74)
    
  elseif (gmcp) and (gmcp.char) and (gmcp.char.base) and (gmcp.char.vitals) then
    ui.player.class          = gmcp.char.base.class or ui.player.class
    ui.player.experience     = gmcp.char.base.experience or ui.player.experience
    ui.player.gold           = gmcp.char.base.gold or ui.player.gold
    ui.player.level          = gmcp.char.base.level or ui.player.level
    ui.player.name           = gmcp.char.base.name or ui.player.name
    ui.player.race           = gmcp.char.base.race or ui.player.race
    ui.player.toNext         = gmcp.char.base.toNext or ui.player.toNext
  
    ui.player.hp             = gmcp.char.vitals.hp or ui.player.hp
    ui.player.maxhp          = gmcp.char.vitals.maxhp or ui.player.maxhp
    ui.player.mana           = gmcp.char.vitals.mana or ui.player.mana
    ui.player.maxmana        = gmcp.char.vitals.maxmana or ui.player.maxmana
    ui.player.mov            = gmcp.char.vitals.mov or ui.player.mov
    ui.player.maxmov         = gmcp.char.vitals.maxmov or ui.player.maxmov
    ui.player.pow            = gmcp.char.vitals.pow or ui.player.pow
    ui.player.maxpow         = gmcp.char.vitals.maxpow or ui.player.maxpow
    
    ui.player.roundMax       = gmcp.char.vitals.roundMax or ui.player.roundMax
    ui.player.roundTicker    = gmcp.char.vitals.roundTicker or ui.player.roundTicker
    
    ui.player.secsToTick     = gmcp.char.vitals.secsToTick or ui.player.secsToTick
  end
  --
  -- Tittle
  if (ui.player.name ~= ui.previous.player.name) or
     (ui.player.race ~= ui.previous.player.race) or
     (ui.player.class ~= ui.previous.player.class) or
     (ui.fastAffects ~= ui.previous.fastAffects) then
    if (ui.fastAffects == '') then
      GUI.Player:setTitle(ui.player.name.." "..ui.player.race.." "..ui.player.class);
    else
      GUI.Player:setTitle(ui.player.name..ui.fastAffects);
    end
  end
  --
  -- Level
  if (ui.player.level ~= ui.previous.player.level) then
    GUI.Player.Level:echo("&lt;center&gt;"..ui.player.level);
  end
  --
  -- Tick
  ui.player.secsToTick = tonumber(ui.player.secsToTick)
  if (ui.player.secsToTick ~= ui.previous.player.secsToTick) then
    GUI.Player.Main.Tick:setValue(math.max(0, ui.player.secsToTick), 74, "")
    --
    -- Cooldowns soften (every seconds)
    if (not table.is_empty(ui.cooldowns)) then
      for cooldown in pairs(ui.cooldowns) do
        ui.cooldowns[cooldown].duration = math.max(0, ui.cooldowns[cooldown].duration - 1/4);
      end
      ui.fRefreshCooldownsWidget()
    end
  end
  --
  -- HP
  ui.player.hp = tonumber(ui.player.hp)
  ui.player.maxhp = tonumber(ui.player.maxhp)
  if (ui.player.hp  ~= ui.previous.player.hp) or
     (ui.player.maxhp  ~= ui.previous.player.maxhp) then
    local hpPerc = math.floor(100 * ui.player.hp / ui.player.maxhp); 
    --
    if (hpPerc &lt;= 40) then
      playSoundFile(ui.files.sounds.path..[[hurt.wav]], 10)
    end
    --
    GUI.Player.Main.Health:setValue(math.min(math.max(0, ui.player.hp), ui.player.maxhp), ui.player.maxhp,"&lt;p align=right&gt;"..ui.player.hp.."/"..ui.player.maxhp.." - "..hpPerc.."% &lt;/p&gt;")
  end
  --
  -- Round counter
  ui.player.roundTicker = tonumber(ui.player.roundTicker)
  ui.player.roundMax = tonumber(ui.player.roundMax)
  ui.player.roundMax = math.max(ui.player.roundMax, 1)  
  if (ui.player.roundTicker ~= ui.previous.player.roundTicker) or
     (ui.player.roundMax ~= ui.previous.player.roundMax) then
    if (ui.player.roundTicker == ui.player.roundMax + 1) then
      ui.fSoftenRound(ui.player.roundTicker)
    end
  end
  --
  -- Mana
  ui.player.mana = tonumber(ui.player.mana)
  ui.player.maxmana = tonumber(ui.player.maxmana)
  if (ui.player.mana ~= ui.previous.player.mana) or
     (ui.player.maxmana  ~= ui.previous.player.maxmana) then
    local manaPerc = math.floor(100 * ui.player.mana / ui.player.maxmana); 
    --
    if (ui.player.mana &lt; ui.previous.player.mana) then
      playSoundFile(ui.files.sounds.path..[[cast.wav]], 10)
    end
    --
    GUI.Player.Main.Mana:setValue(math.min(math.max(0, ui.player.mana), ui.player.maxmana), ui.player.maxmana, "&lt;p align=right&gt;"..ui.player.mana.."/"..ui.player.maxmana.." - "..manaPerc.."% &lt;/p&gt;")
  end
  --
  -- Power
  ui.player.pow = tonumber(ui.player.pow)
  ui.player.maxpow = tonumber(ui.player.maxpow)
  if (ui.player.pow ~= ui.previous.player.pow) or
     (ui.player.maxpow  ~= ui.previous.player.maxpow) then
      local powerPerc = math.floor(100 * ui.player.pow / ui.player.maxpow);
      --
      GUI.Player.Main.Power:setValue(math.min(math.max(0, ui.player.pow), ui.player.maxpow), ui.player.maxpow, "&lt;p align=right&gt;"..ui.player.pow.."/"..ui.player.maxpow.." - "..powerPerc.."% &lt;/p&gt;")
  end
  --
  -- Stamina
  ui.player.mov = tonumber(ui.player.mov)
  ui.player.maxmov = tonumber(ui.player.maxmov)
  if (ui.player.mov ~= ui.previous.player.mov) or
     (ui.player.maxmov  ~= ui.previous.player.maxmov) then
      local staminaPerc = math.floor(100 * ui.player.mov / ui.player.maxmov); 
      --
      GUI.Player.Main.Stamina:setValue(math.min(math.max(0, ui.player.mov), ui.player.maxmov), ui.player.maxmov, "&lt;p align=right&gt;"..ui.player.mov.."/"..ui.player.maxmov.." - "..staminaPerc.."% &lt;/p&gt;")
  end
  --
  -- Experience
  ui.player.experience = tonumber(ui.player.experience)
  ui.player.toNext = tonumber(ui.player.toNext) + ui.player.experience
  ui.player.toNext = math.max(ui.player.toNext, ui.player.experience)  
  if (ui.player.experience ~= ui.previous.player.experience) or
     (ui.player.toNext  ~= ui.previous.player.toNext) then
    GUI.Player.Main.Experience:setValue(math.min(math.max(0, ui.player.experience), ui.player.toNext), ui.player.toNext, "")
  end
  --
  hpGaugeWidthDif = GUI.Player.Main.Health.front:get_width() - hpGaugeWidthDif
  if (hpGaugeWidthDif ~= 0) then
    local x, y, w, h, txt, CSS
    --
    if (hpGaugeWidthDif &lt; 0) then
      x = GUI.Player.Main.Health.front:get_x() - GUI.Player.Main:get_x() + GUI.Player.Main.Health.front:get_width() - 3
      y = GUI.Player.Main.Health.front:get_y() - GUI.Player.Main:get_y()
      w = -hpGaugeWidthDif
      h = GUI.Player.Main.Health.front:get_height()
      txt = "- -"
      CSS = GUI.CSS.GaugeFront..[[
        qproperty-alignment: 'AlignRight';
        border: 1px solid rgba(255, 0, 0, 0.8);
        background-color: rgba(255, 0, 0, 0.4);
      ]]
    else
      x = GUI.Player.Main.Health.front:get_x() - GUI.Player.Main:get_x() + GUI.Player.Main.Health.front:get_width() - hpGaugeWidthDif
      y = GUI.Player.Main.Health.front:get_y() - GUI.Player.Main:get_y()
      w = hpGaugeWidthDif
      h = GUI.Player.Main.Health.front:get_height()
      txt = "++"
      CSS = GUI.CSS.GaugeFront..[[
        qproperty-alignment: 'AlignRight';
        border: 1px solid rgba(0, 255, 0, 0.8);
        background-color: rgba(0, 255, 0, 0.4);
      ]]
    end
    --
    GUI.Player.Main.Health.dif:move(x, y);
    GUI.Player.Main.Health.dif:resize(w, h)
    GUI.Player.Main.Health.dif:echo(txt)
    GUI.Player.Main.Health.dif:setStyleSheet(CSS)
    --
    ui.fDifTimerPlayer(1.5)
  end
  --
  ui.previous.player = ui.player;
  ui.previous.fastAffects = ui.fastAffects;
end</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>Profiles</name>
					<packageName></packageName>
					<script>--
function ui.fGetProfileNameFormattedText(profile)
  return ui.colors.profileName..profile.."&lt;r&gt;"
end
--
--
function ui.fInitProfiles()
  local lfs = require("lfs")
  --
  ui.fDebug("[&lt;cyan&gt;call&lt;r&gt;] ui.fInitProfiles()")
  --
  if (lfs.chdir(ui.files.profiles.path)) then
    ui.fDebug("ui.fInitProfiles() - Cartella profili inizializzata correttamente.")
  elseif (lfs.mkdir(ui.files.profiles.path)) then
    ui.fDebug("ui.fInitProfiles() - Cartella profili creata correttamente.")
  else
    ui.fDebug("ui.fInitProfiles() - Impossibile caricare la cartella profili.")
  end
end
--
-- Get saved profiles list
function ui.fGetProfiles()
  local lfs = require("lfs")
  local profiles = {}
  --
  ui.fDebug("[&lt;cyan&gt;call&lt;r&gt;] ui.fGetProfiles()")
  --
  if (lfs.chdir(ui.files.profiles.path)) then
    for profile in lfs.dir(ui.files.profiles.path) do
      if (profile~=".") and (profile~="..") and (lfs.chdir(ui.files.profiles.path..profile)) then
        profiles[#profiles+1] = profile
      end
    end
  end
  --
  return profiles
end
--
function ui.fContainProfile(profiles, profile)
  for _, p in pairs(profiles) do
    if (p == profile) then
      return true
    end
  end
  --
  return false;
end
--
-- List all aliases
function ui.fShowAllProfiles()
  local profiles = ui.fGetProfiles()
  local nProfiles = 0
  --
  ui.fDebug("[&lt;cyan&gt;call&lt;r&gt;] ui.ShowAllProfiles()")
  --
  cecho(ui.fTitle("Profili"))
  for profile in ui.fOrderedPairs(profiles) do
    nProfiles = nProfiles + 1
    cecho(ui.fGetNumberFormattedText(nProfiles).." "..ui.fGetProfileNameFormattedText(profiles[profile]).."\n")
  end
  --
  if (nProfiles&gt;0) then
    echo("\n")
  else
    cecho("Per maggiori info "..ui.fGetCommandFormattedText("uihelp uiprofiles").."\n\n")
  end
end
--
function ui.fLoadProfile(profile)
  local profiles = ui.fGetProfiles()
  --
  ui.fDebug("[&lt;cyan&gt;call&lt;r&gt;] ui.fLoadProfile("..(profile or "nil")..")")
  --
  if (ui.fContainProfile(profiles, profile)) then
    --
    -- Load variables
    if (ui.fCopyFile(ui.files.profiles.path..profile.."/"..ui.files.variables.name, ui.files.variables.path..ui.files.variables.name)) then
      ui.fDebug("Reload 'Variables' from file")
      ui.fReadFileVariables()
    end
    --
    -- Load targets
    if (ui.fCopyFile(ui.files.profiles.path..profile.."/"..ui.files.targets.name, ui.files.targets.path..ui.files.targets.name)) then
      ui.fDebug("Reload Load 'Targets' from file")
      ui.fReadFileTargets()
    end
    --
    -- Load Aliases
    if (ui.fCopyFile(ui.files.profiles.path..profile.."/"..ui.files.aliases.name, ui.files.aliases.path..ui.files.aliases.name)) then
      ui.fDebug("Reload 'Aliases' from file")
      ui.fReadFileAliases()
    end
    --
    -- Load Highlights
    if (ui.fCopyFile(ui.files.profiles.path..profile.."/"..ui.files.highlights.name, ui.files.highlights.path..ui.files.highlights.name)) then
      ui.fDebug("Reload Load 'Highlights' from file")
      ui.fReadFileHighlights()
    end
    -- Refresh widget
    ui.fUpdateTarget()
    ui.fUpdateOpponent()
    ui.fUpdateGroup()
    ui.fUpdatePlayer()
    ui.fUpdateAliasButton()
    --
    return true
  end
  --
  return nil
end
--
function ui.fRemoveProfile(profile)
  local profiles = ui.fGetProfiles()
  --
  ui.fDebug("[&lt;cyan&gt;call&lt;r&gt;] ui.fRemoveProfile("..(profile or "nil")..")")
  --
  if (ui.fContainProfile(profiles, profile)) then
    ui.fDeleteDirectory(ui.files.profiles.path..profile)
    --
    return true
  end
  --
  return nil
end
--
function ui.fRemoveAllProfiles()
  local profiles = ui.fGetProfiles()
  --
  ui.fDebug("[&lt;cyan&gt;call&lt;r&gt;] ui.fRemoveAllProfiles()")
  --
  for profile in pairs(profiles) do
    ui.fDeleteDirectory(ui.files.profiles.path..profiles[profile])
  end
  --
  return true
end
--
function ui.fSaveProfile(profile)
  local lfs = require("lfs")
  local profiles = ui.fGetProfiles()
  --
  ui.fDebug("[&lt;cyan&gt;call&lt;r&gt;] ui.fSaveProfile("..(profile or "nil")..")")
  --
  if (ui.fContainProfile(profiles, profile)) then
    ui.fDeleteDirectory(ui.files.profiles.path..profile)
  end
  --
  if (lfs.mkdir(ui.files.profiles.path..profile)) then
    ui.fCopyFile(ui.files.aliases.path..ui.files.aliases.name,       ui.files.profiles.path..profile.."/"..ui.files.aliases.name)
    ui.fCopyFile(ui.files.highlights.path..ui.files.highlights.name, ui.files.profiles.path..profile.."/"..ui.files.highlights.name)
    ui.fCopyFile(ui.files.targets.path..ui.files.targets.name,       ui.files.profiles.path..profile.."/"..ui.files.targets.name)
    ui.fCopyFile(ui.files.variables.path..ui.files.variables.name,   ui.files.profiles.path..profile.."/"..ui.files.variables.name)
    --
    return true
  end
  --
  return nil
end</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>Room</name>
					<packageName></packageName>
					<script>function ui.fDrawRoomPosition(position)
  local isPlayerPos = (ui.player.roomPos == position)
  local isPlayersPos = false
  local isMobPos = false 
  --
  -- Players
  for _, player in pairs(ui.room.players) do
    if (player.roomPos == position) then
      isPlayersPos = true
    end
  end
  --
  -- Mobs
  for _, mob in pairs(ui.room.mobs) do
    if (mob.roomPos == position) then
      isMobPos = true
    end
  end
  --
  --      
  if (isPlayerPos) and (isPlayersPos) and (isMobPos) then
    return "&lt;brown&gt;⨂&lt;r&gt;"
  elseif (isPlayerPos) and (isPlayersPos) then
    return "&lt;gold&gt;⨂&lt;r&gt;"
  elseif (isPlayerPos) and (isMobPos) then
    return "&lt;orange&gt;⨂&lt;r&gt;"
  elseif (isPlayersPos) and (isMobPos) then
    return "&lt;magenta&gt;⨂&lt;r&gt;"
  elseif (isMobPos) then
    return "&lt;red&gt;⨂&lt;r&gt;"
  elseif (isPlayersPos) then
    return "&lt;yellow&gt;⨂&lt;r&gt;"
  elseif (isPlayerPos) then
    return "&lt;white&gt;⨂&lt;r&gt;"
  else
    return "&lt;DimGrey&gt;"..position.."&lt;r&gt;"
  end
end
--
function ui.fDrawRoomLine(line)
  local position = ""
  local icon = ""
  --
  -- Player icon or track direction
  if (ui.track == nil) or (ui.track == "") then
    icon = "&lt;white&gt;⨂&lt;r&gt;"
  else
    icon = ui.validExit[ui.track].color..ui.validExit[ui.track].tokenOpen.."&lt;r&gt;"
  end
  --
  -- Line 1
  if (line == 1) then
    position = ui.fDrawRoomPosition(7).."  "..ui.fDrawRoomPosition(8).."  "..ui.fDrawRoomPosition(9)
  --
  -- Line 2
  elseif (line == 2) then
    position = ui.fDrawRoomPosition(4).."  "..ui.fDrawRoomPosition(5).."  "..ui.fDrawRoomPosition(6)
  --
  -- Line 3
  elseif (line == 3) then
    position = ui.fDrawRoomPosition(1).."  "..ui.fDrawRoomPosition(2).."  "..ui.fDrawRoomPosition(3)
  --
  else
    position = "X  X  X"
  end
  --
  return position
end
--
function ui.fGetToken(exits, exit)
  local token = ""
  --
  exit = string.lower(exit)
  if (ui.validExit[exit]) then
    if (table.contains(exits, exit)) then
      --
      -- From direction
      if (table.contains(ui.origins, ui.validExit[exit].short)) then
        token = ui.validExit[exit].color..ui.validExit[exit].tokenFrom.."&lt;r&gt;"
      --
      -- Normal exit
      else
        token = ui.validExit[exit].color..ui.validExit[exit].tokenOpen.."&lt;r&gt;"
      end
    --
    -- No exit
    elseif (ui.validExit[exit]) then
      token = ui.validExit[exit].tokenAbsent
    end
  end
  --
  return token
end
--
function ui.fNextTrack(id)
  id = tonumber(id)
  --
  -- On SpeedWalk
  if (table.contains(ui.speedwalk.path, id)) and (ui.speedwalk.path[#ui.speedwalk.path] ~= id) then
   for i in ipairs(ui.speedwalk.path) do
     if (ui.speedwalk.path[i] == id) then
       while (ui.speedwalk.path[i] == id) do
         i = i + 1;
       end
       return ui.speedwalk.path[i]
     end
   end
  end
  --
  return -1;
end
--
function ui.fUpdateRoom()
  local token
  --
  ui.fDebug("[&lt;cyan&gt;call&lt;r&gt;] ui.fUpdateRoom()")
  --
  if (gmcp) and (gmcp.room) and (gmcp.room.info) then
    local trackText = "&lt;red&gt;[&lt;orange&gt;T&lt;red&gt;]&lt;r&gt;"
    --
    clearWindow("GUI.Room.Main.Console")
    --  
    ui.previous.room = {}
    ui.previous.room = table.deepcopy(ui.room) or {}
    ui.previous.room.exits = ui.previous.room.exits or {}
    ui.previous.room.otherExits = ui.previous.room.otherExits or {}
    --
    ui.room = {
      id      = -1,
      name    = "",
      area    = "",
      subArea = "",
      terrain = "",
      isOnMap = false,
      mobs = {},
      exits = {},
      otherExits = {},  
      objects = {},
      players = {},
    }
    --
    ui.room.id      = tonumber(gmcp.room.info.num) or ui.room.id
    ui.room.name    = ui.fConvertColorString(gmcp.room.info.name or "") or ui.room.name
    ui.room.area    = ui.fConvertColorString(gmcp.room.info.zone or "") or ui.room.area
    ui.room.subArea = ui.fConvertColorString(gmcp.room.info.subzone or "") or ui.room.subArea
    ui.room.terrain = ui.fConvertColorString(gmcp.room.info.terrain or "") or ui.room.terrain
    ui.room.isOnMap = gmcp.room.info.isOnMap or ui.room.isOnMap
    --
    ui.player.roomPos = ui.player.roomPos or 5
    --
    -- Origins
    if (ui.room.id ~= ui.previous.room.id) then
      ui.origins = {}
      --
      -- origins from previous exits
      for exit, id in pairs(ui.previous.room.exits) do
        if (ui.room.id == id) then
          table.insert(ui.origins, ui.validExit[exit].reverse)
        end
      end
      --
      -- origins from previous special exits
      for exit, id in pairs(ui.previous.room.otherExits) do
        if (ui.room.id == id) then
          table.insert(ui.origins, exit)
        end
      end
    end
    --
    --  Exits and Other exits
    if (gmcp.room.info.exits) then
      for exit in pairs(gmcp.room.info.exits) do
        exit = string.lower(exit)
        if (gmcp.room.info.exits[exit] &gt; 0) and (gmcp.room.info.exits[exit] ~= ui.room.id) then
          if (ui.validExit[exit]) then
            ui.room.exits[exit] = tonumber(gmcp.room.info.exits[exit])
          else
            ui.room.otherExits[exit] = tonumber(gmcp.room.info.exits[exit])
          end
        end
      end
    end
    --
    --  Mobs and Players
    if (gmcp.room.info.characters) then
      for _, character in pairs(gmcp.room.info.characters) do
        --
        -- Player
        if (character.player) then
          local name = character.level.."_"..character.desc
          if (ui.room.players[name]) then
            ui.room.players[name].counter = ui.room.players[name].counter + 1 
          else
            ui.room.players[name] = {}
            ui.room.players[name].desc = character.desc;
            ui.room.players[name].level = ui.fdigitNumber(character.level);
            ui.room.players[name].roomPos = character.roomPos;
            ui.room.players[name].counter = 1;
          end
        --
        -- Mob
        else
          local name = character.level.."_"..character.desc.."_"..character.key
          if (ui.room.mobs[name]) then
            ui.room.mobs[name].counter = ui.room.mobs[name].counter + 1 
          else
            ui.room.mobs[name] = {}
            ui.room.mobs[name].desc = character.desc;
            ui.room.mobs[name].key = character.key;
            ui.room.mobs[name].level = ui.fdigitNumber(character.level);
            ui.room.mobs[name].roomPos = character.roomPos;
            ui.room.mobs[name].counter = 1;
          end
        end   
      end
    end
    --
    -- Objects
    if (gmcp.room.info.objects) then
      for _, object in pairs(gmcp.room.info.objects) do
        local name = object.desc.."_"..object.key;
        if (ui.room.objects[name]) then
          ui.room.objects[name].counter = ui.room.objects[name].counter + 1 
        else
          ui.room.objects[name] = {}
          if (object.desc == "") then
            ui.room.objects[name].desc = "["..object.key.."]";
          else
            ui.room.objects[name].desc = object.desc;
          end
          ui.room.objects[name].key = object.key;
          ui.room.objects[name].counter = 1;
        end   
      end
    end    
    --
    if (ui.room.isOnMap) then
      --
      -- Outland
      GUI.Room.Main.Console:cecho("                        "..ui.room.name.."&lt;r&gt;\n")
      GUI.Room.Main.Console:cecho("      ┌       ┐\n")
      GUI.Room.Main.Console:cecho("       "..ui.fDrawRoomLine(1).."\n")
      GUI.Room.Main.Console:cecho("       "..ui.fDrawRoomLine(2).."\n")
      GUI.Room.Main.Console:cecho("       "..ui.fDrawRoomLine(3).."\n")
      GUI.Room.Main.Console:cecho("      └       ┘\n\n")
      --
      GUI.Mapper.Main.Mapper:hide();
      GUI.Mapper.Main.Overland:show();
    else
      --
      -- Mapper
      local exitsAsString = {}
      local exitsDestinationId = {}
      local exitsCommand = {}
      local idx = 1
      --
      -- Prepare Line 1: End of path
      if (ui.speedwalk.path[#ui.speedwalk.path] == ui.room.id) then
        exitsAsString[idx] = "&lt;red&gt;[&lt;white&gt;⨂&lt;cyan&gt;&lt;red&gt;]&lt;cyan&gt;"
      else
        exitsAsString[idx] = "&lt;white&gt; ⨂ &lt;cyan&gt;"
      end
      exitsAsString[idx] = exitsAsString[idx]..ui.room.name.." &lt;ansiMagenta&gt;#&lt;white&gt;"..ui.room.id.."&lt;r&gt;"
      idx = idx + 1
      --
      -- Prepare other line
      for k,v in pairs(ui.room.exits) do
        exitsDestinationId[k] = ui.validExit[k].color..ui.fAddSpace(""..v, 5).."&lt;r&gt;"
        -- Next step in path
        if (ui.fNextTrack(ui.room.id) == v) then
          exitsAsString[idx] = "&lt;red&gt;["..ui.validExit[k].color..ui.validExit[k].tokenOpen.."&lt;red&gt;]&lt;r&gt;"..ui.fConvertColorString(getRoomName(v) or "???")
        else
          exitsAsString[idx] = " "..ui.validExit[k].color..ui.validExit[k].tokenOpen.."&lt;r&gt; "..ui.fConvertColorString(getRoomName(v) or "???")
        end
        -- Exits command
        exitsCommand[idx] = ui.validExit[k].long
        idx = idx + 1
      end
      --
      -- Line 1
      GUI.Room.Main.Console:cecho("        "..(exitsDestinationId["north"] or "     ").."   "..(exitsDestinationId["up"] or "     ").."   ")
      --GUI.Room.Main.Console:cechoLink(ui.cLink("👁 "), [[expandAlias("look")]], "Guarda", true)
      GUI.Room.Main.Console:cecho((exitsAsString[1] or "").."\n")    
      --
      -- Line 2
      GUI.Room.Main.Console:cecho("&lt;r&gt;      ┌───"..ui.fGetToken(ui.room.exits, "north").."───"..ui.fGetToken(ui.room.exits, "up").."         ")
      if (exitsAsString[2]) then
        --GUI.Room.Main.Console:cechoLink(ui.cLink("👁 "), [[expandAlias("look ]]..exitsCommand[2]..[[")]], "Guarda a "..exitsCommand[2], true)
        GUI.Room.Main.Console:cechoLink(exitsAsString[2], [[expandAlias("]]..exitsCommand[2]..[[")]], "Vai a "..exitsCommand[2], true)
      end
      GUI.Room.Main.Console:cecho("\n")
      --
      -- Line 3
      GUI.Room.Main.Console:cecho("&lt;r&gt;      │"..ui.fDrawRoomLine(1).."│         ")
      if (exitsAsString[3]) then
        --GUI.Room.Main.Console:cechoLink(ui.cLink("👁 "), [[expandAlias("look ]]..exitsCommand[3]..[[")]], "Guarda a "..exitsCommand[3], true)
        GUI.Room.Main.Console:cechoLink(exitsAsString[3], [[expandAlias("]]..exitsCommand[3]..[[")]], "Vai a "..exitsCommand[3], true)
      end
      GUI.Room.Main.Console:cecho("\n")
      --
      -- Line 4
      GUI.Room.Main.Console:cecho("&lt;r&gt;"..(exitsDestinationId["west"] or "     ").." "..ui.fGetToken(ui.room.exits, "west")..ui.fDrawRoomLine(2)..ui.fGetToken(ui.room.exits, "east").." "..(exitsDestinationId["east"] or "     ").."   ")
      if (exitsAsString[4]) then
        --GUI.Room.Main.Console:cechoLink(ui.cLink("👁 "), [[expandAlias("look ]]..exitsCommand[4]..[[")]], "Guarda a "..exitsCommand[4], true)
        GUI.Room.Main.Console:cechoLink(exitsAsString[4], [[expandAlias("]]..exitsCommand[4]..[[")]], "Vai a "..exitsCommand[4], true)
      end
      GUI.Room.Main.Console:cecho("\n")
      --
      -- Line 5
      GUI.Room.Main.Console:cecho("&lt;r&gt;      │"..ui.fDrawRoomLine(3).."│         ")
      if (exitsAsString[5]) then
        --GUI.Room.Main.Console:cechoLink(ui.cLink("👁 "), [[expandAlias("look ]]..exitsCommand[5]..[[")]], "Guarda a "..exitsCommand[5], true)
        GUI.Room.Main.Console:cechoLink(exitsAsString[5], [[expandAlias("]]..exitsCommand[5]..[[")]], "Vai a "..exitsCommand[5], true)
      end
      GUI.Room.Main.Console:cecho("\n")
      --
      -- Line 6
      GUI.Room.Main.Console:cecho("&lt;r&gt;      "..ui.fGetToken(ui.room.exits, "down").."───"..ui.fGetToken(ui.room.exits, "south").."───┘         ")
      if (exitsAsString[6]) then
        --GUI.Room.Main.Console:cechoLink(ui.cLink("👁 "), [[expandAlias("look ]]..exitsCommand[6]..[[")]], "Guarda a "..exitsCommand[6], true)
        GUI.Room.Main.Console:cechoLink(exitsAsString[6], [[expandAlias("]]..exitsCommand[6]..[[")]], "Vai a "..exitsCommand[6], true)
      end
      GUI.Room.Main.Console:cecho("\n")
      --
      -- Line 7
      GUI.Room.Main.Console:cecho("&lt;r&gt;"..(exitsDestinationId["down"] or "     ").."   "..(exitsDestinationId["south"] or "     ").."           ")
      if (exitsAsString[7]) then
        --GUI.Room.Main.Console:cechoLink(ui.cLink("👁 "), [[expandAlias("look ]]..exitsCommand[7]..[[")]], "Guarda a "..exitsCommand[7], true)
        GUI.Room.Main.Console:cechoLink(exitsAsString[7], [[expandAlias("]]..exitsCommand[7]..[[")]], "Vai a "..exitsCommand[7], true)
      end
      GUI.Room.Main.Console:cecho("\n\n")
      --
      GUI.Mapper.Main.Mapper:show();
      GUI.Mapper.Main.Overland:hide();
    end
    --
    -- Other exits
    if (table.size(ui.room.otherExits) &gt; 0) then
      for otherExit, idOtherExit in pairs(ui.room.otherExits) do
        otherExit = string.gsub(otherExit, "(%a)([%w_']*)", ui.fTitleCase)
        -- Next step in path
        if (ui.fNextTrack(ui.room.id) == idOtherExit) then
          GUI.Room.Main.Console:cechoLink("&lt;red&gt;[&lt;orange&gt;▷&lt;red&gt;]&lt;orange&gt;"..otherExit.."&lt;r&gt;", [[expandAlias("ent ]]..otherExit..[[")]], "Entra in '"..otherExit.."'", true)
        else
          GUI.Room.Main.Console:cechoLink("&lt;orange&gt; ▷ "..otherExit.."&lt;r&gt;", [[expandAlias("ent ]]..otherExit..[[")]], "Entra in '"..otherExit.."'", true)
        end
        GUI.Room.Main.Console:cecho(" "..ui.fConvertColorString(getRoomName(idOtherExit) or "???").."\n")
      end
      GUI.Room.Main.Console:echo("\n")
    end
    --
    -- Room name
    GUI.Room:setTitle(ui.room.area.." - "..ui.room.terrain)
    --  
    local function fGetCounter(counter)
      if (counter) and (tonumber(counter) &gt; 1) then
        return counter;
      end
      return '-'
    end
    --
    -- Objects
    if (table.size(ui.room.objects) &gt; 0) then
      for _, object in pairs(ui.room.objects) do
        GUI.Room.Main.Console:cecho("&lt;ansiMagenta&gt;[&lt;white&gt;"..fGetCounter(object.counter).."&lt;ansiMagenta&gt;]&lt;r&gt; "..
                                    "&lt;green&gt;O&lt;r&gt; "..
                                    ui.fConvertColorString(object.desc).."&lt;r&gt;\n")        
      end
    end
    --
    -- Charapter
    if (table.size(ui.room.players) &gt; 0) then
      for _, player in pairs(ui.room.players) do
        GUI.Room.Main.Console:cecho("&lt;ansiMagenta&gt;[&lt;white&gt;"..fGetCounter(player.counter).."&lt;ansiMagenta&gt;]&lt;r&gt; "..
                                    "&lt;yellow&gt;P&lt;r&gt; "..
                                    "[&lt;cyan&gt;Liv&lt;r&gt; &lt;white&gt;"..ui.fdigitNumber(player.level).."&lt;r&gt;] "..
                                    ui.fConvertColorString(player.desc).."&lt;r&gt;\n")
      end
    end  
    --
    -- Mobs
    if (table.size(ui.room.mobs) &gt; 0) then
      for _, mob in pairs(ui.room.mobs) do
        GUI.Room.Main.Console:cecho("&lt;ansiMagenta&gt;[&lt;white&gt;"..fGetCounter(mob.counter).."&lt;ansiMagenta&gt;]&lt;r&gt; "..
                                    "&lt;red&gt;M&lt;r&gt; "..
                                    "[&lt;cyan&gt;Liv&lt;r&gt; &lt;"..ui.fLevelColor(mob.level, ui.player.level).."&gt;"..ui.fdigitNumber(mob.level).."&lt;r&gt;] "..
                                    ui.fConvertColorString(mob.desc).."&lt;r&gt;\n")
      end
    end
  end
end</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>Targets</name>
					<packageName></packageName>
					<script>--
function ui.fClickTarget(sender)
  ui.fDebug("[&lt;cyan&gt;call&lt;r&gt;] ui.fClickTarget("..(sender or "nil")..")")
  --
  if (sender) then
    local type, number = ui.fExpandButton(sender)
    --
    if (type == "g") or (type == "o") then
      ui.fExecuteTargetButton(sender)
    end
  end
end
--
function ui.fGetTargetChild(type, number)
  if (type == "g") then
    return GUI.Group.Main[type..number];
  elseif (type == "o") then
    return GUI.Opponent.Main
  elseif (type == "t") then
    return GUI.TargetButtons.Main[type..number]
  else
    return nil
  end
end
--
function ui.fGetTargetFormattedText(target, keybind)
  local str = ui.colors.target..target
  keybind = keybind or false
  --
  if (keybind) and (ui.targets[target]) and (ui.targets[target].keybId) then
    str = ui.fGetKeybFormattedText(ui.targets[target].keybind)..ui.fGetOperatorFormattedText(" » ")..str
  end
  --
  return str.."&lt;r&gt;"
end
--
function ui.fUpdateTargetButtons()
  local distance = 3; 
  local w_h = GUI.TargetButtons.Main:get_height() - distance;
  local w_w = GUI.TargetButtons.Main:get_width() -  distance;
  local h = distance + 25;
  local w = distance + 120;
  local x = 0
  local y = 0
  local r = 1
  local c = 1
  local tot_r, tot_c
  local total = 4
  --
  ui.fDebug("[&lt;cyan&gt;call&lt;r&gt;] ui.fUpdateTargetButtons()")
  --
  tot_c = math.max(1, math.min(math.floor(w_w / w), total));
  -- When working with negative numbers math.floor() returns the closest integer less than or equal to a given value
  tot_r = -math.floor(-total/tot_c);
  --
  -- Recalc w if possible
  w = w_w / tot_c
  --
  -- Recalc h if possible
  h = w_h / tot_r
  --
  for i = 1, 4 do
    if (r &gt; tot_r) then
      GUI.TargetButtons.Main["t"..i]:hide();
    else
      GUI.TargetButtons.Main["t"..i]:resize(w - distance, h - distance)
      GUI.TargetButtons.Main["t"..i]:move(distance + (c-1)*w, distance + (r-1)*h)
      GUI.TargetButtons.Main["t"..i]:show();
      --
      c = c + 1
      if (c &gt; tot_c) then
        c = 1;
        r = r + 1
      end
    end
  end
end
--
-- Refresh target button
function ui.fRefreshTargetButton(button)
  local type, number = ui.fExpandButton(button)
  local child = ui.fGetTargetChild(type, number)
  --
  ui.fDebug("[&lt;cyan&gt;call&lt;r&gt;] ui.fRefreshTargetButton("..(button or "nil")..")")
  --
  if (child ~= nil) then
    button = type..number 
    if (ui.targets[button]) then
      local mod1 = ui.targets[button].mod1 or "";
      local mod2 = ui.targets[button].mod2 or "";
      local key = ui.targets[button].key or "";
      local result, keybind
      local target
      local CCS, bgColor, bgColorHover
      --
      -- Target
      if (ui.targets[button].target) and (ui.targets[button].target ~= "") then
        target = ui.targets[button].target
      else
        target = "'"..button.."'";
      end
      --
      -- Keybind
      if (mod2 ~= "") then
        result, keybind = ui.fSetKeyb(ui.targets, button, [[ui.fExecuteTargetButton("]]..button..[[")]], mod2, mod1, key)
      elseif (mod1 ~= "") then
        result, keybind = ui.fSetKeyb(ui.targets, button, [[ui.fExecuteTargetButton("]]..button..[[")]], mod1, key)
      elseif (key ~= "") then
        result, keybind = ui.fSetKeyb(ui.targets, button, [[ui.fExecuteTargetButton("]]..button..[[")]], key)
      else
        result, keybind = ui.fSetKeyb(ui.targets, button, [[ui.fExecuteTargetButton("]]..button..[[")]])
      end
      --
      if (result &lt;= 0) then
        ui.fRemoveKeyb(ui.targets[button])
      end
      --
      -- Echo
      child.keybind:echo("&lt;p align=right&gt;"..keybind.."&lt;/p&gt;")
      --
      -- CCS
      if (type == "g") or (type == "o") then
        --CCS = GUI.CSS.BorderPlayer;
        CCS = [[
          border-radius: 4px; 
        ]]
        bgColor      = "150, 0, 0, 0.4"
        bgColorHover = "150, 0, 0, 1"
      --
      elseif (type == "t") then
        GUI.TargetButtons.Main[button]:echo("&lt;center&gt;"..target)
        CCS = GUI.CSS.Button;
        bgColor      = "75, 0, 0, 1"
        bgColorHover = "150, 0, 0, 1"
      end
      --
      if (target == ui.variables["target"]) then
        child:setStyleSheet([[
          QLabel{
            ]]..CCS..[[
            background-color: rgba(]]..bgColorHover..[[);
          }
        ]])
      else
        child:setStyleSheet([[
          QLabel{
            ]]..CCS..[[
            background-color: rgba(]]..bgColor..[[);
          }
          QLabel::hover{
            ]]..CCS..[[
            background-color: rgba(]]..bgColorHover..[[);
          }
        ]])
      end
      --
      return true
    end
  end
  --
  return false
end
-- 
-- Refresh all target button
function ui.fUpdateAllTargetButton()
  ui.fDebug("[&lt;cyan&gt;call&lt;r&gt;] ui.fUpdateAllTargetButton()")
  --
  for i=0, 9 do
    if (i &gt;= 1) and (i &lt;= 4) then
      ui.fRefreshTargetButton("t"..i)
    end
    ui.fRefreshTargetButton("g"..i)
  end
  ui.fRefreshTargetButton("o0")
  --
  ui.fUpdateTarget()
  ui.fSaveFileTarges()
end
--
-- Refresh Target
function ui.fUpdateTarget()
  ui.fDebug("[&lt;cyan&gt;call&lt;r&gt;] ui.fUpdateTarget()")
  --
  if (not ui.variables.target) or (ui.variables.target == "") then
    GUI.TargetButtons:setTitle("Target")
  else
    GUI.TargetButtons:setTitle("Target: "..ui.variables["target"])
  end
end
--
-- Assign Target button
function ui.fAssignTargetButton(button, value)
  local ret = 0;
  local type, number = ui.fExpandButton(button)
  --
  ui.fDebug("[&lt;cyan&gt;call&lt;r&gt;] ui.fAssignTargetButton("..(button or "nil")..", "..(value or "nil")..")")
  --
  if (type == "g") or (type == "o") or (type == "t") then
    button = type..number
    ui.targets[button] = ui.targets[button] or {}
    ui.targets[button].target = value
    --
    return 1 -- Value assigned (can be nil)
  end
  --
  return -1 -- Invaid button
end
--
-- Execute Target button
function ui.fExecuteTargetButton(button)
  local type, number = ui.fExpandButton(button)
  --
  ui.fDebug("[&lt;cyan&gt;call&lt;r&gt;] ui.fExecuteTargetButton("..(button or "nil")..")")
  --
  if (type == "g") or (type == "o") or (type == "t") then
    button = type..number
    if (ui.targets[button]) and (ui.targets[button].target) then
      if (ui.variables["target"] == ui.targets[button].target) then
        ui.variables["target"] = ""
        ui.fEcho2n(ui.fGetTargetFormattedText(button)..ui.fGetOperatorFormattedText(" » ").."nessun "..ui.fGetVarNameFormattedText("target").." selezionato")
      else
        ui.variables["target"] = ui.targets[button].target
        ui.fEcho2n(ui.fGetTargetFormattedText(button)..ui.fGetOperatorFormattedText(" » ")..ui.fGetVarNameFormattedText("target").." impostato su "..ui.fGetVarValueFormattedText(ui.variables.target).."&lt;r&gt;.")
      end
      ui.fUpdateTarget()
    elseif (type == "g") then
      ui.fEcho2n("Nessun componente del gruppo da associare a "..ui.fGetTargetFormattedText(button)..".")
    elseif (type == "o") then
      ui.fEcho2n("Nessun avversario ingaggiato da associare a "..ui.fGetTargetFormattedText(button)..".")
    elseif (type == "t") then
      ui.fEcho2n(ui.fGetTargetFormattedText(button).." non configurato. Usare il comanto "..ui.fGetCommandFormattedText(button.." &lt;testo&gt;").." per configurare.")
    end
    -- Save target
    ui.fUpdateAllTargetButton()
    ui.fSaveFileVariables()
  else
    ui.fEcho2n(ui.fGetTargetFormattedText(button).." pulsante non valido.")
  end
  ui.fUpdateOpponent()
end
--
-- Save buttons data from file
function ui.fSaveFileTarges()
  local file = ui.files.targets.path..ui.files.targets.name
  local targetsDataToSave = {}
  --
  ui.fDebug("[&lt;cyan&gt;call&lt;r&gt;] ui.fSaveFileTarges()")
  --
  for button in pairs(ui.targets) do
    targetsDataToSave[button] = {}
    targetsDataToSave[button].target = ui.targets[button].target
    targetsDataToSave[button].mod1 = ui.targets[button].mod1
    targetsDataToSave[button].mod2 = ui.targets[button].mod2
    targetsDataToSave[button].key = ui.targets[button].key
  end
  table.save(file, targetsDataToSave)
end
--
-- Read Targets data from file
function ui.fReadFileTargets()
  local file = ui.files.targets.path..ui.files.targets.name
  --
  ui.fDebug("[&lt;cyan&gt;call&lt;r&gt;] ui.fReadFileTargets()")
  --
  -- Pre defined target buttons
  local pre_defined_target_buttons = {
    g0 = { mod1 = "CTRL", mod2 = "", key = "F10" },
    g1 = { mod1 = "CTRL", mod2 = "", key = "F1" },
    g2 = { mod1 = "CTRL", mod2 = "", key = "F2" },
    g3 = { mod1 = "CTRL", mod2 = "", key = "F3" },
    g4 = { mod1 = "CTRL", mod2 = "", key = "F4" },
    g5 = { mod1 = "CTRL", mod2 = "", key = "F5" },
    g6 = { mod1 = "CTRL", mod2 = "", key = "F6" },
    g7 = { mod1 = "CTRL", mod2 = "", key = "F7" },
    g8 = { mod1 = "CTRL", mod2 = "", key = "F8" },
    g9 = { mod1 = "CTRL", mod2 = "", key = "F9" },
    --
    o0 = { mod1 = "CTRL", mod2 = "", key = "0" },
    --
    t1 = { mod1 = "CTRL", mod2 = "", key = "1" },
    t2 = { mod1 = "CTRL", mod2 = "", key = "2" },
    t3 = { mod1 = "CTRL", mod2 = "", key = "3" },
    t4 = { mod1 = "CTRL", mod2 = "", key = "4" },
  }
  --
  -- Remove actual Targets
  ui.targets = {}
  --
  -- Load Targets
  if (io.exists(file)) then
    table.load(file, ui.targets)
  else
    --
    -- Update only if file targets not esist otherwise it would reassign any removed keys
    ui.targets = table.update(pre_defined_target_buttons, ui.targets)
  end
  --
  -- Save
  table.save(file, ui.targets)
end
--
-- Debug simulation
if (ui.enDebug) and (ui.enDebug &gt;= 2) then
  ui.fUpdateTargetButtons()
end</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>Variables</name>
					<packageName></packageName>
					<script>--
function ui.fGetVarNameFormattedText(varName)
  return ui.colors.varID..ui.varID..ui.colors.varName..varName.."&lt;r&gt;"
end
--
function ui.fGetVarValueFormattedText(varValue)
  return ui.colors.varCont..tostring(varValue)
end
--
function ui.fGetVarFormattedText(variable)
  if (ui.variables[variable]) then
    if (ui.variables[variable] == "") then
      return ui.fGetVarNameFormattedText(variable)
    end
    --
    return ui.fGetVarNameFormattedText(variable)..ui.fGetOperatorFormattedText("=")..ui.fGetVarValueFormattedText(ui.variables[variable])
  end
  --
  return ""
end
--
function ui.fRemoveAllVariables()
  ui.fDebug("[&lt;cyan&gt;call&lt;r&gt;] ui.fRemoveAllVariables()")
  --
  ui.variables = {}
  ui.variables = table.deepcopy(ui.fGetPreDefinitedVariables())
end
--
function ui.fShowAllVar()
  local app = {}
  local idx = 0
  --
  ui.fDebug("[&lt;cyan&gt;call&lt;r&gt;] ui.fShowAllVar()")
  --
  cecho(ui.fTitle("Variabili predefinite"))
  for variable in pairs(ui.variables) do
    if (ui.variables[variable]) and (ui.fGetPreDefinitedVariables()[variable]) then
      idx = idx + 1
      cecho(ui.fGetNumberFormattedText(idx).." "..ui.fGetVarNameFormattedText(variable))
      if (ui.variables[variable]  ~= "") then
        cecho(ui.fGetOperatorFormattedText(" = ")..ui.fGetVarValueFormattedText(ui.variables[variable]))
      end
      cecho("\n")
    end
  end
  --
  cecho(ui.fTitle("Variabili"))
  idx = 0
  for variable in pairs(ui.variables) do
    if (ui.variables[variable]) and (ui.fGetPreDefinitedVariables()[variable] == nil) then
      idx = idx + 1
      cecho(ui.fGetNumberFormattedText(idx).." ")
      cechoLink(ui.cLink("X"), [[expandAlias("uiv ]]..variable..[[ remove]]..getCommandSeparator()..[[uiv")]], "Rimuovi la variabile '"..variable.."'", true)
      checho(" "..ui.fGetVarNameFormattedText(variable))
      if (ui.variables[variable]  ~= "") then
        cecho(ui.fGetOperatorFormattedText(" = ")..ui.fGetVarValueFormattedText(ui.variables[variable]))
      end
      cecho("\n")
    end
  end
  --
  if (idx &gt; 0) then
    echo("\n")
  else
    cecho("Per maggiori info "..ui.fGetCommandFormattedText("uihelp uivariables").."\n\n")
  end
end
--
function ui.fGetPreDefinitedVariables()
  return {
    target = "",
  }
end
--
-- Save Variables data to file
function ui.fSaveFileVariables()
  local file = ui.files.variables.path..ui.files.variables.name
  --
  ui.fDebug("[&lt;cyan&gt;call&lt;r&gt;] ui.fSaveFileVariables()")
  --
  -- Save
  table.save(file, ui.variables)
end
--
-- Read Variables data from file
function ui.fReadFileVariables()
  local file = ui.files.variables.path..ui.files.variables.name
  --
  ui.fDebug("[&lt;cyan&gt;call&lt;r&gt;] ui.fReadFileVariables()")
  --
  -- Remove actual Variables
  ui.variables = {}
  --
  -- Load Variables
  if (io.exists(file)) then
    table.load(file, ui.variables)
  end
  --
  -- Merge pre defined variables
  ui.variables = table.update(ui.fGetPreDefinitedVariables(), ui.variables)
  --
  -- Save
  table.save(file, ui.variables)
end</script>
					<eventHandlerList />
				</Script>
			</ScriptGroup>
			<ScriptGroup isActive="yes" isFolder="yes">
				<name>Graphic elements</name>
				<packageName></packageName>
				<script></script>
				<eventHandlerList />
				<Script isActive="yes" isFolder="no">
					<name>Affects Widget</name>
					<packageName></packageName>
					<script>function ui.fInitAffectsWidget()
  ui.fDebug("[&lt;cyan&gt;call&lt;r&gt;] ui.fInitAffectsWidget()")
  --
  -- Affects
  GUI.Affects = Adjustable.Container:new2({
    name = "GUI.Affects",
    x = -730,
    y = 340,
    width = 200,
    height = 300,
    titleText ="Effetti",
    titleTxtColor = "orange",
    buttonsize = 12,
    buttonFontSize = 5,
    adjLabelstyle = GUI.CSS.Widget, 
    buttonstyle = GUI.CSS.WidgetButton,
  })
  GUI.Affects:changeMenuStyle("dark")
  --
  -- Add Border and Main
  ui.fAddMain(GUI.Affects, GUI.CSS.Border, GUI.CSS.Main)
  --
  -- Set transparent
  ui.fSetBorderMode(GUI.Affects, ui.parameters.widgets.affects.transparent)
  --
  -- Button "Hide"
  GUI.Affects.Button_hide = Geyser.Label:new2({
    name = "GUI.Affects.Button_hide",
    x = -46, 
    y = 4,
    width = 12,
    height = 12,
  },GUI.Affects)
  GUI.Affects.Button_hide:setStyleSheet(GUI.CSS.WidgetButton);
  GUI.Affects.Button_hide:setFontSize(5)
  GUI.Affects.Button_hide:echo(ui.transparentID);
  GUI.Affects.Button_hide:setClickCallback(function() 
                                                   local mode = ui.parameters.widgets.affects.transparent or false;
                                                   ui.fSetBorderMode(GUI.Affects, not mode)
                                                   ui.parameters.widgets.affects.transparent = not mode;
                                                   ui.fSaveFileParameters()
                                                end)
  GUI.Affects.Button_hide:setToolTip("Transparent", 10)
  --
  -- 20x Affects
  local i
  for i=1, 20 do
    local col = (i-1) % 10;
    local row = (i&lt;=10)and(0)or(1)
    --
    GUI.Affects.Main["Affect"..i] = Geyser.Label:new2({
      name = "GUI.Affects.Main.Affect"..i,
      x = 30*col,
      y = 30*row,
      width = 100,
      height = 26,
    }, GUI.Affects.Main)
    GUI.Affects.Main["Affect"..i]:setStyleSheet(GUI.CSS.Item);
    --
    -- Duration
    GUI.Affects.Main["Affect"..i].duration = Geyser.Label:new2({
      name = "GUI.Affects.Main.Affect"..i..".duration",
      x = 2, y = 2,
      width = 26,
      height = -2,
    }, GUI.Affects.Main["Affect"..i])
    GUI.Affects.Main["Affect"..i].duration:enableClickthrough() -- for tooltip
    GUI.Affects.Main["Affect"..i].duration:setStyleSheet(GUI.CSS.ItemLeft)
    GUI.Affects.Main["Affect"..i].duration:setFontSize(7);
    --
    -- Text
    GUI.Affects.Main["Affect"..i].text = Geyser.Label:new2({
      name = "GUI.Affects.Main.Affect"..i..".text",
      x = 28,
      y = 2,
      width = -28,
      height = -2,
    }, GUI.Affects.Main["Affect"..i])
    GUI.Affects.Main["Affect"..i].text:enableClickthrough() -- for tooltip
    GUI.Affects.Main["Affect"..i].text:setStyleSheet(GUI.CSS.ItemText)
    GUI.Affects.Main["Affect"..i].text:setFontSize(7);
    --
    -- Dispel Resistance
    GUI.Affects.Main["Affect"..i].dispelResistance = Geyser.Label:new2({
      name = "GUI.Affects.Main.Affect"..i..".dispelResistance",
      x = -28,
      y = 2,
      width = 26,
      height = "50%-2",
    }, GUI.Affects.Main["Affect"..i])
    GUI.Affects.Main["Affect"..i].dispelResistance:enableClickthrough() -- for tooltip
    GUI.Affects.Main["Affect"..i].dispelResistance:setStyleSheet(GUI.CSS.ItemTopRight)
    GUI.Affects.Main["Affect"..i].dispelResistance:setFgColor("cyan")
    GUI.Affects.Main["Affect"..i].dispelResistance:setFontSize(7);
    --
    -- Stacks
    GUI.Affects.Main["Affect"..i].stacks = Geyser.Label:new2({
      name = "GUI.Affects.Main.Affect"..i..".stacks",
      x = -28, y = "50%",
      width = 26,
      height = "50%-2",
    }, GUI.Affects.Main["Affect"..i])
    GUI.Affects.Main["Affect"..i].stacks:enableClickthrough() -- for tooltip
    GUI.Affects.Main["Affect"..i].stacks:setStyleSheet(GUI.CSS.ItemBottomRight)
    GUI.Affects.Main["Affect"..i].stacks:setFgColor("orange")
    GUI.Affects.Main["Affect"..i].stacks:setFontSize(7);
    --
    GUI.Affects.Main["Affect"..i]:hide()
  end
  --
  -- Wrapping function
  local Minimize = GUI.Affects.minimize
  local Restore = GUI.Affects.restore
  local Resize = GUI.Affects.resize
  --
  function GUI.Affects:minimize(...)
    GUI.Affects.Main:hide()
    return Minimize(GUI.Affects)
  end
  --
  function GUI.Affects:restore(...)
    GUI.Affects.Main:show()
    return Restore(GUI.Affects)
  end
  --
  function GUI.Affects:resize(...)
    ui.fUpdateAffects()
    return Resize(GUI.Affects, ...)
  end
  --
end</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>Alias Buttons Widget</name>
					<packageName></packageName>
					<script>function ui.fInitAliasButtonsWidget()
  ui.fDebug("[&lt;cyan&gt;call&lt;r&gt;] ui.fInitAliasButtonsWidget()")
  --
  -- Alias buttons 
  GUI.AliasButtons = Adjustable.Container:new2({
    name = "GUI.AliasButtons",
    attached = "right",
    x = -500,
    y = "87%",
    width = 500,
    height = "13%",
    titleText ="Pulsanti alias",
    titleTxtColor = "orange",
    buttonsize = 12,
    buttonFontSize = 5,
    adjLabelstyle = GUI.CSS.Widget, 
    buttonstyle = GUI.CSS.WidgetButton,
  })
  GUI.AliasButtons:changeMenuStyle("dark")
  --
  -- Add Border and Main
  ui.fAddMain(GUI.AliasButtons, GUI.CSS.Border, GUI.CSS.Main)
  --
  -- Set transparent
  ui.fSetBorderMode(GUI.AliasButtons, ui.parameters.widgets.aliasButton.transparent)
  --
  -- Button "Hide"
  GUI.AliasButtons.Button_hide = Geyser.Label:new2({
    name = "GUI.AliasButtons.Button_hide",
    x = -46, 
    y = 4,
    width = 12,
    height = 12,
  },GUI.AliasButtons)
  GUI.AliasButtons.Button_hide:setStyleSheet(GUI.CSS.WidgetButton);
  GUI.AliasButtons.Button_hide:setFontSize(5)
  GUI.AliasButtons.Button_hide:echo(ui.transparentID);
  GUI.AliasButtons.Button_hide:setClickCallback(function() 
                                                   local mode = ui.parameters.widgets.aliasButton.transparent or false;
                                                   ui.fSetBorderMode(GUI.AliasButtons, not mode)
                                                   ui.parameters.widgets.aliasButton.transparent = not mode;
                                                   ui.fSaveFileParameters()
                                                end)
  GUI.AliasButtons.Button_hide:setToolTip("Transparent", 10)
  --
  -- Button "A"
  GUI.AliasButtons.Button_a = Geyser.Label:new2({
    name = "GUI.AliasButtons.Button_a",
    x = -106, 
    y = 4,
    width = 12,
    height = 12,
  },GUI.AliasButtons)
  GUI.AliasButtons.Button_a:setStyleSheet(GUI.CSS.WidgetButton);
  GUI.AliasButtons.Button_a:setFontSize(6)
  GUI.AliasButtons.Button_a:echo("&lt;center&gt;a");
  GUI.AliasButtons.Button_a:setClickCallback("ui.fOptionButton", "a")
  --
  -- Button "B"
  GUI.AliasButtons.Button_b = Geyser.Label:new2({
    name = "GUI.AliasButtons.Button_b",
    x = -91, 
    y = 4,
    width = 12,
    height = 12,
  },GUI.AliasButtons)
  GUI.AliasButtons.Button_b:setStyleSheet(GUI.CSS.WidgetButton);
  GUI.AliasButtons.Button_b:setFontSize(6)
  GUI.AliasButtons.Button_b:echo("&lt;center&gt;b");
  GUI.AliasButtons.Button_b:setClickCallback("ui.fOptionButton", "b")
  --
  -- Button "C"
  GUI.AliasButtons.Button_c = Geyser.Label:new2({
    name = "GUI.AliasButtons.Button_c",
    x = -76, 
    y = 4,
    width = 12,
    height = 12,
  },GUI.AliasButtons)
  GUI.AliasButtons.Button_c:setStyleSheet(GUI.CSS.WidgetButton);
  GUI.AliasButtons.Button_c:setFontSize(6)
  GUI.AliasButtons.Button_c:echo("&lt;center&gt;c");
  GUI.AliasButtons.Button_c:setClickCallback("ui.fOptionButton", "c")
  --
  -- Buttons
  for order=1,10 do
    local i = order % 10
    --
    -- Name
    GUI.AliasButtons.Main["Button"..i] = Geyser.Label:new2({
      name = "GUI.AliasButtons.Main.Button"..i,
      x = (10*i).."%", 
      y = 0,
      width = "10%",
      height = "100%",
    },GUI.AliasButtons.Main)
    GUI.AliasButtons.Main["Button"..i]:setClickCallback("ui.fClickAliasButton", i, nil)
    --
    -- Icon
    GUI.AliasButtons.Main["Button"..i].icon = Geyser.Label:new2({
      name = "GUI.AliasButtons.Main.Button"..i..".icon",
      x = 5, y = 5,
      width = -5,
      height = -5,
    }, GUI.AliasButtons.Main["Button"..i])
    GUI.AliasButtons.Main["Button"..i].icon:enableClickthrough()
    GUI.AliasButtons.Main["Button"..i].icon:setFgColor("violet")
    GUI.AliasButtons.Main["Button"..i].icon:setFontSize(9)
    --
    -- Index
    GUI.AliasButtons.Main["Button"..i].index = Geyser.Label:new2({
      name = "GUI.AliasButtons.Main.Button"..i..".index",
      x = 5, 
      y = 1,
      width = "15",
      height = "15",
    }, GUI.AliasButtons.Main["Button"..i])
    GUI.AliasButtons.Main["Button"..i].index:enableClickthrough()
    GUI.AliasButtons.Main["Button"..i].index:setFontSize(ui.parameters.widgets.keybind.fontSize)
    GUI.AliasButtons.Main["Button"..i].index:setStyleSheet(GUI.CSS.Keybind);
    GUI.AliasButtons.Main["Button"..i].index:echo("")
    --
    -- Keybid
    GUI.AliasButtons.Main["Button"..i].keybind = Geyser.Label:new2({
      name = "GUI.AliasButtons.Main.Button"..i..".keybind",
      x = 5, 
      y = -15,
      width = -10,
      height = 15,
    }, GUI.AliasButtons.Main["Button"..i])
    GUI.AliasButtons.Main["Button"..i].keybind:enableClickthrough()
    GUI.AliasButtons.Main["Button"..i].keybind:setStyleSheet(GUI.CSS.Keybind);
    GUI.AliasButtons.Main["Button"..i].keybind:setFontSize(ui.parameters.widgets.keybind.fontSize);
  end
  --
  -- Wrapping function
  local Minimize = GUI.AliasButtons.minimize
  local Restore = GUI.AliasButtons.restore
  local Resize = GUI.AliasButtons.resize
  --
  function GUI.AliasButtons:minimize(...)
    GUI.AliasButtons.Main:hide()
    return Minimize(GUI.AliasButtons)
  end
  --
  function GUI.AliasButtons:restore(...)
    GUI.AliasButtons.Main:show()
    return Restore(GUI.AliasButtons)
  end
  --
  function GUI.AliasButtons:resize(...)
    ui.fUpdateAliasButton()
    return Resize(GUI.AliasButtons, ...)
  end
end</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>Chat Widget</name>
					<packageName></packageName>
					<script>function ui.fInitChatWidget()
  ui.fDebug("[&lt;cyan&gt;call&lt;r&gt;] ui.fInitChatWidget()")
  --
  -- Private messages
  GUI.Chat = Adjustable.Container:new2({
    name = "GUI.Chat",
    attached = "left",
    x = 0,
    y = 0,
    width = 300,
    height = "55%",
    titleText ="Canale privato",
    titleTxtColor = "orange",
    buttonsize = 12,
    buttonFontSize = 5,
    adjLabelstyle = GUI.CSS.Widget, 
    buttonstyle = GUI.CSS.WidgetButton,
  })
  GUI.Chat:changeMenuStyle("dark")
  --
  -- Add Border and Main
  ui.fAddMain(GUI.Chat, GUI.CSS.Border, GUI.CSS.Main)
  --
  -- Button "Split"
  GUI.Chat.Button_split = Geyser.Label:new2({
    name = "GUI.Chat.Button_split",
    x = -133, 
    y = 4,
    width = 40,
    height = 12,
  },GUI.Chat)
  GUI.Chat.Button_split:setStyleSheet(GUI.CSS.WidgetButton);
  GUI.Chat.Button_split:setFontSize(6)
  GUI.Chat.Button_split:echo("&lt;center&gt;split");
  GUI.Chat.Button_split:setClickCallback("ui.fChatSplitClicked")
  --
  -- Button "Type"
  GUI.Chat.Button_type = Geyser.Label:new2({
    name = "GUI.Chat.Button_type",
    x = -89, 
    y = 4,
    width = 40,
    height = 12,
  },GUI.Chat)
  GUI.Chat.Button_type:setStyleSheet(GUI.CSS.WidgetButton);
  GUI.Chat.Button_type:setFontSize(6)
  GUI.Chat.Button_type:echo("&lt;center&gt;"..ui.parameters.widgets.chat.type);
  GUI.Chat.Button_type:setClickCallback("ui.fChatTypeClicked")
  --
  -- Button "Type"
  GUI.Chat.Split_line = Geyser.Label:new2({
    name = "GUI.Chat.Split_line",
    x = 0, 
    y = "50%-2",
    width = "100%",
    height = 4,
  },GUI.Chat.Border)
  GUI.Chat.Split_line:setStyleSheet(GUI.CSS.Border);
  --
  -- Console "All"
  GUI.Chat.Main.All = Geyser.MiniConsole:new2({
    name = 'GUI.Chat.Main.All',
    x=0,
    y=0,
    width = "100%", 
    height = "100%",
    autoWrap = true,
    scrollBar = true,
  }, GUI.Chat.Main)
  GUI.Chat.Main.All:setColor(30, 24, 24)
  GUI.Chat.Main.All:setBgColor(30, 24, 24)
  GUI.Chat.Main.All:setFontSize(ui.parameters.widgets.chat.fontSize)
  --
  -- Console "Public"
  GUI.Chat.Main.Public = Geyser.MiniConsole:new2({
    name = 'GUI.Chat.Main.Public',
    x=0,
    y=0,
    width = "100%", 
    height = "100%",
    autoWrap = true,
    scrollBar = true,
  }, GUI.Chat.Main)
  GUI.Chat.Main.Public:setColor(30, 24, 24)
  GUI.Chat.Main.Public:setBgColor(30, 24, 24)
  GUI.Chat.Main.Public:setFontSize(ui.parameters.widgets.chat.fontSize)
  --
  -- Console "Private"
  GUI.Chat.Main.Private = Geyser.MiniConsole:new2({
    name = 'GUI.Chat.Main.Private',
    x=0,
    y=0,
    width = "100%", 
    height = "100%",
    autoWrap = true,
    scrollBar = true,
  }, GUI.Chat.Main)
  GUI.Chat.Main.Private:setColor(30, 24, 24)
  GUI.Chat.Main.Private:setBgColor(30, 24, 24)
  GUI.Chat.Main.Private:setFontSize(ui.parameters.widgets.chat.fontSize)
  --
  -- Wrapping function
  local Minimize = GUI.Chat.minimize
  local Restore = GUI.Chat.restore
  --
  function GUI.Chat:minimize(...)
    GUI.Chat.Main:hide()
    return Minimize(GUI.Chat)
  end
  --
  function GUI.Chat:restore(...)
    GUI.Chat.Main:show()
    return Restore(GUI.Chat)
  end
end</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>Cooldowns Widget</name>
					<packageName></packageName>
					<script>function ui.fInitCooldownsWidget()
  ui.fDebug("[&lt;cyan&gt;call&lt;r&gt;] ui.fInitCooldownsWidget()")
  --
  -- Equip
  GUI.Cooldowns = Adjustable.Container:new2({
    name = "GUI.Cooldowns",
    x = 300,
    y = 0,
    width = 500,
    height = 100,
    titleText ="Cooldowns",
    titleTxtColor = "orange",
    buttonsize = 12,
    buttonFontSize = 5,
    adjLabelstyle = GUI.CSS.Widget, 
    buttonstyle = GUI.CSS.WidgetButton,
  })
  GUI.Cooldowns:changeMenuStyle("dark")
  --
  -- Add Border and Main
  ui.fAddMain(GUI.Cooldowns, GUI.CSS.Border, GUI.CSS.Main)
  --
  -- Set transparent
  ui.fSetBorderMode(GUI.Cooldowns, ui.parameters.widgets.cooldowns.transparent)
  --
  -- Button "Hide"
  GUI.Cooldowns.Button_hide = Geyser.Label:new2({
    name = "GUI.Cooldowns.Button_hide",
    x = -46, 
    y = 4,
    width = 12,
    height = 12,
  },GUI.Cooldowns)
  GUI.Cooldowns.Button_hide:setStyleSheet(GUI.CSS.WidgetButton);
  GUI.Cooldowns.Button_hide:setFontSize(5)
  GUI.Cooldowns.Button_hide:echo(ui.transparentID);
  GUI.Cooldowns.Button_hide:setClickCallback(function() 
                                            local mode = ui.parameters.widgets.cooldowns.transparent or false;
                                            ui.fSetBorderMode(GUI.Cooldowns, not mode)
                                            ui.parameters.widgets.cooldowns.transparent = not mode;
                                            ui.fSaveFileParameters()
                                          end)
  GUI.Cooldowns.Button_hide:setToolTip("Transparent", 10)
  --
  -- 10x Slot
  for i=1, 10 do
    GUI.Cooldowns.Main["Item"..i] = Geyser.Gauge:new2({
      name = "GUI.Cooldowns.Main.Item"..i,
      x = 5,
      y = 5,
      width = 100,
      height = 10,
    },GUI.Cooldowns.Main)
    GUI.Player.Main.Health:setValue(0, 100)
    --
  GUI.Cooldowns.Main["Item"..i].back:setStyleSheet(GUI.CSS.GaugeBack..[[
    background-color: DimGrey;
  ]])
  --
  GUI.Cooldowns.Main["Item"..i].front:setStyleSheet(GUI.CSS.GaugeFront..[[
    background-color: DarkSlateGrey;
  ]])
    --GUI.Cooldowns.Main["Item"..i].back:setStyleSheet(GUI.CSS.GaugeBack..[[
    --  background-color: rgba(150, 0, 0, 0.5);
    --]])
    --
    --GUI.Cooldowns.Main["Item"..i].front:setStyleSheet(GUI.CSS.GaugeFront..[[
    --  background-color: QLinearGradient( x1: 0, y1: 0, x2: 0, y2: 1, stop: 0 #ee0000, stop: 0.65 #990000, stop: 1 #bb0000);
    --]])
    --
    GUI.Cooldowns.Main["Item"..i]:echo("Item"..i)
    --
    GUI.Cooldowns.Main["Item"..i]:hide()
  end
  --
  -- Wrapping function
  local Minimize = GUI.Cooldowns.minimize
  local Restore = GUI.Cooldowns.restore
  local Resize = GUI.Cooldowns.resize
  --
  function GUI.Cooldowns:minimize(...)
    GUI.Cooldowns.Main:hide()
    return Minimize(GUI.Cooldowns)
  end
  --
  function GUI.Cooldowns:restore(...)
    GUI.Cooldowns.Main:show()
    return Restore(GUI.Cooldowns)
  end
  --
  function GUI.Cooldowns:resize(...)
    ui.fUpdateCooldowns()
    return Resize(GUI.Cooldowns, ...)
  end
end</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>Endowment Widget</name>
					<packageName></packageName>
					<script>function ui.fInitEndowmentWidget()
  ui.fDebug("[&lt;cyan&gt;call&lt;r&gt;] ui.fInitEndowmentWidget()")
  --
  -- Equip
  GUI.Endowment = Adjustable.Container:new2({
    name = "GUI.Endowment",
    attached = "right",
    x = -500,
    y = "58%",
    width = 500,
    height = "29%",
    titleText ="Equipaggiamento",
    titleTxtColor = "orange",
    buttonsize = 12,
    buttonFontSize = 5,
    adjLabelstyle = GUI.CSS.Widget, 
    buttonstyle = GUI.CSS.WidgetButton,
  })
  GUI.Endowment:changeMenuStyle("dark")
  --
  -- Add Border and Main
  ui.fAddMain(GUI.Endowment, GUI.CSS.Border, GUI.CSS.Main)
  --
  -- Set transparent
  ui.fSetBorderMode(GUI.Endowment, ui.parameters.widgets.endowment.transparent)
  --
  -- Button "Hide"
  GUI.Endowment.Button_hide = Geyser.Label:new2({
    name = "GUI.Endowment.Button_hide",
    x = -46, 
    y = 4,
    width = 12,
    height = 12,
  },GUI.Endowment)
  GUI.Endowment.Button_hide:setStyleSheet(GUI.CSS.WidgetButton);
  GUI.Endowment.Button_hide:setFontSize(5)
  GUI.Endowment.Button_hide:echo(ui.transparentID);
  GUI.Endowment.Button_hide:setClickCallback(function() 
                                            local mode = ui.parameters.widgets.endowment.transparent or false;
                                            ui.fSetBorderMode(GUI.Endowment, not mode)
                                            ui.parameters.widgets.endowment.transparent = not mode;
                                            ui.fSaveFileParameters()
                                          end)
  GUI.Endowment.Button_hide:setToolTip("Transparent", 10)
  --
  -- 25x Slot
  for i=1, 25 do
    --
    GUI.Endowment.Main["Item"..i] = Geyser.Label:new2({
      name = "GUI.Endowment.Main.Item"..i,
      width = 100,
      height = 26,
    }, GUI.Endowment.Main)
    GUI.Endowment.Main["Item"..i]:setStyleSheet(GUI.CSS.Item);
    --
    -- Index
    GUI.Endowment.Main["Item"..i].Index = Geyser.Label:new2({
      name = "GUI.Endowment.Main.Item"..i..".Index",
      x = 2,
      y = 2,
      width = 30,
      height = "50%-2",
    }, GUI.Endowment.Main["Item"..i])
    GUI.Endowment.Main["Item"..i].Index:enableClickthrough() -- for tooltip
    GUI.Endowment.Main["Item"..i].Index:setStyleSheet(GUI.CSS.ItemTopLeft)
    GUI.Endowment.Main["Item"..i].Index:setFgColor("white")
    GUI.Endowment.Main["Item"..i].Index:setFontSize(7);
    --
    -- Status
    GUI.Endowment.Main["Item"..i].Slot = Geyser.Label:new2({
      name = "GUI.Endowment.Main.Item"..i..".Slot",
      x = 2,
      y = "50%",
      width = 30,
      height = "50%-2",
    }, GUI.Endowment.Main["Item"..i])
    GUI.Endowment.Main["Item"..i].Slot:enableClickthrough() -- for tooltip
    GUI.Endowment.Main["Item"..i].Slot:setStyleSheet(GUI.CSS.ItemBottomLeft)
    GUI.Endowment.Main["Item"..i].Slot:setFgColor("orange")
    GUI.Endowment.Main["Item"..i].Slot:setFontSize(7);
    --
    -- Text
    GUI.Endowment.Main["Item"..i].Text = Geyser.Label:new2({
      name = "GUI.Endowment.Main.Item"..i..".Text",
      x = 32,
      y = 2,
      width = -32,
      height = -2,
    }, GUI.Endowment.Main["Item"..i])
    GUI.Endowment.Main["Item"..i].Text:enableClickthrough() -- for tooltip
    GUI.Endowment.Main["Item"..i].Text:setStyleSheet(GUI.CSS.ItemText)
    GUI.Endowment.Main["Item"..i].Text:setFontSize(7);
    GUI.Endowment.Main["Item"..i].Text:setFgColor("black")    --
    -- Level
    GUI.Endowment.Main["Item"..i].Level = Geyser.Label:new2({
      name = "GUI.Endowment.Main.Item"..i..".Level",
      x = -32,
      y = 2,
      width = 30,
      height = "50%-2",
    }, GUI.Endowment.Main["Item"..i])
    GUI.Endowment.Main["Item"..i].Level:enableClickthrough() -- for tooltip
    GUI.Endowment.Main["Item"..i].Level:setStyleSheet(GUI.CSS.ItemTopRight)
    GUI.Endowment.Main["Item"..i].Level:setFgColor("green")
    GUI.Endowment.Main["Item"..i].Level:setFontSize(7);
    --
    -- Slot
    GUI.Endowment.Main["Item"..i].Status = Geyser.Label:new2({
      name = "GUI.Endowment.Main.Item"..i..".Status",
      x = -32,
      y = "50%",
      width = 30,
      height = "50%-2",
    }, GUI.Endowment.Main["Item"..i])
    GUI.Endowment.Main["Item"..i].Status:enableClickthrough() -- for tooltip
    GUI.Endowment.Main["Item"..i].Status:setStyleSheet(GUI.CSS.ItemBottomRight)
    GUI.Endowment.Main["Item"..i].Status:setFgColor("orange")
    GUI.Endowment.Main["Item"..i].Status:setFontSize(7);
    --
    GUI.Endowment.Main["Item"..i]:hide()
  end
  --
  -- Wrapping function
  local Minimize = GUI.Endowment.minimize
  local Restore = GUI.Endowment.restore
  local Resize = GUI.Endowment.resize
  --
  function GUI.Endowment:minimize(...)
    GUI.Endowment.Main:hide()
    return Minimize(GUI.Endowment)
  end
  --
  function GUI.Endowment:restore(...)
    GUI.Endowment.Main:show()
    return Restore(GUI.Endowment)
  end
  --
  function GUI.Endowment:resize(...)
    ui.fUpdateEndowment()
    return Resize(GUI.Endowment, ...)
  end
end</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>Group Widget</name>
					<packageName></packageName>
					<script>function ui.fInitGroupWidget()
  ui.fDebug("[&lt;cyan&gt;call&lt;r&gt;] ui.fInitGroupWidget()")
  --
  -- Group Members
  GUI.Group = Adjustable.Container:new2({
    name = "GUI.Group",
    x = -730,
    y = 20,
    width = 200,
    height = 300,
    titleText ="Gruppo",
    titleTxtColor = "orange",
    buttonsize = 12,
    buttonFontSize = 5,
    adjLabelstyle = GUI.CSS.Widget, 
    buttonstyle = GUI.CSS.WidgetButton,
  })
  GUI.Group:changeMenuStyle("dark")
  --
  -- Add Border and Main
  ui.fAddMain(GUI.Group, GUI.CSS.Border, GUI.CSS.Main)
  --
  -- Set transparent
  ui.fSetBorderMode(GUI.Group, ui.parameters.widgets.group.transparent)
  --
  -- Button "Hide"
  GUI.Group.Button_hide = Geyser.Label:new2({
    name = "GUI.Group.Button_hide",
    x = -46, 
    y = 4,
    width = 12,
    height = 12,
  },GUI.Group)
  GUI.Group.Button_hide:setStyleSheet(GUI.CSS.WidgetButton);
  GUI.Group.Button_hide:setFontSize(5)
  GUI.Group.Button_hide:echo(ui.transparentID);
  GUI.Group.Button_hide:setClickCallback(function() 
                                                   local mode = ui.parameters.widgets.group.transparent or false;
                                                   ui.fSetBorderMode(GUI.Group, not mode)
                                                   ui.parameters.widgets.group.transparent = not mode;
                                                   ui.fSaveFileParameters()
                                                end)
  GUI.Group.Button_hide:setToolTip("Transparent", 10)
  --
  -- Members
  for i=1, 10 do
    local mod = i % 10
    --
    -- Member
    GUI.Group.Main["g"..mod] = Geyser.Label:new2({
      name = "GUI.Group.Main.g"..mod
    }, GUI.Group.Main)
    GUI.Group.Main["g"..mod]:setClickCallback("ui.fClickTarget", "g"..mod)
    --
    -- Index
    GUI.Group.Main["g"..mod].index = Geyser.Label:new2({
      name = "GUI.Group.Main.g"..mod..".index",
      x = 2, 
      y = 0,
      width = 20,
      height = 10,
    }, GUI.Group.Main["g"..mod])
    GUI.Group.Main["g"..mod].index:enableClickthrough()
    GUI.Group.Main["g"..mod].index:setStyleSheet(GUI.CSS.Keybind);
    GUI.Group.Main["g"..mod].index:setFontSize(ui.parameters.widgets.keybind.fontSize)
    GUI.Group.Main["g"..mod].index:echo("g"..mod.."")
    --
    -- Index
    GUI.Group.Main["g"..mod].Member = Geyser.Label:new2({
      name = "GUI.Group.Main.g"..mod..".Member",
      x = 22, 
      y = 0,
      width = "100%-44",
      height = 10,
    }, GUI.Group.Main["g"..mod])
    GUI.Group.Main["g"..mod].Member:enableClickthrough()
    GUI.Group.Main["g"..mod].Member:setStyleSheet(GUI.CSS.Keybind);
    GUI.Group.Main["g"..mod].Member:setFontSize(ui.parameters.widgets.keybind.fontSize)
    GUI.Group.Main["g"..mod].Member:echo("")
    --
    -- Member Health Gauges
    GUI.Group.Main["g"..mod].Health = Geyser.Gauge:new2({
      name = "GUI.Group.Main.g"..mod..".Health",
      x = 2,
      y = 11,
      width = -2,
      height = 15,
    }, GUI.Group.Main["g"..mod])
    GUI.Group.Main["g"..mod].Health:setValue(0, 100)
    GUI.Group.Main["g"..mod].Health:enableClickthrough()
    --
    GUI.Group.Main["g"..mod].Health.back:setStyleSheet(GUI.CSS.GaugeBack..[[
      background-color: rgba(0, 0, 0, 0.3);
    ]])
    GUI.Group.Main["g"..mod].Health.back:enableClickthrough()
    --
    GUI.Group.Main["g"..mod].Health.front:setStyleSheet(GUI.CSS.GaugeFront..[[
      background-color: QLinearGradient( x1: 0, y1: 0, x2: 0, y2: 1, stop: 0 #ee0000, stop: 0.65 #990000, stop: 1 #bb0000);
    ]])
    GUI.Group.Main["g"..mod].Health.front:enableClickthrough()
    --
    -- Member Mana Gauges
    GUI.Group.Main["g"..mod].Mana = Geyser.Gauge:new2({
      name = "GUI.Group.Main.g"..mod..".Mana",
      x = 2,
      y = 27,
      width = -2,
      height = 6,
    }, GUI.Group.Main["g"..mod])
    GUI.Group.Main["g"..mod].Mana:setValue(0, 100)
    GUI.Group.Main["g"..mod].Mana:enableClickthrough()
    --
    GUI.Group.Main["g"..mod].Mana.back:setStyleSheet(GUI.CSS.GaugeBack..[[
      background-color: rgba(0, 0, 250, .3);
    ]])
    GUI.Group.Main["g"..mod].Mana.back:enableClickthrough()
    --
    GUI.Group.Main["g"..mod].Mana.front:setStyleSheet(GUI.CSS.GaugeFront..[[
      background-color: QLinearGradient( x1: 0, y1: 0, x2: 0, y2: 1, stop: 0 #0000ee, stop: 0.65 #000099, stop: 1 #0000bb);
    ]])
    GUI.Group.Main["g"..mod].Mana.front:enableClickthrough()
    --
    -- Member Stamina Gauges
    GUI.Group.Main["g"..mod].Stamina = Geyser.Gauge:new2({
      name = "GUI.g"..mod..".Stamina",
      x = 2,
      y = 34,
      width = -2,
      height = 6,
    }, GUI.Group.Main["g"..mod])
    GUI.Group.Main["g"..mod].Stamina:setValue(0, 100)
    GUI.Group.Main["g"..mod].Stamina:enableClickthrough()
    --
    GUI.Group.Main["g"..mod].Stamina.back:setStyleSheet(GUI.CSS.GaugeBack..[[
      background-color: rgba(0, 250, 0, .2);
    ]])
    GUI.Group.Main["g"..mod].Stamina.back:enableClickthrough()
    --
    GUI.Group.Main["g"..mod].Stamina.front:setStyleSheet(GUI.CSS.GaugeFront..[[
      background-color: QLinearGradient( x1: 0, y1: 0, x2: 0, y2: 1, stop: 0 #00aa00, stop: 0.65 #006600, stop: 1 #008800);
    ]])
    GUI.Group.Main["g"..mod].Stamina.front:enableClickthrough()
    --
    -- Keybid
    GUI.Group.Main["g"..mod].keybind = Geyser.Label:new2({
      name = "GUI.Group.Main.g"..mod..".keybind",
      x = 30,
      y = -10,
      width = -10,
      height = 10,
    }, GUI.Group.Main["g"..mod])
    GUI.Group.Main["g"..mod].keybind:enableClickthrough()
    GUI.Group.Main["g"..mod].keybind:setStyleSheet(GUI.CSS.Keybind);
    GUI.Group.Main["g"..mod].keybind:setFontSize(ui.parameters.widgets.keybind.fontSize);
    GUI.Group.Main["g"..mod].keybind:echo("keybind")
  end
  --
  -- Wrapping function
  local Minimize = GUI.Group.minimize
  local Restore = GUI.Group.restore
  local Resize = GUI.Group.resize
  --
  function GUI.Group:minimize(...)
    GUI.Group.Main:hide()
    return Minimize(GUI.Group)
  end
  --
  function GUI.Group:restore(...)
    GUI.Group.Main:show()
    return Restore(GUI.Group)
  end
  --
  function GUI.Group:resize(...)
    ui.fUpdateGroup()
    return Resize(GUI.Group, ...)
  end
end</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>Help Widget</name>
					<packageName></packageName>
					<script>function ui.fInitHelpWidget()
  ui.fDebug("[&lt;cyan&gt;call&lt;r&gt;] ui.fInitHelpWidget()")
  --
  -- Public messages
  GUI.Help = Adjustable.Container:new2({
    name = "GUI.Help",
    x = 100,
    y = 100,
    width = -100,
    height = -100,
    titleText ="Lumen et Umbra UI rel. "..ui.release.." - Help",
    titleTxtColor = "orange",
    buttonsize = 12,
    buttonFontSize = 5,
    adjLabelstyle = GUI.CSS.Widget, 
    buttonstyle = GUI.CSS.WidgetButton,
  })
  GUI.Help:changeMenuStyle("dark")
  --
  -- Add Border and Main
  ui.fAddMain(GUI.Help, GUI.CSS.Border, GUI.CSS.Main)
  --
  -- Console
  GUI.Help.Main.Console = Geyser.MiniConsole:new2({
    name = 'GUI.Help.Main.Console',
    x=0,
    y=0,
    width = "100%", 
    height = "100%",
    autoWrap = true,
    scrollBar = true,
  }, GUI.Help.Main)
  GUI.Help.Main.Console:setColor(30, 24, 24)
  GUI.Help.Main.Console:setBgColor(30, 24, 24)
  GUI.Help.Main.Console:setFontSize(ui.parameters.widgets.help.fontSize)
  --
  -- Wrapping function
  local Minimize = GUI.Help.minimize
  local Restore = GUI.Help.restore
  --
  function GUI.Help:minimize(...)
    GUI.Help.Main:hide()
    return Minimize(GUI.Help)
  end
  --
  function GUI.Help:restore(...)
    GUI.Help.Main:show()
    return Restore(GUI.Help)
  end
end</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>Mapper Widget</name>
					<packageName></packageName>
					<script>function ui.fInitMapperWidget()
  ui.fDebug("[&lt;cyan&gt;call&lt;r&gt;] ui.fInitMapperWidget()")
  --
  -- Public messages
  GUI.Mapper = Adjustable.Container:new2({
    name = "GUI.Mapper",
    attached = "right",
    x = -500,
    y = 0,
    width = 500,
    height = "29%",
    titleText ="Mapper",
    titleTxtColor = "orange",
    buttonsize = 12,
    buttonFontSize = 5,
    adjLabelstyle = GUI.CSS.Widget, 
    buttonstyle = GUI.CSS.WidgetButton,
  })
  GUI.Mapper:changeMenuStyle("dark")
  --
  -- Add Border and Main
  ui.fAddMain(GUI.Mapper, GUI.CSS.Border, GUI.CSS.Main)
  --
  -- Mapper
  GUI.Mapper.Main.Mapper = Geyser.Mapper:new2({
    name = 'GUI.Mapper.Main.Mapper',
    x=0,
    y=0,
    width = "100%", 
    height = "100%",
  }, GUI.Mapper.Main)
  --
  -- Overland
  GUI.Mapper.Main.Overland = Geyser.MiniConsole:new2({ 
    name = 'GUI.Mapper.Main.Overland',
    x=0,
    y=0,
    width = "100%", 
    height = "100%", 
    autoWrap = false,
    scrollBar = false,
  }, GUI.Mapper.Main)
  GUI.Mapper.Main.Overland:setColor(0,0,0)
  GUI.Mapper.Main.Overland:setBgColor(0,0,0)
  GUI.Mapper.Main.Overland:setFontSize(ui.parameters.widgets.overland.fontSize)
  GUI.Mapper.Main.Overland:hide()
  --
  -- Wrapping function
  local Minimize = GUI.Mapper.minimize
  local Restore = GUI.Mapper.restore
  --
  function GUI.Mapper:minimize(...)
    GUI.Mapper.Main:hide()
    return Minimize(GUI.Mapper)
  end
  --
  function GUI.Mapper:restore(...)
    GUI.Mapper.Main:show()
    return Restore(GUI.Mapper)
  end
end</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>Opponent Widget</name>
					<packageName></packageName>
					<script>function ui.fInitOpponentWidget()
  ui.fDebug("[&lt;cyan&gt;call&lt;r&gt;] ui.fInitOpponentWidget()")
  --
  -- Opponent
  GUI.Opponent = Adjustable.Container:new2({
    name = "GUI.Opponent",
    attached = "left",
    x = 0,
    y = "70%",
    width = 300,
    height = "10%",
    titleText = "Avversario",
    titleTxtColor = "orange",
    buttonsize = 12,
    buttonFontSize = 5,
    adjLabelstyle = GUI.CSS.Widget, 
    buttonstyle = GUI.CSS.WidgetButton,
  });
  GUI.Opponent:changeMenuStyle("dark")
  --
  -- Add Border and Main
  ui.fAddMain(GUI.Opponent, GUI.CSS.Border, GUI.CSS.Main)
  GUI.Opponent.Main:disableClickthrough()
  GUI.Opponent.Main:setClickCallback("ui.fExecuteTargetButton", "o0", nil)
  --
  -- Set transparent
  ui.fSetBorderMode(GUI.Opponent, ui.parameters.widgets.opponent.transparent)
  --
  -- Button "Hide"
  GUI.Opponent.Button_hide = Geyser.Label:new2({
    name = "GUI.Opponent.Button_hide",
    x = -46, 
    y = 4,
    width = 12,
    height = 12,
  },GUI.Opponent)
  GUI.Opponent.Button_hide:setStyleSheet(GUI.CSS.WidgetButton);
  GUI.Opponent.Button_hide:setFontSize(5)
  GUI.Opponent.Button_hide:echo(ui.transparentID);
  GUI.Opponent.Button_hide:setClickCallback(function() 
                                                   local mode = ui.parameters.widgets.opponent.transparent or false;
                                                   ui.fSetBorderMode(GUI.Opponent, not mode)
                                                   ui.parameters.widgets.opponent.transparent = not mode;
                                                   ui.fSaveFileParameters()
                                                end)
  GUI.Opponent.Button_hide:setToolTip("Transparent", 10)
  --
  -- Opponent Level
  GUI.Opponent.Level = Geyser.Label:new2({
    name = "GUI.Opponent.Level",
    x = -74,
    y = "0%-3",
    width = 25,
    height = 25,
    fontSize = 8,
  }, GUI.Opponent)
  GUI.Opponent.Level:setStyleSheet(GUI.CSS.Level);
  GUI.Opponent.Level:enableClickthrough()
  --
  -- Opponent Health Gauges
  GUI.Opponent.Main.Health = Geyser.Gauge:new2({
    name = "GUI.Opponent.Main.Health",
    x = 2,
    y = 2,
    width = -2,
    height = -10,
  },GUI.Opponent.Main)
  GUI.Opponent.Main.Health:setValue(0, 100)
  GUI.Opponent.Main.Health:enableClickthrough()
  --
  GUI.Opponent.Main.Health.back:setStyleSheet(GUI.CSS.GaugeBack..[[
    background-color: rgba(0, 0, 0, 0.3);
  ]]);
  GUI.Opponent.Main.Health.back:enableClickthrough()
  --
  GUI.Opponent.Main.Health.front:setStyleSheet(GUI.CSS.GaugeFront..[[
    background-color: QLinearGradient( x1: 0, y1: 0, x2: 0, y2: 1, stop: 0 #ee0000, stop: 0.65 #990000, stop: 1 #bb0000);
  ]])
  GUI.Opponent.Main.Health.front:enableClickthrough()
  --
  --
  GUI.Opponent.Main.Health.dif = Geyser.Label:new2({
    name = "GUI.Opponent.Main.Health.dif",
    x = 0,
    y = 0,
    width = "10",
    height = "10",
  }, GUI.Opponent.Main)
  GUI.Opponent.Main.Health.dif:enableClickthrough()
  GUI.Opponent.Main.Health.dif:setFontSize(5)
  GUI.Opponent.Main.Health.dif:hide()
  --
  -- Keybid
  GUI.Opponent.Main.keybind = Geyser.Label:new2({
    name = "GUI.Opponent.Main.keybind",
    x = 5, y = -10,
    width = -5,
    height = 10,
  }, GUI.Opponent.Main)
  GUI.Opponent.Main.keybind:enableClickthrough()
  GUI.Opponent.Main.keybind:setStyleSheet(GUI.CSS.Keybind);
  GUI.Opponent.Main.keybind:setFontSize(ui.parameters.widgets.keybind.fontSize);
  --
  -- Wrapping function
  local Minimize = GUI.Opponent.minimize
  local Restore = GUI.Opponent.restore
  --
  function GUI.Opponent:minimize(...)
    GUI.Opponent.Main:hide()
    return Minimize(GUI.Opponent)
  end
  --
  function GUI.Opponent:restore(...)
    GUI.Opponent.Main:show()
    return Restore(GUI.Opponent)
  end
end</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>Player Widget</name>
					<packageName></packageName>
					<script>function ui.fInitPlayerWidget()
  ui.fDebug("[&lt;cyan&gt;call&lt;r&gt;] ui.fInitPlayerWidget()")
  --
  -- Player 
  GUI.Player = Adjustable.Container:new2({
    name = "GUI.Player",
    attached = "left",
    x = 0,
    y = "80%",
    width = 300,
    height = "20%",
    titleText ="Player",
    titleTxtColor = "orange",
    buttonsize = 12,
    buttonFontSize = 5,
    adjLabelstyle = GUI.CSS.Widget, 
    buttonstyle = GUI.CSS.WidgetButton,
  })
  GUI.Player:changeMenuStyle("dark")
  --
  -- Border and Main
  ui.fAddMain(GUI.Player, GUI.CSS.Border, GUI.CSS.Main)
  --
  -- Set transparent
  ui.fSetBorderMode(GUI.Player, ui.parameters.widgets.player.transparent)
  --
  -- Level
  GUI.Player.Level = Geyser.Label:new2({
    name = "GUI.Player.Level",
    x = -74,
    y = "0%-3",
    width = 25,
    height = 25,
    fontSize = 8,
  }, GUI.Player)
  GUI.Player.Level:setStyleSheet(GUI.CSS.Level);
  GUI.Player.Level:enableClickthrough()
  --
  -- Button "Hide"
  GUI.Player.Button_hide = Geyser.Label:new2({
    name = "GUI.Player.Button_hide",
    x = -46, 
    y = 4,
    width = 12,
    height = 12,
  },GUI.Player)
  GUI.Player.Button_hide:setStyleSheet(GUI.CSS.WidgetButton);
  GUI.Player.Button_hide:setFontSize(5)
  GUI.Player.Button_hide:echo(ui.transparentID);
  GUI.Player.Button_hide:setClickCallback(function() 
                                            local mode = ui.parameters.widgets.player.transparent or false;
                                            ui.fSetBorderMode(GUI.Player, not mode)
                                            ui.parameters.widgets.player.transparent = not mode;
                                            ui.fSaveFileParameters()
                                          end)
  GUI.Player.Button_hide:setToolTip("Transparent", 10)
  --
  -- Tick 
  GUI.Player.Main.Tick = Geyser.Gauge:new2({
    name = "GUI.Player.Main.Tick",
    x = 2, 
    y = 0,
    width = -2,
    height = 5,
  },GUI.Player.Main)
  GUI.Player.Main.Tick:setValue(0, 74)
  --
  GUI.Player.Main.Tick.front:echo("")
  --
  GUI.Player.Main.Tick.back:setStyleSheet(GUI.CSS.GaugeBack..[[
    background-color: rgba(255, 255, 255, 0.1);
    border-radius: 2px;
  ]])
  --
  GUI.Player.Main.Tick.front:setStyleSheet(GUI.CSS.GaugeFront..[[
    background-color: grey;
    border-radius: 1px;
  ]])
  --
  -- Health
  GUI.Player.Main.Health = Geyser.Gauge:new2({
    name = "GUI.Player.Main.Health",
    x = 2,
    y = 6,
    width = -2,
    height = "40%-12",
  },GUI.Player.Main)
  GUI.Player.Main.Health:setValue(0, 100)
  --
  GUI.Player.Main.Health.back:setStyleSheet(GUI.CSS.GaugeBack..[[
    background-color: rgba(150, 0, 0, 0.3);
  ]])
  --
  GUI.Player.Main.Health.front:setStyleSheet(GUI.CSS.GaugeFront..[[
    background-color: QLinearGradient( x1: 0, y1: 0, x2: 0, y2: 1, stop: 0 #ee0000, stop: 0.65 #990000, stop: 1 #bb0000);
  ]])
  GUI.Player.Main.Health.front:echo("Vita")
  --
  --
  GUI.Player.Main.Health.dif = Geyser.Label:new2({
    name = "GUI.Player.Main.Health.dif",
    x = 0,
    y = 0,
    width = "10",
    height = "10",
  }, GUI.Player.Main)
  GUI.Player.Main.Health.dif:setFontSize(5)
  GUI.Player.Main.Health.dif:hide();
  --
  -- Round
  GUI.Player.Main.Round = Geyser.Gauge:new2({
    name = "GUI.Player.Main.Round",
    x = 2,
    y = "40%-6",
    width = -2,
    height = 5,
  }, GUI.Player.Main)
  GUI.Player.Main.Round:setValue(0, 4)
  --
  GUI.Player.Main.Round.back:setStyleSheet(GUI.CSS.GaugeBack..[[
    background-color: rgba(255, 255, 255, 0.1);
    border-radius: 2px;
  ]])
  --
  GUI.Player.Main.Round.front:setStyleSheet(GUI.CSS.GaugeFront..[[
    background-color: darkgrey;
    border-radius: 1px;
  ]])
  --
  -- Mana
  GUI.Player.Main.Mana = Geyser.Gauge:new2({
    name = "GUI.Player.Main.Mana",
    x = 2,
    y = "40%",
    width = -2,
    height = "20%-3",
  },GUI.Player.Main)
  GUI.Player.Main.Mana:setValue(0, 100)
  --
  GUI.Player.Main.Mana.back:setStyleSheet(GUI.CSS.GaugeBack..[[
    background-color: rgba(0, 100, 250, .3);
  ]])
  --
  GUI.Player.Main.Mana.front:setStyleSheet(GUI.CSS.GaugeFront..[[
    background-color: QLinearGradient( x1: 0, y1: 0, x2: 0, y2: 1, stop: 0 #0000ee, stop: 0.65 #000099, stop: 1 #0000bb);
  ]])
  GUI.Player.Main.Mana.front:echo("Mana")
  --
  -- Power (used for energy)
  GUI.Player.Main.Power = Geyser.Gauge:new2({
    name = "GUI.Player.Power",
    x = 2,
    y = "60%-2",
    width = -2,
    height = "20%-3",
  },GUI.Player.Main)
  GUI.Player.Main.Power:setValue(0, 100)
  --
  GUI.Player.Main.Power.back:setStyleSheet(GUI.CSS.GaugeBack..[[
    background-color: rgba(204, 85, 0, .2);
  ]])
  --
  GUI.Player.Main.Power.front:setStyleSheet(GUI.CSS.GaugeFront..[[
    background-color: QLinearGradient( x1: 0, y1: 0, x2: 0, y2: 1, stop: 0 #ffa500, stop: 0.65 #e86100, stop: 1 #ff8c00);
  ]])
  GUI.Player.Main.Power.front:echo("Energia")
  --
  -- Stamina (used for moviment)
  GUI.Player.Main.Stamina = Geyser.Gauge:new2({
    name = "GUI.Player.Main.Stamina",
    x = 2,
    y = "80%-4",
    width = -2,
    height = "20%-3",
  },GUI.Player.Main)
  GUI.Player.Main.Stamina:setValue(0, 100)
  --
  GUI.Player.Main.Stamina.back:setStyleSheet(GUI.CSS.GaugeBack..[[
    background-color: rgba(0, 250, 0, .2);
  ]])
  --
  GUI.Player.Main.Stamina.front:setStyleSheet(GUI.CSS.GaugeFront..[[
    background-color: QLinearGradient( x1: 0, y1: 0, x2: 0, y2: 1, stop: 0 #00aa00, stop: 0.65 #006600, stop: 1 #008800);
  ]])
  GUI.Player.Main.Stamina.front:echo("Movimento")
  --
  -- Experience 
  GUI.Player.Main.Experience = Geyser.Gauge:new2({
    name = "GUI.Player.Main.Experience",
    x = 2, 
    y = -6,
    width = -2,
    height = 6,
  },GUI.Player.Main)
  GUI.Player.Main.Experience:setValue(0, 100)
  --
  GUI.Player.Main.Experience.front:echo("")
  --
  GUI.Player.Main.Experience.back:setStyleSheet(GUI.CSS.GaugeBack..[[
    background-color: rgba(255, 255, 255, 0.1);
    border-radius: 2px;
  ]])
  --
  GUI.Player.Main.Experience.front:setStyleSheet(GUI.CSS.GaugeFront..[[
    background-color: purple;
    border-radius: 1px;
  ]])
  --
  -- Wrapping function
  local Minimize = GUI.Player.minimize
  local Restore = GUI.Player.restore
  --
  function GUI.Player:minimize(...)
    GUI.Player.Main:hide()
    return Minimize(GUI.Player)
  end
  --
  function GUI.Player:restore(...)
    GUI.Player.Main:show()
    return Restore(GUI.Player)
  end
end</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>Room Widget</name>
					<packageName></packageName>
					<script>function ui.fInitRoomWidget()
  ui.fDebug("[&lt;cyan&gt;call&lt;r&gt;] ui.fInitRoomWidget()")
  --
  -- Room
  GUI.Room = Adjustable.Container:new2({
    name = "GUI.Room",
    attached = "right",
    x = -500,
    y = "29%",
    width = 500,
    height = "29%",
    titleText ="Stanza",
    titleTxtColor = "orange",
    buttonsize = 12,
    buttonFontSize = 5,
    adjLabelstyle = GUI.CSS.Widget, 
    buttonstyle = GUI.CSS.WidgetButton,
  })
  GUI.Room:changeMenuStyle("dark")
  --
  -- Add Border and Main
  ui.fAddMain(GUI.Room, GUI.CSS.Border, GUI.CSS.Main)
  --
  -- Exits
  GUI.Room.Main.Console = Geyser.MiniConsole:new2({ 
    name = 'GUI.Room.Main.Console',
    x=0,
    y=0,
    width = "100%", 
    height = "100%", 
    autoWrap = false,
    scrollBar = false,
  }, GUI.Room.Main)
  GUI.Room.Main.Console:setColor(30, 24, 24)
  GUI.Room.Main.Console:setBgColor(30, 24, 24)
  GUI.Room.Main.Console:setFontSize(ui.parameters.widgets.room.fontSize)
  --
  -- Wrapping function
  local Minimize = GUI.Room.minimize
  local Restore = GUI.Room.restore
  --
  function GUI.Room:minimize(...)
    GUI.Room.Main:hide()
    return Minimize(GUI.Room)
  end
  --
  function GUI.Room:restore(...)
    GUI.Room.Main:show()
    return Restore(GUI.Room)
  end
end</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>Target Buttons Widget</name>
					<packageName></packageName>
					<script>function ui.fInitTargetButtonsWidget()
  ui.fDebug("[&lt;cyan&gt;call&lt;r&gt;] ui.fInitTargetButtonsWidget()")
  --
  -- Target
  GUI.TargetButtons = Adjustable.Container:new2({
    name = "GUI.TargetButtons",
    attached = "left",
    x = 0,
    y = "55%",
    width = 300,
    height = "15%",
    titleText ="Target",
    titleTxtColor = "orange",
    buttonsize = 12,
    buttonFontSize = 5,
    adjLabelstyle = GUI.CSS.Widget, 
    buttonstyle = GUI.CSS.WidgetButton,
  })
  GUI.TargetButtons:changeMenuStyle("dark")
  --
  -- Add Border and Main
  ui.fAddMain(GUI.TargetButtons, GUI.CSS.Border, GUI.CSS.Main)
  --
  -- Set transparent
  ui.fSetBorderMode(GUI.TargetButtons, ui.parameters.widgets.targets.transparent)
  --
  -- Button "Hide"
  GUI.TargetButtons.Button_hide = Geyser.Label:new2({
    name = "GUI.TargetButtons.Button_hide",
    x = -46, 
    y = 4,
    width = 12,
    height = 12,
  },GUI.TargetButtons)
  GUI.TargetButtons.Button_hide:setStyleSheet(GUI.CSS.WidgetButton);
  GUI.TargetButtons.Button_hide:setFontSize(5)
  GUI.TargetButtons.Button_hide:echo(ui.transparentID)
  GUI.TargetButtons.Button_hide:setClickCallback(function() 
                                                   local mode = ui.parameters.widgets.targets.transparent or false;
                                                   ui.fSetBorderMode(GUI.TargetButtons, not mode)
                                                   ui.parameters.widgets.targets.transparent = not mode;
                                                   ui.fSaveFileParameters()
                                                end)
  GUI.TargetButtons.Button_hide:setToolTip("Transparent", 10)
  --
  -- Target buttons
  for i=1,4 do
    GUI.TargetButtons.Main["t"..i] = Geyser.Label:new2({
      name = "GUI.TargetButtons.Main.t"..i,
      x = 0,
      y = 0,
      width = "10",
      height = "10",
    },GUI.TargetButtons.Main)
    GUI.TargetButtons.Main["t"..i]:setClickCallback("ui.fExecuteTargetButton", "t"..i, nil)
    GUI.TargetButtons.Main["t"..i]:setFontSize(9)
    GUI.TargetButtons.Main["t"..i]:setFgColor("LightGoldenrod")
    --
    -- Index
    GUI.TargetButtons.Main["t"..i].index = Geyser.Label:new2({
      name = "GUI.TargetButtons.Main.t"..i..".index",
      x = 5, 
      y = 1,
      width = "15",
      height = "15",
    }, GUI.TargetButtons.Main["t"..i])
    GUI.TargetButtons.Main["t"..i].index:enableClickthrough()
    GUI.TargetButtons.Main["t"..i].index:setFontSize(ui.parameters.widgets.keybind.fontSize)
    GUI.TargetButtons.Main["t"..i].index:setStyleSheet(GUI.CSS.Keybind);
    GUI.TargetButtons.Main["t"..i].index:echo("t"..i.."")
    --
    -- Keybid
    GUI.TargetButtons.Main["t"..i].keybind = Geyser.Label:new2({
      name = "GUI.TargetButtons.Main.t"..i..".keybind",
      x = 5, 
      y = -15,
      width = "100%-10",
      height = 15,
    }, GUI.TargetButtons.Main["t"..i])
    GUI.TargetButtons.Main["t"..i].keybind:enableClickthrough()
    GUI.TargetButtons.Main["t"..i].keybind:setStyleSheet(GUI.CSS.Keybind);
    GUI.TargetButtons.Main["t"..i].keybind:setFontSize(ui.parameters.widgets.keybind.fontSize)
  end
  --
  -- Wrapping function
  local Minimize = GUI.TargetButtons.minimize
  local Restore = GUI.TargetButtons.restore
  local Resize = GUI.TargetButtons.resize
  --
  function GUI.TargetButtons:minimize(...)
    GUI.TargetButtons.Main:hide()
    return Minimize(GUI.TargetButtons)
  end
  --
  function GUI.TargetButtons:restore(...)
    GUI.TargetButtons.Main:show()
    return Restore(GUI.TargetButtons)
  end
  --
  function GUI.TargetButtons:resize(...)
    ui.fUpdateTargetButtons()
    return Resize(GUI.TargetButtons, ...)
  end
end</script>
					<eventHandlerList />
				</Script>
			</ScriptGroup>
			<Script isActive="yes" isFolder="no">
				<name>Init Structures</name>
				<packageName></packageName>
				<script>--
ui = ui or {}
ui.enDebug = 0 -- 0 = Off, 1 = Text only, 2 = simulate values
ui.release = getPackageInfo("LeU_UI", "version")
ui.echo = "&lt;blue&gt;[  &lt;DodgerBlue&gt;UI  &lt;blue&gt;] "
ui.transparentID = '&lt;center&gt;⋯'
ui.varID = "&amp;"
--
-- Colors
ui.colors = {
  aliasButton  = "&lt;orange&gt;",
  aliasName    = "&lt;violet&gt;",
  aliasOutput  = "&lt;r&gt;",  -- "&lt;PaleGoldenrod&gt;"
  command      = "&lt;steel_blue&gt;",
  error        = "&lt;DarkOrange&gt;",
  input        = "&lt;bisque&gt;", -- #
  keybind      = "&lt;cyan&gt;",
  link         = "&lt;gold&gt;",
  operator     = "&lt;gold&gt;",         -- » or «
  profileName  = "&lt;green&gt;",
  separator    = "&lt;orange_red&gt;",     -- ; or /
  target       = "&lt;orange&gt;",
  text         = "&lt;r&gt;",
  title        = "&lt;white&gt;",
  varID        = "&lt;steel_blue&gt;",
  varName      = "&lt;LightBlue&gt;",
  varCont      = "&lt;MediumSeaGreen&gt;",
  widget       = "25,20,20",
  wBackground  = "30,24,24",
  wBorder      = "90,72,72",
  wButton      = "90,72,72",
  wButtonHover = "180,144,144",
  wText        = "69,69,69",
}
--
local packPath = getMudletHomeDir().."/LeU_UI/"
local dataPath = getMudletHomeDir().."/LeU_UI_data/"
--
ui.files = {
  aliases = {
    path = dataPath,
    name = "aliases.lua",
  },
  data = {
    path = dataPath,
  },
  highlights = {
    path = dataPath,
    name = "highlights.lua",
  },
  icons = {
    path = packPath.."icons/",
  },
  images = {
    path = packPath.."images/",
  },
  map        = {
    path = packPath.."map/",
    name = "map.lua",
  },
  options    = {
    path = dataPath,
    name = "options.lua",
  },
  parameters = {
    path = dataPath,
    name = "parameters.lua",
  },
  profiles = {
    path = getMudletHomeDir().."/../../profilesLeu/",
  },
  sounds = {
    path = packPath.."sounds/",
  },
  targets    = {
    path = dataPath,
    name = "targets.lua",
  },
  variables  = {
    path = dataPath,
    name = "variables.lua",
  },
}
--
ui.fastAffects = "";
--
-- Modifier for keybind
ui.keyb_modifier = {
  CTRL = mudlet.keymodifier.Control,
  ALT  = mudlet.keymodifier.Alt,
}
--
-- Keys for keybind
ui.keyb_single = {
  ["0"] = mudlet.key["0"],
  ["1"] = mudlet.key["1"],
  ["2"] = mudlet.key["2"],
  ["3"] = mudlet.key["3"],
  ["4"] = mudlet.key["4"],
  ["5"] = mudlet.key["5"],
  ["6"] = mudlet.key["6"],
  ["7"] = mudlet.key["7"],
  ["8"] = mudlet.key["8"],
  ["9"] = mudlet.key["9"],
  --
  A = mudlet.key.A,
  B = mudlet.key.B,
  C = mudlet.key.C,
  D = mudlet.key.D,
  E = mudlet.key.E,
  F = mudlet.key.F,
  G = mudlet.key.G,
  H = mudlet.key.H,
  I = mudlet.key.I,
  J = mudlet.key.J,
  K = mudlet.key.k,
  L = mudlet.key.L,
  M = mudlet.key.M,
  N = mudlet.key.N,
  O = mudlet.key.O,
  P = mudlet.key.P,
  Q = mudlet.key.Q,
  R = mudlet.key.R,
  S = mudlet.key.S,
  T = mudlet.key.T,
  U = mudlet.key.U,
  V = mudlet.key.V,
  W = mudlet.key.W,
  X = mudlet.key.X,
  Y = mudlet.key.Y,
  Z = mudlet.key.Z,
  --
  F1  = mudlet.key.F1,
  F2  = mudlet.key.F2,
  F3  = mudlet.key.F3,
  F4  = mudlet.key.F4,
  F5  = mudlet.key.F5,
  F6  = mudlet.key.F6,
  F7  = mudlet.key.F7,
  F8  = mudlet.key.F8,
  F9  = mudlet.key.F9,
  F10 = mudlet.key.F10,
  F11 = mudlet.key.F11,
  F12 = mudlet.key.F12,
}
--
ui.validExit = {
  down  = {short = "d", long = "down",  reverse = "u", tokenOpen = "⤦", tokenClose = "□", tokenAbsent = "└", tokenFrom = "◆", tokenSecret = "S", color = "&lt;white&gt;", dColor = "&lt;255,255,255:30,24,24&gt;",},
  east  = {short = "e", long = "east",  reverse = "w", tokenOpen = "▷", tokenClose = "□", tokenAbsent = "│", tokenFrom = "◆", tokenSecret = "S", color = "&lt;yellow&gt;", dColor = "&lt;255,255,0:30,24,24&gt;",},
  north = {short = "n", long = "north", reverse = "s", tokenOpen = "△", tokenClose = "□", tokenAbsent = "─", tokenFrom = "◆", tokenSecret = "S", color = "&lt;green&gt;", dColor = "&lt;0,255,0:30,24,24&gt;",},
  south = {short = "s", long = "south", reverse = "n", tokenOpen = "▽", tokenClose = "□", tokenAbsent = "─", tokenFrom = "◆", tokenSecret = "S", color = "&lt;blue&gt;", dColor = "&lt;0,0,255:30,24,24&gt;",},
  up    = {short = "u", long = "up",    reverse = "d", tokenOpen = "⤤", tokenClose = "□", tokenAbsent = "┐", tokenFrom = "◆", tokenSecret = "S", color = "&lt;cyan&gt;", dColor = "&lt;0,255,255:30,24,24&gt;",},
  west  = {short = "w", long = "west",  reverse = "e", tokenOpen = "◁", tokenClose = "□", tokenAbsent = "│", tokenFrom = "◆", tokenSecret = "S", color = "&lt;magenta&gt;", dColor = "&lt;255,0,255:30,24,24&gt;",},
}
--
ui.validExit["basso"] = ui.validExit.down
ui.validExit["d"]     = ui.validExit.down
--
ui.validExit["est"]   = ui.validExit.east
ui.validExit["e"]     = ui.validExit.east
--
ui.validExit["nord"]  = ui.validExit.north
ui.validExit["n"]     = ui.validExit.north
--
ui.validExit["sud"]   = ui.validExit.south
ui.validExit["s"]     = ui.validExit.south
--
ui.validExit["alto"]  = ui.validExit.up
ui.validExit["u"]     = ui.validExit.up
--
ui.validExit["w"]     = ui.validExit.west
ui.validExit["ovest"] = ui.validExit.west
ui.validExit["o"]     = ui.validExit.west
--
-- Speedwalk
ui.speedwalk = ui.speedwalk or {
  delay   = 0.01, -- (sec)
  path    = {},
  timeOut = 1,    -- (sec)
}
--
-- Affects
ui.affects = ui.affects or {}
--
-- Cooldowns
ui.cooldowns = ui.cooldowns or {}
--
-- Equipment
ui.equipment = ui.equipment or {}
--
-- Group
ui.group = ui.group or {}
--
-- Handlers
ui.handlers = ui.handlers or {}
--
-- Opponent
ui.opponent = ui.opponent or {}
--
-- Player
ui.player = ui.player or {}
--
-- Previous
ui.previous = ui.previous or {}
-- 
-- Map coordinates
ui.map = ui.map or {}</script>
				<eventHandlerList />
			</Script>
			<Script isActive="yes" isFolder="no">
				<name>Init CSS</name>
				<packageName></packageName>
				<script>--
ui.fDebug("[init] CSS")
--
GUI = GUI or {}
GUI.CSS = GUI.CSS or {}
--
-- Item
GUI.CSS.Item = [[
  border: 2px outset rgb(]]..ui.colors.wBorder..[[);
  border-top-left-radius: 12px;
  border-top-right-radius:12px;
  border-bottom-left-radius: 12px;
  border-bottom-right-radius:12px;
]]
--
-- Item Left
GUI.CSS.ItemLeft = [[
  border: 2px inset rgb(]]..ui.colors.wBorder..[[);
  border-top-left-radius: 10px;
  border-top-right-radius: 5px;
  border-bottom-left-radius: 10px;
  border-bottom-right-radius: 5px;
  background-color: rgb(]]..ui.colors.wBackground..[[);
]]
--
-- Item Top Left
GUI.CSS.ItemTopLeft = [[
  border: 2px inset rgb(]]..ui.colors.wBorder..[[);
  border-bottom: none;
  border-top-left-radius: 10px;
  border-top-right-radius: 5px;
  background-color: rgb(]]..ui.colors.wBackground..[[);
]]
--
-- Item Bottom Left
GUI.CSS.ItemBottomLeft = [[
  border: 2px inset rgb(]]..ui.colors.wBorder..[[);
  border-top: none;
  border-bottom-left-radius: 10px;
  border-bottom-right-radius: 5px;
  background-color: rgb(]]..ui.colors.wBackground..[[);
]]
--
-- Item Text
GUI.CSS.ItemText = [[
  border: none;
  border-radius: 0px;
  qproperty-wordWrap: true;
]]
--
-- Item Top Right
GUI.CSS.ItemTopRight = [[
  border: 2px inset rgb(]]..ui.colors.wBorder..[[);
  border-bottom: none;
  border-top-left-radius: 5px;
  border-top-right-radius: 10px;
  background-color: rgb(]]..ui.colors.wBackground..[[);
]]
--
-- Item Bottom Right
GUI.CSS.ItemBottomRight = [[
  border: 2px inset rgb(]]..ui.colors.wBorder..[[);
  border-top: none;
  border-bottom-left-radius: 5px;
  border-bottom-right-radius: 10px;
  background-color: rgb(]]..ui.colors.wBackground..[[);
]]
--
-- Border
GUI.CSS.Border = [[
  border: 2px inset rgb(]]..ui.colors.wBorder..[[); 
  border-radius: 4px;
  background-color: rgb(]]..ui.colors.wBackground..[[);
]]
--
-- Border transparent
GUI.CSS.BorderTransparent = [[
  border: none;
  padding: 2px;
  background: transparent;
]]
--
-- Target buttons
GUI.CSS.Button = [[
  border: 2px outset #aa8822;
  border-radius: 5px 10px;
  qproperty-wordWrap: true;
]]
--
-- Buttons Icon
GUI.CSS.ButtonsIcon = [[
  background: transparent;
  qproperty-wordWrap: true;
]]
--
-- Gauge back
GUI.CSS.GaugeBack = [[
  border: none;
  border-radius: 5px;
  margin: 0px;
]]
--
-- Gauge front
GUI.CSS.GaugeFront = [[
  border-radius: 3px;
  margin:  2px;
]]
--
-- Keybind
GUI.CSS.Keybind = [[
  background: transparent;
]]
--
-- Level
GUI.CSS.Level = [[
  border-image: url("]]..ui.files.images.path..[[borderRound.png") 0px stretch;
  background-color: rgb(]]..ui.colors.wBackground..[[);
  background: transparent;
]]
--
-- Widget Body

GUI.CSS.Main = [[
  background: transparent;
]]
--
--
GUI.CSS.Widget = [[
  border: 2px outset rgb(]]..ui.colors.wBorder..[[); 
  border-top-left-radius: 10px;
  border-top-right-radius: 10px;
  border-bottom-left-radius: 4px;
  border-bottom-right-radius: 4px;
  background-color: rgb(]]..ui.colors.widget..[[);
]]
--
GUI.CSS.WidgetButton = [[
  QLabel{
    border-radius: 6px;
    background-color: rgb(]]..ui.colors.wButton..[[);
  }
  QLabel::hover{
    background-color: rgb(]]..ui.colors.wButtonHover..[[);
  }
]]
--
--
GUI.CSS.WidgetTransparent = [[
  QWidget{
    border: none;
    border-top-left-radius: 10px;
    border-top-right-radius: 10px;
    border-bottom-left-radius: 4px;
    border-bottom-right-radius: 4px;
    padding: 2px;
    background: transparent;
  }
  QWidget::hover{
    border: 2px outset rgba(]]..ui.colors.wBorder..[[, 0.7); 
    background-color: rgba(]]..ui.colors.wBackground..[[, 0.7);
  }
]]</script>
				<eventHandlerList />
			</Script>
			<Script isActive="yes" isFolder="no">
				<name>Init Help</name>
				<packageName></packageName>
				<script>ui.fDebug("[init] Help")
--
ui.help = {}
--
ui.help.error = [[
Non esiste aiuto per questa parola

Ritorna alla pagina principale dell'&lt;link help&gt;help&lt;/link&gt;.
]]
--
ui.help.help = [[
&lt;title&gt;Lumen et Umbra UI Help&lt;/title&gt; Lumen et Umbra UI comprende un insieme di finestre (widget), script, trigger, etc, creati per personalizzare l'esperienza di gioco con il MUD Lumen et Umbra su client Mudlet. Usare il comando &lt;command&gt;uih[elp] &lt;comando&gt;&lt;/command&gt; o clicca sui link tra parentesi quadre per avere informazioni sugli argomenti disponibili.

&lt;yellow&gt;Witgets&lt;r&gt; &lt;link widgets&gt;Panoramica&lt;/link&gt;
  &lt;link affects&gt;Affects&lt;/link&gt;   ▷ Widget effetti attivi                      &lt;link mapper&gt;Mapper&lt;/link&gt;   ▷ Widget mappa 
  &lt;link buttons&gt;Buttons&lt;/link&gt;   ▷ Widget bottoni per alias                   &lt;link opponent&gt;Opponent&lt;/link&gt; ▷ Widget dati avversatrio 
  &lt;link chat&gt;Chat&lt;/link&gt;      ▷ Widget chat                                &lt;link player&gt;Player&lt;/link&gt;   ▷ Widget dati giocatore
  &lt;link cooldowns&gt;Cooldowns&lt;/link&gt; ▷ Widget cooldowns                           &lt;link room&gt;Room&lt;/link&gt;     ▷ Widget stanza 
  &lt;link endowment&gt;Endowment&lt;/link&gt; ▷ Widget equipaggiamento                     &lt;link targets&gt;Target&lt;/link&gt;   ▷ Widget bottoni per target 
  &lt;link group&gt;Group&lt;/link&gt;     ▷ Widget gruppo

&lt;yellow&gt;Comandi (principali):                                    Comandi (mappa):&lt;r&gt;
  &lt;link alias&gt;uia[liases]&lt;/link&gt;    ▷ Comando per gestire gli aliases       &lt;link go&gt;uig[o]&lt;/link&gt;     ▷ Comando per muoversi automaticamente a una stanza 
  &lt;link help&gt;uih[elp]&lt;/link&gt;       ▷ Questo help                           &lt;link info&gt;uii[nfo]&lt;/link&gt;   ▷ Comando avere informazioni su una stanza
  &lt;link highlight&gt;uihi[ghlights]&lt;/link&gt; ▷ Comando per gestione gli highlights   &lt;link search&gt;uis[earch]&lt;/link&gt; ▷ Comando per cercare una stanza
  &lt;link variable&gt;uiv[ariables]&lt;/link&gt;  ▷ Comando per gestione le variabili     &lt;link track&gt;uit[rack]&lt;/link&gt;  ▷ Comando per tracciare il percorso a una stanza

&lt;yellow&gt;Altri comandi:&lt;r&gt;
  &lt;link walk&gt;.&lt;/link&gt;,
  &lt;link walk&gt;..&lt;/link&gt;           ▷ Comandi di walk e speedwalk
  &lt;link target&gt;g0..g9&lt;/link&gt;,
  &lt;link target&gt;o0&lt;/link&gt;,
  &lt;link target&gt;t1..t4&lt;/link&gt;       ▷ Comandi per la gestione della variabile &lt;var&gt;target&lt;/var&gt;
  &lt;link button&gt;uib[uttons]&lt;/link&gt;  ▷ Comando per la gestione dei pulsanti del widget Button
  &lt;link color&gt;uic[olors]&lt;/link&gt;   ▷ Comando per la visualizzazione dei colori disponibili per gli highlights
  &lt;link fontsize&gt;uif[ontsize]&lt;/link&gt; ▷ Comando per la gestione della dimensione dei font di aluni widget
  &lt;link keybind&gt;uik[eibind]&lt;/link&gt;  ▷ Comando per la gestione dei tasti rapidi per aliases e targets
  &lt;link profile&gt;uip[rofiles]&lt;/link&gt; ▷ Comando per la gestione dei profili
  &lt;link reply&gt;uir[eply]&lt;/link&gt;    ▷ Comando per rispondere velocemente all'ultimo messsaggio ricevuto
  &lt;link widget&gt;uiw[idget]&lt;/link&gt;   ▷ Comando per il ripristino dei widget chiusi
]]
--
ui.help.affects = [[
&lt;title&gt;Widget Affects&lt;/title&gt;Il widget Affects visualizza automaticamente (via GMCP) i dati relativi agli effetti attivi sul personaggio. Ogni elemento del widget rappresenta un effetto attivo ed è composto dal suo nome (al centro), il tempo di permanenza (a sinistra, r=round, t=tick, P=permanente), il suo livello di resistenza al dispel (in alto a destra, in azzurro) e il suo valore di stack (in basso a destra, in arancione).

Rimanendo con il cursore del mouse su un effetto è possibile visualizzare in un tooltip le caratteristiche dell'effetto selezionato.

Ritorna alla pagina principale dell'&lt;link help&gt;help&lt;/link&gt;.
]]
--
ui.help.alias = [[
&lt;title&gt;Aliases&lt;/title&gt;Gli aliases permettono di associare un testo semplice a uno o più comandi complessi. I comandi di un alias possono contenere variabili create con il comando &lt;link variable&gt;uiv[ariables]&lt;/link&gt; o altri alias creati precedenemente con il comando &lt;link alias&gt;uia[liases]&lt;/link&gt;. 
Per associare più comandi ad un alias utilizzare uno degli appositi separatori di comando (]]..ui.colors.separator..[[;&lt;r&gt; o ]]..ui.colors.separator..[[/&lt;r&gt;). Richiamando l'alias i comandi verranno eseguiti sequenzialmente dal primo all'ultimo.

&lt;yellow&gt;Configurazione:&lt;r&gt;
  &lt;command&gt;uia[liases]&lt;/command&gt;                   Per visualizzare l'elenco degli aliases
  &lt;command&gt;uia[liases]&lt;/command&gt; &lt;aliasName&gt;&lt;alias&gt;&lt;/aliasName&gt;           Per visualizzare il singolo alias
  &lt;command&gt;uia[liases]&lt;/command&gt; &lt;aliasName&gt;&lt;alias&gt;&lt;/aliasName&gt; &lt;comandi&gt; Per creare o modificare un alias
  &lt;command&gt;uia[liases]&lt;/command&gt; &lt;aliasName&gt;&lt;alias&gt;&lt;/aliasName&gt; &lt;command&gt;remove&lt;/command&gt;    Per eliminare un alias
  &lt;command&gt;uia[liases] remove_all&lt;/command&gt;        Per eliminare tutti gli aliases

&lt;yellow&gt;Utilizzo:&lt;r&gt;
  &lt;aliasName&gt;&lt;alias&gt;&lt;/aliasName&gt; &lt;input&gt;[argomento]&lt;/input&gt;           Per eseguire l'alias

&lt;yellow&gt;Carattere speciale&lt;r&gt; &lt;input&gt;#&lt;/input&gt;
Normalmente, durante l'esecuzione di un alias, l'input passato come parametro ad un alias viene appeso al comando o sostituito all'ultima variabile del comando (se presente). Il carattere speciale &lt;input&gt;#&lt;/input&gt; permette di specificare il punto esatto all'interno del comando dove inserire il testo di input.

&lt;yellow&gt;Carattere speciale&lt;r&gt; ]]..ui.colors.varID..ui.varID..[[&lt;r&gt;
Per utilizzare una variabile precedentemente dichiarata con il comando &lt;link variable&gt;uiv[ariables]&lt;/link&gt; all'interno di un alias usare il carattere speciale ]]..ui.colors.varID..ui.varID..[[&lt;r&gt; prima delnome della variabile.

&lt;yellow&gt;Caratteri speciali&lt;r&gt; ]]..ui.colors.separator..[[;&lt;r&gt; o ]]..ui.colors.separator..[[/&lt;r&gt;
Utilizzare uno dei seguenti carattere speciali per dividere più comandi all'interno dello stesso alias

&lt;yellow&gt;Esempio 1: Comando semplice&lt;r&gt;
  Dichiarazione:
    ▷ &lt;command&gt;uia&lt;/command&gt; &lt;aliasName&gt;hl&lt;/aliasName&gt; &lt;aliasOutput&gt;cast 'heal'&lt;/aliasOutput&gt;

  Esecuzione:
    ▷ &lt;aliasName&gt;hl&lt;/aliasName&gt;
    ◁ &lt;aliasOutput&gt;cast 'heal'&lt;/aliasOutput&gt;       

  Esecuzione con parametri:
    ▷ &lt;aliasName&gt;hl&lt;/aliasName&gt; Pippo
    ◁ &lt;aliasOutput&gt;cast 'heal'&lt;/aliasOutput&gt; Pippo 
    
  L'input viene appeso al comando.

&lt;yellow&gt;Esempio 2: Comando con variabile&lt;r&gt;
  Dichiarazione:
    ▷ &lt;command&gt;uia&lt;/command&gt; &lt;aliasName&gt;bt&lt;/aliasName&gt; bash &lt;varName&gt;target&lt;/varName&gt;   
   
  Con &lt;varName&gt;target&lt;/varName&gt; precedentemente inizializzato a &lt;varValue&gt;Pluto&lt;/varValue&gt;

  Esecuzione:
    ▷ &lt;aliasName&gt;bt&lt;/aliasName&gt;
    ◁ bash &lt;varValue&gt;Pluto&lt;/varValue&gt;

  Esecuzione con parameri:
    ▷ &lt;aliasName&gt;bt&lt;/aliasName&gt; Pippo
    ◁ bash Pippo
  
  L'ultima variabile viene sostituita dall'input. Il valore della variabile, in questo caso &lt;varName&gt;target&lt;/varName&gt;, non cambierà

&lt;yellow&gt;Esempio 3: Comando con più variabili&lt;r&gt;
  Dichiarazione:
    ▷ &lt;command&gt;uia&lt;/command&gt; &lt;aliasName&gt;aa&lt;/aliasName&gt; &lt;varName&gt;action&lt;/varName&gt; &lt;varName&gt;target&lt;/varName&gt;
  
  Con &lt;varName&gt;action&lt;/varName&gt; precedentemente inizializzata a &lt;varValue&gt;kick&lt;/varValue&gt; e &lt;varName&gt;target&lt;/varName&gt; a &lt;varValue&gt;Pluto&lt;/varValue&gt;
   
  Esecuzione:
    ▷ &lt;aliasName&gt;aa&lt;/aliasName&gt;
    ◁ &lt;varValue&gt;kick&lt;/varValue&gt; &lt;varValue&gt;Pluto&lt;/varValue&gt;

  Esecuzione con parameri:
    ▷ &lt;aliasName&gt;aa&lt;/aliasName&gt; Pippo
    ◁ &lt;varValue&gt;kick&lt;/varValue&gt; Pippo 
  
  L'ultima variabile viene sostituita dall'input. Il valore della variabile, in questo caso &lt;varName&gt;target&lt;/varName&gt;, non cambierà

&lt;yellow&gt;Esempio 4: Comandi multipli con input a posizione definita
  Dichiarazione:
    ▷ &lt;command&gt;uia&lt;/command&gt; &lt;aliasName&gt;dd&lt;/aliasName&gt; &lt;aliasOutput&gt;get&lt;/aliasOutput&gt; &lt;input&gt;#&lt;/input&gt; &lt;varName&gt;bag&lt;/varName&gt; ]]..ui.colors.separator..[[/&lt;r&gt; &lt;aliasOutput&gt;drink&lt;/aliasOutput&gt; &lt;input&gt;#&lt;/input&gt; ]]..ui.colors.separator..[[/&lt;r&gt; &lt;aliasOutput&gt;put&lt;/aliasOutput&gt; &lt;input&gt;#&lt;/input&gt; &lt;varName&gt;bag&lt;/varName&gt;
  
  Con &lt;varName&gt;bag&lt;/varName&gt; precedentemente inizializzata a &lt;varValue&gt;moltetasche&lt;/varValue&gt;

  Esecuzione con parameri:
    ▷ &lt;aliasName&gt;dd&lt;/aliasName&gt; limonata
    ◁ [1] &lt;aliasOutput&gt;get&lt;/aliasOutput&gt; &lt;input&gt;limonata&lt;/input&gt; &lt;varValue&gt;moltetasche&lt;/varValue&gt;
    ◁ [2] &lt;aliasOutput&gt;drink&lt;/aliasOutput&gt; &lt;input&gt;limonata&lt;/input&gt;
    ◁ [3] &lt;aliasOutput&gt;put&lt;/aliasOutput&gt; &lt;input&gt;limonata&lt;/input&gt; &lt;varValue&gt;moltetasche&lt;/varValue&gt;
  
  Il carattere speciale &lt;input&gt;#&lt;/input&gt; verrà sostituito dall'imput. Si noti che in caso di mancanza di input, il carattere speciale &lt;input&gt;#&lt;/input&gt; verrà sostituito da uno spazio vuoto

&lt;yellow&gt;Esempio 5: Comandi multipli complessi con alias, variabili e input a posizione definita
  Dichiarazione (si faccia riferimento agli esempi precedenti):
    ▷ &lt;command&gt;uia&lt;/command&gt; &lt;aliasName&gt;gg&lt;/aliasName&gt; &lt;aliasOutput&gt;get&lt;/aliasOutput&gt; &lt;input&gt;#&lt;/input&gt; &lt;varName&gt;bag&lt;/varName&gt;
    ▷ &lt;command&gt;uia&lt;/command&gt; &lt;aliasName&gt;pp&lt;/aliasName&gt; &lt;aliasOutput&gt;put&lt;/aliasOutput&gt; &lt;input&gt;#&lt;/input&gt; &lt;varName&gt;bag&lt;/varName&gt;
    ▷ &lt;command&gt;uia&lt;/command&gt; &lt;aliasName&gt;dd&lt;/aliasName&gt; &lt;aliasName&gt;gg&lt;/aliasName&gt; &lt;input&gt;#&lt;/input&gt; ]]..ui.colors.separator..[[/&lt;r&gt; &lt;aliasOutput&gt;drink&lt;/aliasOutput&gt; &lt;input&gt;#&lt;/input&gt; ]]..ui.colors.separator..[[/&lt;r&gt; &lt;aliasName&gt;pp&lt;/aliasName&gt; &lt;input&gt;#&lt;/input&gt;
  
  Con &lt;varName&gt;bag&lt;/varName&gt; precedentemente inizializzata a &lt;varValue&gt;moltetasche&lt;/varValue&gt;

  Esecuzione con parameri:
    ▷ &lt;aliasName&gt;dd&lt;/aliasName&gt; limonata
    ◁ [1] &lt;aliasName&gt;gg&lt;/aliasName&gt; limonata
      ◁ &lt;aliasOutput&gt;get&lt;/aliasOutput&gt; &lt;input&gt;limonata&lt;/input&gt; &lt;varValue&gt;moltetasche&lt;/varValue&gt;
    ◁ [2] &lt;aliasOutput&gt;drink&lt;/aliasOutput&gt; &lt;input&gt;limonata&lt;/input&gt;
    ◁ [3] &lt;aliasName&gt;pp&lt;/aliasName&gt; limonata
      ◁ &lt;aliasOutput&gt;put&lt;/aliasOutput&gt; &lt;input&gt;limonata&lt;/input&gt; &lt;varValue&gt;moltetasche&lt;/varValue&gt;
  
&lt;yellow&gt;Per maggiori informazioni:&lt;r&gt;
  &lt;link keybind&gt;uik[eibind]&lt;/link&gt; ▷ Comando per la gestione dei tasti rapidi per aliases e targets
 
Ritorna alla pagina principale dell'&lt;link help&gt;help&lt;/link&gt;.
]]
--
ui.help.buttons = [[
&lt;title&gt;Widget Button&lt;/title&gt;Il widget Button contiene dei pulsanti che posso essere assonciati ad un alias creato precedentemente. I pulsanti sono identificati da una lettera (&lt;red&gt;a&lt;r&gt;, &lt;green&gt;b&lt;r&gt; oppure &lt;blue&gt;c&lt;r&gt;) e un numero (da 0 a 9) per un totale di 30 pulsanti configurabili (da &lt;red&gt;a0&lt;r&gt; a &lt;red&gt;a9&lt;r&gt;, da &lt;green&gt;b0&lt;r&gt; a &lt;green&gt;b9&lt;r&gt; e da &lt;blue&gt;c0&lt;r&gt; a &lt;blue&gt;c9&lt;r&gt;).

I pulsanti sono ragruppati per lettera ed è possibile passare da un gruppo all'altro cliccando sui pulsanti a, b e c sulla barra del titolo del widget.

Tramite il comando &lt;link button&gt;uib[uttons]&lt;/link&gt; è possibile configurare i pusanti del widget.

Cliccare su un pulsante o richiamarlo per nome da console equivale a eseguire l'alias a cui è stato associato.

&lt;yellow&gt;Per maggiori informazioni:&lt;r&gt;
  &lt;link button&gt;uib[uttons]&lt;/link&gt;  ▷ Comando per la gestione dei pulsanti del widget Button

Ritorna alla pagina principale dell'&lt;link help&gt;help&lt;/link&gt;.
]]
--
ui.help.button = [[
&lt;title&gt;Gestione dei pulsanti del widget Button&lt;/title&gt;Tramite il comando &lt;command&gt;uib[uttons]&lt;/command&gt; è possibile associare, cambiare o rimuovere un alias a uno dei 30 pulsanti del widget Button.

Una volta associato ad un alias, sul pulsante appariranno le informazioni relative al suo nome (in alto a sinistra), all'alias associato (al centro) e al tasto di scelta rapida associato all'alias (in basso a destra, se presente). Si noti che il tasto di scelta rapida va associato all'alias (tramite il comando &lt;link keybind&gt;uik[eibind]&lt;/link&gt;) e non al pulsante.

&lt;yellow&gt;Configurazione:&lt;r&gt;
  &lt;command&gt;uib[uttons]&lt;/command&gt;                   Per visualizzare l'elenco dei pulsanti configurati
  &lt;command&gt;uib[uttons]&lt;/command&gt; &lt;button&gt;&lt;button&gt;&lt;/button&gt;          Per visualizzare il singolo pulsante
  &lt;command&gt;uib[uttons]&lt;/command&gt; &lt;button&gt;&lt;button&gt;&lt;/button&gt; &lt;aliasName&gt;&lt;alias&gt;&lt;/aliasName&gt;  Per associare un alias al pusante
  &lt;command&gt;uib[uttons]&lt;/command&gt; &lt;button&gt;&lt;button&gt;&lt;/button&gt; &lt;command&gt;remove&lt;/command&gt;   Per eliminare l'alias associato al pulsante
  &lt;command&gt;uib[uttons] remove_all&lt;/command&gt;        Per eliminare gli aliases associati a tutti i pulsanti

&lt;yellow&gt;Utilizzo:&lt;r&gt;
  &lt;button&gt;&lt;button&gt;&lt;/button&gt; o click             Per eseguire l'alias associato al pulsante

&lt;button&gt;&lt;button&gt;&lt;/button&gt; deve essere compreso tra uno dei 30 pulsanti disponibili (da &lt;red&gt;a0&lt;r&gt; a &lt;red&gt;a9&lt;r&gt;, da &lt;green&gt;b0&lt;r&gt; a &lt;green&gt;b9&lt;r&gt; e da &lt;blue&gt;c0&lt;r&gt; a &lt;blue&gt;c9&lt;r&gt;).

&lt;yellow&gt;Per maggiori informazioni:&lt;r&gt;
  &lt;link buttons&gt;Buttons&lt;/link&gt;     ▷ Widget bottoni per alias
  &lt;link alias&gt;uia[liases]&lt;/link&gt; ▷ Comando per gestire gli aliases

Ritorna alla pagina principale dell'&lt;link help&gt;help&lt;/link&gt;.
]]
--
ui.help.chat = [[
&lt;title&gt;Widget Chat&lt;/title&gt;Il widget Chat cattura e visualizza in modo automatico (via trigger) i testi di comunicazione privati (tel, send, etc) e pubblici (gossip, ot, etc).

Tramite il tasto nella barra del titolo è possibile scegliere se visualizzare solo i messaggi privati (private), solo i messagi pubblici (public) oppure tutti i messaggi (all). Nel caso in cui sia attiva la visualizzazione di tutti i messaggi, tramite il tasto "split" è possibile suddividere la visualizzazione dei messaggi privati\pubblici in orizzontale, verticale o ragruppati in un unica finestra.

Ritorna alla pagina principale dell'&lt;link help&gt;help&lt;/link&gt;.
]]
--
ui.help.cooldowns = [[
&lt;title&gt;Widget Cooldowns&lt;/title&gt;Il widget Cooldowns visualizza automaticamente (via GMCP) i dati relativi ai cooldowns attivi sul personaggio. Ogni elemento del widget rappresenta un cooldownd attivo ed è composto dal suo nome (a sinistra) e il tempo di durata (a destra, generalmente in round).

Ritorna alla pagina principale dell'&lt;link help&gt;help&lt;/link&gt;.
]]
--
ui.help.color = [[
&lt;title&gt;Colori&lt;/title&gt;Tramite il comando &lt;command&gt;uiColors&lt;/command&gt; è possibile visualizzare l'elenco dei colori che si possono utilizzare negli &lt;link highlight&gt;highlight&lt;/link&gt;.  

&lt;yellow&gt;Utilizzo:&lt;r&gt;
  &lt;command&gt;uic[olors]&lt;/command&gt;    Per visualizzare l'elenco dei colori

Ritorna alla pagina principale dell'&lt;link help&gt;help&lt;/link&gt;.
]]
--
ui.help.endowment = [[&lt;title&gt;Widget Endowment&lt;/title&gt;Il widget Endowment visualizza i dati relativi all'equipaggiamento e si aggiorna manualmente con il comando &lt;command&gt;equipment&lt;/command&gt;. Ogni elemento del widget rappresenta un pezzo dell'equipaggiamento indossato ed è composto dal suo nome (al centro), il numero dello slot che occupa (in alto a sinistra), il nome dello slot che occupa (i basso a sinistra, abbreviato a 3 lettere), il suo livello di potenza (in alto a destra) e la sua percentuale di usura (in basso a destra). La percentuale di usura determina anche il colore del bordo dell'elemento (100%=grigio poi &lt;green&gt;verde&lt;r&gt;, &lt;yellow&gt;giallo&lt;r&gt;, &lt;orange&gt;arancione&lt;r&gt;, &lt;red&gt;rosso&lt;r&gt;, &lt;brown&gt;marrone&lt;r&gt;).

Rimanendo con il cursore del mouse su un elemento è possibile visualizzare un tooltip con le caratteristiche principali del pezzo selezionato. Queste informazioni vengono ricaricate automaticamente con il comando &lt;command&gt;equipment statistic&lt;/command&gt;. Inoltre il tooltip visualizzarà nella parte inferiore anche le statistiche dell'ultimo oggetto identificato, per permettere un paragone veloce e diretto.

Ritorna alla pagina principale dell'&lt;link help&gt;help&lt;/link&gt;.
]]
--
ui.help.fontsize = [[
&lt;title&gt;Impostare la dimensione del font dei widget&lt;/title&gt;Tramite il comando &lt;command&gt;uif[ontsize]&lt;/command&gt; è possibile cambiare la dimensione del font di alcuni widget dell'UI.

&lt;yellow&gt;Utilizzo:&lt;r&gt;
  &lt;command&gt;uif[ontsize]&lt;/command&gt; &lt;input&gt;&lt;widget&gt;&lt;/input&gt; &lt;input&gt;&lt;dimensione&gt;&lt;/input&gt;

I &lt;input&gt;&lt;widget&gt;&lt;/input&gt; a cui è possibile cambiare la dimensione del font sono: &lt;input&gt;all&lt;/input&gt; (per tutti contemporaneamente), &lt;input&gt;chat&lt;/input&gt;, &lt;input&gt;endowment&lt;/input&gt;, &lt;input&gt;help&lt;/input&gt;, &lt;input&gt;overland&lt;/input&gt;, o &lt;input&gt;room&lt;/input&gt;.

Le &lt;input&gt;&lt;dimensione&gt;&lt;/input&gt; del font devono essere un valore compreso tra &lt;varValue&gt;1&lt;/varValue&gt; e &lt;varValue&gt;30&lt;/varValue&gt;.

Ritorna alla pagina principale dell'&lt;link help&gt;help&lt;/link&gt;.
]]
--
ui.help.go = [[
&lt;title&gt;Mapper: go&lt;/title&gt;Tramite il comando &lt;command&gt;uig[o]&lt;/command&gt; è possibile muoversi automaticamente verso una stanza che è stata mappata.

&lt;yellow&gt;Utilizzo:&lt;r&gt;
  &lt;command&gt;uif[go]&lt;/command&gt; &lt;input&gt;&lt;id&gt;&lt;/input&gt;|&lt;input&gt;&lt;nome&gt;&lt;/input&gt;

Il parametro di ricerca della destinazione può essere indistintamente l'&lt;input&gt;&lt;id&gt;&lt;/input&gt; o il &lt;input&gt;&lt;nome&gt;&lt;/input&gt; della stanza.

&lt;yellow&gt;Per maggiori informazioni:&lt;r&gt;
  &lt;link info&gt;uii[nfo]&lt;/link&gt;   ▷ Comando avere informazioni su una stanza
  &lt;link search&gt;uis[earch]&lt;/link&gt; ▷ Comando per cercare una stanza
  &lt;link track&gt;uit[rack]&lt;/link&gt;  ▷ Comando per tracciare il percorso a una stanza

Ritorna alla pagina principale dell'&lt;link help&gt;help&lt;/link&gt;.
]]
--
ui.help.group = [[
&lt;title&gt;Widget Group&lt;/title&gt;Il widget Group visualizza automaticamente (via GMCP) i dati relativi ai componenti del gruppo a cui si partecipa. Il leader del gruppo viene evidenziato col simbolo 👑 a fianco al nome.

Cliccando su un elemento del gruppo, la variabile &lt;varName&gt;target&lt;/varName&gt; viene autimaticamente aggiornata con il nome del componente del gruppo cliccato.

Lo stesso effetto lo si ottiene digitanto il nome dell'elemento del gruppo (da &lt;button&gt;g0&lt;/button&gt; a &lt;button&gt;g9&lt;/button&gt;) oppure con la combinazione di tasti rapidi associata all'elemento del gruppo (visualizzata in basso a destra).

Questa funzionalità, combinata con gli alias, permette di eseguire comandi specifici sull'avversario.

&lt;yellow&gt;Per maggiori informazioni:&lt;r&gt;
  &lt;link target&gt;g0..g9&lt;/link&gt;,
  &lt;link target&gt;o0&lt;/link&gt;,
  &lt;link target&gt;t1..t4&lt;/link&gt;       ▷ Comandi per la gestione della variabile &lt;var&gt;target&lt;/var&gt;
  &lt;link keybind&gt;uik[eibind]&lt;/link&gt;  ▷ Comando per la gestione dei tasti rapidi per aliases e targets

Ritorna alla pagina principale dell'&lt;link help&gt;help&lt;/link&gt;.
]]        
--
ui.help.highlight = [[
&lt;title&gt;Highlights&lt;/title&gt;Gli Highlights permettono di evidenziare parole o frasi del mud cambiandone il colore. Questo può semplificare la visualizzazione di elementi importanti all'interno del testo come, ad esempio, evidenziare la presenza di una &lt;red&gt;cassa&lt;r&gt; o di una &lt;cyan&gt;chiave&lt;r&gt; nella descrizione di una stanza.

&lt;yellow&gt;Configurazione:&lt;r&gt;
  &lt;command&gt;uihi[lights]&lt;/command&gt;                   Per visualizzare l'elenco degli highlights
  &lt;command&gt;uihi[lights]&lt;/command&gt; &lt;testo&gt;           Per visualizzare il colore del testo
  &lt;command&gt;uihi[lights]&lt;/command&gt; &lt;testo&gt; &lt;colore&gt;  Per associare un colore a un testo
  &lt;command&gt;uihi[lights]&lt;/command&gt; &lt;testo&gt; &lt;command&gt;remove&lt;/command&gt;    Per eliminare highlights associato al testo
  &lt;command&gt;uihi[lights] remove_all&lt;/command&gt;        Per eliminare gli aliases associati a tutti i pulsanti

E' possibile visualizzare un elenco dei colori disponibili per gli highlights utilizzando il comando &lt;link color&gt;uic[olors]&lt;/link&gt;.

Ritorna alla pagina principale dell'&lt;link help&gt;help&lt;/link&gt;.
]]
--
ui.help.info = [[
&lt;title&gt;Mapper: info&lt;/title&gt;Tramite il comando &lt;command&gt;uii[nfo]&lt;/command&gt; è possibile ottenere informazioni su una stanza che è stata mappata.

&lt;yellow&gt;Utilizzo:&lt;r&gt;
  &lt;command&gt;uii[nfo]&lt;/command&gt; &lt;input&gt;&lt;id&gt;&lt;/input&gt;|&lt;input&gt;&lt;nome&gt;&lt;/input&gt;

Il parametro di ricerca della destinazione può essere indistintamente l'&lt;input&gt;&lt;id&gt;&lt;/input&gt; o il &lt;input&gt;&lt;nome&gt;&lt;/input&gt; della stanza.

Se non viene specificato nessun parametro di ricerca il comando restituirà informazioni sulla stanza in cui si trova attualmente il giocatore.

Se è selezionata una stanza sul widget Mappa (e viene specificato nessun parametro)uih u il comando restituirà informazioni sulla stanza selezionata.

&lt;yellow&gt;Per maggiori informazioni:&lt;r&gt;
  &lt;link go&gt;uig[o]&lt;/link&gt;     ▷ Comando per muoversi automaticamente a una stanza 
  &lt;link search&gt;uis[earch]&lt;/link&gt; ▷ Comando per cercare una stanza
  &lt;link track&gt;uit[rack]&lt;/link&gt;  ▷ Comando per tracciare il percorso a una stanza

Ritorna alla pagina principale dell'&lt;link help&gt;help&lt;/link&gt;.
]]
--
ui.help.keybind = [[
&lt;title&gt;Tasti rapidi per aliases e target&lt;/title&gt;Tramite il comando &lt;command&gt;uik[eybind]&lt;/command&gt; è possibile associare una combinazione di tasti rapidi a un &lt;link alias&gt;alias&lt;/link&gt; o a un &lt;link target&gt;target&lt;/link&gt;.

&lt;yellow&gt;Configurazione:&lt;r&gt;
  &lt;command&gt;uik[eybind]&lt;/command&gt;                           Per visualizzare l'elenco dei tasti rapidi
  &lt;command&gt;uik[eybind]&lt;/command&gt; &lt;aliasName&gt;&lt;alias&gt;&lt;/aliasName&gt;|&lt;button&gt;&lt;target&gt;&lt;/button&gt;          Per visualizzare i tasti dell'alias\del target
  &lt;command&gt;uik[eybind]&lt;/command&gt; &lt;aliasName&gt;&lt;alias&gt;&lt;/aliasName&gt;|&lt;button&gt;&lt;target&gt;&lt;/button&gt; &lt;keybind&gt;&lt;tasti&gt;&lt;/keybind&gt;  Per associare uun tasto all'alias\al target
  &lt;command&gt;uik[eybind]&lt;/command&gt; &lt;aliasName&gt;&lt;alias&gt;&lt;/aliasName&gt;|&lt;button&gt;&lt;target&gt;&lt;/button&gt; &lt;command&gt;remove&lt;/command&gt;   Per eliminare i tasti dell'alias\del target
  &lt;command&gt;uik[eybind] remove_all&lt;/command&gt;                Per eliminare tutti i tasti rapidi

I tasti utillizzabili possono essere o i tasti funzione (&lt;keybind&gt;f1&lt;/keybind&gt;, &lt;keybind&gt;f2&lt;/keybind&gt;, &lt;keybind&gt;f3&lt;/keybind&gt;, etc) o i caratteri dell'alfabeto (&lt;keybind&gt;a&lt;/keybind&gt;, &lt;keybind&gt;b&lt;/keybind&gt;, &lt;keybind&gt;c&lt;/keybind&gt;, etc) o i numeri (&lt;keybind&gt;0&lt;/keybind&gt;, &lt;keybind&gt;1&lt;/keybind&gt;, &lt;keybind&gt;2&lt;/keybind&gt;, etc), presi singolarmente oppure preceduti da &lt;keybind&gt;CTRL&lt;/keybind&gt; o &lt;keybind&gt;ALT&lt;/keybind&gt; (o entrambi).

&lt;yellow&gt;Per maggiori informazioni:&lt;r&gt;
  &lt;link target&gt;g0..g9&lt;/link&gt;,
  &lt;link target&gt;o0&lt;/link&gt;,
  &lt;link target&gt;t1..t4&lt;/link&gt;      ▷ Comandi per la gestione della variabile &lt;var&gt;target&lt;/var&gt;
  &lt;link alias&gt;uia[liases]&lt;/link&gt; ▷ Comando per gestire gli aliases
 
Ritorna alla pagina principale dell'&lt;link help&gt;help&lt;/link&gt;.
]]
--
ui.help.mapper = [[
&lt;title&gt;Widget Mapper\Overland&lt;/title&gt;Il widget Mapper ha la doppia funzione di visualizzare le aree di gioco interne che sono state esplorate e di visualizzare le zone esterne dell'overland. Il passaggio tre le due visualizzazioni avviene automaticamente in base alla posizione del personaggio.

&lt;yellow&gt;Mapper&lt;r&gt;
Per la gestione delle aree interne il widget Mapper utilizza il componente &lt;cyan&gt;Geyser Mapper&lt;r&gt; di Mudlet che comprende funzionalità generiche per le gestione delle stanze esplorate accessibili dal menù che appare clickandoci sopra con il tasto destro (fare riferimento all'help on line di Mudlet), alle quali sono state aggiunte delle funzionalità personalizzate create su misura per Lumen et Umbra come la ricerca automatica del percorso più breve (ove possibile, facendo doppio click sulla stanza che si desidera raggiungere), la visualizzazione di portali, la visualizzazione di uscite speciali o la visualizzazione del percorso da seguire.

Le funzionalità del widget Mapper sono inoltre arricchite dai comandi testuali &lt;link go&gt;uig[o]&lt;/link&gt; per spostarsu ad una stanza specifica, &lt;link info&gt;uii[nfo]&lt;/link&gt; per avere informazioni sulla stanza attuale o una stanza specifica, &lt;link search&gt;uis[earch]&lt;/link&gt; per cercare una stanza partendo dal suo nome e &lt;link track&gt;uit[rack]&lt;/link&gt; per tracciare sulla mappa il percorso verso una stanza, ove possibile.

&lt;yellow&gt;Overland&lt;r&gt;
Per la gestione delle zone dell'overland il widget Mapper si aggiorna automaticamente con le informazioni ricevute dal server via GMCP. Non integra ulteriori funzioni speciali.

&lt;yellow&gt;Per maggiori informazioni:&lt;r&gt;
  &lt;link go&gt;uig[o]&lt;/link&gt;     ▷ Comando per muoversi automaticamente a una stanza 
  &lt;link info&gt;uii[nfo]&lt;/link&gt;   ▷ Comando avere informazioni su una stanza
  &lt;link search&gt;uis[earch]&lt;/link&gt; ▷ Comando per cercare una stanza
  &lt;link track&gt;uit[rack]&lt;/link&gt;  ▷ Comando per tracciare il percorso a una stanza

Ritorna alla pagina principale dell'&lt;link help&gt;help&lt;/link&gt;.
]]
--
ui.help.opponent = [[
&lt;title&gt;Widget Opponent&lt;/title&gt;Il widget Opponent visualizza automaticamente (via GMCP) i dati dell'avversario contro cui si sta combattendo relativi a nome, livello e HP (barra rossa).

Cliccando sulla barra degli HP, la variabile &lt;varName&gt;target&lt;/varName&gt; viene autimaticamente aggiornata con il nome dell'avversario.

Lo stesso effetto lo si ottiene digitanto il nome del widget (&lt;button&gt;o0&lt;/button&gt;) oppure con la combinazione di tasti rapidi associata all'avversario (visualizzata in basso a destra).

Questa funzionalità, combinata con gli alias, permette di eseguire comandi specifici sull'avversario.

&lt;yellow&gt;Per maggiori informazioni:&lt;r&gt;
  &lt;link target&gt;g0..g9&lt;/link&gt;,
  &lt;link target&gt;o0&lt;/link&gt;,
  &lt;link target&gt;t1..t4&lt;/link&gt;       ▷ Comandi per la gestione della variabile &lt;var&gt;target&lt;/var&gt;
  &lt;link keybind&gt;uik[eibind]&lt;/link&gt;  ▷ Comando per la gestione dei tasti rapidi per aliases e targets

Ritorna alla pagina principale dell'&lt;link help&gt;help&lt;/link&gt;.
]]
--
ui.help.player = [[
&lt;title&gt;Widget Player&lt;/title&gt;Il widget Player visualizza automaticamente (via GMCP) i dati del personaggio in gioco relativi a nome, razza, classe, livello, HP (barra rossa), mana (barra blu), energia (barra gialla) e movimanto (barra verde). Inoltre è possibile tenere sotto controlo il tick counter (barra sopra la barra HP), il round counter (barra sotto la barra HP) e l'esperienza (barra sotto la barra del movimento).

Ritorna alla pagina principale dell'&lt;link help&gt;help&lt;/link&gt;.
]]
--
ui.help.profile = [[
&lt;title&gt;Profili&lt;/title&gt;Tramite l'utilizzo dei profili è possibile salvare alias, highlights, target e variabili  

&lt;yellow&gt;Configurazione:&lt;r&gt;
  &lt;command&gt;uip[rofiles]&lt;/command&gt;                   Per visualizzare l'elenco dei disponibili
  &lt;command&gt;uip[rofiles] load&lt;/command&gt; &lt;profile&gt;&lt;profilo&gt;&lt;/profile&gt;    Per caricare un profile
  &lt;command&gt;uip[rofiles] save&lt;/command&gt; &lt;profile&gt;&lt;profilo&gt;&lt;/profile&gt;    Per salvare i dati in uso su un profilo
  &lt;command&gt;uip[rofiles] remove&lt;/command&gt; &lt;profile&gt;&lt;profilo&gt;&lt;/profile&gt;  Per rimuovere un profilo
  &lt;command&gt;uip[rofiles] remove_all&lt;/command&gt;        Per eliminare tutti i profile

Ritorna alla pagina principale dell'&lt;link help&gt;help&lt;/link&gt;.
]]
--
ui.help.room = [[
&lt;title&gt;Widget Room&lt;/title&gt;Il widget Room visualizza i dati relativi alla stanza in cui si trova attualmete il personaggio e si aggiorna automaticamente (via GMCP) ad ogni spostamento.

Il widget è composto da un quadrato in formato ASCII che rappresenta la stanza in cui ci si trova sul quale è possibile visualizzare le uscite disponibili (con frecce che indicano le direzioni nord, est, sud, ovest, su e giu) con gli ID delle stanze di destinazione, la posizione del personaggio all'interno della stanza (con un cerchio crociato, vedere il comando &lt;command&gt;sposta&lt;/command&gt;) e la direzione da cui si è entrati nella stanza (rombo pieno al posto della reccia di direzione).

A fianco al quadrato e riportata una legenda della stanza dalla quale è possibile visualizzare il nome e l'ID della stanza attuale e il nome delle stanze a cui fanno riferimento le uscite. Da questa leggenda è possibile spostarsi ad una stanza adiacente clickando sul nome della destinazione.

Sotto il quadrato vengono riportate altre informazioni relative alla stanza tra cui le uscite speciali o portali (se presenti) ai quali si può entrare clickandoci sopra, l'elendo degli oggetti, dei giocatori e dei MOB (in questo ordine) presenti in stanza.

Ritorna alla pagina principale dell'&lt;link help&gt;help&lt;/link&gt;.
]]
--
ui.help.search = [[
&lt;title&gt;Mapper: search&lt;/title&gt;Tramite il comando &lt;command&gt;uis[earch]&lt;/command&gt; è possibile ricercare stanze che sono state mappate.

&lt;yellow&gt;Utilizzo:&lt;r&gt;
  &lt;command&gt;uis[earch]&lt;/command&gt; &lt;input&gt;&lt;id&gt;&lt;/input&gt;|&lt;input&gt;&lt;nome&gt;&lt;/input&gt;

Il parametro di ricerca della destinazione può essere indistintamente l'&lt;input&gt;&lt;id&gt;&lt;/input&gt; o il &lt;input&gt;&lt;nome&gt;&lt;/input&gt; della stanza.

Nell'elenco dei risultati oltre all'id, il nome e all'area della stanza, verranno riportati dei link iperattivi tramite i quali sarà possibile eseguire direttamente i comandi &lt;link info&gt;uii[nfo]&lt;/link&gt; (I), &lt;link track&gt;uit[rack]&lt;/link&gt; (T) e &lt;link go&gt;uig[o]&lt;/link&gt; (G).

&lt;yellow&gt;Per maggiori informazioni:&lt;r&gt;
  &lt;link go&gt;uig[o]&lt;/link&gt;     ▷ Comando per muoversi automaticamente a una stanza 
  &lt;link info&gt;uii[nfo]&lt;/link&gt;   ▷ Comando avere informazioni su una stanza
  &lt;link track&gt;uit[rack]&lt;/link&gt;  ▷ Comando per tracciare il percorso a una stanza

Ritorna alla pagina principale dell'&lt;link help&gt;help&lt;/link&gt;.
]]
--
ui.help.target = [[
&lt;title&gt;Target (g0..g9, o0, t1..t4)&lt;/title&gt;La variable &lt;varName&gt;target&lt;/varName&gt; è una variabile predefinita utilizzabile negli &lt;link alias&gt;uia[liases]&lt;/link&gt; e che è possibile impostare in modi differenti.

Oltre ad essere getibile come semplice variabile tramite il comando &lt;link variable&gt;uiv[ariables]&lt;/link&gt; è possibile impostarla utilizzando o i 4 tasti del widget Target (&lt;button&gt;t1&lt;/button&gt;, &lt;button&gt;t2&lt;/button&gt;, &lt;button&gt;t3&lt;/button&gt; e &lt;button&gt;t4&lt;/button&gt;), o cliccando sull'avversario ingaggiato dal widget Opponent (&lt;button&gt;o0&lt;/button&gt;) o ancora cliccando su uno dei componenti del gruppo dal widget Gruppo.
di gioco (da &lt;button&gt;g0&lt;/button&gt; a &lt;button&gt;g9&lt;/button&gt;).

I tasti del widget Target &lt;button&gt;t1&lt;/button&gt;, &lt;button&gt;t2&lt;/button&gt;, &lt;button&gt;t3&lt;/button&gt; e &lt;button&gt;t4&lt;/button&gt; sono configurabili, mentre &lt;button&gt;o0&lt;/button&gt; e da &lt;button&gt;g0&lt;/button&gt; a &lt;button&gt;g9&lt;/button&gt; sono preimpostati in base all'avversario ingaggiato o alla composizione attuale del gruppo.

&lt;yellow&gt;Configurazione:&lt;r&gt;
  &lt;command&gt;t1&lt;/command&gt;|&lt;command&gt;t2&lt;/command&gt;|&lt;command&gt;t3&lt;/command&gt;|&lt;command&gt;t4&lt;/command&gt; &lt;valore&gt;        Per assegnare un valore a &lt;button&gt;t1&lt;/button&gt;, &lt;button&gt;t2&lt;/button&gt;, &lt;button&gt;t3&lt;/button&gt; o &lt;button&gt;t4&lt;/button&gt;
  &lt;command&gt;t1&lt;/command&gt;|&lt;command&gt;t2&lt;/command&gt;|&lt;command&gt;t3&lt;/command&gt;|&lt;command&gt;t4 remove&lt;/command&gt;          Per rimuovere il valore assegnato a &lt;command&gt;t1&lt;/command&gt;, &lt;command&gt;t2&lt;/command&gt;, &lt;command&gt;t3&lt;/command&gt; o &lt;command&gt;t4&lt;/command&gt;

&lt;yellow&gt;Utilizzo:&lt;r&gt;
  &lt;command&gt;g0&lt;/command&gt;| .. | &lt;command&gt;g9&lt;/command&gt; o click sul widget Group      Per assegnare a &lt;varName&gt;target&lt;/varName&gt; il nome del relativo componente del gruppo
  &lt;command&gt;o0&lt;/command&gt;          o click sul widget Opponent   Per assegnare a &lt;varName&gt;target&lt;/varName&gt; il nome dell'avversario ingaggiato
  &lt;command&gt;t1&lt;/command&gt;|&lt;command&gt;t2&lt;/command&gt;|&lt;command&gt;t3&lt;/command&gt;|&lt;command&gt;t4&lt;/command&gt; o click sug widget Targets    Per assegnare a &lt;varName&gt;target&lt;/varName&gt; il valore assegnato a &lt;button&gt;t1&lt;/button&gt;, &lt;button&gt;t2&lt;/button&gt;, &lt;button&gt;t3&lt;/button&gt; o &lt;button&gt;t4&lt;/button&gt;

&lt;yellow&gt;Per maggiori informazioni:&lt;r&gt;
  &lt;link group&gt;Group&lt;/link&gt;       ▷ Widget gruppo
  &lt;link opponent&gt;Opponent&lt;/link&gt;    ▷ Widget dati avversatrio 
  &lt;link targets&gt;Target&lt;/link&gt;      ▷ Widget bottoni per target 
  &lt;link keybind&gt;uik[eibind]&lt;/link&gt; ▷ Comando per la gestione dei tasti rapidi per aliases e targets

Ritorna alla pagina principale dell'&lt;link help&gt;help&lt;/link&gt;.
]]
--
ui.help.targets= [[
&lt;title&gt;Widget Targets&lt;/title&gt;Il widget Target è coposto da 4 pulsanti personalizzabili sui quali è possibile memorizzare 4 target differenti. Clickando su uno dei pulsanti la variabile &lt;varName&gt;Target&lt;/varName&gt; viene aggiornata con il valore che è stato assegnato al pulsante.

Lo stesso effetto lo si ottiene digitanto il nome del pulsante (&lt;button&gt;t1&lt;/button&gt;, &lt;button&gt;t2&lt;/button&gt;, &lt;button&gt;t3&lt;/button&gt; e &lt;button&gt;t4&lt;/button&gt;) oppure con la combinazione di tasti rapidi associata al pulsante (visualizzata su ogni tasto, in basso a destra).

Questa funzionalità, combinata con gli alias, permette di passare velcemente da un target all'altro.

&lt;yellow&gt;Per maggiori informazioni:&lt;r&gt;
  &lt;link target&gt;g0..g9&lt;/link&gt;,
  &lt;link target&gt;o0&lt;/link&gt;,
  &lt;link target&gt;t1..t4&lt;/link&gt;       ▷ Comandi per la gestione della variabile &lt;var&gt;target&lt;/var&gt;
  &lt;link keybind&gt;uik[eibind]&lt;/link&gt;  ▷ Comando per la gestione dei tasti rapidi per aliases e targets

Ritorna alla pagina principale dell'&lt;link help&gt;help&lt;/link&gt;.
]]
--
ui.help.track = [[
&lt;title&gt;Mapper: track&lt;/title&gt;Tramite il comando &lt;command&gt;uit[rack]&lt;/command&gt; è possibile tracciare un sentiero sulla mappa che porterà ad una stanza che sia stata mappata.

&lt;yellow&gt;Utilizzo:&lt;r&gt;
  &lt;command&gt;uit[rack]&lt;/command&gt; &lt;input&gt;&lt;id&gt;&lt;/input&gt;|&lt;input&gt;&lt;nome&gt;&lt;/input&gt;

Il parametro di ricerca della destinazione può essere indistintamente l'&lt;input&gt;&lt;id&gt;&lt;/input&gt; o il &lt;input&gt;&lt;nome&gt;&lt;/input&gt; della stanza.

&lt;yellow&gt;Per maggiori informazioni:&lt;r&gt;
  &lt;link go&gt;uig[o]&lt;/link&gt;     ▷ Comando per muoversi automaticamente a una stanza 
  &lt;link info&gt;uii[nfo]&lt;/link&gt;   ▷ Comando avere informazioni su una stanza
  &lt;link search&gt;uis[earch]&lt;/link&gt; ▷ Comando per cercare una stanza

Ritorna alla pagina principale dell'&lt;link help&gt;help&lt;/link&gt;.
]]
--
ui.help.variable = [[
&lt;title&gt;Variabili&lt;/title&gt;E' possibile definire delle variabili (retentive) da riutilizzare negli alias.
E' possibile richiamare una variabile all'interno di un alias facendo precedere al nome della variabile il carattere speciale &lt;command&gt;]]..ui.varID..[[&lt;/command&gt;.
Alcune delle variabili sono già dichiarate (variabili predefinite), e vengno utilizzate per gli elementi l'interfaccia.
Le variabili sono utilizzabili nel codice dei vostri script facendo accesso alla tabella LUA ui.variables[nomevariabile].

&lt;yellow&gt;Configurazione:&lt;r&gt;
  &lt;command&gt;uiv[ariable]&lt;/command&gt;|&lt;command&gt;]]..ui.varID..[[&lt;/command&gt;                       Per visualizzare l'elenco delle variabili
  &lt;command&gt;uiv[ariable]&lt;/command&gt;|&lt;command&gt;]]..ui.varID..[[&lt;/command&gt; &lt;varName&gt;&lt;nome&gt;&lt;/varName&gt;               Per visualizzare il valore di una variabile
  &lt;command&gt;uiv[ariable]&lt;/command&gt;|&lt;command&gt;]]..ui.varID..[[&lt;/command&gt; &lt;varName&gt;&lt;nome&gt;&lt;/varName&gt; &lt;varValue&gt;&lt;valore&gt;&lt;/varValue&gt;      Per creare o modificare una variabile
  &lt;command&gt;uiv[ariable]&lt;/command&gt;|&lt;command&gt;]]..ui.varID..[[&lt;/command&gt; &lt;varName&gt;&lt;nome&gt;&lt;/varName&gt; &lt;command&gt;remove&lt;/command&gt;        Per rimuovere una variabile
  &lt;command&gt;uiv[ariable]&lt;/command&gt;|&lt;command&gt;]]..ui.varID..[[&lt;/command&gt; &lt;command&gt;remove_all&lt;/command&gt;            Per rimuovere tutte le variabili

Ritorna alla pagina principale dell'&lt;link help&gt;help&lt;/link&gt;.
]]
--
ui.help.walk = [[
&lt;title&gt;Walk, Speedwalk e Backwalk&lt;/title&gt;Tramite il comandi "&lt;command&gt;.&lt;/command&gt;" è possibile percorrere un &lt;percorso&gt; espressi nel formato "ee2w4suuu9n".

Tramite il comando "&lt;command&gt;..&lt;/command&gt;" oltre che ripercorrere un &lt;percorso&gt; all'indietro. 

&lt;yellow&gt;Utilizzo:&lt;r&gt;
  &lt;command&gt;.&lt;/command&gt;&lt;percorso&gt;   Per eseguire il percorso specificato
  &lt;command&gt;..&lt;/command&gt;&lt;percorso&gt;  Per eseguire il percorso specificato all'indietro
  &lt;command&gt;.&lt;/command&gt;             Per ripercorere i propri passi (massimo 50 locazioni)
  &lt;command&gt;..&lt;/command&gt;            Per ripercorere i propri passi all'indietro (massimo 50 locazioni)

Ritorna alla pagina principale dell'&lt;link help&gt;help&lt;/link&gt;.
]]
--
ui.help.widget = [[
&lt;title&gt;Ripristino dei widget chiusi&lt;/title&gt;E' possibile ripristinare i widget dell'UI che sono stati minimizzati o chiusi.

&lt;yellow&gt;Utilizzo:&lt;r&gt;
  &lt;command&gt;uiw[idget] &lt;nome_widget&gt;&lt;/command&gt;

I &lt;command&gt;&lt;nome_widget&gt;&lt;/command&gt; disponibili sono: &lt;exec uiwidget all&gt;all&lt;/exec&gt; (ripristina tutti i widgets), &lt;exec uiwidget affects&gt;affects&lt;/exec&gt;, &lt;exec uiwidget buttons&gt;buttons&lt;/exec&gt;, &lt;exec uiwidget chat&gt;chat&lt;/exec&gt;, &lt;exec uiwidget cooldowns&gt;cooldowns&lt;/exec&gt;, &lt;exec uiwidget endowment&gt;endowment&lt;/exec&gt;, &lt;exec uiwidget group&gt;group&lt;/exec&gt;, &lt;exec uiwidget help&gt;help&lt;/exec&gt;, &lt;exec uiwidget mapper&gt;mapper&lt;/exec&gt;, &lt;exec uiwidget opponent&gt;opponent&lt;/exec&gt;, &lt;exec uiwidget player&gt;player&lt;/exec&gt;, &lt;exec uiwidget room&gt;room&lt;/exec&gt; o &lt;exec uiwidget target&gt;target&lt;/exec&gt; per i relativi widgets.

Ritorna alla pagina principale dell'&lt;link help&gt;help&lt;/link&gt;.
]]
--
ui.help.widgets = [[
&lt;title&gt;Widgets&lt;/title&gt;I widget sono gli elementi a finestra che compongono l'interfaccia e permettono di interagire con il gioco per avere una visuale più completa delle informazioni che il gioco stesso mette a disposizione.

Tutti i widget hanno la possibilità di essere spostati, ridimensionato, chiusi (tasto &lt;cyan&gt;&lt;x&gt;&lt;r&gt; nella barra del titolo), nascosti (tasto &lt;cyan&gt;&lt;_&gt;&lt;r&gt; nella barra del titolo) o ripristinati (con il comando &lt;link widget&gt;uiw[idget]&lt;/link&gt;). Alcuni widget possono essere resi trasparenti (tasto &lt;cyan&gt;&lt;...&gt;&lt;r&gt; nella barra del titolo) per personalizare il più possibile la disposizione dei widget all'interno dell'area di gioco.

I widget sono creati utilizzando il componeti &lt;cyan&gt;Geyser Adjustable Container&lt;r&gt; di Mudlet (fare riferimento all'help on line di Mudlet) che integrano delle funzionalità comuni accessibili dal menù che appare cliccando con il tasto destro sulla barra del titolo.
Tra queste funzionalità merita di essere menzionata la possibilità di agganciare il widget a un bordo della finestra principale di gioco. Per fare questo è sufficente spostare il widget contro il bordo al quale lo si vuole agganciare, cliccare con tasto destro sulla barra del titolo e selezionare &lt;cyan&gt;&lt;Aggancia a:&gt;&lt;r&gt;. Apparirà un sottomenù con i nomi dei bordi della finestra principale (es: basso, destra, etc) ai quali sarà possibie agganciare il widget. Per sganciare il widget dal bordo è sufficiente spostare il widget lontano dal bordo al quale è stato agganciato.

Ritorna alla pagina principale dell'&lt;link help&gt;help&lt;/link&gt;.
]]
</script>
				<eventHandlerList />
			</Script>
			<Script isActive="yes" isFolder="no">
				<name>Init Widgets</name>
				<packageName></packageName>
				<script>--
-- GMCP
gmcp = gmcp or {}
--
-- Check if the generic_mapper package is installed and if so uninstall it
if table.contains(getPackages(), "generic_mapper") then
  ui.fDebug("[&lt;white&gt;init&lt;r&gt;] Unistall 'generic_mapper package")
  uninstallPackage("generic_mapper")
end
--
-- Init DATA directory
ui.fDebug("[&lt;white&gt;init&lt;r&gt;] DATA directory")
ui.fInitDataDirectory()
--
-- Load parameters
ui.fDebug("[&lt;white&gt;init&lt;r&gt;] Load 'Parameters' from file")
ui.fReadFileParameters()
--
-- Load variables
ui.fDebug("[&lt;white&gt;init&lt;r&gt;] Load 'Variables' from file")
ui.fReadFileVariables()
--
-- Load targets
ui.fDebug("[&lt;white&gt;init&lt;r&gt;] Load 'Targets' from file")
ui.fReadFileTargets()
--
-- Load Aliasese
ui.fDebug("[&lt;white&gt;init&lt;r&gt;] Load 'Aliases' from file")
ui.fReadFileAliases()
--
-- Load Highlights
ui.fDebug("[&lt;white&gt;init&lt;r&gt;] Load 'Highlights' from file")
ui.fReadFileHighlights()
--
-- Opponent
ui.fDebug("[&lt;white&gt;init&lt;r&gt;] Opponent")
ui.fInitOpponentWidget()
--
-- Group
ui.fDebug("[&lt;white&gt;init&lt;r&gt;] Group")
ui.fInitGroupWidget()
--
-- Target Buttons
ui.fDebug("[&lt;white&gt;init&lt;r&gt;] Target Buttons")
ui.fInitTargetButtonsWidget()
ui.fUpdateTargetButtons()
--
--  Opponent and Groups are also targets. Widgets needed before updating
ui.fUpdateAllTargetButton()
ui.fUpdateOpponent()
ui.fUpdateGroup()
--
-- Chat
ui.fDebug("[&lt;white&gt;init&lt;r&gt;] Chat")
ui.fInitChatWidget()
ui.fUpdateChat()
--
-- Player
ui.fDebug("[&lt;white&gt;init&lt;r&gt;] Player")
ui.fInitPlayerWidget()
ui.fUpdatePlayer()
--
-- Alias Button
ui.fDebug("[&lt;white&gt;init&lt;r&gt;] Alias Buttons")
ui.fInitAliasButtonsWidget()
ui.fUpdateAliasButton()
--
-- Affects
ui.fDebug("[&lt;white&gt;init&lt;r&gt;] Affects")
ui.fInitAffectsWidget()
ui.fUpdateAffects()
--
-- Mapper
ui.fInitMapperWidget()
ui.fInitMapper()
--
-- Map/Compass
ui.fDebug("[&lt;white&gt;init&lt;r&gt;] Room")
ui.fInitRoomWidget()
ui.fUpdateRoom()
--
-- Cooldowns
ui.fDebug("[&lt;white&gt;init&lt;r&gt;] Cooldowns")
ui.fInitCooldownsWidget()
ui.fUpdateCooldowns()
--
-- Endowment
ui.fDebug("[&lt;white&gt;init&lt;r&gt;] Endowment")
ui.fInitEndowmentWidget()
ui.fUpdateEndowment()
--
-- Help
ui.fDebug("[&lt;white&gt;init&lt;r&gt;] Help")
ui.fInitHelpWidget()
GUI.Help:hide()
--
-- Profile
ui.fDebug("[&lt;white&gt;init&lt;r&gt;] Profiles")
ui.fInitProfiles()
--
-- GMCP
ui.fDebug("[&lt;white&gt;init&lt;r&gt;] setMergeTables()")
setMergeTables("gmcp")
--
-- Events
--
-- Resize main window
if (ui.handlers.fWindowResize) then
  killAnonymousEventHandler(ui.handlers.fWindowResize)
  ui.handlers.fWindowResize = nil
end
ui.handlers.fWindowResize = registerAnonymousEventHandler("sysWindowResizeEvent", ui.fWindowResize)
--
-- gmcp.char
ui.fDebug("[&lt;white&gt;init&lt;r&gt;] Register events")
if (ui.handlers.fUpdateGMCP_char) then
  killAnonymousEventHandler(ui.handlers.fUpdateGMCP_char)
  ui.handlers.fUpdateGMCP_char = nil
end
ui.handlers.fUpdateGMCP_char  = registerAnonymousEventHandler("gmcp.char", "ui.fUpdateGMCP");
--
-- gmcp.room
if (ui.handlers.fUpdateGMCP_room) then
  killAnonymousEventHandler(ui.handlers.fUpdateGMCP_room)
  ui.handlers.fUpdateGMCP_room = nil
end
ui.handlers.fUpdateGMCP_room = registerAnonymousEventHandler("gmcp.room", "ui.fUpdateGMCP")
--
-- gmcp.overland
if (ui.handlers.fUpdateGMCP_overland) then
  killAnonymousEventHandler(ui.handlers.fUpdateGMCP_overland)
  ui.handlers.fUpdateGMCP_overland = nil
end
ui.handlers.fUpdateGMCP_overland = registerAnonymousEventHandler("gmcp.overland", "ui.fUpdateGMCP")
--
-- Connection Event
if (ui.handlers.fConnection) then
  killAnonymousEventHandler(ui.handlers.fConnection)
  ui.handlers.fConnection = nil
end
ui.handlers.fConnection = registerAnonymousEventHandler("sysConnectionEvent", "ui.fConnection")
--
ui.fDebug("[&lt;white&gt;init&lt;r&gt;] ... end UI init!")
</script>
				<eventHandlerList />
			</Script>
		</ScriptGroup>
		<ScriptGroup isActive="yes" isFolder="yes">
			<name>Telegram Connector</name>
			<packageName>Telegram Connector</packageName>
			<script></script>
			<eventHandlerList />
			<Script isActive="yes" isFolder="no">
				<name>TelegramMainScript</name>
				<packageName></packageName>
				<script>-- #########################################################################
-- TODO
--  * Add #COMMANDS
--    * #TELEGRAM CONFIGURE
--    * #TELEGRAM ENABLE/DISABLE
--    * #TELEGRAM VERSION
--    * #TELEGRAM HELP
--    * #TELEGRAM UPDATE
--    * #HELP
--    * #VERSION
--    * #ABOUT
-- #########################################################################
-- Telegram configure 
--    -&gt; collect and store Token and update interval
--    -&gt; also allow setting a char name, or use Profile Name
--    -&gt; also allowed "senders"
-- 
local url_versionDownload = "https://github.com/takilara/MudletTelegramConnector/releases/latest/download/version.lua"
local url_latestVersion = "https://github.com/takilara/MudletTelegramConnector/releases/latest/download/"
local URL_GETUPDATES=nil
local URL_SENDMESSAGE=nil
local lineBuffer = {}
local current_message_id = -1
local current_chat_id = -1
--
Telegram = Telegram or {}
Telegram.Version = "v0.0.4"
Telegram.PackageName = "Telegram Connector"
Telegram.downloadPath = getMudletHomeDir().."/telegram downloads/"
Telegram.Options = {}
Telegram.MyName = "lep" -- Telegram.MyName or getProfileName()
Telegram.UpdateInterval = Telegram.UpdateInterval or 10 -- seconds
Telegram.Enabled = Telegram.Enabled or true
Telegram.Enabled = true
Telegram.EventHandlerIds = Telegram.EventHandlerIds or {}
Telegram.AliasHandlerIds = Telegram.AliasHandlerIds or {}
Telegram.URL = "https://api.telegram.org/bot"
Telegram.getReturnHandler = Telegram.getReturnHandler or nil
Telegram.getUpdateTimerId = Telegram.getUpdateTimerId or nil
Telegram.LastIdHandled = Telegram.LastIdHandled or -1
--Telegram.LastIdHandled = -1
function Telegram:SaveConfig()
  cecho("&lt;cyan&gt;Saving Telegram config...\n")
  table.save(getMudletHomeDir().."/telegram_options.lua", Telegram.Options)
end
--
function Telegram:SetToken(token)
  Telegram.Options["Token"] = token
  Telegram:UpdateUrls()
end
--
function Telegram:checkVersion()
  local path = Telegram.downloadPath .. "versions.lua"
  local versions = {}  
  table.load(path, versions)
  local pos = table.index_of(versions, Telegram.Version) or 0
  local line = ""
  if pos ~= 1 then
    line = "&lt;orange&gt;(online - ".. versions[1] ..")\n \t #TELEGRAM UPGRADE to upgrade"
  else
    line =""
  end
  return line
end
--
function Telegram:downloadVersionFile()
  if not io.exists(Telegram.downloadPath) then lfs.mkdir(Telegram.downloadPath) end
  local filename = "versions.lua"
  Telegram.downloading=true
  downloadFile(Telegram.downloadPath .. filename, url_versionDownload)
end
--
function Telegram:downloadLatestVersion()
  cecho("&lt;cyan&gt;Downloading the latest version of "..Telegram.PackageName)
  print()
  if not io.exists(Telegram.downloadPath) then lfs.mkdir(Telegram.downloadPath) end
  local filename = "TelegramConnector.mpackage"
  Telegram.downloading=true
  downloadFile(Telegram.downloadPath .. filename, url_latestVersion .. filename)
end
--
function Telegram:update_version()
  print("Update the version")
  Telegram:killAllExistingEventHandlers()
  uninstallPackage("Telegram Connector")
  installPackage(Telegram.downloadPath .. "TelegramConnector.mpackage")
end
--
function Telegram:UpdateUrls()
  if Telegram.Options["Token"]~=nil then
    URL_GETUPDATES=Telegram.URL..Telegram.Options.Token.."/getUpdates"
    URL_SENDMESSAGE=Telegram.URL..Telegram.Options.Token.."/sendMessage"
  end
end
--
function Telegram:LoadConfig()
  if io.exists(getMudletHomeDir().."/telegram_options.lua") then
    cecho("&lt;cyan&gt;Loading Telegram config...\n")
    table.load(getMudletHomeDir().."/telegram_options.lua", Telegram.Options) -- using / is OK on Windows too.
  else
    -- save it if it doesnt exits
    cecho("&lt;cyan&gt;Creating new Telegram config...\n")
    Telegram:DeleteConfig()
    Telegram:SaveConfig()
    Telegram:Reset()
  end
  Telegram:UpdateUrls()
end
--
function Telegram:HandleUserCommand(cmd,args)
  cmd = string.lower(cmd)
  local cmdA = string.split(args," ")
  sub_cmd = string.lower(table.remove(cmdA,1))
  sub_args = table.concat(cmdA," ")
  if (cmd=="help") then         -- Hook to global #HELP
    Telegram:showHelp()
  elseif (cmd=="version") then  -- Hook to global #VERSION
    Telegram:showVersion()
  elseif (cmd=="about") then    -- Hook to global #ABOUT
    Telegram:showAbout()
  -- Package specific below
  elseif (cmd=="telegram") then
    if sub_cmd=="" then
      Telegram:showHelp()
      Telegram:showStatus()
    elseif sub_cmd=="enable" then
      Telegram.Enabled = true
      cecho("&lt;green&gt;"..Telegram.PackageName.." ENABLED\n")
    elseif sub_cmd=="disable" then
      Telegram.Enabled = false
      cecho("&lt;orange&gt;"..Telegram.PackageName.." DISABLED\n")
    elseif sub_cmd=="version" then
      Telegram:showVersion()
    elseif sub_cmd=="help" then
      Telegram:showHelp()
    elseif sub_cmd=="about" then
      Telegram:showAbout()
    elseif sub_cmd=="status" then
      Telegram:showStatus()
    elseif sub_cmd=="delete" then
      Telegram:DeleteConfig()
      Telegram:SaveConfig()
      Telegram:Reset()
    elseif sub_cmd=="token" then
      Telegram:SetToken(sub_args)
      Telegram:CheckConfig()
      Telegram:SaveConfig()
    elseif sub_cmd=="auth" or sub_cmd=="authorize" then
      Telegram:Authorize(sub_args)
    elseif sub_cmd=="unauth" then
      Telegram:UnAuthorize(sub_args)
    elseif sub_cmd=="interval" then
      Telegram:SetInterval(sub_args)
    elseif sub_cmd=="tell" then
      local msgA = string.split(sub_args," ")
      local username = table.remove(msgA,1)
      local msg = table.concat(msgA," ")
      Telegram:Tell(username, msg)
    elseif sub_cmd=="whisper" then
      local msgA = string.split(sub_args," ")
      local username = table.remove(msgA,1)
      local msg = table.concat(msgA," ")
      Telegram:Tell(username, msg, true)
    elseif sub_cmd=="upgrade" then
      Telegram:downloadLatestVersion()
    end 
  end
end
--
function Telegram:showHelp()
  cecho("&lt;cyan&gt;".. Telegram.PackageName ..":\n")
  cecho(string.format("&lt;cyan&gt;%-30s- %s\n",string.format(" %s","#HELP"),"Show Helpfile(s)"))
  cecho(string.format("&lt;cyan&gt;%-30s- %s\n",string.format(" %s","#VERSION"),"Show version(s)"))
  cecho(string.format("&lt;cyan&gt;%-30s- %s\n",string.format(" %s","#TELEGRAM STATUS"),"Show Telegram Status"))
  cecho(string.format("&lt;cyan&gt;%-30s- %s\n",string.format(" %s","#TELEGRAM TOKEN &lt;token&gt;"),"Set Telegram Token"))
  cecho(string.format("&lt;cyan&gt;%-30s- %s\n",string.format(" %s","#TELEGRAM UPGRADE"),"Upgrade the package"))
  cecho(string.format("&lt;cyan&gt;%-30s- %s\n",string.format(" %s","#TELEGRAM INTERVAL &lt;seconds&gt;"),"Set polling interval, default 10s"))
  cecho(string.format("&lt;cyan&gt;%-30s- %s\n",string.format(" %s","#TELEGRAM TELL &lt;username&gt; &lt;message&gt;"),"Send a message to a telegram user"))
  cecho(string.format("&lt;cyan&gt;%-30s- %s\n",string.format(" %s","#TELEGRAM WHISPER &lt;username&gt; &lt;message&gt;"),"Send a message to a telegram user (no notification)"))
  cecho(string.format("&lt;cyan&gt;%-30s- %s\n",string.format(" %s","#TELEGRAM ENABLE/DISABLE"),"Enable or Disable the package"))
  cecho(string.format("&lt;cyan&gt;%-30s- %s\n",string.format(" %s","#TELEGRAM AUTH &lt;name&gt;"),"Authorize a Telegram user."))
  cecho(string.format("&lt;cyan&gt;%-30s- %s\n",string.format(" %s","#TELEGRAM UNAUTH &lt;name&gt;"),"UnAuthorize a Telegram user."))
  cecho("&lt;cyan&gt;---------------------------------------------------------------------------------------\n")
  print()
end
--
function Telegram:showAbout()
  print("Show about")
end
--
function Telegram:SetInterval(seconds)
  local s = tonumber(seconds)
  if s then
    cecho("&lt;green&gt;Set Telegram polling inverval to "..s.." seconds\n")
    Telegram.Options.Interval=s
    Telegram:SaveConfig()
    if Telegram.getUpdateTimerId~=nil then
      killTimer(Telegram.getUpdateTimerId)
    end
    Telegram.getUpdateTimerId = tempTimer(Telegram.Options.Interval,[[Telegram:getUpdates()]],true)
  else
    cecho("&lt;orange&gt;'"..seconds.."' is not a valid interval...\n")
  end
end
--
function Telegram:Authorize(name)
  if Telegram.Options.PendingAuthorization[name]~=nil then
    Telegram.Options.Authorized[name]=Telegram.Options.PendingAuthorization[name]
    Telegram.Options.PendingAuthorization[name]=nil
    cecho("&lt;green&gt;Authorized '"..name.."' for Telegram usage. You can now also send messages using\n")
    cecho("&lt;green&gt;#TELEGRAM TELL "..name.." &lt;message&gt;\n")    
    Telegram.SaveConfig()
  else
    cecho("&lt;orange&gt;'"..name.."' not pending authorization, have him/her send a message to the bot first...\n")
  end
end
--
function Telegram:UnAuthorize(name)
  if Telegram.Options.Authorized[name]~=nil then
    Telegram.Options.Authorized[name]= nil
    Telegram.Options.PendingAuthorization[name]=nil
    cecho("&lt;green&gt;UnAuthorized '"..name.."' for Telegram usage. \n")
    Telegram.SaveConfig()
  else
    cecho("&lt;orange&gt;'"..name.."' not authorized, nothing done...\n")
  end
end
--
function Telegram:showStatus()
  cecho("&lt;cyan&gt;---------------------------- TELEGRAM CONNECTOR STATUS --------------------------------\n")
  Telegram:showVersion()
  cecho("&lt;cyan&gt;Token: '"..Telegram.Options["Token"].."'\n")
  cecho("&lt;cyan&gt;Enabled: '"..tostring(Telegram.Options.Enabled).."'\n")
  cecho("&lt;cyan&gt;Polling Interval: "..Telegram.Options.Interval.." seconds\n")
  -- authorized
  cecho("&lt;cyan&gt;Authorized:\n")
  local countAuthorized =0
  local countPending =0
  for _ in pairs(Telegram.Options.Authorized) do countAuthorized = countAuthorized + 1 end
  for _ in pairs(Telegram.Options.PendingAuthorization) do countPending = countPending + 1 end
  if countAuthorized&gt;0 then
    for name,v in pairs(Telegram.Options.Authorized) do
      cecho("\t&lt;green&gt;"..name.."\n")
    end
  else
    cecho("\t&lt;orange&gt;NONE!\n")
  end
  -- pending authorization
  if countPending&gt;0 then
    cecho("&lt;cyan&gt;Pending Authorization:\n")
    for name,v in pairs(Telegram.Options.PendingAuthorization) do
      cecho("\t&lt;orange&gt;"..name.."\n")
    end
  end
  -- ignored
  cecho("&lt;cyan&gt;---------------------------------------------------------------------------------------\n")
  Telegram:Reset()
  Telegram:CheckConfig()
  Telegram:getUpdates()
end
--
function Telegram:showVersion()
  local vline = Telegram:checkVersion()
  cecho(string.format("&lt;cyan&gt;%-50s: %s %s\n",Telegram.PackageName,Telegram.Version,vline))
end
--
function Telegram:DeleteConfig()
  cecho("&lt;cyan&gt;Deleting Telegram config...\n")
  Telegram.Options = {}
  Telegram.Options.Authorized={}
  Telegram.Options.PendingAuthorization = {} -- populate from file
  Telegram.Options.Enabled = true
  Telegram.Options.Token=""
  Telegram.Options.Interval=10
  Telegram:UpdateUrls()
end
--
function Telegram:getInitialUpdates()
  if Telegram.Options.Enabled and Telegram.Options.Token~="" then
    getHTTP(URL_GETUPDATES)
  end
end
--
function Telegram:getUpdates()
  if Telegram.Options.Enabled and Telegram.Options.Token~="" then
    local header = {["Content-Type"] = "application/json"}
    local opts = {}
    opts["allowed_updates"] = {"message"}
    if Telegram.LastIdHandled == -1 then
      opts["offset"] = -2
    else
      opts["offset"] = Telegram.LastIdHandled+1
    end
    postHTTP(yajl.to_string(opts),URL_GETUPDATES,header)
  end
end
--
function Telegram:onHttpPost(event, ...)
  if event=="sysPostHttpError" then
    if string.find(arg[1],"telegram")~=nil then
      display(arg)
    end
  else
    local content = yajl.to_value(arg[2])
    local url = arg[1]      -- use this to check if this is a telegram message, and if so what type
    local response = arg[3] -- not sure what to use this for
    --if string.starts(url,Telegram.URL) then
    if url:starts("https://api.telegram.org") then    -- we only care about telegram messages
      if url == URL_GETUPDATES then
        if content["ok"] then
          Telegram:ParseUpdates(content["result"])
        else
          cecho("&lt;orange&gt;getUpdates was not successful, check URL\n")
          display(arg)
        end
      end
    end
  end
end
--
function Telegram:onHttpGetDone(event, ...)
  local content = yajl.to_value(arg[2])
  local url = arg[1]      -- use this to check if this is a telegram message, and if so what type
  local response = arg[3] -- not sure what to use this for
  --if string.starts(url,Telegram.URL) then
  if url:starts("https://api.telegram.org") then    -- we only care about telegram messages
    if url == URL_GETUPDATES then
      if content["ok"] then
        Telegram:ParseUpdates(content["result"])
      else
        cecho("&lt;orange&gt;getUpdates was not successful, check URL\n")
        display(arg)
      end
    else
      cecho("&lt;orange&gt;GET Not handled\n")
      display(url)
      display(contents)
    end
  end
end
--
function Telegram:Reset()
  Telegram.LastIdHandled=-1
  Telegram:UpdateUrls()
end
--
function Telegram:onFileDownloaded(event, ...)
  if event == "sysDownloadDone" and Telegram.downloading then
    local file = arg[1]
    if string.ends(file,"/versions.lua") then
      Telegram.downloading=false
      Telegram:checkVersion()
    elseif string.ends(file,"/TelegramConnector.mpackage") then
      Telegram.downloading=false
      Telegram:update_version()
    end
  end
end
--
function Telegram:ParseUpdates(contents)
  if Telegram.LastIdHandled==-1 then
    print("just loaded, update lasthandled to..")
    for i,m in pairs(contents) do
      if m["message"]~=nil then
        if m["message"]["message_id"] then
          Telegram.LastIdHandled = m["message"]["message_id"]
        end
      end
    end
    print("Last id handled set to:"..Telegram.LastIdHandled)
  end
  for i,m in pairs(contents) do
    if m["message"]==nil then
      --print("system message, ignore")
    else
      local t = m["message"]["chat"]["type"]  -- private or group
      local message_id = m["message"]["message_id"]
      local chat_id = m["message"]["chat"]["id"]
      local from_id = m["message"]["from"]["id"]
      local sender_id = m["message"]["from"]["id"]
      local cmd = m["message"]["text"]
      local from_username = m["message"]["from"]["username"]
      if message_id&gt;Telegram.LastIdHandled then
        if t=="group" then
          -- is this message for me?
          cmdA = cmd:split(" ")
          local cmdName = string.lower(cmdA[1])
          if string.find(cmdName,string.lower(Telegram.MyName))~=nil then
            -- remove first word
            table.remove(cmdA,1)
            cmd = table.concat(cmdA," ")
          else
            print("This command is for '"..cmdName.."', i am '"..Telegram.MyName.."', Ignore it...")
            cmd = nil
          end
        else
          -- private message, just execute it
        end
        if cmd~=nil then
          if Telegram:CheckAuthorized(from_username) then
            Telegram:HandleCommand(cmd,message_id,chat_id,from_username)
          else
            cecho("&lt;orange&gt;Telegram (".. from_username .." UNAUTHORIZED) has asked me to: '"..cmd.."'\n")
            cecho("&lt;orange&gt;#TELEGRAM AUTH "..from_username.." to authorize\n")
            cecho("&lt;orange&gt;#TELEGRAM IGNORE "..from_username.." to ignore future requests\n")
            -- add to pending approvals
            Telegram.Options.PendingAuthorization[from_username]=from_id
            local msg = "&lt;b&gt;"..Telegram:HtmlEncode("Command ignored....\nUser '"..from_username.."' not authorized\n#TELEGRAM AUTH "..from_username.." in Mudlet to Authorize.").."&lt;/b&gt;"
            local retMsg = {}
            retMsg["chat_id"]=chat_id
            retMsg["text"]=msg
            retMsg["reply_to_message_id"]=message_id
            retMsg["disable_notification"]=true
            retMsg["parse_mode"]="HTML"
            current_message_id = message_id
            current_chat_id = chat_id
            Telegram:SendMessage(retMsg)
            Telegram.LastIdHandled = message_id            
          end
        else
          -- just update the id
          Telegram.LastIdHandled = message_id
        end
      end
    end
  end
end
--
function Telegram:HtmlEncode(str)
  str = string.gsub(str,"&amp;","&amp;amp;")
  str = string.gsub(str,"&lt;","&amp;lt;")
  str = string.gsub(str,"&gt;","&amp;gt;")
  return str
end
--
function Telegram:CaptureLine(...)
  if isPrompt() then
    killTrigger(Telegram.lineTriggerId)
    Telegram.lineTriggerId = nil
    local htmlMsg = Telegram:HtmlEncode(table.concat(lineBuffer,"\n"))     
    local retMsg = {}
    retMsg["chat_id"]=current_chat_id
    retMsg["text"]="&lt;pre&gt;"..htmlMsg.."&lt;/pre&gt;"
    retMsg["reply_to_message_id"]=current_message_id
    retMsg["disable_notification"]=true
    retMsg["parse_mode"]="HTML"
    Telegram:SendMessage(retMsg)
  else
    -- dont add prompt
    table.insert(lineBuffer,line)
  end
end
--
function Telegram:Tell(username,msg,disable_notification)
  disable_notification = disable_notification or false
  if Telegram.Options.Authorized[username]~=nil then
    local htmlMsg = Telegram:HtmlEncode(msg) 
    local retMsg = {}
    retMsg["chat_id"]= Telegram.Options.Authorized[username]
    retMsg["text"]=msg
    retMsg["disable_notification"]= disable_notification
    Telegram:SendMessage(retMsg)
  else
    cecho("&lt;orange&gt;'"..username.."' is not authorized, use:\n")
    cecho("&lt;orange&gt;#TELEGRAM AUTH "..username.."\n")
  end
end
--
function Telegram:SendMessage(msgTable)
  local header = {["Content-Type"] = "application/json"}
  Telegram:UpdateUrls()
  cecho("&lt;cyan&gt;Sending to telegram...\n")
  postHTTP(yajl.to_string(msgTable),URL_SENDMESSAGE,header)
end
--
function Telegram:CheckConfig()
  if Telegram.Options["Token"]=="" then
    cecho("&lt;orange&gt;Token has not been set.\n")
    cecho("&lt;orange&gt;#TELEGRAM TOKEN &lt;token&gt; to set..\n")
  end
  local countAuthorized = 0
  for _ in pairs(Telegram.Options.Authorized) do countAuthorized = countAuthorized + 1 end
  --    
  if countAuthorized==0 then
    cecho("&lt;orange&gt;No one has been authorized. Send a message to the bot from Telegram, then!\n")
    cecho("&lt;orange&gt;#TELEGRAM AUTH &lt;charname&gt;\n")
  end
end
--
function Telegram:CheckAuthorized(from_username)
  if Telegram.Options.Authorized[from_username]==nil then
    return false
  else
    return true
  end
end
--
function Telegram:HandleCommand(cmd,message_id,chat_id,from_username)
  -- check if Authorized
  -- notify "On It"
  cecho("&lt;cyan&gt;Telegram (".. from_username ..") has asked me to: '"..cmd.."'\n")
  local retMsg = {}
  retMsg["chat_id"]=chat_id
  retMsg["text"]="on it"
  retMsg["reply_to_message_id"]=message_id
  retMsg["disable_notification"]=true
  current_message_id = message_id
  current_chat_id = chat_id
  Telegram:SendMessage(retMsg)
  -- start capture
  lineBuffer = {}
  -- enable line trigger
  if Telegram.lineTriggerId then 
    killTrigger(Telegram.lineTriggerId)
    Telegram.lineTriggerId = nil
  end
  Telegram.lineTriggerId = tempLineTrigger(0,99,[[Telegram:CaptureLine()]])
  -- send command
  expandAlias(cmd)
  -- update last handled
  Telegram.LastIdHandled = message_id
  -- stop Capture
  -- send last 3 lines back
  return true
end
--
function Telegram:killAllExistingEventHandlers()
  -- kill all dynamic handlers
  -- ... events
  for i,handlerId in pairs(Telegram.EventHandlerIds) do
    if tonumber(handlerId) then
      killAnonymousEventHandler(handlerId)
      Telegram.EventHandlerIds[i]= nil
    end
  end
  -- ... Aliases
  for i,handlerId in pairs(Telegram.AliasHandlerIds) do
    --print("Should remove alias "..handlerId)
    if tonumber(handlerId) then
      killAlias(handlerId)
      Telegram.AliasHandlerIds[i]= nil
    end
  end
  if Telegram.getReturnHandler~=nil then
    killAnonymousEventHandler(Telegram.getReturnHandler)
  end
  if Telegram.getUpdateTimerId~=nil then
    killTimer(Telegram.getUpdateTimerId)
  end
end
-- Init
--Telegram:killAllExistingEventHandlers()
-- setup dynamic eventHandlers
--table.insert(Telegram.EventHandlerIds,registerAnonymousEventHandler("sysPostHttpDone", [[Telegram:onHttpPost]]))
--table.insert(Telegram.EventHandlerIds,registerAnonymousEventHandler("sysPostHttpError", [[Telegram:onHttpPost]]))
--table.insert(Telegram.EventHandlerIds,registerAnonymousEventHandler("sysDownloadDone", [[Telegram:onFileDownloaded]]))
--table.insert(Telegram.AliasHandlerIds,tempAlias([[^#(?i)(\btelegram\b|\bhelp\b|\bversion\b|\babout\b)(?-i)\s*(.*)$]],[[Telegram:HandleUserCommand(matches[2],matches[3])]]))
--for i,handlerId in pairs(Telegram.AliasHandlerIds) do
--  if tonumber(handlerId) then
--    enableAlias(handlerId)
--  end
--end
-- manual handlers
--Telegram.getReturnHandler = registerAnonymousEventHandler("sysGetHttpDone", [[Telegram:onHttpGetDone]])
--Telegram:downloadVersionFile()
--Telegram:LoadConfig()
--Telegram.getUpdateTimerId = tempTimer(Telegram.Options.Interval,[[Telegram:getUpdates()]],true)
--Telegram:CheckConfig()
--Telegram:getInitialUpdates()</script>
				<eventHandlerList />
			</Script>
		</ScriptGroup>
		<ScriptGroup isActive="yes" isFolder="yes">
			<name>Varie</name>
			<packageName>Luogotenenti_scripts</packageName>
			<script></script>
			<eventHandlerList />
			<ScriptGroup isActive="yes" isFolder="yes">
				<name>Discord Webhook</name>
				<packageName></packageName>
				<script></script>
				<eventHandlerList />
				<Script isActive="yes" isFolder="no">
					<name>sendToDiscordWebhook</name>
					<packageName></packageName>
					<script>function sendToDiscordWebhook(message)
  local httpdone = registerAnonymousEventHandler('sysPostHttpDone', function(event, rurl, response)
                                                                      if rurl == url then 
                                                                        display(r) 
                                                                      else
                                                                        return true 
                                                                      end
                                                                    end, true)
  --
  local httperror = registerAnonymousEventHandler('sysPostHttpError', function(event, response, rurl)
                                                                        if rurl == url then 
                                                                          display(r) 
                                                                        else 
                                                                          return true 
                                                                        end
                                                                      end, true)
  --
  local url = "https://discord.com/api/webhooks/1069019910606430298/C38n1RlUOmsQq3q1fqwbOllc8gG9SUu2SfWK3sjBlGDmpBQV4YdcE4sPuVBHegeTnDmU"
  --
  local data = {
    username = "Invasione [by Kyrus]", 
    avatar_url = "https://s3.amazonaws.com/grapevine-haus/games/46/cover/thumbnail-054bf964-d5ae-4b54-8dc8-63cb85a87538.png",
    content = message
  }

  local header = {
    ["Content-Type"] = "application/json",
  }
  --
  postHTTP(yajl.to_string(data), url, header)
  killAnonymousEventHandler(httpdone)
  killAnonymousEventHandler(httperror)
end</script>
					<eventHandlerList />
				</Script>
			</ScriptGroup>
			<ScriptGroup isActive="yes" isFolder="yes">
				<name>Luogotenenti</name>
				<packageName></packageName>
				<script></script>
				<eventHandlerList />
				<Script isActive="yes" isFolder="no">
					<name>luogotenenti</name>
					<packageName></packageName>
					<script>function getPosition(direzione)
  if direzione == 'sud' then
    return 2
  elseif direzione == 'est' then
    return 6
  elseif direzione == 'nord' then
    return 8
  elseif direzione == 'ovest' then
    return 4
  elseif direzione == 'sud-ovest' then
    return 1
  elseif direzione == 'sud-est' then
    return 3
  elseif direzione == 'nord-est' then
    return 9
  elseif direzione == 'nord-ovest' then
    return 7
  elseif direzione == 'centro' then
    return 5
  end
end
--
function sposta(direction)
  local actualPosition = ui.player.roomPos or 5
  if (actualPosition == direction) then
    cecho("\n&lt;white:green&gt;Movimento non necessario. Sei gia' in ("..actualPosition..")&lt;r&gt;",false)
  else
    if (actualPosition == 1) and (direction == 4 or direction == 2) then
      onestepmove=true      
    elseif (actualPosition == 2) and (direction == 1 or direction == 3) then
      onestepmove=true      
    elseif (actualPosition == 3) and (direction == 2 or direction == 6) then
      onestepmove=true      
    elseif (actualPosition == 4) and (direction == 1 or direction == 7) then
      onestepmove=true      
    elseif (actualPosition == 5) or (direction == 5) then
      onestepmove=true
    elseif (actualPosition == 6) and (direction == 3 or direction == 9) then
      onestepmove=true      
    elseif (actualPosition == 7) and (direction == 4 or direction == 8) then
      onestepmove=true      
    elseif (actualPosition == 8) and (direction == 6 or direction == 7) then
      onestepmove=true      
    elseif (actualPosition == 9) and (direction == 6 or direction == 8) then
      onestepmove=true      
    else
      onestepmove=false
    end
    
    if onestepmove then    
      cecho("\n&lt;white:orange&gt;Movimento veloce da ("..actualPosition..") a ("..direction..")&lt;r&gt;\n",false)      
      send("sposta "..direction, true)      
    else
      cecho("\n&lt;white:red&gt;Movimento lento da ("..actualPosition..") a (5) a ("..direction..")&lt;r&gt;\n",false)
      send("sposta 5", true)
      send("sposta "..direction, true)
    end
  end
end</script>
					<eventHandlerList />
				</Script>
			</ScriptGroup>
			<Script isActive="yes" isFolder="no">
				<name>Mapper utility</name>
				<packageName></packageName>
				<script>--
function onMapMarkSelectedRooms(event, markRoomType)
  local selectedRooms = getMapSelection()["rooms"]
  local centerRoom = getMapSelection()["center"]
  --
  ui.fDebug("[&lt;cyan&gt;call&lt;r&gt;] onMapMarkSelectedRooms("..(event or "nil")..", "..(markRoomType or "nil")..")")
  --
  if (selectedRooms ~= nil) then
    for i, val in ipairs(selectedRooms) do
      --
      -- DT
      if markRoomType == "markRoomsAsDeathTrap" then
        lockRoom(val, true) -- Locks room if from being walked through when speedwalking
        setRoomChar(val, "DT")
      --
      -- Market
      elseif markRoomType == "markRoomsAsMarket" then
        lockRoom(val, false) -- Unlocks room
        setRoomChar(val, "$")
      --
      -- Teleport
      elseif markRoomType == "markRoomsAsTeleport" then
        lockRoom(val, false) -- Unlocks room
        setRoomChar(val, "T")
      end
    end
  end
  updateMap()
end
--
function gogogo()
  local selectedRooms = getMapSelection()["rooms"]
  if (selectedRooms ~= nil) and (#selectedRooms == 1) then
    send('go '..selectedRooms[1])
  end
end
--
-- Custom Sub-Menu
--addMapMenu("Room type")
--addMapEvent("markRoomsAsDeathTrap", "onMapMarkSelectedRooms", "Room type", "Death Trap")
--addMapEvent("markRoomsAsMarket",    "onMapMarkSelectedRooms", "Room type", "Market")
--addMapEvent("markRoomsAsTeleport",  "onMapMarkSelectedRooms", "Room type", "Teleport")
addMapEvent("[Debug: GO]",  "gogogo")
--
-- Events
registerAnonymousEventHandler("onMapMarkSelectedRooms", "onMapMarkSelectedRooms")
registerAnonymousEventHandler("gogogo", "gogogo")
--
function myMap(areaName)
  local areas = getAreaTable()
  --local areaId = areas[areaName] 
  --
  for areaName, areaId in pairs(areas) do
    if (areaId) then
      local rooms = getAreaRooms(areaId)
      local t = 0;
      local c = 0;
      --
      for _, roomId in pairs(rooms) do
        local x, y, z = getRoomCoordinates(roomId)
        local nameRoom = getRoomName(roomId)
        if (z ~= 0) then
          -- local areaId = getRoomArea(roomId)
          local roomAtZ0 = getRoomsByPosition(areaId, z, y, 0)
          --
          t = t +1
          if (roomAtZ0 == nil) or (table.is_empty(roomAtZ0)) then
            cecho(roomId.." - z:"..z.." - "..areaName.." - "..getRoomAreaName(areaId).."&lt;orange&gt;..spostabile\n")
            c = c + 1
          end
        end
      end
      if (t &gt; 0) then
        echo('\n'..t..' stanze a livelli diversi da 0 di cui '..c..' spostabili\n\n')
      end
    else
      echo('Area non trovata ('..name..')')
    end
  end
end
--
--[[
local roomDrawed = {}
local level;
local entryTab = {
  "east",
  "north",
  "south",
  "west",
}
]]
--
--
function getAreaDimension(areaId)
  local rooms = getAreaRooms(areaId)
  local max_x = nil;
  local min_x = nil;
  local max_y = nil;
  local min_y = nil;
  --
  for _, roomId in pairs(rooms) do
    local x, y, z = getRoomCoordinates(roomId)
    
    if (z == 0) then
      if (max_x == nil) or (x &gt; max_x) then
        max_x = x
      end
  
      if (min_x == nil) or (x &lt; min_x) then
        min_x = x
      end
  
      if (max_y == nil) or (y &gt; max_y) then
        max_y = y
      end
  
      if (min_y == nil) or (y &lt; min_y) then
        min_y = y
      end
    end
  end
  --
  return min_x, min_y, max_x, max_y
end
--
function purgeExits()
  local areas = getAreaTable()
  --
  for areaName, areaId in pairs(areas) do
    local rooms = getAreaRooms(areaId)
    --
    for _, roomId in pairs(rooms) do
      local exits = getRoomExits(roomId)
      for exitDir, exitRoom in pairs(exits) do
        if (exitRoom == 0) or (exitRoom == roomId) then
          echo(areaId..") "..areaName.." =&gt; "..roomId.." =&gt; "..exitDir.." = "..exitRoom.."\n")
          setExit(roomId, -1, exitDir)
        end
      end      
    end
  end
end
--
function pharseArea()
  local roomId = getPlayerRoom()
  local areaId = getRoomArea(roomId)
  local rooms = getAreaRooms(areaId)
  
  for _, roomId in pairs(rooms) do
    send("go "..roomId)
  end
end
--
function pw(pr)
  if (tonumber(pr[1]) == map.room.id) then
    if (#pr &gt; 0) then
      -- Send command
      table.remove(pr,1)
      send("go "..pr[1])
      --
      -- Recall to check time out and send next command if necessary
      if (pw_id) then 
        killTimer(pw_id) 
      end
      pw_id = tempTimer(0.01, function() pw(pr) end)
    end
  else
    if (pw_id) then 
      killTimer(pw_id) 
    end
    pw_id = tempTimer(0.01, function() pw(pr) end)
  end
end
--
--
function pharseWorld(restart)
  pwRooms = pwRooms or {}
  
  if (restart) then
    pwRooms = {}
    -- iterate over all rooms in code
    for id,name in pairs(getRooms()) do
      table.insert(pwRooms,id)
    end
  end
  --
  send("go "..pwRooms[1])
  pw(pwRooms)
end
--
function offlinePlayerMove (dir)
  local id = getPlayerRoom()
  local name = getRoomName(id)
  --
  if (name) then
    local exits = getRoomExits(id)
    --
    for k, v in pairs(exits) do
      if (ui.validExit[k].short == ui.validExit[dir].short) then
        centerview(v)
        return true
      end      
    end
  end
  ui.fEchon("Non esistono uscite verso "..ui.validExit[dir].color..ui.validExit[dir].long)
  --
  return false
end
--
function saveMap(area)
  --
  -- Salva la mappa nel formato {vNum = {x, y, z}}
  local file = ui.files.map.path..ui.files.map.name
  --
  if (area) then
    --
    -- iterate over all rooms in selected area
    local areas = getAreaTable()
    local areaID = areas[string.trim(area)]
    --
    if (areaID) then
      local rooms = getAreaRooms(areaID)
      --
      for _,id in ipairs(rooms) do
        ui.map[id] = {}
        ui.map[id].x, ui.map[id].y, ui.map[id].z = getRoomCoordinates(id)
      end
      ui.fEchon("Area salvata")
    else
      ui.fEchon("Area non trovata")
    end
  else
    ui.map = {}
    --
    -- iterate over all rooms in code
    for id,name in pairs(getRooms()) do
      ui.map[id] = {}
      ui.map[id].x, ui.map[id].y, ui.map[id].z = getRoomCoordinates(id)
    end
    ui.fEchon("Mappa salvata")
  end
  --
  table.save(file, ui.map)
end
--
function reloadMap(area)
  --
  if (area) then
    --
    -- iterate over all rooms in selected area
    local areas = getAreaTable()
    local areaID = areas[string.trim(area)]
    --
    if (areaID) then
      local rooms = getAreaRooms(areaID)
      --
      for _,id in ipairs(rooms) do
        setRoomCoordinates(id, ui.map[id].x or 0, ui.map[id].y or 0, 0)
      end
      ui.fEchon("Area ricaricata")
    else
      ui.fEchon("Area non trovata")
    end
  else
    ui.fEchon("Necessario specificare un area")
  end
end
--
function cleanRoomsName()
  local areas = getAreaTable()
  --
  for areaName, areaId in pairs(areas) do
    local rooms = getAreaRooms(areaId)
    --
    for _, roomId in pairs(rooms) do
      local name = getRoomName(roomId)
      if (string.match(name, "$C%d%d%d%d") ~= nil) then
        echo(roomId.." - "..name.." = ")
        name = string.gsub(name, "$C%d%d%d%d", "")
        echo(name.."\n")
        setRoomName(roomId, name)
      end
      
    end
  end
end
--
function cleanRoomsDoors()
  local areas = getAreaTable()
  --
  for areaName, areaId in pairs(areas) do
    local rooms = getAreaRooms(areaId)
    --
    for _, roomId in pairs(rooms) do
      --
      local doors = getDoors(roomId)
      if (not table.is_empty(doors)) then
        ui.fEcho("Porte &lt;orange&gt;eliminate&lt;r&gt; in "..roomId)        
        for d, x in pairs(doors) do
          echo(" - "..d..": "..x)
          setDoor(roomId, d, 0)
        end
        echo("\n")
      end
      --
      local userData = getAllRoomUserData(roomId)
      if (not table.is_empty(userData)) then
        ui.fEcho("Porte &lt;green&gt;aggiunte&lt;r&gt; in: "..roomId)
        for d, x in pairs(userData) do
          echo(" - "..d..": "..x)
          setDoor(roomId, d, 2)
        end
        echo("\n")
      end
    end
  end
  echo("Done\n")
end</script>
				<eventHandlerList />
			</Script>
			<Script isActive="no" isFolder="no">
				<name>Rosa dei venti</name>
				<packageName></packageName>
				<script>local CSS_Pulsante = [[
  QLabel{
    border: 2px outset #aa8822;
    border-radius: 5px 10px;
    qproperty-wordWrap: true;
    background-color: rgba(150, 0, 0, .4);
  }
  QLabel::hover{
    background-color: rgba(150, 0, 0, 1);
  }
]]
--
function fExecuteCommand(cmd)
  send(cmd)
end
--
rosaDeiVenti = Adjustable.Container:new2({
  name = "rosaDeiVenti",
  x = 100,
  y = 100,
  width = 100,
  height = 125,
  titleText ="Target",
  titleTxtColor = "orange",
  buttonsize = 12,
  buttonFontSize = 5,
  adjLabelstyle = [[
    border: 2px outset rgb(90,72,72); 
    border-top-left-radius: 10px;
    border-top-right-radius: 10px;
    border-bottom-left-radius: 4px;
    border-bottom-right-radius: 4px;
    background-color: rgb(30,24,24);
  ]], 
  buttonstyle = [[
    QLabel{
      border-radius: 5px;
      background-color: rgb(90,72,72);
    }
    QLabel::hover{
      background-color: rgb(180,144,144);}
  ]],
})
--
rosaDeiVenti.Main = Geyser.Label:new2({
  name = "rosaDeiVenti.Main",
  x = 3,
  y = 25,
  width = "100%-6",
  height = "100%-28",
},rosaDeiVenti)
--
-- Buttons
rosaDeiVenti.Main.pulsante_nw = Geyser.Label:new2({
  name = "rosaDeiVenti.Main.pulsante_nw",
  x = 0,
  y = 0,
  width = "33%",
  height = "33%",
},rosaDeiVenti.Main)
rosaDeiVenti.Main.pulsante_nw:setStyleSheet(CSS_Pulsante);
rosaDeiVenti.Main.pulsante_nw:setFontSize(9)
rosaDeiVenti.Main.pulsante_nw:setFgColor("LightGoldenrod")
rosaDeiVenti.Main.pulsante_nw:setClickCallback("fExecuteCommand", "sposta 7", nil)
rosaDeiVenti.Main.pulsante_nw:echo("&lt;center&gt;N-W")
--
rosaDeiVenti.Main.pulsante_n = Geyser.Label:new2({
  name = "rosaDeiVenti.Main.pulsante_n",
  x = "33%",
  y = 0,
  width = "34%",
  height = "33%",
},rosaDeiVenti.Main)
rosaDeiVenti.Main.pulsante_n:setStyleSheet(CSS_Pulsante);
rosaDeiVenti.Main.pulsante_n:setFontSize(9)
rosaDeiVenti.Main.pulsante_n:setFgColor("LightGoldenrod")
rosaDeiVenti.Main.pulsante_n:setClickCallback("fExecuteCommand", "sposta 8", nil)
rosaDeiVenti.Main.pulsante_n:echo("&lt;center&gt;N")
--
rosaDeiVenti.Main.pulsante_ne = Geyser.Label:new2({
  name = "rosaDeiVenti.Main.pulsante_ne",
  x = "67%",
  y = 0,
  width = "33%",
  height = "33%",
},rosaDeiVenti.Main)
rosaDeiVenti.Main.pulsante_ne:setStyleSheet(CSS_Pulsante);
rosaDeiVenti.Main.pulsante_ne:setFontSize(9)
rosaDeiVenti.Main.pulsante_ne:setFgColor("LightGoldenrod")
rosaDeiVenti.Main.pulsante_ne:setClickCallback("fExecuteCommand", "sposta 9", nil)
rosaDeiVenti.Main.pulsante_ne:echo("&lt;center&gt;N-E")
--
--
--
rosaDeiVenti.Main.pulsante_w = Geyser.Label:new2({
  name = "rosaDeiVenti.Main.pulsante_w",
  x = 0,
  y = "33%",
  width = "33%",
  height = "34%",
},rosaDeiVenti.Main)
rosaDeiVenti.Main.pulsante_w:setStyleSheet(CSS_Pulsante);
rosaDeiVenti.Main.pulsante_w:setFontSize(9)
rosaDeiVenti.Main.pulsante_w:setFgColor("LightGoldenrod")
rosaDeiVenti.Main.pulsante_w:setClickCallback("fExecuteCommand", "sposta 4", nil)
rosaDeiVenti.Main.pulsante_w:echo("&lt;center&gt;W")
--
rosaDeiVenti.Main.pulsante_c = Geyser.Label:new2({
  name = "rosaDeiVenti.Main.pulsante_c",
  x = "33%",
  y = "33%",
  width = "34%",
  height = "34%",
},rosaDeiVenti.Main)
rosaDeiVenti.Main.pulsante_c:setStyleSheet(CSS_Pulsante);
rosaDeiVenti.Main.pulsante_c:setFontSize(9)
rosaDeiVenti.Main.pulsante_c:setFgColor("LightGoldenrod")
rosaDeiVenti.Main.pulsante_c:setClickCallback("fExecuteCommand", "sposta 5", nil)
rosaDeiVenti.Main.pulsante_c:echo("&lt;center&gt;C")
--
rosaDeiVenti.Main.pulsante_e = Geyser.Label:new2({
  name = "rosaDeiVenti.Main.pulsante_e",
  x = "67%",
  y = "33%",
  width = "33%",
  height = "34%",
},rosaDeiVenti.Main)
rosaDeiVenti.Main.pulsante_e:setStyleSheet(CSS_Pulsante);
rosaDeiVenti.Main.pulsante_e:setFontSize(9)
rosaDeiVenti.Main.pulsante_e:setFgColor("LightGoldenrod")
rosaDeiVenti.Main.pulsante_e:setClickCallback("fExecuteCommand", "sposta 6", nil)
rosaDeiVenti.Main.pulsante_e:echo("&lt;center&gt;E")
--
--
--
rosaDeiVenti.Main.pulsante_sw = Geyser.Label:new2({
  name = "rosaDeiVenti.Main.pulsante_sw",
  x = 0,
  y = "67%",
  width = "33%",
  height = "33%",
},rosaDeiVenti.Main)
rosaDeiVenti.Main.pulsante_sw:setStyleSheet(CSS_Pulsante);
rosaDeiVenti.Main.pulsante_sw:setFontSize(9)
rosaDeiVenti.Main.pulsante_sw:setFgColor("LightGoldenrod")
rosaDeiVenti.Main.pulsante_sw:setClickCallback("fExecuteCommand", "sposta 1", nil)
rosaDeiVenti.Main.pulsante_sw:echo("&lt;center&gt;S-W")
--
rosaDeiVenti.Main.pulsante_s = Geyser.Label:new2({
  name = "rosaDeiVenti.Main.pulsante_s",
  x = "33%",
  y = "67%",
  width = "34%",
  height = "33%",
},rosaDeiVenti.Main)
rosaDeiVenti.Main.pulsante_s:setStyleSheet(CSS_Pulsante);
rosaDeiVenti.Main.pulsante_s:setFontSize(9)
rosaDeiVenti.Main.pulsante_s:setFgColor("LightGoldenrod")
rosaDeiVenti.Main.pulsante_s:setClickCallback("fExecuteCommand", "sposta 2", nil)
rosaDeiVenti.Main.pulsante_s:echo("&lt;center&gt;S")
--
rosaDeiVenti.Main.pulsante_se = Geyser.Label:new2({
  name = "rosaDeiVenti.Main.pulsante_se",
  x = "67%",
  y = "67%",
  width = "33%",
  height = "33%",
},rosaDeiVenti.Main)
rosaDeiVenti.Main.pulsante_se:setStyleSheet(CSS_Pulsante);
rosaDeiVenti.Main.pulsante_se:setFontSize(9)
rosaDeiVenti.Main.pulsante_se:setFgColor("LightGoldenrod")
rosaDeiVenti.Main.pulsante_se:setClickCallback("fExecuteCommand", "sposta 3", nil)
rosaDeiVenti.Main.pulsante_se:echo("&lt;center&gt;S-E")
--
-- Wrapping function
local Minimize = rosaDeiVenti.minimize
local Restore = rosaDeiVenti.restore
--
function rosaDeiVenti:minimize(...)
  rosaDeiVenti.Main:hide()
  return Minimize(rosaDeiVenti)
end
--
function rosaDeiVenti:restore(...)
  rosaDeiVenti.Main:show()
  return Restore(rosaDeiVenti)
end
</script>
				<eventHandlerList />
			</Script>
		</ScriptGroup>
	</ScriptPackage>
	<KeyPackage>
		<KeyGroup isActive="yes" isFolder="yes">
			<name>LeU_UI</name>
			<packageName>LeU_UI</packageName>
			<script></script>
			<command></command>
			<keyCode>0</keyCode>
			<keyModifier>0</keyModifier>
			<KeyGroup isActive="yes" isFolder="yes">
				<name>Keypad</name>
				<packageName></packageName>
				<script></script>
				<command></command>
				<keyCode>-1</keyCode>
				<keyModifier>0</keyModifier>
				<KeyGroup isActive="yes" isFolder="yes">
					<name>Movement (keypad)</name>
					<packageName></packageName>
					<script></script>
					<command></command>
					<keyCode>-1</keyCode>
					<keyModifier>0</keyModifier>
					<Key isActive="yes" isFolder="no">
						<name>keypad + 1 (down)</name>
						<packageName></packageName>
						<script></script>
						<command>d</command>
						<keyCode>49</keyCode>
						<keyModifier>536870912</keyModifier>
					</Key>
					<Key isActive="yes" isFolder="no">
						<name>keypad + 2 (south)</name>
						<packageName></packageName>
						<script></script>
						<command>s</command>
						<keyCode>50</keyCode>
						<keyModifier>536870912</keyModifier>
					</Key>
					<Key isActive="yes" isFolder="no">
						<name>keypad + 4 (west)</name>
						<packageName></packageName>
						<script></script>
						<command>w</command>
						<keyCode>52</keyCode>
						<keyModifier>536870912</keyModifier>
					</Key>
					<Key isActive="yes" isFolder="no">
						<name>keypad + 6 (east)</name>
						<packageName></packageName>
						<script></script>
						<command>e</command>
						<keyCode>54</keyCode>
						<keyModifier>536870912</keyModifier>
					</Key>
					<Key isActive="yes" isFolder="no">
						<name>keypad + 8 (north)</name>
						<packageName></packageName>
						<script></script>
						<command>n</command>
						<keyCode>56</keyCode>
						<keyModifier>536870912</keyModifier>
					</Key>
					<Key isActive="yes" isFolder="no">
						<name>keypad + 9 (up)</name>
						<packageName></packageName>
						<script></script>
						<command>u</command>
						<keyCode>57</keyCode>
						<keyModifier>536870912</keyModifier>
					</Key>
				</KeyGroup>
			</KeyGroup>
		</KeyGroup>
		<KeyGroup isActive="yes" isFolder="yes">
			<name>Varie</name>
			<packageName></packageName>
			<script></script>
			<command></command>
			<keyCode>33554431</keyCode>
			<keyModifier>0</keyModifier>
			<Key isActive="yes" isFolder="no">
				<name>keypad + 0 (group)</name>
				<packageName></packageName>
				<script></script>
				<command>group</command>
				<keyCode>48</keyCode>
				<keyModifier>536870912</keyModifier>
			</Key>
			<Key isActive="yes" isFolder="no">
				<name>keypad + 5 (look)</name>
				<packageName></packageName>
				<script></script>
				<command>look</command>
				<keyCode>53</keyCode>
				<keyModifier>536870912</keyModifier>
			</Key>
			<Key isActive="yes" isFolder="no">
				<name>ALT + keypad + 1 (get all cad)</name>
				<packageName></packageName>
				<script>expandAlias("ll")</script>
				<command></command>
				<keyCode>49</keyCode>
				<keyModifier>671088640</keyModifier>
			</Key>
			<Key isActive="yes" isFolder="no">
				<name>ALT + keypad + 5 (cerca)</name>
				<packageName></packageName>
				<script></script>
				<command>cerca</command>
				<keyCode>53</keyCode>
				<keyModifier>671088640</keyModifier>
			</Key>
			<KeyGroup isActive="yes" isFolder="yes">
				<name>Look at direction  (control + keypad)</name>
				<packageName></packageName>
				<script></script>
				<command></command>
				<keyCode>-1</keyCode>
				<keyModifier>0</keyModifier>
				<Key isActive="yes" isFolder="no">
					<name>CTRL + keypad 1</name>
					<packageName></packageName>
					<script></script>
					<command>look down</command>
					<keyCode>49</keyCode>
					<keyModifier>603979776</keyModifier>
				</Key>
				<Key isActive="yes" isFolder="no">
					<name>CTRL + keypad 2</name>
					<packageName></packageName>
					<script></script>
					<command>look south</command>
					<keyCode>50</keyCode>
					<keyModifier>603979776</keyModifier>
				</Key>
				<Key isActive="yes" isFolder="no">
					<name>CTRL + keypad 4</name>
					<packageName></packageName>
					<script></script>
					<command>look west</command>
					<keyCode>52</keyCode>
					<keyModifier>603979776</keyModifier>
				</Key>
				<Key isActive="yes" isFolder="no">
					<name>CTRL + keypad 6</name>
					<packageName></packageName>
					<script></script>
					<command>look east</command>
					<keyCode>54</keyCode>
					<keyModifier>603979776</keyModifier>
				</Key>
				<Key isActive="yes" isFolder="no">
					<name>CTRL + keypad 8</name>
					<packageName></packageName>
					<script></script>
					<command>look north</command>
					<keyCode>56</keyCode>
					<keyModifier>603979776</keyModifier>
				</Key>
				<Key isActive="yes" isFolder="no">
					<name>CTRL + keypad 9</name>
					<packageName></packageName>
					<script></script>
					<command>loo up</command>
					<keyCode>57</keyCode>
					<keyModifier>603979776</keyModifier>
				</Key>
			</KeyGroup>
			<KeyGroup isActive="yes" isFolder="yes">
				<name>Mapper</name>
				<packageName></packageName>
				<script></script>
				<command></command>
				<keyCode>33554431</keyCode>
				<keyModifier>0</keyModifier>
				<Key isActive="yes" isFolder="no">
					<name>CTRL + ALT + keypad + 1</name>
					<packageName></packageName>
					<script>offlinePlayerMove ("d")</script>
					<command></command>
					<keyCode>49</keyCode>
					<keyModifier>738197504</keyModifier>
				</Key>
				<Key isActive="yes" isFolder="no">
					<name>CTRL + ALT + keypad + 2</name>
					<packageName></packageName>
					<script>offlinePlayerMove ("s")</script>
					<command></command>
					<keyCode>50</keyCode>
					<keyModifier>738197504</keyModifier>
				</Key>
				<Key isActive="yes" isFolder="no">
					<name>CTRL + ALT + keypad + 4</name>
					<packageName></packageName>
					<script>offlinePlayerMove ("w")</script>
					<command></command>
					<keyCode>52</keyCode>
					<keyModifier>738197504</keyModifier>
				</Key>
				<Key isActive="yes" isFolder="no">
					<name>CTRL + ALT + keypad + 6</name>
					<packageName></packageName>
					<script>offlinePlayerMove ("e")</script>
					<command></command>
					<keyCode>54</keyCode>
					<keyModifier>738197504</keyModifier>
				</Key>
				<Key isActive="yes" isFolder="no">
					<name>CTRL + ALT + keypad + 8</name>
					<packageName></packageName>
					<script>offlinePlayerMove ("n")</script>
					<command></command>
					<keyCode>56</keyCode>
					<keyModifier>738197504</keyModifier>
				</Key>
				<Key isActive="yes" isFolder="no">
					<name>CTRL + alt + keypad + 9</name>
					<packageName></packageName>
					<script>offlinePlayerMove ("u")</script>
					<command></command>
					<keyCode>57</keyCode>
					<keyModifier>738197504</keyModifier>
				</Key>
			</KeyGroup>
		</KeyGroup>
	</KeyPackage>
	<VariablePackage>
		<HiddenVariables />
	</VariablePackage>
</MudletPackage>
