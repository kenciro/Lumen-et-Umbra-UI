<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE MudletPackage>
<MudletPackage version="1.001">
	<TriggerPackage>
		<TriggerGroup isActive="yes" isFolder="yes" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
			<name>Communications</name>
			<script></script>
			<triggerType>0</triggerType>
			<conditonLineDelta>99</conditonLineDelta>
			<mStayOpen>0</mStayOpen>
			<mCommand></mCommand>
			<packageName></packageName>
			<mFgColor>#ff0000</mFgColor>
			<mBgColor>#ffff00</mBgColor>
			<mSoundFile></mSoundFile>
			<colorTriggerFgColor>#000000</colorTriggerFgColor>
			<colorTriggerBgColor>#000000</colorTriggerBgColor>
			<regexCodeList />
			<regexCodePropertyList />
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>Personal communications</name>
				<script>ui.fDebug("[trig] Personal communications")
--
local from = copy2decho(matches[2])
local to = copy2decho(matches[3])
local message = copy2decho(matches[4])
--
if (matches[2] == "["..ui.variables.character_name.."]") then
  from = string.gsub(from, ui.variables.character_name, "Tu")
  from = string.gsub(from, "]\&lt;r\&gt;", "]")
  from = from.." a "..matches[3].."\&lt;r\&gt;"
elseif (matches[2] == "Mandi") or (matches[2] == "Tu") then
  local color = string.gsub(from, matches[2].."\&lt;r\&gt;", "")
  from = color.."[\&lt;255,255,255:0,0,0\&gt;"..matches[2] ..color.."]".." a \&lt;255,255,255:0,0,0\&gt;"..matches[3].."\&lt;r\&gt;"
  from = string.gsub(from, "Mandi", "Tu")
else
  ui.reply = matches[2];
  ui.reply = string.gsub(ui.reply, "%[", "")
  ui.reply = string.gsub(ui.reply, "%]", "")
  ui.reply = string.gsub(ui.reply, ",", "")
  ui.reply = ui.fRemoveArticle(ui.reply)
  ui.reply = string.sub (ui.reply, 1, string.find(ui.reply, " ")-1)
  --
  -- Reply
  GUI.PrivateChat:setTitle("Canale privato ["..ui.reply.."]")
end
--
if (ui.lastFromPrivate) and (ui.lastFromPrivate == from) then
  str = "  "..message.."\n"
else
  str = "\n"..from.." &lt;128,128,128:30,24,24&gt;"..os.date("%H:%M:%S").."\n  "..message.."\n"
  ui.lastFromPrivate = from
end
--
str = string.gsub(str, ":0,0,0&gt;", ":30,24,24&gt;")
str = string.gsub(str, "&lt;0,0,255:", "&lt;128,128,255:")
GUI.PrivateChat.Main.Body.Console:decho(str)
playSoundFile(ui.pathSnd..[[message.wav]], 10)</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>^(Mandi) a (.*) il (?:pensiero|messaggio) (\'.*\')$</string>
					<string>^(Tu) (?:chiedi|dici|sussurri) (?:a|ai|al|alla|alle|agli) (.*) (\'.*\')$</string>
					<string>^(\[.*\]) (ti) (?:manda il messaggio|manda il pensiero|chiede|dice|sussurra) (\'.*\')$</string>
					<string>^(\[.*\]) dice (?:a |ai |al |all'|alla |alle |agli )(.*) (\'.*\')$</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>1</integer>
					<integer>1</integer>
					<integer>1</integer>
					<integer>1</integer>
				</regexCodePropertyList>
			</Trigger>
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>Public  communication</name>
				<script>ui.fDebug("[trig] Public communication")
--
local str = copy2decho(matches[1])
local color = copy2decho(matches[2])
local from = copy2decho(matches[3])
local message = copy2decho(matches[4])
-- Color
color = string.gsub(color, 'Tu&lt;r&gt;', '')
color = string.gsub(color, '%[&lt;r&gt;', '')
-- Text
if (ui.lastFromPubblic) and (ui.lastFromPubblic == from) then
  str = "  "..message.."\n"
  str = string.gsub(str, ":0,0,0&gt;",    ":30,24,24&gt;")
else
  str = string.gsub(str, "&gt;Tu",      "&gt;[Tu]")
  str = string.gsub(str, "] grida ",   "]")
  str = string.gsub(str, "] esclama ", "]")
  str = string.gsub(str, "] mormora ", "]")
  str = string.gsub(str, "] vi dice ", "]")
  str = string.gsub(str, "] dice ",    "]")
  str = string.gsub(str, "] dici ",    "]")
  str = string.gsub(str, "] risuona ", "]")
  str = string.gsub(str, "]",          "] &lt;128,128,128:30,24,24&gt;"..os.date("%H:%M:%S").."\n  "..color)
  str = string.gsub(str, ":0,0,0&gt;",    ":30,24,24&gt;")
  str = "\n"..str.."\n"
  ui.lastFromPubblic = from
end
from = ui.fRemoveArticle(from)
GUI.PublicChat:setTitle("Canale pubblico ["..from.."]")
GUI.PublicChat.Main.Body.Console:decho(str)</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>(^\[)(.*)\] (?:grida|esclama|mormora|vi dice|dice|risuona) (\'.*\')$</string>
					<string>(^(Tu)) (?:gridi|dici) (\'.*\')$</string>
					<string>(^\[)(.*)\] (\'.*\')$</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>1</integer>
					<integer>1</integer>
					<integer>1</integer>
				</regexCodePropertyList>
			</Trigger>
		</TriggerGroup>
		<TriggerGroup isActive="yes" isFolder="yes" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
			<name>Exits</name>
			<script></script>
			<triggerType>0</triggerType>
			<conditonLineDelta>0</conditonLineDelta>
			<mStayOpen>0</mStayOpen>
			<mCommand></mCommand>
			<packageName></packageName>
			<mFgColor>#ff0000</mFgColor>
			<mBgColor>#ffff00</mBgColor>
			<mSoundFile></mSoundFile>
			<colorTriggerFgColor>#000000</colorTriggerFgColor>
			<colorTriggerBgColor>#000000</colorTriggerBgColor>
			<regexCodeList />
			<regexCodePropertyList />
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>Exits</name>
				<script>ui.fDebug("[trig] Exits")
ui.strExits = matches[2]
ui.fUpdateMap()</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>^Uscite: (.*)</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>1</integer>
				</regexCodePropertyList>
			</Trigger>
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>Room name</name>
				<script>ui.fDebug("[trig] Room name")
ui.roomName = matches[2]
ui.roomType = matches[3]</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>^(.*) - (Foresta|Al chiuso|Citta'|Deserto|Pianura|Strada|Collina|Montagna|Acque Basse|Acque Profonde|Sott'acqua|A mezz'aria|Tra gli Alberi|Citta' oscura|Sottosuolo|Dungeon|Caverna|Cripta|Castello|Maniero|Tempio|Prigione|Negozio|Giungla|Costa|Spiaggia|Palude|Tundra|Taiga|Ghiacci|Steppa|Savana|Piano Astrale|Piano Esterno|Sigil|Vuoto cosmico|Sconosciuto|Teletrasporto|Prato)</string>
					<string>^(.*) (\[Zona di Guerra\])</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>1</integer>
					<integer>1</integer>
				</regexCodePropertyList>
			</Trigger>
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>Teleport</name>
				<script>ui.fDebug("[trig] Teleport")
--
ui.path = {}
ui.memPath = 0
ui.idxPath = 0
--
ui.nCad = 0</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>Chiudi gli occhi ed apri un passaggio nel quale entri velocemente.</string>
					<string>Cerchi di attraversare l'acqua, ma la superfice sembra respingerti.</string>
					<string>Cerchi di fuggire in tutta fretta.</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>3</integer>
					<integer>3</integer>
					<integer>3</integer>
				</regexCodePropertyList>
			</Trigger>
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>Specchi di Astral</name>
				<script>ui.fDebug("[trig] Specchi di Astral")
ui.strExits = ui.strExits.." "..string.gsub(matches[2], " ", "-")
ui.fUpdateMap()</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>^Nell'avvicinarti vedi uno specchio d'acqua color (.*).</string>
					<string>^Nell'avvicinarti vedi uno specchio d'acqua di colore (.*).</string>
					<string>^Nell'avvicinarti vedi uno specchio d'acqua appiccicosa color (.*).</string>
					<string>^Nell'avvicinarti vedi uno specchio d'acqua (.*).</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>1</integer>
					<integer>1</integer>
					<integer>1</integer>
					<integer>1</integer>
				</regexCodePropertyList>
			</Trigger>
		</TriggerGroup>
		<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
			<name>Equipment</name>
			<script>ui.fDebug("[trig] Equipment start")
ui.equipment = {}
clearWindow("GUI.Equipment.Main.Body.Console")
enableTrigger("equipment_valid")
enableTrigger("equipment_end")</script>
			<triggerType>0</triggerType>
			<conditonLineDelta>0</conditonLineDelta>
			<mStayOpen>1</mStayOpen>
			<mCommand></mCommand>
			<packageName></packageName>
			<mFgColor>#ff0000</mFgColor>
			<mBgColor>#ffff00</mBgColor>
			<mSoundFile></mSoundFile>
			<colorTriggerFgColor>#000000</colorTriggerFgColor>
			<colorTriggerBgColor>#000000</colorTriggerBgColor>
			<regexCodeList>
				<string>^Stai usando:$</string>
				<string>^(.*) sta usando:$</string>
			</regexCodeList>
			<regexCodePropertyList>
				<integer>1</integer>
				<integer>1</integer>
			</regexCodePropertyList>
			<Trigger isActive="no" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>equipment_valid</name>
				<script>-- match[1] = [2:numero] &lt;3:locazione&gt; [4:livello] |5:tipo| 6:descrizione
ui.fDebug("[trig] Equipment_valid")
if (matches[5] == "") then
  matches[5] = "-"
end
local equipment = {}
equipment.number   = matches[2]
equipment.location = string.gsub(copy2decho(matches[3]), ":0,0,0&gt;", ":30,24,24&gt;")
equipment.level    = string.gsub(copy2decho(matches[4]), ":0,0,0&gt;", ":30,24,24&gt;")
equipment.type     = string.gsub(copy2decho(matches[5]), ":0,0,0&gt;", ":30,24,24&gt;")
equipment.name, equipment.statusColor, equipment.good, equipment.evil, equipment.bring, equipment.noisy, equipment.brittle = ui.fParsingItem(copy2decho(matches[6]))
equipment.name = string.gsub(equipment.name, ":0,0,0&gt;", ":30,24,24&gt;")
if (equipment.good) then
  equipment.name = equipment.name.."&lt;0,0,255:30,24,24&gt;*"
end
if (equipment.evil) then
  equipment.name = equipment.name.."&lt;255,0,0:30,24,24&gt;*"
end
if (equipment.bright) then
  equipment.name = equipment.name.."&lt;255,255,255:30,24,24&gt;*"
end
if (equipment.noisy) then
  equipment.name = equipment.name.."&lt;128,128,128:30,24,24&gt;*"
end
if (equipment.brittle) then
  equipment.name = equipment.name.."&lt;0,128,128:30,24,24&gt;*"
end
GUI.Equipment.Main.Body.Console:decho(equipment.statusColor..equipment.number.."&lt;r&gt; "..equipment.level.." "..equipment.type.. " "..equipment.name.."\n")
table.insert(ui.equipment, equipment)
setTriggerStayOpen("Equipment", 1)
</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>(?:\[(.*)\] )?\&lt;(.*)\&gt;.*\[(.*)\] (?:\|(.*)\| )?(.*)</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>1</integer>
				</regexCodePropertyList>
			</Trigger>
			<Trigger isActive="no" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>equipment_end</name>
				<script>ui.fDebug("[trig] Equipment_end")
disableTrigger("equipment_valid")
disableTrigger("equipment_invalid")
disableTrigger("equipment_end")
GUI.Equipment:setTitle("Equipaggiamento "..getTime(true, "[hh:mm]"))</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>^Il livello di potenza medio del tuo equipaggiamento e' .*$</string>
					<string>^    Nulla.$</string>
					<string>^$</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>1</integer>
					<integer>1</integer>
					<integer>1</integer>
				</regexCodePropertyList>
			</Trigger>
		</Trigger>
		<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
			<name>Loot</name>
			<script>ui.fDebug("[trig] Loot start")
clearWindow("GUI.Inventory.Main.Body.Console")
enableTrigger("loot_valid")
enableTrigger("loot_invalid")
enableTrigger("loot_end")</script>
			<triggerType>0</triggerType>
			<conditonLineDelta>0</conditonLineDelta>
			<mStayOpen>1</mStayOpen>
			<mCommand></mCommand>
			<packageName></packageName>
			<mFgColor>#ff0000</mFgColor>
			<mBgColor>#ffff00</mBgColor>
			<mSoundFile></mSoundFile>
			<colorTriggerFgColor>#000000</colorTriggerFgColor>
			<colorTriggerBgColor>#000000</colorTriggerBgColor>
			<regexCodeList>
				<string>^Stai trasportando:$</string>
				<string>^Non stai trasportando nulla.</string>
				<string>^Quando ci guardi dentro, vedi:</string>
			</regexCodeList>
			<regexCodePropertyList>
				<integer>1</integer>
				<integer>1</integer>
				<integer>1</integer>
			</regexCodePropertyList>
			<Trigger isActive="no" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>loot_valid</name>
				<script>-- match[1] = [2:numero] &lt;3:locazione&gt; [4:livello] |5:tipo| 6:descrizione
ui.fDebug("[trig] Loot_valid")
if (matches[3]=="") then
  matches[3] = "-"
end
local number   = matches[2]
local eqtype   = string.gsub(copy2decho(matches[3]), ":0,0,0&gt;", ":30,24,24&gt;")
local name, statusColor, good, evil, bring, noisy, brittle = ui.fParsingItem(copy2decho(matches[4]))
name = string.gsub(name, ":0,0,0&gt;", ":30,24,24&gt;")
if (good) then
  name = name.."&lt;0,0,255:30,24,24&gt;*"
end
if (evil) then
  name = name.."&lt;255,0,0:30,24,24&gt;*"
end
if (bright) then
  name = name.."&lt;255,255,255:30,24,24&gt;*"
end
if (noisy) then
  name = name.."&lt;128,128,128:30,24,24&gt;*"
end
if (brittle) then
  name = name.."&lt;0,128,128:30,24,24&gt;*"
end
GUI.Inventory.Main.Body.Console:decho(statusColor..number.."&lt;r&gt; "..eqtype.. " "..name.."\n")
setTriggerStayOpen("Loot", 1)
</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>1</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>^\[(.*)\] (?:\|(.*)\| )?(.*)</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>1</integer>
				</regexCodePropertyList>
			</Trigger>
			<Trigger isActive="no" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>loot_invalid</name>
				<script>ui.fDebug("[trig] Loot_invalid")
if (matches[2]) then
  GUI.Inventory.Main.Body.Console:decho (matches[2]..":\n")
end
setTriggerStayOpen("Loot", 1)</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>1</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>^Oggetti in inventario : .* su .*</string>
					<string>^Peso trasportato\s+: .* su .* etti</string>
					<string>^(.*) \(.*\)'*</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>1</integer>
					<integer>1</integer>
					<integer>1</integer>
				</regexCodePropertyList>
			</Trigger>
			<Trigger isActive="no" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>loot_end</name>
				<script>ui.fDebug("[trig] Loot_end")
disableTrigger("loot_valid")
disableTrigger("loot_invalid")
disableTrigger("loot_end")
GUI.Inventory:setTitle("Contenitore "..getTime(true, "[hh:mm]"))</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>^$</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>1</integer>
				</regexCodePropertyList>
			</Trigger>
		</Trigger>
		<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
			<name>Affects Capture</name>
			<script>ui.fDebug("[trig] Affect start")
ui.actAffects = {}
enableTrigger("affects_invalid")
enableTrigger("affects_valid")
enableTrigger("affects_end")</script>
			<triggerType>0</triggerType>
			<conditonLineDelta>0</conditonLineDelta>
			<mStayOpen>1</mStayOpen>
			<mCommand></mCommand>
			<packageName></packageName>
			<mFgColor>#ff0000</mFgColor>
			<mBgColor>#ffff00</mBgColor>
			<mSoundFile></mSoundFile>
			<colorTriggerFgColor>#000000</colorTriggerFgColor>
			<colorTriggerBgColor>#000000</colorTriggerBgColor>
			<regexCodeList>
				<string>+- Effetti Attivi -------------------------------------------------------------+</string>
			</regexCodeList>
			<regexCodePropertyList>
				<integer>3</integer>
			</regexCodePropertyList>
			<Trigger isActive="no" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>affects_invalid</name>
				<script>ui.fDebug("[trig] Affect_invalid")
setTriggerStayOpen("Affects Capture", 1)</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>1</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>| Non hai effetti attivi al momento...                                         |</string>
					<string>+- Effetti Permanenti ---------------------------------------------------------+</string>
					<string>| Non hai effetti permanenti attivi...                                         |</string>
					<string>+- Altri Effetti --------------------------------------------------------------+</string>
					<string>| Non hai altri effetti attivi...                                              |</string>
					<string>+- Cooldown -------------------------------------------------------------------+</string>
					<string>| Non hai cooldown attivi al momento...                                        |</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>3</integer>
					<integer>3</integer>
					<integer>3</integer>
					<integer>3</integer>
					<integer>3</integer>
					<integer>3</integer>
					<integer>3</integer>
				</regexCodePropertyList>
			</Trigger>
			<Trigger isActive="no" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>affects_valid</name>
				<script>ui.fDebug("[trig] Affect_valid")
local name = string.trim(matches[2])
local duration = tonumber(string.trim(matches[3]))
if (matches[4] == "round") then
  duration = duration / 10
end
ui.actAffects[name] = duration
setTriggerStayOpen("Affects Capture", 1)</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>1</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>^\|(.*)\| (.*) (ore|round)\s+\|</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>1</integer>
				</regexCodePropertyList>
			</Trigger>
			<Trigger isActive="no" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>affects_end</name>
				<script>ui.fDebug("[trig] Affect_end")
disableTrigger("affects_invalid")
disableTrigger("affects_valid")
disableTrigger("affects_end")
ui.fUpdateAffects()</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>+------------------------------------------------------------------------------+</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>3</integer>
				</regexCodePropertyList>
			</Trigger>
		</Trigger>
		<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
			<name>Group</name>
			<script>ui.fDebug("[trig] Group start")
ui.group = {}
ui.totalMember = 0
enableTrigger("group_valid")
enableTrigger("group_end")</script>
			<triggerType>0</triggerType>
			<conditonLineDelta>0</conditonLineDelta>
			<mStayOpen>1</mStayOpen>
			<mCommand></mCommand>
			<packageName></packageName>
			<mFgColor>#ff0000</mFgColor>
			<mBgColor>#ffff00</mBgColor>
			<mSoundFile></mSoundFile>
			<colorTriggerFgColor>#000000</colorTriggerFgColor>
			<colorTriggerBgColor>#000000</colorTriggerBgColor>
			<regexCodeList>
				<string>^Ma non sei il membro di un gruppo!$</string>
				<string>^I membri del tuo gruppo(.*)sono\:(.*)$</string>
			</regexCodeList>
			<regexCodePropertyList>
				<integer>1</integer>
				<integer>1</integer>
			</regexCodePropertyList>
			<Trigger isActive="no" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>group_valid</name>
				<script>ui.fDebug("[trig] group_valid")
if (matches[2] ~= ui.variables.character_name) then
  local member = {matches[2], (matches[3] == "(Capo)"), tonumber(matches[4]), tonumber(matches[5]), tonumber(matches[6])}
  ui.totalMember = ui.totalMember + 1
  ui.group[ui.totalMember] = member
end
setTriggerStayOpen("Group", 1)</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#00ff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>^\s+(\S+)\s+(.*) HP:\s+(\d+)\% MANA:\s+(\d+)\% MV:\s+(\d+)\%$</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>1</integer>
				</regexCodePropertyList>
			</Trigger>
			<Trigger isActive="no" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>group_end</name>
				<script>ui.fDebug("[trig] group_end")
disableTrigger("group_valid")
disableTrigger("group_end")
--
ui.fUpdateGroup()</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>1</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#00ffff</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>^$</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>1</integer>
				</regexCodePropertyList>
			</Trigger>
		</Trigger>
		<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
			<name>Tick</name>
			<script>ui.fIncrementTickTimer(65)</script>
			<triggerType>0</triggerType>
			<conditonLineDelta>0</conditonLineDelta>
			<mStayOpen>0</mStayOpen>
			<mCommand></mCommand>
			<packageName></packageName>
			<mFgColor>#ff0000</mFgColor>
			<mBgColor>#ffff00</mBgColor>
			<mSoundFile></mSoundFile>
			<colorTriggerFgColor>#000000</colorTriggerFgColor>
			<colorTriggerBgColor>#000000</colorTriggerBgColor>
			<regexCodeList>
				<string>^Un[']altra ora della giornata si accinge a trascorrere[.]</string>
			</regexCodeList>
			<regexCodePropertyList>
				<integer>1</integer>
			</regexCodePropertyList>
		</Trigger>
		<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
			<name>Track</name>
			<script>ui.fDebug("[trig] Track")
if (matches[2]) then
  ui.track = ui.dirCompress[string.lower(matches[2])]
else
  ui.track = ""
end
ui.fUpdateMap()</script>
			<triggerType>0</triggerType>
			<conditonLineDelta>0</conditonLineDelta>
			<mStayOpen>0</mStayOpen>
			<mCommand></mCommand>
			<packageName></packageName>
			<mFgColor>#ff0000</mFgColor>
			<mBgColor>#ffff00</mBgColor>
			<mSoundFile></mSoundFile>
			<colorTriggerFgColor>#000000</colorTriggerFgColor>
			<colorTriggerBgColor>#000000</colorTriggerBgColor>
			<regexCodeList>
				<string>^Vedi una traccia della tua preda che va verso (?:l'|il )?(.*).$</string>
				<string>^Vedi una debole traccia verso (?:l'|il )?(.*)$</string>
				<string>^Cio' che cerchi e' gia' qui!$</string>
				<string>^Non riesci a trovare tracce.$</string>
				<string>^Hai trovato la tua preda!$</string>
				<string>^Hai perso la traccia.$</string>
			</regexCodeList>
			<regexCodePropertyList>
				<integer>1</integer>
				<integer>1</integer>
				<integer>1</integer>
				<integer>1</integer>
				<integer>1</integer>
				<integer>1</integer>
			</regexCodePropertyList>
		</Trigger>
		<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="yes" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
			<name>Position</name>
			<script>ui.position = matches[2] or ""
ui.fUpdateMap()</script>
			<triggerType>0</triggerType>
			<conditonLineDelta>0</conditonLineDelta>
			<mStayOpen>0</mStayOpen>
			<mCommand></mCommand>
			<packageName></packageName>
			<mFgColor>#ff0000</mFgColor>
			<mBgColor>#ffff00</mBgColor>
			<mSoundFile></mSoundFile>
			<colorTriggerFgColor>#000000</colorTriggerFgColor>
			<colorTriggerBgColor>#000000</colorTriggerBgColor>
			<regexCodeList>
				<string>^Ti muovi rapidamente verso (?:il lato|l'angolo|il) (.*) della stanza.</string>
			</regexCodeList>
			<regexCodePropertyList>
				<integer>1</integer>
			</regexCodePropertyList>
		</Trigger>
	</TriggerPackage>
	<TimerPackage />
	<AliasPackage>
		<Alias isActive="yes" isFolder="no">
			<name>UI Aliases</name>
			<script>local alias = matches[2] or ""
local value = matches[3] or ""
-- Mostra tutti gli aliases
if (alias == "") then
  ui.fShowAllAliases()
-- Rimuove tutti gli aliases
elseif (alias == "remove_all") then
  ui.fRemoveAllAliases()
  ui.fEcho2n("Tutti gli alias sono stati rimossi.")
-- Mostra il singolo alias
elseif (value == "") then
  if (ui.aliases[alias]) then
    ui.fEcho2n(ui.fGetAliasFormattedText(alias))
  else
    ui.fError("L'alias "..ui.fGetAliasNameFormattedText(alias).." non esiste.")
  end
-- Rimuove il singolo alias
elseif value == "remove" then
  if (ui.fRemoveAlias(alias)) then
    ui.fEcho2n("L'alias "..ui.fGetAliasNameFormattedText(alias).." e' stato rimosso.")
  else
    ui.fError("L'alias "..ui.fGetAliasNameFormattedText(alias).." non esiste.")
  end
-- Crea o modifica l'alias
else
  local alreadyExist = ui.aliases[alias];
  local result, output = ui.fAddAlias(alias, value)
  if (result == -1) then
    ui.fError("L'alias "..ui.fGetAliasNameFormattedText(alias).." non è stato creato/modificato. La variabile "..ui.fGetVarNameFormattedText(output).." non esiste.")
  elseif (result == 1) then
    if (alreadyExist) then
      ui.fEcho2n("L'alias "..ui.fGetAliasNameFormattedText(alias).." è stato modificato: "..output..".")
    else
      ui.fEcho2n("L'alias "..ui.fGetAliasNameFormattedText(alias).." è stato creato: "..output..".")
    end
  else
    ui.fError("Errore non previsto.")
  end
end
ui.fSaveFileAliases()
ui.fUpdateAllAliasButton()
</script>
			<command></command>
			<packageName></packageName>
			<regex>^(?i)(?:uia(?:l(?:i(?:a(?:s(?:e(?:s)?)?)?)?)?)?)(?:\s+(\w*)\s*(.*))?$</regex>
		</Alias>
		<Alias isActive="yes" isFolder="no">
			<name>UI Buttons (configurazione)</name>
			<script>local button = matches[2] or ""
local alias = matches[3] or ""
-- Mostra tutti gli alias button
if (button == "") then
  ui.fShowAllAliasButtons()
-- Rimuove tutti gli alias buttons
elseif (button == "remove_all") then
  ui.fRemoveAllAliasButtons()
  ui.fEcho2n("Tutti i pulsanti alias sono stati rimossi.")
-- Mostra il singolo alias button
elseif (alias == "") then
  local type, number = ui.fExpandButton(button)
  if (type == "a") or (type == "b") or (type == "c") then
    button = type..number
    local alias = ui.fSearchAliasButton(button)
    if (alias) then
      ui.fEcho2n(ui.fGetAliasFormattedText(alias))
    else
      ui.fEcho2n("Nessun alias associato al pulsante "..ui.fGetAliasButtonFormattedText(button)..".")
    end
  else
      display(button)
    ui.fError(ui.fGetAliasButtonFormattedText(button).." non è un pulsante valido.")
  end
-- Rimuove il singolo alias button
elseif (alias == "remove") then
  local result = ui.fRemoveAliasButton(button)
  if (result == -2) then
    ui.fEcho2n("Nessun alias da rimuovere per il pulsante "..ui.fGetAliasButtonFormattedText(button)..".")
  elseif (result == -1) then
    ui.fError(ui.fGetAliasButtonFormattedText(button).." non è un pulsante valido.")
  elseif (result == 1) then
    ui.fEcho2n("L'alias associato al pulsante "..ui.fGetAliasButtonFormattedText(button).." è stato rimosso.")
  else
    ui.fError("Errore non previsto.")
  end
-- Crea o modifica l'alias button
else
  local result = ui.fAssignAliasButton(button, alias)
  if (result == -2) then
    ui.fError("L'alias "..ui.fGetAliasNameFormattedText(alias).." non esiste.")
  elseif (result == -1) then
    ui.fError(ui.fGetAliasButtonFormattedText(button).." non è un pulsante valido.")
  elseif (result == 1) then
    ui.fEcho2n("Il pulsante "..ui.fGetAliasButtonFormattedText(button).." è stato associato all'alias "..ui.fGetAliasNameFormattedText(alias)..".")
  else
    ui.fError("Errore non previsto.")
  end
end
ui.fSaveFileAliases()
ui.fUpdateAllAliasButton()</script>
			<command></command>
			<packageName></packageName>
			<regex>^(?i)(?:uib(?:u(?:t(?:t(?:o(?:n(?:s)?)?)?)?)?)?)(?:\s+(\w*)\s*(.*))?$</regex>
		</Alias>
		<Alias isActive="yes" isFolder="no">
			<name>UI Buttons (esecuzione)</name>
			<script>ui.fExecuteAliasButton(matches[2])</script>
			<command></command>
			<packageName></packageName>
			<regex>^(?i)([abc]\d)$</regex>
		</Alias>
		<Alias isActive="yes" isFolder="no">
			<name>UI Colors</name>
			<script>cecho(ui.fTitle("Colori disponibili:"))
ui.fDisplayColors({justText = false, removeDupes = true})</script>
			<command></command>
			<packageName></packageName>
			<regex>^(?i)(?:uic(?:o(?:l(?:o(?:r(?:s?)?)?)?)?)?)$</regex>
		</Alias>
		<Alias isActive="yes" isFolder="no">
			<name>UI Directiones</name>
			<script>-- TODO: integrare comando RUN ^(?i)(?:ru(?:n)?\s+)?([neswud])$
--
local dir = string.lower(matches[2]);
-- Don't save path if retrace
if (not ui.retrace) then
  ui.fSavePath(dir)
end
ui.retrace = false;
-- Initi cadaver counter
ui.nCad = 0
--
ui.fDebug("[alias] UI Directiones - Mem: "..ui.idxPath.."/"..ui.memPath.." - Dir: "..dir)
send(dir, false)</script>
			<command></command>
			<packageName></packageName>
			<regex>^(?i)([neswud])$</regex>
		</Alias>
		<Alias isActive="yes" isFolder="no">
			<name>UI Help</name>
			<script>local helpselect = ""
if matches[2] then
  helpselect = string.lower(matches[2] or "")
end
--
if (helpselect == "") then
  ui.fHelp()
elseif (rex.match(helpselect, [[(?i)(?:uia(?:l(?:i(?:a(?:s(?:e(?:s)?)?)?)?)?)?)$]])) then
  ui.fHelp("alias")
elseif (rex.match(helpselect, [[(?i)(uib(?:u(?:t(?:t(?:o(?:n(?:s)?)?)?)?)?)?)$]])) then
  ui.fHelp("button")
elseif (rex.match(helpselect, [[(?i)(?:uic(?:o(?:l(?:o(?:r(?:s?)?)?)?)?)?)$]])) then
  ui.fHelp("color")
elseif (rex.match(helpselect, [[(?i)(?:uisetf(?:o(?:n(?:t(?:s(?:i(?:z(?:e)?)?)?)?)?)?)?)$]])) then
  ui.fHelp("fontsize")
elseif (rex.match(helpselect, [[(?i)(?:uihi(?:g(?:h(?:l(?:i(?:g(?:h(?:t(?:s)?)?)?)?)?)?)?)?)$]])) then
  ui.fHelp("highlight")
elseif (rex.match(helpselect, [[(?i)(?:uik(?:e(?:y(?:b(?:i(?:n(?:d)?)?)?)?)?)?)$]])) then
  ui.fHelp("keybind")
elseif (rex.match(helpselect, [[(?i)(?:t(?:a(?:r(?:g(?:e(?:t(?:s)?)?)?)?)?)?)$]])) then
  ui.fHelp("target")
elseif (rex.match(helpselect, [[(?i)(?:uip(?:r(?:o(?:f(?:i(?:l(?:(?:e)?s)?)?)?)?)?)?)$]])) then
  ui.fHelp("profile")
elseif (rex.match(helpselect, [[(?i)(?:uiv(?:a(?:r(?:i(?:a(?:b(?:l(?:e)?)?)?)?)?)?)?|@)$]])) then
  ui.fHelp("variable")
elseif (rex.match(helpselect, [[^\.(?:\.)?$]])) then
  ui.fHelp("walk")
else
  ui.fHelp(helpselect)
end</script>
			<command></command>
			<packageName></packageName>
			<regex>^(?i)(?:uih(?:e(?:l(?:p?)?)?)?)(?:\s+(.*))?$</regex>
		</Alias>
		<Alias isActive="yes" isFolder="no">
			<name>UI Reply</name>
			<script>if (ui.reply) then
  local msg = matches[2] or ""
  expandAlias("telep "..ui.reply.." "..msg)
end</script>
			<command></command>
			<packageName></packageName>
			<regex>^(?i)(?:uir)(?:\s+(.*))?$</regex>
		</Alias>
		<Alias isActive="yes" isFolder="no">
			<name>UI Highlights</name>
			<script>--
local text = string.trim(matches[2] or "")
local color = string.trim(matches[3] or "")
--
if (color ~= "") and (color ~= "remove") then
  if (text == "") and (color == "remove_all") then
    text = "remove_all"
    color = ""
  elseif (text == "") and (color ~= "") then
    text = color
    color = ""
  elseif (text ~= "") and (not ui.fColorCheck(color)) then
    text = text.." "..color
    color = ""
  end
end
-- Mostra tutti gli highlights
if (text == "") and (color == "") then
  ui.fShowAllHighlights()
-- Rimuove tutti gli highlights
elseif (text == "remove_all") then
  ui.fRemoveAllHighlights()
  ui.fEcho2n("Tutti gli highlight sono stati eliminati.")
-- Rimuove il singolo highlight
elseif (color == "remove") then
  if (ui.fRemoveHighlight(text)) then
    ui.fEcho2n("L'highlight e' stato rimosso.")
  else
    ui.fError("L'highlight '"..text.."' non esiste.")
  end
-- Mostra il singolo highlight
elseif (color == "") then
  if (ui.highlights[text]) then
    ui.fEcho2n(ui.fGetHighlightFormattedText(text))
  else
    ui.fError("L'highlight '"..text.."' non esiste.")
  end
-- Crea o modifica l'Highlight
else
  local alreadyExist = ui.highlights[text];
  local result = ui.fAddHighlight(text, color)
  if (result == -2) then
    ui.fError("L'highlight '"..text.."' non è stato creato/modificato. Il colore '"..color.."' non è valido. Usare il comando "..ui.fGetCommandFormattedText("uicolor").." per l'elenco dei colori disponibili.")
  elseif (result == -1) then
    ui.fError("L'highlight '"..text.."' non è stato creato/modificato. Specificare un testo valido.")
  elseif (result == 1) then
    if (alreadyExist) then
      ui.fEcho2n("L'highlight &lt;"..color.."&gt;"..text.."&lt;reset&gt; è stato modificato.")
    else
      ui.fEcho2n("L'highlight &lt;"..color.."&gt;"..text.."&lt;reset&gt; è stato creato.")
    end
  else
    ui.fError("Errore non previsto.")
  end
end
--
ui.fSaveFileHighlights()</script>
			<command></command>
			<packageName></packageName>
			<regex>^(?i)(?:uihi(?:g(?:h(?:l(?:i(?:g(?:h(?:t(?:s)?)?)?)?)?)?)?)?)(?:\s?(.*)\s?( \w+))?$</regex>
		</Alias>
		<Alias isActive="yes" isFolder="no">
			<name>UI Keybind</name>
			<script>local element = matches[2] or ""
local key1 = matches[3] or ""
local key2 = matches[4] or ""
local key3 = matches[5] or ""
local isValid, mod1, mod2, key, keybind = ui.fGetKeyb(key1, key2, key3)
-- Mostra tutti i keybind associati a targetselement e aliases
if (element == "") then
  ui.fShowAllKeyb()
-- Rimuove tutti i keybind associati a argets e aliases
elseif (element == "remove_all") then
  ui.fRemoveAllKeyb()
  ui.fEcho2n("Tutti i tasti rapidi sono stati rimossi.")
-- Mostra il singolo keybind
elseif (key1 == "") then
  -- Target
  if (ui.targets[element]) then
    if (ui.targets[element].keybId) then
      ui.fEcho2n(ui.fGetTargetFormattedText(element))
    else
      ui.fEcho2n("Nessun tasto rapido è assegnato al target "..ui.fGetTargetFormattedText(element)..".")
    end
  -- Alias
  elseif (ui.aliases[element]) then
    if (ui.aliases[element].keybId) then
      ui.fEcho2n(ui.fGetAliasFormattedText(element))
    else
      ui.fEcho2n("Nessun tasto rapido è assegnato all'alias "..ui.fGetAliasNameFormattedText(element)..".")
    end
  else
    ui.fError("L'alias "..ui.fGetAliasNameFormattedText(element).." non esiste.")
  end
-- Rimuove il singolo keybind
elseif key1 == "remove" then
  local result
  -- Target
  if (ui.targets[element]) then
    keybind = ui.targets[element].keybind
    result = ui.fRemoveKeyb(ui.targets[element])
    if (result == -2) then
      ui.fError("Il target non esiste.")
    elseif (result == -1) then
      ui.fEcho2n("Nessun tasto rapido assegnato al target "..ui.fGetTargetFormattedText(element).." da rimuovere.")
    elseif (result == 1) then
      ui.fEcho2n("Il tasto rapido "..ui.fGetKeybFormattedText(keybind)..", associato al target "..ui.fGetTargetFormattedText(element)..", e' stato rimosso.")
    else
      ui.fError("Errore non previsto.")
    end
  -- Alias
  elseif (ui.aliases[element]) then
    keybind = ui.aliases[element].keybind
    result = ui.fRemoveKeyb(ui.aliases[element])
    if (result == -2) then
      ui.fError("L'alias non esiste.")
    elseif (result == -1) then
      ui.fEcho2n("Nessun tasto rapido assegnato all'alias "..ui.fGetAliasNameFormattedText(element).." da rimuovere.")
    elseif (result == 1) then
      ui.fEcho2n("Il tasto rapido "..ui.fGetKeybFormattedText(keybind)..", associato all'alias "..ui.fGetAliasNameFormattedText(element)..", e' stato rimosso.")
    else
      ui.fError("Errore non previsto.")
    end
  else
    ui.fError("L'alias "..ui.fGetAliasNameFormattedText(element).." non esiste o non è associato a nessun tasto rapido.")
  end
-- Crea o modifica il keybind
else
  local result, keybind, isTarget
  if (ui.targets[element]) then
    isTarget = true
    result, keybind = ui.fSetKeyb(ui.targets, element, [[ui.fExecuteTargetButton("]]..element..[[")]], key1, key2, key3)
  else
    isTarget = false
    result, keybind = ui.fSetKeyb(ui.aliases, element, ui.aliases[element].code, key1, key2, key3)
  end
  if (result == -4) then
    ui.fError("Il tasto rapido non è stato assegnato. La combinazione di tasti "..ui.fGetKeybFormattedText(keybind).." è già utilizzata in un alias.")
  elseif (result == -3) then
    ui.fError("Il tasto rapido non è stato assegnato. La combinazione di tasti "..ui.fGetKeybFormattedText(keybind).." è già utilizzata in un target.")
  elseif (result == -2) then
    ui.fError("Il tasto rapido non è stato assegnato. La combinazione di tasti "..ui.fGetKeybFormattedText(keybind).." non è valida.")
  elseif (result == -1) then
    ui.fError("Il tasto rapido non è stato assegnato. L'alias "..ui.fGetAliasNameFormattedText(element).." non esiste.")
  elseif (result == 1) and (isTarget) then
    ui.fEcho2n("Il tasto rapido è stato assegnato al target "..ui.fGetTargetFormattedText(element)..".")
  elseif (result == 1) and (not isTarget) then
    ui.fEcho2n("Il tasto rapido è stato assegnato all'alias "..ui.fGetAliasFormattedText(element)..".")
  elseif (result == 2) and (isTarget) then
    ui.fEcho2n("Il tasto rapido associato al target "..ui.fGetTargetFormattedText(element).." è stato rimosso.")
  elseif (result == 2) and (not isTarget) then
    ui.fEcho2n("Il tasto rapido associato all'alias "..ui.fGetAliasNameFormattedText(element).." è stato rimosso.")
  end
end
--
ui.fSaveFileAliases()
ui.fUpdateAllAliasButton()
--
ui.fSaveFileTargets()
ui.fUpdateAllTargetButton()
</script>
			<command></command>
			<packageName></packageName>
			<regex>^(?i)(?:uik(?:e(?:y(?:b(?:i(?:n(?:d)?)?)?)?)?)?)(?:\s*(\w+)?|$)(?:\s*(\w+)?|$)(?:\s*(\w+)?|$)(?:\s*(\w+)?|$)</regex>
		</Alias>
		<Alias isActive="yes" isFolder="no">
			<name>UI Profiles</name>
			<script>local subCommand = matches[2] or ""
local profile = matches[3] or ""
-- Mostra tutti i profiles
if (subCommand == "") then
  ui.fShowAllProfiles()
-- Carica il Profile
elseif (subCommand == "load") then
  if (ui.fLoadProfile(profile)) then
    ui.fEcho2n("Il profilo "..ui.fGetProfileNameFormattedText(profile).." e' stato caricato.")
  else
    ui.fError("Il profilo "..ui.fGetProfileNameFormattedText(profile).." non e' stato caricato.")
  end
-- Merge Profile
elseif (subCommand == "merge") then
  if (ui.fMergeProfile(profile)) then
    ui.fEcho2n("Il profilo "..ui.fGetProfileNameFormattedText(profile).." e' stato aggiunto.")
  else
    ui.fError("Il profilo "..ui.fGetProfileNameFormattedText(profile).." non e' stato aggiunto.")
  end
-- Save Profile
elseif (subCommand == "save") then
  if (ui.fSaveProfile(profile)) then
    ui.fEcho2n("Il profilo "..ui.fGetProfileNameFormattedText(profile).." e' stato salvato.")
  else
    ui.fError("Il profilo "..ui.fGetProfileNameFormattedText(profile).." non e' stato salvato.")
  end
-- Rimuove il singolo Profile
elseif (subCommand == "remove") then
  if (ui.fRemoveProfile(profile)) then
    ui.fEcho2n("Il profilo "..ui.fGetProfileNameFormattedText(profile).." e' stato rimosso.")
  else
    ui.fError("Il profilo "..ui.fGetProfileNameFormattedText(profile).." non e' stato rimosso.")
  end
-- Rimuove tutti i Profiles
elseif (subCommand == "remove_all") then
  ui.fRemoveAllProfiles()
  ui.fEcho2n("Tutti i profili sono stati rimossi.")
--
else
  ui.fError("Parametro non previsto.")
end</script>
			<command></command>
			<packageName></packageName>
			<regex>^(?i)(?:uip(?:r(?:o(?:f(?:i(?:l(?:e(?:s?)?)?)?)?)?)?)?)(?:\s+(\w*)\s*(.*))?$</regex>
		</Alias>
		<Alias isActive="yes" isFolder="no">
			<name>UI Reset</name>
			<script>resetProfile()
saveWindowLayout()
ui.fEcho2n("Interfaccia ripristinata... Riavviare il Mudlet.")
</script>
			<command></command>
			<packageName></packageName>
			<regex>^(?i)(?:uireset)$</regex>
		</Alias>
		<Alias isActive="yes" isFolder="no">
			<name>UI Save</name>
			<script>if (saveWindowLayout()) then
  ui.fEcho2n("Interfaccia salvata. Digitare "..ui.fGetCommandFormattedText("uireset").." per tornare alle impostazioni originali.")
else
  ui.fError("Salvataggio interfaccia non riuscito.")
end</script>
			<command></command>
			<packageName></packageName>
			<regex>^(?i)(?:uisave)$</regex>
		</Alias>
		<Alias isActive="yes" isFolder="no">
			<name>UI Set font size</name>
			<script>local windows = string.lower(matches[2] or "")
local fontsize = tonumber(matches[3] or -1)
if (matches[3]) then
  if (fontsize &gt;= 1) and (fontsize &lt;= 30) then
    if (windows == "contenitore") then
      ui.parameters.fsInventory = fontsize
      GUI.Inventory.Main.Body.Console:setFontSize(ui.parameters.fsInventory)
    elseif (windows == "equipaggiamento") then
      ui.parameters.fsEquipment = fontsize
      GUI.Equipment.Main.Body.Console:setFontSize(ui.parameters.fsEquipment)
    elseif (windows == "mappa") then
      ui.parameters.fsMapCompass = fontsize
      ui.fUpdateMap()
    elseif (windows == "privato") then
      ui.parameters.fsPrivateChat = fontsize
      GUI.PrivateChat.Main.Body.Console:setFontSize(ui.parameters.fsPrivateChat)
    elseif (windows == "pubblico") then
      ui.parameters.fsPublicChat = fontsize
      GUI.PublicChat.Main.Body.Console:setFontSize(ui.parameters.fsPublicChat)
    else
      fontsize = 0
      ui.fError("Nome finestra errato: Usare "..ui.fGetCommandFormattedText("contenitore")..", "
                                             ..ui.fGetCommandFormattedText("equipaggiamento")..", "
                                             ..ui.fGetCommandFormattedText("mappa")..", "
                                             ..ui.fGetCommandFormattedText("privato").." o "
                                             ..ui.fGetCommandFormattedText("pubblico")..".")
    end
    --
    if (fontsize &gt; 0) then
      table.save(ui.fileParameters, ui.parameters)
      ui.fEcho2n("La dimensione del font della finetra "..ui.fGetCommandFormattedText(windows).." e' stato impostato a "..ui.fGetCommandFormattedText(fontsize)..".")
    end
  else
    ui.fError("La dimensione del font e' errata: Usare un valore compreso tra "..ui.fGetCommandFormattedText("1").." e "..ui.fGetCommandFormattedText("30")..".")
  end
else
  ui.fEchon(ui.fGetCommandFormattedText("contenitore")..": "..ui.parameters.fsInventory);
  ui.fEchon(ui.fGetCommandFormattedText("equipaggiamento")..": "..ui.parameters.fsEquipment);
  ui.fEchon(ui.fGetCommandFormattedText("mappa")..": "..ui.parameters.fsMapCompass);
  ui.fEchon(ui.fGetCommandFormattedText("privato")..": "..ui.parameters.fsPrivateChat);
  ui.fEchon(ui.fGetCommandFormattedText("pubblico")..": "..ui.parameters.fsPublicChat);
  ui.fEcho2n("Usare "..ui.fGetCommandFormattedText("uisetf[ontsize] &lt;nome_finestra&gt; &lt;dimensione_font&gt;"))
end</script>
			<command></command>
			<packageName></packageName>
			<regex>^(?i)(?:uisetf(?:o(?:n(?:t(?:s(?:i(?:z(?:e)?)?)?)?)?)?)?)(?:\s*(\w+)?|$)(?:\s*(\w+)?|$)</regex>
		</Alias>
		<Alias isActive="yes" isFolder="no">
			<name>UI Speedwalk</name>
			<script>ui.fDebug("[alias] UI Speedwalk")
--
local in_path = string.lower(matches[3] or "")
local out_path = ""
local backwards = (matches[2] == ".")
--
if (in_path == "") then
  -- Retrace your steps back
  if (backwards) then
    if (ui.idxPath &gt;= 1) then
      out_path = ui.dirReverse[ui.path[ui.idxPath]]
      ui.idxPath = ui.idxPath - 1;
      ui.retrace = true
    else
      ui.fEcho2n("Sei all'inizio del percorso memorizzato.")
    end
  -- Retrace your steps forward 
  elseif (not backwards) then
    if (ui.idxPath &lt; ui.memPath) then
      ui.idxPath = ui.idxPath + 1
      out_path = ui.path[ui.idxPath]
      ui.retrace = true
    else
      ui.fEcho2n("Sei alla fine del percorso memorizzato.")
    end
  end
else
  -- Speedwalk
  local number
  local idx = 1
  while (idx&lt;=in_path:len()) do
    number, idx = ui.fGetNextNumber(in_path, idx)
    if (idx&lt;=in_path:len()) then
      local char = string.lower(in_path:sub(idx, idx))
      for j=1, number do
        if (backwards) then
          out_path = ui.dirReverse[char]..out_path
        else
          out_path = out_path..char
        end
      end
      idx = idx + 1
    end
  end
end
--
if (backwards) then
  ui.fDebug("[alias] UI Speedwalk (Back) - in: "..in_path.." - out: "..out_path)
else
  ui.fDebug("[alias] UI Speedwalk (Forward) - in: "..in_path.." - out: "..out_path)
end
-- Execute out path
for j=1, out_path:len() do
  -- Execute Ui Direction alias
  expandAlias(out_path:sub(j, j), false); 
end</script>
			<command></command>
			<packageName></packageName>
			<regex>^\.(\.)?(?i)([nsewdu\d]+)?$</regex>
		</Alias>
		<Alias isActive="yes" isFolder="no">
			<name>UI Target</name>
			<script>local button_type = string.upper(matches[2])
local button_number = tonumber(matches[3])
local value = matches[4] or ""
local button = button_type..button_number
-- G buttons
if (button_type == "G") then
  if (button_number&lt;0) or (button_number&gt;9) then
    ui.fError(ui.fGetTargetFormattedText(button).." non valido. Usare un target compreso tra "..ui.fGetTargetFormattedText("G0").." e "..ui.fGetTargetFormattedText("G9"))
  elseif (value ~= "") then
    ui.fError(ui.fGetTargetFormattedText(button).." non è possibile assegnare o rimuovere un valore al target avversario "..ui.fGetTargetFormattedText(button))
  else
    ui.fExecuteTargetButton(button)
  end
-- O button
elseif (button_type == "O") then
  if (button_number~=0)  then
    ui.fError(ui.fGetTargetFormattedText(button).." non valido. Usare "..ui.fGetTargetFormattedText("T0"))
  elseif (value ~= "") then
    ui.fError(ui.fGetTargetFormattedText(button).." non è possibile assegnare o rimuovere un valore al target di gruppo "..ui.fGetTargetFormattedText(button))
  else
    ui.fExecuteTargetButton(button)
  end
-- T buttons
elseif (button_type == "T") then
  if (button_number&lt;1) or (button_number&gt;4) then
    ui.fError(ui.fGetTargetFormattedText(button).." non valido. Usare "..ui.fGetTargetFormattedText("T1")..", "..ui.fGetTargetFormattedText("T2")..", "..ui.fGetTargetFormattedText("T3").." oppure "..ui.fGetTargetFormattedText("T4"))
  elseif (value == "") then
    ui.fExecuteTargetButton(button)
  elseif (value == "remove") then
    if (ui.fAssignTargetButton(button, nil)) then
      ui.fEcho2n(ui.fGetTargetFormattedText(button).." valore rimosso.")
    else
      ui.fError(ui.fGetTargetFormattedText(button).." errore durante la rimozione del valore.")
    end
  else
    if (ui.fAssignTargetButton(button, value)) then
      ui.fEcho2n(ui.fGetTargetFormattedText(button).." valore impostato "..ui.fGetVarValueFormattedText(value)..".")
    else
      ui.fError(ui.fGetTargetFormattedText(button).." errore durante il cambio di valore.")
    end
  end
end</script>
			<command></command>
			<packageName></packageName>
			<regex>^(?i)([got])(\d)(?:\s+(.*))?$</regex>
		</Alias>
		<Alias isActive="yes" isFolder="no">
			<name>UI Variables</name>
			<script>local variable = matches[2]
local value = matches[3]
-- Mostra tutte le variabili
if variable == nil or variable == "" then
  ui.fShowAllVar()
-- Rimuove tutte le variabili
elseif variable == "remove_all" then
  ui.fRemoveAllVariables();
  ui.fEcho2n("Tutte le variabili sono state eliminate.")
-- Mostra la singola variabile
elseif value == nil or value == "" then
  if ui.variables[variable] then
    ui.fEcho2n(ui.fGetVarFormattedText(variable))
  else
    ui.fEcho2n("La variabile "..ui.fGetVarNameFormattedText(variable).." non esiste.")
  end
-- Rimuove la singola variabile
elseif value == "remove" then
  if not ui.variables[variable] then
    ui.fEcho2n("La variabile "..ui.fGetVarNameFormattedText(variable).." non esiste.")
  elseif table.contains(ui.pre_defined_variables, variable) then
    ui.variables[variable] = ""
    ui.fEcho2n("La variabile predefinita "..ui.fGetVarNameFormattedText(variable).." è stata pulita.")
  else
    ui.variables[variable] = nil
    ui.fEcho2n("La variabile "..ui.fGetVarNameFormattedText(variable).." e' stata rimossa.")
  end
-- Crea o modifica la variabile
else
  if (ui.variables[variable])then
    ui.variables[variable] = value
    ui.fEcho2n('La variabile è stata aggiornata: '..ui.fGetVarFormattedText(variable))
  else
    ui.variables[variable] = value
    ui.fEcho2n('La variabile è stata creata: '..ui.fGetVarFormattedText(variable))
  end
end
if (variable and variable == "target") then
  ui.fUpdateAllTargetButton()
  ui.fUpdateTarget()
end
table.save(ui.fileVariables, ui.variables)</script>
			<command></command>
			<packageName></packageName>
			<regex>^(?i)(?:uiv(?:a(?:r(?:i(?:a(?:b(?:l(?:e)?)?)?)?)?)?)?|@)(?:\s*@?(\w+)(?:\s*)?(.*))?$</regex>
		</Alias>
	</AliasPackage>
	<ActionPackage />
	<ScriptPackage>
		<ScriptGroup isActive="yes" isFolder="yes">
			<name>Functions</name>
			<packageName></packageName>
			<script></script>
			<eventHandlerList />
			<Script isActive="yes" isFolder="no">
				<name>Affects</name>
				<packageName></packageName>
				<script>function ui.fUpdateAffects()
  local x = 0
  local y = 0
  local i
  local orderTable = {}
  -- Simulation (for debug)
  if (ui.enDebug) then
    for i=1, 20 do
      if (ui.actAffects["affect_"..i] == nil) then
        ui.actAffects["affect_"..i] = i*2
      end
    end
  end
  -- Order Affects
  for affect in pairs(ui.actAffects) do
    orderTable[#orderTable+1] = affect
  end
  table.sort(orderTable, function (affect1, affect2) 
                           return ui.actAffects[affect1] &lt; ui.actAffects[affect2]
                         end )
  --
  i = 0;
  for j,affect in ipairs(orderTable) do
    if (ui.actAffects[affect] &lt; 0) then
      ui.actAffects[affect] = nil
    elseif (i&lt;20) then
      local color
      -- Duration color
      if (ui.actAffects[affect] == 0) then
        color = "red"
      elseif (ui.actAffects[affect] == 1) then
        color = "orange"
      elseif  (ui.actAffects[affect] == 2) then
        color = "yellow"
      else
        color = "green"
      end
      i = i + 1
      -- Duration
      GUI["AffectIcon"..i].time:setFontSize(6);
      GUI["AffectIcon"..i].time:setFgColor(color)
      GUI["AffectIcon"..i].time:echo("&lt;center&gt;"..ui.actAffects[affect])
      local CCS = GUI.CSS.AffectIcon
      if table.contains(ui.affects, affect) then
        -- Icon
        if (ui.affects[affect].icon) and (io.exists(ui.pathIcn..ui.affects[affect].icon)) then
          CCS = GUI.CSS.AffectIcon..[[
                  border-image: url("]]..ui.pathIcn..ui.affects[affect].icon..[[") 0px stretch;
                ]]
        -- BG Color
        elseif (ui.affects[affect].color) then
          CCS = GUI.CSS.AffectIcon..[[
                  background-color: qradialgradient(spread:pad, cx:0.5, cy:0, radius:1, fx:0.5, fy:0, stop:0 white, stop:1 "]]..ui.affects[affect].color..[[");
                ]]
        else
          CCS = GUI.CSS.AffectIcon..[[
                  background-color: qradialgradient(spread:pad, cx:0.5, cy:0, radius:1, fx:0.5, fy:0, stop:0 rgba(61, 174, 219, 255), stop:1 rgba(27, 87, 141, 255));;
                ]]
        end
        -- ShortName
        if (ui.affects[affect].shortName) then
          GUI["AffectIcon"..i].icon:echo(ui.affects[affect].shortName)
        else
          GUI["AffectIcon"..i].icon:echo(affect:sub(1, 5))
        end
      else
        CCS = GUI.CSS.AffectIcon..[[
                background-color: qradialgradient(spread:pad, cx:0.5, cy:0, radius:1, fx:0.5, fy:0, stop:0 white, stop:1 grey);
              ]]
        GUI["AffectIcon"..i].icon:echo(affect:sub(1, 5))
      end
      -- StyleSheet
      GUI["AffectIcon"..i].icon:setStyleSheet(CCS)
      GUI["AffectIcon"..i].icon:setFgColor("black");
      GUI["AffectIcon"..i].icon:setFontSize(5);
      -- ToolTip
      GUI["AffectIcon"..i]:setToolTip(affect, 10)
      -- Position
      GUI["AffectIcon"..i]:move(x, y)
      -- Show if inside box
      if (y&lt;=GUI.Affect.Main.Body:get_height() - 20) then
        GUI["AffectIcon"..i]:show();
      else
        GUI["AffectIcon"..i]:hide();
      end
      --
      if (x &gt; GUI.Affect.Main.Body:get_width() - 60) then
        x = 0
        y = y + 32
      else
        x = x + 32
      end
    end
  end
  -- Hide not used affects
  for i=i+1, 20 do
    if (GUI["AffectIcon"..i]) then
      GUI["AffectIcon"..i]:hide();
    end
  end
end
--
function ui.fTickUpdateAffects()
  ui.fDebug("ui.fTickUpdateAffects()");
  for affect in pairs(ui.actAffects) do
    ui.actAffects[affect] = ui.actAffects[affect] - 1
  end
  ui.fUpdateAffects()
end</script>
				<eventHandlerList />
			</Script>
			<Script isActive="yes" isFolder="no">
				<name>Alias buttons</name>
				<packageName></packageName>
				<script>--
function ui.fGetAliasButtonFormattedText(button)
  return ui.cAliasButton.."["..button.."]".."&lt;reset&gt;"
end
--
function ui.fSearchAliasButton(button)
  local type, number = ui.fExpandButton(button)
  if (type == "a") or (type == "b") or (type == "c") then
    button = type..number
    for alias in pairs(ui.aliases) do
      if (ui.aliases[alias].button) and (ui.aliases[alias].button==button) then
        return alias
      end
    end
  end
  return nil
end
--
-- List all alias buttons
function ui.fShowAllAliasButtons()
  local i = 0
  cecho(ui.fTitle("Pulsanti alias"))
  for alias in ui.fOrderedPairs(ui.aliases) do
    if (ui.aliases[alias].button) then
      i = i + 1
      cecho(ui.fGetNumberFormattedText(i).." "..ui.fGetAliasFormattedText(alias).."\n")
    end
  end
  if (i&gt;0) then
    echo("\n")
  else
    cecho("Per maggiori info "..ui.fGetCommandFormattedText("ui.fHelp uibuttons").."\n\n")
  end
end
--
-- Remove alias button
function ui.fRemoveAliasButton(button)
  local ret = 0;
  local type, number = ui.fExpandButton(button)
  if (type == "a") or (type == "b") or (type == "c") then
    button = type..number 
    local alias = ui.fSearchAliasButton(button)
    if (alias) then
      ui.aliases[alias].button = nil
      return 1
    end
    return -2 -- Not alias assigned
  end
  return -1 -- Invaid button
end
--
-- Remove all alias button
function ui.fRemoveAllAliasButtons()
  for alias in pairs(ui.aliases) do
    if (ui.aliases[alias].button) then
      ui.aliases[alias].button = nil
    end
  end
end
--
-- Assign alias button
function ui.fAssignAliasButton(button, alias)
  local ret = 0;
  local type, number = ui.fExpandButton(button)
  if (type == "a") or (type == "b") or (type == "c") then
    button = type..number
    if (ui.aliases[alias]) then
      ui.fRemoveAliasButton(button)
      ui.aliases[alias].button = button
      return 1
    end
    return -2 -- Alias not exist
  end
  return -1 -- Invaid button
end
--
function ui.fExecuteAliasButton(button)
  local alias = nil;
  local type, number = ui.fExpandButton(button)
  if (type == "a") or (type == "b") or (type == "c") then
    button = type..number
    alias = ui.fSearchAliasButton(button)
    if (alias) then
      expandAlias(alias, false)
    else
      ui.fEcho2n(ui.fGetAliasButtonFormattedText(button).." non configurato. Usare il comanto "..ui.fGetCommandFormattedText(button.." &lt;alias&gt;").." per configurare.")
    end
  end
  return alias
end
--
function ui.fRefreshAliasButton(number)
  local found = nil;
  local bgColor
  local title = ""
  local keybind = ""
  local button = ui.parameters.page..number
  for alias in pairs(ui.aliases) do
    if (ui.aliases[alias].button) and (ui.aliases[alias].button==button) then
      found = alias
      break
    end
  end
  if (ui.parameters.page == "a") then
    bgColor = "200,0,0"
  elseif (ui.parameters.page == "b") then
    bgColor = "0,200,0"
  elseif (ui.parameters.page == "c") then
    bgColor = "0,0,200"
  end
  if (found) then
    title = found
    keybind = ui.aliases[found].keybind or ""
  end
  GUI.AliasButtons.Main.Body.CButtons["Custom"..number].index:echo("&lt;center&gt;"..ui.parameters.page..number)
  GUI.AliasButtons.Main.Body.CButtons["Custom"..number].icon:echo("&lt;center&gt;"..title)
  GUI.AliasButtons.Main.Body.CButtons["Custom"..number].keybind:echo("&lt;center&gt;"..keybind)
  GUI.AliasButtons.Main.Body.CButtons["Custom"..number]:setStyleSheet([[
    QLabel{
      background-color: rgba(]]..bgColor..[[,.5);
      ]]..GUI.CSS.AliasButtons..[[
    }
    QLabel::hover{
      background-color: rgba(]]..bgColor..[[,1);
    }
  ]])
  GUI.AliasButtons.Main.Body.CButtons["Custom"..number].icon:setStyleSheet(GUI.CSS.ButtonsIcon)
end
--
function ui.fUpdateAllAliasButton()
  for i = 0, 9 do
    ui.fRefreshAliasButton(i)
  end
end
--
function ui.fClickAliasButton(number)
  local button = ui.parameters.page..number
  ui.fExecuteAliasButton(button)
end
--
-- Incrase page index
function ui.fIncraseButtonsPage()
  ui.parameters.page = ui.parameters.page or "";
  if (ui.parameters.page == "a") then
    ui.parameters.page = "b"
  elseif (ui.parameters.page == "b") then
    ui.parameters.page = "c"
  else
    ui.parameters.page = "a"
  end
  table.save(ui.fileParameters, ui.parameters)
  GUI.AliasButtons.Main.Body.Navigator.Page:echo("&lt;center&gt;"..ui.parameters.page)
  ui.fUpdateAllAliasButton()
end
--
-- Decrase page index
function ui.fDecraseButtonsPage()
  ui.parameters.page = ui.parameters.page or "";
  if (ui.parameters.page == "a") then
    ui.parameters.page = "c"
  elseif (ui.parameters.page == "c") then
    ui.parameters.page = "b"
  else
    ui.parameters.page = "a"
  end
  table.save(ui.fileParameters, ui.parameters)
  GUI.AliasButtons.Main.Body.Navigator.Page:echo("&lt;center&gt;"..ui.parameters.page)
  ui.fUpdateAllAliasButton()
end</script>
				<eventHandlerList />
			</Script>
			<Script isActive="yes" isFolder="no">
				<name>Aliases</name>
				<packageName></packageName>
				<script>--
function ui.fGetAliasNameFormattedText(alias)
  return ui.cAliasName..alias.."&lt;reset&gt;"
end
--
function ui.fGetAliasOutputFormattedText(command, input)
  if (command) then
    input = input or ""
    -- Add same spaces between commands
    command = string.gsub(command, "(%s*/%s*)", " / ")
    command = string.gsub(command, "(%s*;%s*)", "; ")
    -- Format Aliases
    command = string.gsub(command, "^(%w+)", function(str)
                                               if ui.aliases[str] then
                                                 return ui.fGetAliasNameFormattedText(str)..ui.cAliasOutput
                                               end
                                             end)
    command = string.gsub(command, "/ (%w+)", function(str)
                                                if ui.aliases[str] then
                                                  return "/ "..ui.fGetAliasNameFormattedText(str)..ui.cAliasOutput
                                                end
                                              end)
    command = string.gsub(command, "; (%w+)", function(str)
                                                if ui.aliases[str] then
                                                  return "; "..ui.fGetAliasNameFormattedText(str)..ui.cAliasOutput
                                                end
                                              end)
    -- Format Variables
    command = string.gsub(command, ui.varID.."(%w+)", function(str)
                                                        if not ui.variables[str] then
                                                          return ui.fGetVarNameFormattedText(str)..ui.fGetOperatorFormattedText("(")..ui.cError.."Variabile non trovata!"..ui.fGetOperatorFormattedText(")")..ui.cAliasOutput
                                                        else
                                                          return ui.fGetVarFormattedText(str)..ui.cAliasOutput
                                                        end
                                                      end)
    -- Format commands separator
    command = string.gsub(command, ";", ui.cSeparator..";"..ui.cAliasOutput)
    command = string.gsub(command, "/", ui.cSeparator.."/"..ui.cAliasOutput)
    -- Format input command
    command = string.gsub(command, "#", ui.fGetInputFormattedText("#"..input)..ui.cAliasOutput)
    --
    return ui.cAliasOutput..command.."&lt;reset&gt;"
  end
  return ""
end
--
function ui.fGetAliasFormattedText(alias)
  local ret = ""
  if (ui.aliases[alias]) then
    ret = ui.fGetAliasNameFormattedText(alias).." "..ui.fGetOperatorFormattedText("»").." "..ui.fGetAliasOutputFormattedText(ui.aliases[alias].text)
    if (ui.aliases[alias].keybId) then
      ret = ui.fGetKeybFormattedText(ui.aliases[alias].keybind).." "..ret
    end
    if (ui.aliases[alias].button) then
      ret = ui.fGetAliasButtonFormattedText(ui.aliases[alias].button).." "..ret
    end
  end
  return ret
end
--
-- List all aliases
function ui.fShowAllAliases()
  local i = 0
  cecho(ui.fTitle("Aliases"))
  for alias in ui.fOrderedPairs(ui.aliases) do
    i = i + 1
    cecho(ui.fGetNumberFormattedText(i).." "..ui.fGetAliasFormattedText(alias).."\n")
  end
  if (i&gt;0) then
    echo("\n")
  else
    cecho("Per maggiori info "..ui.fGetCommandFormattedText("ui.fHelp uialias").."\n\n")
  end
end
--
function ui.fRemoveAlias(alias)
  if (ui.aliases[alias]) then
    ui.fRemoveKeyb(ui.aliases[alias]);
    if (ui.aliases[alias]["id"]) then
      killAlias(ui.aliases[alias]["id"])
    end
    ui.aliases[alias] = nil
    return true
  end
  return false
end
--
function ui.fRemoveAllAliases()
  for alias in pairs(ui.aliases) do
    ui.fRemoveAlias(alias)
  end
  ui.aliases = {}
end
--
function ui.fAddAlias(alias, value)
  local command
  local commands, varNameError = ui.fExpandVariables(value, true)
  if (not varNameError) then
    -- Init alias (if no exist)
    ui.aliases[alias] = ui.aliases[alias] or {}
    -- Remove old alias
    if (ui.aliases[alias].id) then
      killAlias(ui.aliases[alias].id)
    end
    -- Save value in text format
    ui.aliases[alias].text = value
    -- Generate alias code
    local code = [[
ui.levelCode = (ui.levelCode or -1) + 1
if (ui.levelCode &gt; 20) then
  ui.levelCode = ui.levelCode -1
  ui.fError("Stack overflow protection.")
  return
end
--
matches = matches or {}
local __mtchs2__ = matches[2] or ""
]]
    commands = ui.fExpandCommand(value)
    if (#commands == 1) then
      -- Single command
      command = ui.fExpandVariables(value, true)
      if (string.match(command, "__mtchs2__")) then
        code = code..[[
-- Single command with #
ui.fEchon(ui.fGetAliasOutputFormattedText("]]..value..[[", __mtchs2__), ui.levelCode);
expandAlias("]]..command..[[", false);
]]
      else
        -- Search for variables in command
        local last_variable = ""
        local last_expanded_variable = ""
        for variable in string.gfind(command, "ui.variables%.%w+") do
          last_variable = string.gsub(variable, "ui.variables%.", "@")
          last_expanded_variable = variable
        end
        if (last_variable == "") then
          -- If not variables in comman, add matches[2]
          code = code..[[
-- Single command without # and without variables
if (__mtchs2__ == "") then
  ui.fEchon(ui.fGetAliasOutputFormattedText("]]..value..[["), ui.levelCode);
  expandAlias("]]..command..[[", false);
else
  -- Append matches[2]
  ui.fEchon(ui.fGetAliasOutputFormattedText("]]..value..[[ #", __mtchs2__), ui.levelCode);
  expandAlias("]]..command..[[".." "..__mtchs2__, false);
end
]]
        else
          -- If variables in command, replace last variable with matches[2]
          local command_matches = string.gsub(command, last_expanded_variable, "__mtchs2__")
          code = code..[[
-- Single command without # but with variables
if (__mtchs2__ == "") then
  ui.fEchon(ui.fGetAliasOutputFormattedText("]]..value..[["), ui.levelCode);
  expandAlias("]]..command..[[", false);
else
  -- Replace last variable with matches[2]
  ui.fEchon(ui.fGetAliasOutputFormattedText("]]..string.gsub(value, last_variable, "#")..[[", __mtchs2__), ui.levelCode);
  expandAlias("]]..command_matches..[[", false);
end
]]
        end
      end
    else
      -- Multiple commands
      code = code..[[
-- Multiple commands
]]
      for _, cmd in ipairs(commands) do
        command = ui.fExpandVariables(cmd, true)
        code = code..[[
ui.fEchon(ui.fGetAliasOutputFormattedText("]]..cmd..[[", __mtchs2__), ui.levelCode);
expandAlias("]]..command..[[", false);
]]
      end
    end
    code = code..[[
--
ui.levelCode = math.max(-1, ui.levelCode - 1)
]]
    -- Save alias code (for debug only)
    ui.aliases[alias].code = code
    -- Assign keybind
    local mod1 = ui.aliases[alias].mod1 or "";
    local mod2 = ui.aliases[alias].mod2 or "";
    local key = ui.aliases[alias].key or "";
    local result, keybind
    if (mod2 ~= "") then
      result, keybind = ui.fSetKeyb(ui.aliases, alias, ui.aliases[alias].code, mod2, mod1, key)
    elseif (mod1 ~= "") then
      result, keybind = ui.fSetKeyb(ui.aliases, alias, ui.aliases[alias].code, mod1, key)
    elseif (key ~= "") then
      result, keybind = ui.fSetKeyb(ui.aliases, alias, ui.aliases[alias].code, key)
    else
      result, keybind = ui.fSetKeyb(ui.aliases, alias, ui.aliases[alias].code)
    end
    -- Remove keybind if not valid (or already used)
    if (result &lt;= 0) then
      ui.fRemoveKeyb(ui.aliases[alias])
    end
    -- Create alias
    ui.aliases[alias].id = tempAlias([[^]]..alias..[[(?: (.*))?$]], code)
    return 1, ui.fGetAliasFormattedText(alias)
  end
  return -1, varNameError  -- Variable not exist
end
--
-- Save aliases data from file
function ui.fSaveFileAliases()
  local aliasesDataToSave = {}
  for alias in pairs(ui.aliases) do
    aliasesDataToSave[alias] = {}
    aliasesDataToSave[alias].text = ui.aliases[alias].text
    aliasesDataToSave[alias].mod1 = ui.aliases[alias].mod1
    aliasesDataToSave[alias].mod2 = ui.aliases[alias].mod2
    aliasesDataToSave[alias].key = ui.aliases[alias].key
    aliasesDataToSave[alias].button = ui.aliases[alias].button
  end
  table.save(ui.fileAliases, aliasesDataToSave)
end
--
-- Read Aliases data from file
function ui.fReadFileAliases()
  -- Remove actual Aliases
  ui.aliases = ui.aliases or {}
  ui.fRemoveAllAliases()
  -- Load Aliases
  if (io.exists(ui.fileAliases)) then
    table.load(ui.fileAliases, ui.aliases)
  end
  --
  -- Create Aliases
  for alias in pairs(ui.aliases) do
    ui.fAddAlias(alias, ui.aliases[alias].text)
  end
end</script>
				<eventHandlerList />
			</Script>
			<Script isActive="yes" isFolder="no">
				<name>Border</name>
				<packageName></packageName>
				<script>function ui.fAddBorder(sender, border)
  if (sender) then
    border = border or 1
    if (border == 1) then
      sender.LT = Geyser.Label:new2({name = sender.name .. "LT", x = 0, y = 0, width = 20, height = 20 }, sender)
      sender.LT:setStyleSheet([[background-color: rgba(30, 24, 24, 100%); background-image: url("]]..ui.pathImg..[[frameBorderLT.png")]]);
      sender.LT:enableClickthrough()
      sender.T1 = Geyser.Label:new2({name = sender.name .. "T1", x = 20, y = 0, width = 40, height = 20 }, sender)
      sender.T1:setStyleSheet([[background-color: rgba(30, 24, 24, 100%); background-image: url("]]..ui.pathImg..[[frameBorderT1.png")]]);
      sender.T1:enableClickthrough()
      sender.T2 = Geyser.Label:new2({name = sender.name .. "T2", x = 60, y = 0, width = -60, height = 20 }, sender)
      sender.T2:setStyleSheet([[background-color: rgba(30, 24, 24, 100%); background-image: url("]]..ui.pathImg..[[frameBorderT2.png")]]);
      sender.T2:enableClickthrough()
      sender.T3 = Geyser.Label:new2({name = sender.name .. "T3", x = -60, y = 0, width = 40, height = 20 }, sender)
      sender.T3:setStyleSheet([[background-color: rgba(30, 24, 24, 100%); background-image: url("]]..ui.pathImg..[[frameBorderT3.png")]]);
      sender.T3:enableClickthrough()
      sender.RT = Geyser.Label:new2({name = sender.name .. "RT", x = -20, y = 0, width = 20, height = 20 }, sender)
      sender.RT:setStyleSheet([[background-color: rgba(30, 24, 24, 100%); background-image: url("]]..ui.pathImg..[[frameBorderRT.png")]]);
      sender.RT:enableClickthrough()
      sender.L1 = Geyser.Label:new2({name = sender.name .. "L1", x = 0, y = 20, width = 20, height = 40 }, sender)
      sender.L1:setStyleSheet([[background-color: rgba(30, 24, 24, 100%); background-image: url("]]..ui.pathImg..[[frameBorderL1.png")]]);
      sender.L1:enableClickthrough()
      sender.L2 = Geyser.Label:new2({name = sender.name .. "L2", x = 0, y = 60, width = 20, height = -60 }, sender)
      sender.L2:setStyleSheet([[background-color: rgba(30, 24, 24, 100%); background-image: url("]]..ui.pathImg..[[frameBorderL2.png")]]);
      sender.L2:enableClickthrough()
      sender.L3 = Geyser.Label:new2({name = sender.name .. "L3", x = 0, y = -60, width = 20, height = 40 }, sender)
      sender.L3:setStyleSheet([[background-color: rgba(30, 24, 24, 100%); background-image: url("]]..ui.pathImg..[[frameBorderL3.png")]]);
      sender.L3:enableClickthrough()
      sender.Body = Geyser.Label:new2({name = sender.name .. "Body", x = 20, y = 20, width = -20, height = -20}, sender)
      sender.Body:setStyleSheet([[background-color: rgba(30, 24, 24, 100%)]]);
      sender.Body:enableClickthrough()
      sender.R1 = Geyser.Label:new2({name = sender.name .. "R1", x = -20, y = 20, width = 20, height = 40}, sender)
      sender.R1:setStyleSheet([[background-color: rgba(30, 24, 24, 100%); background-image: url("]]..ui.pathImg..[[frameBorderR1.png")]]);
      sender.R1:enableClickthrough()
      sender.R2 = Geyser.Label:new2({name = sender.name .. "R2", x = -20, y = 60, width = 20, height = -60 }, sender)
      sender.R2:setStyleSheet([[background-color: rgba(30, 24, 24, 100%); background-image: url("]]..ui.pathImg..[[frameBorderR2.png")]]);
      sender.R2:enableClickthrough()
      sender.R3 = Geyser.Label:new2({name = sender.name .. "R3", x = -20, y = -60, width = 20, height = 40 }, sender)
      sender.R3:setStyleSheet([[background-color: rgba(30, 24, 24, 100%); background-image: url("]]..ui.pathImg..[[frameBorderR3.png")]]);
      sender.R3:enableClickthrough()
      sender.LB = Geyser.Label:new2({name = sender.name .. "LB", x = 0, y = -20, width = 20, height = 20}, sender)
      sender.LB:setStyleSheet([[background-color: rgba(30, 24, 24, 100%); background-image: url("]]..ui.pathImg..[[frameBorderLB.png")]]);
      sender.LB:enableClickthrough()
      sender.B1 = Geyser.Label:new2({name = sender.name .. "B1", x = 20, y = -20, width = 40, height = 20}, sender)
      sender.B1:setStyleSheet([[background-color: rgba(30, 24, 24, 100%); background-image: url("]]..ui.pathImg..[[frameBorderB1.png")]]);
      sender.B1:enableClickthrough()
      sender.B2 = Geyser.Label:new2({name = sender.name .. "B2", x = 60, y = -20, width = -60, height = 20 }, sender)
      sender.B2:setStyleSheet([[background-color: rgba(30, 24, 24, 100%); background-image: url("]]..ui.pathImg..[[frameBorderB2.png")]]);
      sender.B2:enableClickthrough()
      sender.B3 = Geyser.Label:new2({name = sender.name .. "B3", x = -60, y = -20, width = 40, height = 20 }, sender)
      sender.B3:setStyleSheet([[background-color: rgba(30, 24, 24, 100%); background-image: url("]]..ui.pathImg..[[frameBorderB3.png")]]);
      sender.B3:enableClickthrough()
      sender.RB = Geyser.Label:new2({name = sender.name .. "RB", x = -20, y = -20, width = 20, height = 20}, sender)
      sender.RB:setStyleSheet([[background-color: rgba(30, 24, 24, 100%); background-image: url("]]..ui.pathImg..[[frameBorderRB.png")]]);
      sender.RB:enableClickthrough()
    elseif (border == 2) then
      sender.LT = Geyser.Label:new2({name = sender.name .. "LT",x = 0, y = 0, width = 15, height = 15},sender)
      sender.LT:setStyleSheet([[background-color: rgba(30, 24, 24, 100%); background-image: url("]]..ui.pathImg..[[footerBorderLT.png")]]);
      sender.LT:enableClickthrough()
      sender.T = Geyser.Label:new2({name = sender.name .. "T",x = 15, y = 0, width = -15, height = 15},sender)
      sender.T:setStyleSheet([[background-color: rgba(30, 24, 24, 100%); background-image: url("]]..ui.pathImg..[[footerBorderT.png")]]);
      sender.T:enableClickthrough()
      sender.RT = Geyser.Label:new2({name = sender.name .. "RT",x = -15, y = 0, width = 15, height = 15},sender)
      sender.RT:setStyleSheet([[background-color: rgba(30, 24, 24, 100%); background-image: url("]]..ui.pathImg..[[footerBorderRT.png")]]);
      sender.RT:enableClickthrough()
      sender.L = Geyser.Label:new2({name = sender.name .. "L",x = 0, y= 15, width = 15, height = -15},sender)
      sender.L:setStyleSheet([[background-color: rgba(30, 24, 24, 100%); background-image: url("]]..ui.pathImg..[[footerBorderL.png")]]);
      sender.L:enableClickthrough()
      sender.Body = Geyser.Label:new2({name = sender.name .. "Body",x = 15, y = 15, width = -15, height = -15},sender)
      sender.Body:setStyleSheet([[background-image: url("]]..ui.pathImg..[[footerBody.png")]]);
      sender.Body:enableClickthrough()
      sender.R = Geyser.Label:new2({name = sender.name .. "R",x = -15, y = 15, width = 15, height = -15},sender)
      sender.R:setStyleSheet([[background-color: rgba(30, 24, 24, 100%); background-image: url("]]..ui.pathImg..[[footerBorderR.png")]]);
      sender.R:enableClickthrough()
      sender.LB = Geyser.Label:new2({name = sender.name .. "LB",x = 0, y = -15, width = 15, height = 15},sender)
      sender.LB:setStyleSheet([[background-color: rgba(30, 24, 24, 100%); background-image: url("]]..ui.pathImg..[[footerBorderLB.png")]]);
      sender.LB:enableClickthrough()
      sender.B = Geyser.Label:new2({name = sender.name .. "B",x = 15, y = -15, width = -15, height = 15},sender)
      sender.B:setStyleSheet([[background-color: rgba(30, 24, 24, 100%); background-image: url("]]..ui.pathImg..[[footerBorderB.png")]]);
      sender.B:enableClickthrough()
      sender.RB = Geyser.Label:new2({name = sender.name .. "RB",x = -15, y = -15, width = 15, height = 15},sender)
      sender.RB:setStyleSheet([[background-color: rgba(30, 24, 24, 100%); background-image: url("]]..ui.pathImg..[[footerBorderRB.png")]]);
      sender.RB:enableClickthrough()
    elseif (border == 3) then
      sender.Body = Geyser.Label:new2({name = sender.name .. "Body",x = 0, y = 0, width = "100%", height = "100%"}, sender)
      sender.Body:setStyleSheet(GUI.CSS.Border3);
      sender.Body:enableClickthrough()
    end
  end
end</script>
				<eventHandlerList />
			</Script>
			<Script isActive="yes" isFolder="no">
				<name>Colors</name>
				<packageName></packageName>
				<script>--
-- Coded by Mudlet community developer demonnic
-- internal sorting function, sorts first by hue, then luminosity, then value
local sortColorsByHue = function(lhs, rhs)
  local lh, ll, lv = unpack(lhs.sort)
  local rh, rl, rv = unpack(rhs.sort)
  if lh &lt; rh then
    return true
  elseif lh &gt; rh then
    return false
  elseif ll &lt; rl then
    return true
  elseif ll &gt; rl then
    return false
  else
    return lv &lt; rv
  end
end
--
-- Internal sorting function, removes _ from snake_case and compares to camelCase
local sortColorsByName = function(a, b)
  local aname = string.gsub(string.lower(a.name), "_", "")
  local bname = string.gsub(string.lower(b.name), "_", "")
  return aname &lt; bname
end
--
-- Internal function used to turn sorted colors table into columns
local chunkify = function(tbl, num_chunks)
  local pop =
    function(t)
      return table.remove(t, 1)
    end
  local tbl = table.deepcopy(tbl)
  local tblsize = #tbl
  local base_chunk_size = tblsize / num_chunks
  local chunky_chunks = tblsize % num_chunks
  local chunks = {}
  for i = 1, num_chunks do
    local chunk_size = base_chunk_size
    if i &lt;= chunky_chunks then
      chunk_size = chunk_size + 1
    end
    local chunk = {}
    for j = 1, chunk_size do
      chunk[j] = pop(tbl)
    end
    chunks[i] = chunk
  end
  return chunks
end
--
-- internal function, converts rgb to hsv
-- found at https://github.com/EmmanuelOga/columns/blob/master/utils/color.lua#L89
local rgbToHsv = function(r, g, b)
  r, g, b = r / 255, g / 255, b / 255
  local max, min = math.max(r, g, b), math.min(r, g, b)
  local h, s, v
  v = max
  local d = max - min
  if max == 0 then
    s = 0
  else
    s = d / max
  end
  if max == min then
    h = 0
    -- achromatic
  else
    if max == r then
      h = (g - b) / d
      if g &lt; b then
        h = h + 6
      end
    elseif max == g then
      h = (b - r) / d + 2
    elseif max == b then
      h = (r - g) / d + 4
    end
    h = h / 6
  end
  return h, s, v
end
--
-- internal stepping function, removes some of the noise for a more pleasing sort
-- cribbed from the python on https://www.alanzucconi.com/2015/09/30/colour-sorting/
local step = function(r, g, b)
  local lum = math.sqrt(.241 * r + .691 * g + .068 * b)
  local reps = 8
  local h, s, v = rgbToHsv(r, g, b)
  local h2 = math.floor(h * reps)
  local lum2 = math.floor(lum * reps)
  local v2 = math.floor(v * reps)
  if h2 % 2 == 1 then
    v2 = reps - v2
    lum2 = reps - lum2
  end
  return h2, lum2, v2
end
--
local function calc_luminosity(r, g, b)
  r = r &lt; 11 and r / (255 * 12.92) or ((0.055 + r / 255) / 1.055) ^ 2.4
  g = g &lt; 11 and g / (255 * 12.92) or ((0.055 + g / 255) / 1.055) ^ 2.4
  b = b &lt; 11 and b / (255 * 12.92) or ((0.055 + b / 255) / 1.055) ^ 2.4
  return (0.2126 * r) + (0.7152 * g) + (0.0722 * b)
end
--
local function include(color, options)
  if options.removeDupes then
    if string.find(color, "_") or string.find(color:lower(), 'gray') then
      return false
    else
      return true
    end
  else
    if string.find(color, "ansi_%d%d%d") then
      return false
    else
      return true
    end
  end
end
--
local function echoColor(color, options)
  local rgb = color.rgb
  local fgc = "white"
  if calc_luminosity(unpack(rgb)) &gt; 0.5 then
    fgc = "black"
  end
  local colorString
  if options.justText then
    colorString = string.format('&lt;%s:%s&gt; %-23s&lt;reset&gt; ', color.name, 'black', color.name, spacer)
  else
    colorString = string.format('&lt;%s:%s&gt; %-23s&lt;reset&gt; ', fgc, color.name, color.name)
  end
  if options.window == "main" then
    if options.echoOnly then
      cecho(colorString)
    else
      cechoLink(
        colorString, [[appendCmdLine("]]..color.name..[[")]], table.concat(rgb, ", "), true
      )
    end
  else
    if options.echoOnly then
      cecho(options.window, colorString)
    else
      cechoLink(
        options.window,
        colorString,
        [[appendCmdLine("]]..color.name..[[")]],
        table.concat(rgb, ", "),
        true
      )
    end
  end
end
--
function ui.fDisplayColors(options)
  local options = options or {}
  local optionsType = type(options)
  assert(
    optionsType == "table",
    "ui.fDisplayColors(options) argument error: options as table expects, got "..optionsType
  )
  options.cols = options.cols or 4
  options.search = options.search or ""
  options.sort = options.sort or false
  if options.removeDupes == nil then
    options.removeDupes = true
  end
  if options.columnSort == nil then
    options.columnSort = true
  end
  if type(options.window) == "table" then
    options.window = options.window.name
  end
  options.window = options.window or "main"
  local color_table = options.color_table or color_table
  local cols, search, sort = options.cols, options.search, options.sort
  local colors = {}
  for k, v in pairs(color_table) do
    local color = {}
    color.rgb = v
    color.name = k
    color.sort = {step(unpack(v))}
    if include(k, options) and k:lower():find(search) then
      table.insert(colors, color)
    end
  end
  if sort then
    table.sort(colors, sortColorsByName)
  else
    table.sort(colors, sortColorsByHue)
  end
  if options.columnSort then
    local columns_table = chunkify(colors, cols)
    local lines = #columns_table[1]
    for i = 1, lines do
      for j = 1, cols do
        local color = columns_table[j][i]
        if color then
          echoColor(color, options)
        end
      end
      echo(options.window, "\n")
    end
  else
    local i = 1
    for _, k in ipairs(colors) do
      echoColor(k, options)
      if i == cols then
        echo(options.window, "\n")
        i = 1
      else
        i = i + 1
      end
    end
    if i ~= 1 then
      echo(options.window, "\n")
    end
  end
end
--
-- Check color
function ui.fColorCheck(color)
  local color = color:lower()
  color = color:gsub("_", "")
  for color_name, _ in pairs(color_table) do
    if color_name:lower() == color then
      return color_name
    end
  end
  return false
end
</script>
				<eventHandlerList />
			</Script>
			<Script isActive="yes" isFolder="no">
				<name>Generic</name>
				<packageName></packageName>
				<script>--
function ui.fClickTarget(sender)
  if (sender) then
    local type, number = ui.fExpandButton(sender)
    if (type == "g") or (type == "o") then
      ui.fExecuteTargetButton(sender)
    end
  end
end
--
function ui.fGenOrderedIndex( t )
  local orderedIndex = {}
  for key in pairs(t) do
    table.insert(orderedIndex, key)
  end
  table.sort(orderedIndex)
  return orderedIndex
end
--
function ui.fOrderedNext(t, state)
  -- Equivalent of the next function, but returns the keys in the alphabetic
  -- order. We use a temporary ordered key table that is stored in the
  -- table being iterated.
  local key = nil
  if state == nil then
    -- the first time, generate the index
    t.__orderedIndex = ui.fGenOrderedIndex(t)
    key = t.__orderedIndex[1]
  else
    -- Fetch the next value
    for i = 1,table.getn(t.__orderedIndex) do
      if t.__orderedIndex[i] == state then
        key = t.__orderedIndex[i+1]
      end
    end
  end
  if key then
    return key, t[key]
  end
  -- No more value to return, cleanup
  t.__orderedIndex = nil
  return
end
--
function ui.fOrderedPairs(t, state)
  -- Equivalent of the pairs() function on tables. Allows to iterate in order
  return ui.fOrderedNext, t, state
end
--
function ui.fDebug(text)
  if ui.enDebug then
    ui.fEchon("&lt;orange&gt;- DEBUG - &lt;white&gt;("..getTime(true, "hh:mm:ss.zzz")..") "..ui.cText..text.."&lt;reset&gt;")
  end
end
--
function ui.fEcho(text)
  text = ui.echo..ui.cText..text.."&lt;reset&gt;"
  cecho(text)
end
--
function ui.fEchon(text, level)
  local tab = ""
  if (level) and (level &gt; 0) then 
    for i=2, level do
      tab = tab.."    "
    end
    tab = tab..ui.fGetOperatorFormattedText("  » ")
  end
  text = ui.echo..tab..ui.cText..text.."&lt;reset&gt;\n"
  cecho(text)
end
--
function ui.fEcho2n(text)
  text = ui.echo..ui.cText..text.."&lt;reset&gt;\n\n"
  cecho(text)
end
--
function ui.fError(text)
  text = ui.echo..ui.cError.."[ERRORE] "..ui.cText..text.."&lt;reset&gt;\n\n"
  cecho(text)
end
--
function ui.fDecho(text)
  text = copy2decho(ui.echo..ui.cText)..text..copy2decho("&lt;reset&gt;").."\n\n"
  decho(text)
end
--
function ui.fTitle(text)
  local title = "\n"..ui.echo..ui.cTitle..text.."\n"
  text = string.gsub(ui.echo..text, "\&lt;%a+\&gt;", "")
  for i=1, text:len() do
    title = title.."-"
  end
  title = title.."\n"
  return title
end
--
function ui.fGetNumberFormattedText(number)
  if (number &lt; 10) then
    return "&lt;white&gt;[&lt;steel_blue&gt; "..number.."&lt;white&gt;]".."&lt;reset&gt;"
  end
  return "&lt;white&gt;[&lt;steel_blue&gt;"..number.."&lt;white&gt;]".."&lt;reset&gt;"
end
--
function ui.fRemoveArticle(text)
  text = " "..text.." "
  text = string.gsub(text, "&gt;", "&gt; ")
  text = string.gsub(text, " con ", " ")
  text = string.gsub(text, " d'", " ")
  text = string.gsub(text, " da ", " ")
  text = string.gsub(text, " di ", " ")
  text = string.gsub(text, " dei ", " ")
  text = string.gsub(text, " del ", " ")
  text = string.gsub(text, " dell'", " ")
  text = string.gsub(text, " degli ", " ")
  text = string.gsub(text, " della ", " ")
  text = string.gsub(text, " delle ", " ")
  text = string.gsub(text, " dello ", " ")
  text = string.gsub(text, " gli ", " ")
  text = string.gsub(text, " i ", " ")
  text = string.gsub(text, " il ", " ")
  text = string.gsub(text, " Il ", " ")
  text = string.gsub(text, " in ", " ")
  text = string.gsub(text, " l'", " ")
  text = string.gsub(text, " la ", " ")
  text = string.gsub(text, " le ", " ")
  text = string.gsub(text, " lo ", " ")
  text = string.gsub(text, " un ", " ")
  text = string.gsub(text, " un'", " ")
  text = string.gsub(text, " una ", " ")
  text = string.gsub(text, " uno ", " ")
  text = string.gsub(text, " Uno ", " ")
  text = string.gsub(text, "&gt; ", "&gt;")
  text = string.trim(text)
  return text
end
--
function ui.fParsingItem(text)
  -- TODO: missing colors
  local statusColor = "&lt;128,128,128:30,24,24&gt;"
  if (string.find(text, "indistruttibil")) then
    text = string.gsub(text, "...E` indistruttibile!", "")
    text = string.gsub(text, "...Sono indistruttibili!", "")
    statusColor = "&lt;255,255,255:30,24,24&gt;"
  elseif (string.find(text, "in condizioni eccellenti")) then
    text = string.gsub(text, "...E` in condizioni eccellenti", "")
    text = string.gsub(text, "...Sono in condizioni eccellenti", "")
    statusColor = "&lt;128,128,128:30,24,24&gt;"
  elseif (string.find(text, "in ottime condizioni")) then
    text = string.gsub(text, "...&lt;r&gt;&lt;0,255,0:0,0,0&gt;E` in ottime condizioni&lt;r&gt;", "")
    text = string.gsub(text, "...&lt;r&gt;&lt;0,255,0:0,0,0&gt;Sono in ottime condizioni&lt;r&gt;", "")
    statusColor = "&lt;0,255,0:30,24,24&gt;"
  elseif (string.find(text, "danni superficiali")) then
    text = string.gsub(text, "...&lt;r&gt;&lt;255,255,0:0,0,0&gt;Presenta danni superficiali&lt;r&gt;", "")
    text = string.gsub(text, "...&lt;r&gt;&lt;255,255,0:0,0,0&gt;Presentano danni superficiali&lt;r&gt;", "")
    statusColor = "&lt;255,255,0:30,24,24&gt;"
  elseif (string.find(text, "danneggiat")) then
    text = string.gsub(text, "...&lt;r&gt;&lt;0,255,255:0,0,0&gt;E` danneggiato ed usurato&lt;r&gt;", "")
    text = string.gsub(text, "...&lt;r&gt;&lt;0,255,255:0,0,0&gt;Sono danneggiati ed usurati&lt;r&gt;", "")
    statusColor = "&lt;0,255,255:30,24,24&gt;"
  elseif (string.find(text, "in pessime condizioni")) then
    text = string.gsub(text, "...&lt;255,255,0:0,0,0&gt;E` in pessime condizioni", "")
    text = string.gsub(text, "...&lt;255,255,0:0,0,0&gt;Sono in pessime condizioni", "")
    statusColor = "&lt;255,255,0:30,24,24&gt;"
  elseif (string.find(text, "bisogno di essere riparat")) then
    text = string.gsub(text, "...&lt;255,0,0:0,0,0&gt;Ha bisogno di essere riparato", "")
    text = string.gsub(text, "...&lt;255,0,0:0,0,0&gt;Hanno bisogno di essere riparati", "")
    statusColor = "&lt;255,0,0:30,24,24&gt;"
  elseif (string.find(text, "per cadere in pezzi")) then
    text = string.gsub(text, "...Sta per cadere in pezzi", "")
    text = string.gsub(text, "...Stanno per cadere in pezzi", "")
    statusColor = "-TO DO-"
  elseif (string.find(text, "rompersi da un momento all'altro")) then
    text = string.gsub(text, "...Potrebbe rompersi da un momento all'altro!", "")
    text = string.gsub(text, "...Potrebbero rompersi da un momento all'altro!", "")
    statusColor = "&lt;128,0,0:30,24,24&gt;"
  elseif (string.find(text, "in frantumi. Inutilizzabil")) then
    text = string.gsub(text, "...E` in frantumi. Inutilizzabile!", "")
    text = string.gsub(text, "...Sono in frantumi. Inutilizzabili!", "")
    statusColor = "-TO DO-"
  end
  local good = string.find(text, "luce blu")
  if (good) then
    text = string.gsub(text, "...Ha un alone di &lt;r&gt;&lt;0,0,255:0,0,0&gt;luce blu&lt;r&gt;", "")
    text = string.gsub(text, "...Hanno un alone di &lt;r&gt;&lt;0,0,255:0,0,0&gt;luce blu&lt;r&gt;", "")
  end
  local evil = string.find(text, "luce rossa")
  if (evil) then
    text = string.gsub(text, "...Ha un alone di &lt;r&gt;&lt;255,0,0:0,0,0&gt;luce rossa&lt;r&gt;", "")
    text = string.gsub(text, "...Hanno un alone di &lt;r&gt;&lt;255,0,0:0,0,0&gt;luce rossa&lt;r&gt;", "")
  end
  local bright = string.find(text, "alone luminoso")
  if (bright) then
    text = string.gsub(text, "...Ha un &lt;r&gt;&lt;255,255,255:0,0,0&gt;alone luminoso&lt;r&gt;", "")
    text = string.gsub(text, "...Hanno un &lt;r&gt;&lt;255,255,255:0,0,0&gt;alone luminoso&lt;r&gt;", "")
  end
  local noisy = string.find(text, "forte ronzio")
  if (noisy) then
    text = string.gsub(text, "...Emette un &lt;r&gt;&lt;128,128,128:0,0,0&gt;forte ronzio&lt;r&gt;", "")
    text = string.gsub(text, "...Emettono un &lt;r&gt;&lt;128,128,128:0,0,0&gt;forte ronzio&lt;r&gt;", "")
  end
  local brittle = string.find(text, "molto fragil")
  if (brittle) then
    text = string.gsub(text, "...&lt;0,128,128:0,0,0&gt;Sembra molto fragile", "")
    text = string.gsub(text, "...&lt;0,128,128:0,0,0&gt;Sembrano molto fragili", "")
  end
  text = ui.fRemoveArticle(text)
  return text, statusColor, good, evil, bring, noisy, brittle
end
--
function ui.fExpandVariables(value, toAlias)
  if (toAlias) then
    value = string.gsub(value, "#", '"..__mtchs2__.."')
    value = string.gsub(value, ui.varID.."(%w+)", '"..ui.variables.%1.."')
  else
    value = string.gsub(value, ui.varID.."(%w+)", "ui.variables.%1")
  end
  --
  for varName in string.gfind(value, "ui.variables%.(%w+)") do
    if (not ui.variables[varName]) then
      return nil, varName
    elseif (not toAlias) then
      value = string.gsub(value, "ui.variables%.(%w+)", ui.variables[varName])
    end
  end
  return value, nil
end
--
function ui.fGetCommandFormattedText(command)
  return ui.cCommand..command.."&lt;reset&gt;"
end
--
function ui.fGetOperatorFormattedText(operator)
  return ui.cOperator..operator.."&lt;reset&gt;"
end
--
function ui.fGetInputFormattedText(input)
  return ui.cInput..input.."&lt;reset&gt;"
end
--
function ui.fExpandCommand(value)
  if string.match(value, "/") then
    return string.split(value, "%s*/%s*")
  end
  return string.split(value, "%s*;%s*")
end
--
-- Expand button name. Es. ui.fExpandButton("T5") -&gt; "t", 5
function ui.fExpandButton(button)
  local val = 0
  button = string.lower(button or "")
  if (string.find(button, "^[abcgot]%d$")) then
    return string.sub(button, 1, 1), tonumber(string.sub(button, 2, 2))
  end
  return nil, nil
end
--
function ui.fTitleCase(first, rest)
   return first:upper()..rest:lower()
end
--
function ui.fExecutePath(table, option)
  if (not option) then
    -- execute all
    for i = 1, #table do
      expandAlias(table[i])
    end
--[[    if (#table == 1) then
      -- Execute first (alone)
      expandAlias(table[1])
    else
      -- Show all
      for i = 1, #table do
        cecho(ui.fGetNumberFormattedText(i).." "..ui.fGetAliasOutputFormattedText(table[i]).."\n")
      end
    end
]]
  else
    local itemNumber = tonumber(option)
    if (itemNumber) then
      if (itemNumber == 0) then
        -- Show all
        for i = 1, #table do
          cecho(ui.fGetNumberFormattedText(i).." "..ui.fGetAliasOutputFormattedText(table[i]).."\n")
        end
      elseif (itemNumber &gt;= 1) and (itemNumber &lt;= #table) then
        expandAlias(table[itemNumber])
      else
        ui.fError("Indice non valido.")
      end
    else
      -- execute command for all (es. tell Pippo)
      for i = 1, #table do
        send(option.." "..i..") "..table[i]:gsub("(%s*;%s*)", " | "))
      end    
    end
  end
end
--
function ui.fDeleteDirectory(dir)
  local lfs = require('lfs')
  local deletedir
  deletedir = function(dir)
    for file in lfs.dir(dir) do
      local file_path = dir..'/'..file
      if file ~= "." and file ~= ".." then
        if lfs.attributes(file_path, 'mode') == 'file' then
          os.remove(file_path)
          print('remove file',file_path)
        elseif lfs.attributes(file_path, 'mode') == 'directory' then
          print('dir', file_path)
          deletedir(file_path)
        end
      end
    end
    lfs.rmdir(dir)
    print('remove dir',dir)
  end
  --
  deletedir(dir)
end
</script>
				<eventHandlerList />
			</Script>
			<Script isActive="yes" isFolder="no">
				<name>Group</name>
				<packageName></packageName>
				<script>--
function ui.fUpdateGroup()
  -- Show 10 members max
  local nGroupMembers = ui.enDebug and math.random(0, 12) or ui.totalMember
  local wndH = GUI.Group.Main.Body:get_height();
  local wndW = GUI.Group.Main.Body:get_width();
  local memberH = 55
  local memberW = 100;
  local nCol = 2;
  local nRow = 5;
  local i = 1
  local mod
  --
  if (nGroupMembers &lt;= math.floor(wndH / memberH)) then
    nCol = 1;
  end
  nRow = math.min(10/nCol, math.floor(wndH / memberH));
  memberW = wndW / nCol;
  --
  if nGroupMembers &gt; 10 then
    nGroupMembers = 10
  end
  --
  for r = 1, nRow do
    for c = 1, nCol do
      i = (r-1)*nCol + c; 
      mod = i % 10
      --
      GUI.Group.Main.Body["g"..mod]:resize(memberW-5, memberH-5)
      GUI.Group.Main.Body["g"..mod]:move((c-1)*memberW, (r-1)*memberH)
      if (i &gt; nGroupMembers) then
        GUI.Group.Main.Body["g"..mod]:hide();
        ui.fAssignTargetButton("g"..mod, nil)
      else
        local memberName = ui.enDebug and "D3Bu4 G"..i or (ui.group[i][1] or "")
        local isLeader = ui.enDebug and true or (ui.group[i][2] or false)
        local memberHp = ui.enDebug and math.random(0, 100) or (ui.group[i][3] or 0)
        local memberMana = ui.enDebug and math.random(0, 100) or (ui.group[i][4] or 0)
        local memberPow = ui.enDebug and math.random(0, 100) or (ui.group[i][5] or 0)
        --
        --GUI.Group.Main.Body["g"..mod].Health.front:echo(ansi2string(memberName))
        GUI.Group.Main.Body["g"..mod].Health:setValue(memberHp, 100, memberHp.."% "..ansi2string(memberName))
        GUI.Group.Main.Body["g"..mod].Mana:setValue(memberMana, 100)
        GUI.Group.Main.Body["g"..mod].Stamina:setValue(memberPow, 100)
        --
        if (ui.enDebug) then
          isLeader = (mod == nGroupMembers)
        end
        
        if (isLeader) then
          GUI.Group.Main.Body["g"..mod].Gem:show()
        else
          GUI.Group.Main.Body["g"..mod].Gem:hide()
        end
        GUI.Group.Main.Body["g"..mod]:show();
        ui.fAssignTargetButton("g"..mod, memberName)
      end
    end
  end
  --
  for g = i+1, 10 do
    mod = g % 10
    GUI.Group.Main.Body["g"..mod]:hide()
    ui.fAssignTargetButton("g"..mod, nil)
  end
  --
  GUI.Group:setTitle("Gruppo ["..nGroupMembers.."]")
end</script>
				<eventHandlerList />
			</Script>
			<Script isActive="yes" isFolder="no">
				<name>Help</name>
				<packageName></packageName>
				<script>--
local function parse_help_text(text)
  --text = text:gsub("%$ROOM_NAME_STATUS", (map.currentName and map.currentName ~= "") and '✔️' or '❌')
  --text = text:gsub("%$ROOM_NAME", map.currentName or '')
  --text = text:gsub("%$ROOM_EXITS_STATUS", (not map.currentExits or table.is_empty(map.currentExits)) and '❌' or '✔️')
  --text = text:gsub("%$ROOM_EXITS", map.currentExits and table.concat(map.currentExits, ' ') or '')
  return text
end
--
function ui.fHelp(cmd)
  -- Command
  if cmd and cmd ~= "" then
    cmd = cmd:lower():gsub(" ","_")
    if not ui.help[cmd] then
      cmd = "error"
    end
  else
    cmd = "help"
  end
  -- Pharse lines
  for line in parse_help_text(ui.help[cmd]):gmatch("[^\n]*\n") do
    -- Search tag
    repeat
      local before, tag, main, after = rex.match(line, [[(?&lt;before&gt;.*)&lt;(?&lt;tag&gt;[^&gt;]+)&gt;(?&lt;inside&gt;.*)&lt;\/\k&lt;tag&gt;&gt;(?&lt;after&gt;.*)]], 0, 'm')
      -- Execute tag
      if (tag) then
        -- Tag
        tag = tag:lower()
        -- Main
        if (tag == "title") then
          main = ui.fTitle(main)
        elseif (tag == "command") then
          main = ui.fGetCommandFormattedText(main)
        elseif (tag == "aliasname") then
          main = ui.fGetAliasNameFormattedText(main)
        elseif (tag == "aliasoutput") then
          main = ui.fGetAliasOutputFormattedText(main)
        elseif (tag == "alias") then
          main = ui.fGetAliasFormattedText(main)          
        elseif (tag == "input") then
          main = ui.fGetInputFormattedText(main)          
        elseif (tag == "varname") then
          main = ui.fGetVarNameFormattedText(main)          
        elseif (tag == "varvalue") then
          main = ui.fGetVarValueFormattedText(main)          
        elseif (tag == "var") then
          main = ui.fGetVarFormattedText(main) 
        end
        -- After
        if (tag ~= "title") then
          after = after.."\n"
        end
        -- Final line
        line = before..main..after
      end
    until (tag == nil)
    cecho(line)
  end
end
--
function ui.fHelp_links(htext, hlinktext, hurl, hcaption)
  if htext ~= nil and hlinktext ~= nil and hurl ~= nil and hcaption ~= nil then
    cecho(ui.cText..htext.." ")
    cechoLink(ui.cLink..hlinktext..ui.cText.."\n",
              [[openWebPage("https://]]..hurl..[[")]],
              hcaption,
              true)
  end
end</script>
				<eventHandlerList />
			</Script>
			<Script isActive="yes" isFolder="no">
				<name>Highlights</name>
				<packageName></packageName>
				<script>--
function ui.fGetHighlightFormattedText(highlight)
  if (ui.highlights[highlight]) then
    return "&lt;"..ui.highlights[highlight].color.."&gt;"..highlight.."&lt;reset&gt;"
  end
  return ""
end
--
function ui.fShowAllHighlights()
  local i = 0
  local num
  cecho(ui.fTitle("Highlights"))
  for highlight in pairs(ui.highlights) do
    i = i + 1
    cecho(ui.fGetNumberFormattedText(i).." "..ui.fGetHighlightFormattedText(highlight).."\n")
  end
  if (i&gt;0) then
    echo("\n")
  else
    cecho("Per maggiori info "..ui.fGetCommandFormattedText("ui.fHelp uihighlights").."\n\n")
  end
end
--
function ui.fRemoveHighlight(highlight)
  if (ui.highlights[highlight]) then
    if (ui.highlights[highlight].id) then
      killTrigger(ui.highlights[highlight].id)
    end
    ui.highlights[highlight] = nil
    return true
  end
  return false
end
--
function ui.fRemoveAllHighlights()
  for highlight in pairs(ui.highlights) do
    ui.fRemoveHighlight(highlight)
  end
  ui.highlights = {}
end
--
function ui.fAddHighlight(highlight, color)
  if ui.fColorCheck(color) then
    highlight = highlight or "" 
    if (highlight ~= "") then
      -- Init highlight (if not exist)
      ui.highlights[highlight] = ui.highlights[highlight] or {}
      -- Remove old highlight
      if (ui.highlights[highlight].id) then
        killTrigger(ui.highlights[highlight].id)
      end
      -- Create trigger
      ui.highlights[highlight].id = tempRegexTrigger([[(?i)(?:^|\W|\s)(]]..highlight..[[)(?:\W|$|\s)]], function()
                                                                                                          selectString(matches[2], 1)
                                                                                                          fg(color)
                                                                                                          resetFormat()
                                                                                                        end)
      ui.highlights[highlight].color = color
      return 1
    end
    return -1 -- Invaid text
  end
  return -2 -- Invalid color
end
--
-- Save Highlights data from file
function ui.fSaveFileHighlights()
  local highlightsDataToSave = {}
  for highlight in pairs(ui.highlights) do
    highlightsDataToSave[highlight] = {}
    highlightsDataToSave[highlight].color = ui.highlights[highlight].color
  end
  table.save(ui.fileHighlights, highlightsDataToSave)
end
--
-- Read Highlights data from file
function ui.fReadFileHighlights()
  -- Remove actual Highlights
  ui.highlights = ui.highlights or {}
  ui.fRemoveAllHighlights()
  -- Load Highlights
  if (io.exists(ui.fileHighlights)) then
    table.load(ui.fileHighlights, ui.highlights)
  end
  --
  -- Create Highlights
  for highlight in pairs(ui.highlights) do
    ui.fAddHighlight(highlight, ui.highlights[highlight].color)
  end
end</script>
				<eventHandlerList />
			</Script>
			<Script isActive="yes" isFolder="no">
				<name>Keybind</name>
				<packageName></packageName>
				<script>--
function ui.fGetKeybFormattedText(keybind)
  if (keybind) then
    return ui.cKeybind.."["..keybind.."]".."&lt;reset&gt;"
  end
  return ""
end
--
-- Validate 3 keys for keybind (order: mod1 mod2 key)
function ui.fGetKeyb(key1, key2, key3)
  local isValid = false;
  local mod1 = "";
  local mod2 = "";
  local key = "";
  local keybind = ""
  key1 = string.upper(key1 or "")
  key2 = string.upper(key2 or "")
  key3 = string.upper(key3 or "")
  if (key3 ~= "") then  -- es: key1=CTRL key2=ALT key3=F1
    if (key1 ~= key2) and
       (table.contains(ui.keyb_modifier, key1)) and
       (table.contains(ui.keyb_modifier, key2)) and
       (table.contains(ui.keyb_single,   key3)) then
      local idx1 = table.index_of(table.keys(ui.keyb_modifier), key1)
      local idx2 = table.index_of(table.keys(ui.keyb_modifier), key2)
      mod1 = idx1 &lt; idx2 and key2 or key1
      mod2 = idx1 &lt; idx2 and key1 or key2
      key = key3
      isValid = true
    end
  elseif (key2 ~= "") then  -- es: key1=CTRL key2=F1
    if (table.contains(ui.keyb_modifier, key1) and table.contains(ui.keyb_single, key2))then
      mod1 = key1
      mod2 = ""
      key = key2
      isValid = true
    end
  elseif (key1~= "") then -- es: key1=F1
    if (table.contains(ui.keyb_single, key1)) then
      mod1 = ""
      mod2 = ""
      key = key1
      isValid = true
    end
  else
    mod1 = ""
    mod2 = ""
    key = ""
    isValid = true
  end
  if (mod2 ~= "") then
    keybind = string.gsub(mod1 or "", "(%a)([%w_']*)", ui.fTitleCase).."+"..
               string.gsub(mod2 or "", "(%a)([%w_']*)", ui.fTitleCase).."+"..
               string.gsub(key or "", "(%a)([%w_']*)", ui.fTitleCase)
  elseif (mod1 ~= "") then
    keybind = string.gsub(mod1 or "", "(%a)([%w_']*)", ui.fTitleCase).."+"..
               string.gsub(key or "", "(%a)([%w_']*)", ui.fTitleCase)
  elseif (key ~= "") then
    keybind = string.gsub(key or "", "(%a)([%w_']*)", ui.fTitleCase)
  end
  return isValid, mod1, mod2, key, keybind
end
--
function ui.fSearchKeyb(table, keybind, excludeKey)
  keybind = keybind or ""
  excludeKey = excludeKey or ""
  if (keybind ~= "") and (table) then
    for key in pairs(table) do
      if (key ~= excludeKey) and (table[key].keybind == keybind) then
        return key
      end
    end
  end
  return nil
end
--
function ui.fShowAllKeyb()
  local orderTable = {}
  -- Order Target keybind
  for target in pairs(ui.targets) do
    orderTable[#orderTable+1] = target
  end
  table.sort(orderTable, function (target1, target2) 
                           keybind1 = ui.targets[target1].keybind or ""
                           keybind2 = ui.targets[target2].keybind or ""                  
                           if (rex.match(keybind1, [[F\d$]])) then
                             keybind1 = keybind1:gsub("F%w", "F0%1")                             
                           end
                           if (rex.match(keybind2, [[F\d$]])) then
                             keybind2 = keybind2:gsub("F%w", "F0%1")                             
                           end
                           return keybind1 &lt; keybind2
                         end )
  -- Show Target keybind
  cecho(ui.fTitle("Target keybind"))
  for i,target in ipairs(orderTable) do
    if (ui.targets[target].keybId) then
      if (ui.targets[target].target) then
        cecho(ui.fGetNumberFormattedText(i).." "..ui.fGetTargetFormattedText(target)..ui.fGetOperatorFormattedText(" » ")..ui.fGetVarNameFormattedText("target")..ui.fGetOperatorFormattedText(" = ")..ui.fGetVarValueFormattedText(ui.targets[target].target).."\n")
      else
        cecho(ui.fGetNumberFormattedText(i).." "..ui.fGetTargetFormattedText(target).."\n")
      end
    end
  end
  if (#orderTable==0) then
    cecho("Per maggiori info "..ui.fGetCommandFormattedText("ui.fHelp uikeybind").."\n")
  end
  -- Order Aliases keybind
  orderTable = {}
  for alias in pairs(ui.aliases) do
    if (ui.aliases[alias].keybId) then
      orderTable[#orderTable+1] = alias
    end
  end
  table.sort(orderTable, function (alias1, alias2) 
                           keybind1 = ui.aliases[alias1].keybind
                           keybind2 = ui.aliases[alias2].keybind                           
                           if (rex.match(keybind1, [[F\d$]])) then
                             keybind1 = keybind1:gsub("F%w", "F0%1")                             
                           end
                           if (rex.match(keybind2, [[F\d$]])) then
                             keybind2 = keybind2:gsub("F%w", "F0%1")                             
                           end
                           return keybind1 &lt; keybind2
                         end )
  -- Show Aliases keybind
  cecho(ui.fTitle("Aliases keybind"))
  for i,alias in ipairs(orderTable) do
    cecho(ui.fGetNumberFormattedText(i).." "..ui.fGetAliasFormattedText(alias).."\n")
  end
  if (#orderTable==0) then
    cecho("Per maggiori info "..ui.fGetCommandFormattedText("ui.fHelp uikeybind").."\n\n")
  else
    echo("\n")
  end
end
--
-- Delete keybind from a table
function ui.fRemoveKeyb(element)
  if (element) then
    if (element.mod1) then
      element.mod1 = nil
    end
    if (element.mod2) then
      element.mod2 = nil
    end
    if (element.key) then
      element.key = nil
    end
    if (element.keybind) then
      element.keybind = nil
    end
    if (element.keybId) then
      killKey(element.keybId)
      element.keybId = nil
      return 1 -- keyb removed
    end
    return -1 -- Not keyb to remove
  end
  return -2 -- Invalid element
end
--
function ui.fRemoveAllKeyb()
  for element in pairs(ui.aliases) do
    ui.fRemoveKeyb(ui.aliases[element])
  end
  for element in pairs(ui.targets) do
    ui.fRemoveKeyb(ui.targets[element])
  end
end
--
-- Set, modify or delete a keybind
function ui.fSetKeyb(table, tKey, code, key1, key2, key3)
  local isValid, mod1, mod2, key, keybind = ui.fGetKeyb(key1, key2, key3)
  if (table[tKey]) then
    if (isValid) then
      if (ui.fSearchKeyb(ui.targets, keybind, tKey) == nil) then
        if (ui.fSearchKeyb(ui.aliases, keybind, tKey) == nil) then
          -- Remove old keybind
          ui.fRemoveKeyb(table[tKey]);
          -- Create new keybind
          if (mod2 ~= "") then
            table[tKey].keybId = tempKey(ui.keyb_modifier[mod1] + ui.keyb_modifier[mod2], ui.keyb_single[key], code)
          elseif (mod1 ~= "") then
            table[tKey].keybId = tempKey(ui.keyb_modifier[mod1], ui.keyb_single[key], code)
          elseif (key ~= "") then
            table[tKey].keybId = tempKey(ui.keyb_single[key], code)
          else
            return 2, keybind -- keybind removed
          end
          -- Save data
          table[tKey].mod1 = mod1
          table[tKey].mod2 = mod2
          table[tKey].key = key
          table[tKey].keybind = keybind
          return 1, keybind -- keybind changed or created
        end
        return -4, keybind -- keybind already used in an alias
      end
      return -3, keybind -- keybind already used in a target
    end
    return -2, keybind -- Not valid keys
  end
  return -1, keybind -- Alias not exist
end
--
-- Save Targets data from file
function ui.fSaveFileTargets()
  local targetsDataToSave = {}
  for target in pairs(ui.targets) do
    targetsDataToSave[target] = {}
    targetsDataToSave[target].mod1 = ui.targets[target].mod1
    targetsDataToSave[target].mod2 = ui.targets[target].mod2
    targetsDataToSave[target].key = ui.targets[target].key
    targetsDataToSave[target].target = ui.targets[target].target
  end
  table.save(ui.fileTargets, targetsDataToSave)
end</script>
				<eventHandlerList />
			</Script>
			<Script isActive="yes" isFolder="no">
				<name>Map/Compass</name>
				<packageName></packageName>
				<script>--
function ui.fGetPosition(line)
  local position = ""
  local icon = ""
  --
  -- Player icon or track direction
  if (ui.track == nil) or (ui.track == "") then
    icon = "&lt;255,255,255:30,24,24&gt;⨂&lt;69,69,69:30,24,24&gt;"
  else
    icon = ui.dirTokenColor[ui.track]..ui.dirToken[ui.track].."&lt;69,69,69:30,24,24&gt;"
  end
  --
  -- West side
  if ((line == 3) and (ui.position == "sud-ovest")) or
     ((line == 2) and (ui.position == "ovest")) or
     ((line == 1) and (ui.position == "nord-ovest")) then
    position = icon.."      "
  --
  -- Central side
  elseif ((line == 3) and (ui.position == "sud")) or
         ((line == 2) and (ui.position == "centro")) or
         ((line == 1) and (ui.position == "nord")) then
    position = "   "..icon.."   "
  --
  -- East side
  elseif ((line == 3) and (ui.position == "sud-est")) or
         ((line == 2) and (ui.position == "est")) or
         ((line == 1) and (ui.position == "nord-est")) then
    position = "      "..icon
  --
  --  No position in line
  else
    position = "       "
  end
  --
  return position
end
--
function ui.fGetToken(exits, dir)
  local token = ""
  if (table.contains(exits, dir)) then
    local idx = table.index_of(exits, dir)
    table.remove(exits, idx)
    --
    -- Close exit
    if (exits[idx]) and (exits[idx] == "(chiuso)") then
      token = "&lt;255,0,0:30,24,24&gt;"..ui.dirTokenClose[dir].."&lt;69,69,69:30,24,24&gt;"
      table.remove(exits, idx)
    --
    -- Secret exit
    elseif (exits[idx]) and (exits[idx] == "(segreto)") then
      token = "&lt;255,0,0:30,24,24&gt;"..ui.dirTokenSecret[dir].."&lt;69,69,69:30,24,24&gt;"
      table.remove(exits, idx)
    --
    -- From direction  
    elseif (ui.path[ui.idxPath]) and (ui.dirReverse[ui.path[ui.idxPath]] == dir ) then
      token = ui.dirTokenColor[dir]..ui.dirTokenFrom[dir].."&lt;69,69,69:30,24,24&gt;"
    --
    -- Normal exit
    else
      token = ui.dirTokenColor[dir]..ui.dirToken[dir].."&lt;69,69,69:30,24,24&gt;"
    end
  --
  -- No exit
  elseif (ui.dirTokenX[dir]) then
    token = ui.dirTokenX[dir]
  end
  --
  return token
end
--
function ui.fUpdateMap()
  local token
  local exits = {}
  --
  -- Generate directiones table
  ui.exits = {}
  for token in string.gmatch(ui.strExits, "[^%s]+") do
    local dir = string.lower(token)
    if (ui.dirCompress[dir]) then
      table.insert(exits, ui.dirCompress[dir]);
      table.insert(ui.exits, ui.dirCompress[dir]);
    else
      table.insert(exits, token);
    end
  end
  --
  clearWindow("GUI.MapCompass.Main.Body.Exits")
  clearWindow("GUI.MapCompass.Main.Body.OtherExits")
  --
  -- Font size
  GUI.MapCompass.Main.Body.Exits:setFontSize(ui.parameters.fsMapCompass)
  GUI.MapCompass.Main.Body.OtherExits:setFontSize(ui.parameters.fsMapCompass)
  GUI.MapCompass.Main.B2:setFontSize(ui.parameters.fsMapCompass)    
  --
  -- Room name
  GUI.MapCompass:setTitle(ui.roomName)
  --
  -- Exits and Position
  GUI.MapCompass.Main.Body.Exits:decho("&lt;69,69,69:30,24,24&gt;┌───"..ui.fGetToken(exits, "n").."───"..ui.fGetToken(exits, "u").."\n")
  GUI.MapCompass.Main.Body.Exits:decho("&lt;69,69,69:30,24,24&gt;│"..ui.fGetPosition(1).."│\n")
  GUI.MapCompass.Main.Body.Exits:decho("&lt;69,69,69:30,24,24&gt;"..ui.fGetToken(exits, "w")..ui.fGetPosition(2)..ui.fGetToken(exits, "e").."\n")
  GUI.MapCompass.Main.Body.Exits:decho("&lt;69,69,69:30,24,24&gt;│"..ui.fGetPosition(3).."│".."\n")
  GUI.MapCompass.Main.Body.Exits:decho("&lt;69,69,69:30,24,24&gt;"..ui.fGetToken(exits, "d").."───"..ui.fGetToken(exits, "s").."───┘\n")
  --
  -- Storico del percorso  
  local str;
  if (ui.idxPath == ui.memPath) then
    str = ui.idxPath;
  elseif (ui.memPath - ui.idxPath &lt;= 4) then 
    str = ui.memPath;
  elseif (ui.idxPath &gt; 4) then 
    str = ui.idxPath + 4;
  else
    str = 8;
  end
  --
  for i=str, str-7, -1 do
    if (ui.path[i]) then
      local dir = ui.path[i]
      --
      if (i&lt;=ui.idxPath) then
        dir = ui.dirReverse[dir]
      end
      --      
      if (i == ui.memPath) and (ui.idxPath == ui.memPath)then
        dir = "⨂ "..dir
      elseif (i == ui.idxPath) then
        dir = " ⨂ "..dir
      elseif (i == 1) and (ui.idxPath == 0) then
        dir = dir.." ⨂"
      end
      GUI.MapCompass.Main.Body.Exits:decho(dir)
    end
  end
  --
  -- Other exits
  if (table.size (exits) &gt; 0) then
    GUI.MapCompass.Main.Body.OtherExits:setFgColor("white")
    GUI.MapCompass.Main.Body.OtherExits:echo("Altre uscite:\n")
    while (exits[1] ~= nil) do
      token = exits[1]
      if (exits[2] ~= nil) and (exits[2] == "(chiuso)") then
        table.remove(exits, 2)
        token = "("..token..")"
      end
      GUI.MapCompass.Main.Body.OtherExits:decho(ui.dirToken["e"].." "..token.."\n")
      table.remove(exits, 1)
    end
  end
  --
  -- Room type
  GUI.MapCompass.Main.B2:echo("&lt;center&gt;"..ui.roomType)
end
--</script>
				<eventHandlerList />
			</Script>
			<Script isActive="yes" isFolder="no">
				<name>Opponent (GMCP)</name>
				<packageName></packageName>
				<script>--
function ui.fIncrement_difTimer_o(time_left)
  if ui.difTimer then
    killTimer(ui.difTimer)
  end
  --
  if time_left &gt; 0 then
    time_left = time_left - 1
    ui.difTimer = tempTimer(1, function() ui.fIncrement_difTimer_o(time_left) end)
    GUI.Opponent.Main.Health.dif:show()
  else
    GUI.Opponent.Main.Health.dif:hide()
  end
end
--
function ui.fUpdateOpponent()
  if (ui.enDebug) then
    ui.variables.opponent_health     = math.random(0, 100)
    ui.variables.opponent_health_max = 100
    ui.variables.opponent_level      = math.random(0, 99)
    ui.variables.opponent_name       = "C4tt1v0ne"
  else
    ui.variables.opponent_health     = gmcp.MSDP.OPPONENT_HEALTH or ui.variables.opponent_health
    ui.variables.opponent_health_max = gmcp.MSDP.OPPONENT_HEALTH_MAX or ui.variables.opponent_health_max
    ui.variables.opponent_level      = gmcp.MSDP.OPPONENT_LEVEL or ui.variables.opponent_level
    ui.variables.opponent_name       = gmcp.MSDP.OPPONENT_NAME or ui.variables.opponent_name
  end
  --
  if (ui.variables.opponent_name ~= "") then
    local dif = GUI.Opponent.Main.Health.front:get_width()
    local hp = tonumber(ui.variables.opponent_health) or 0
    local hpMax = tonumber(ui.variables.opponent_health_max) or 0
    local hpPerc = 0
    if hpMax ~= 0 then
      hpPerc = math.floor(100 * hp / hpMax)
    else
      hpPerc = 0
    end
    local levDif = tonumber(ui.variables.level) - tonumber(ui.variables.opponent_level)
    local color = "white";
    if (levDif &gt;= 5) then
      color = "white"
    elseif (levDif &gt;= 0) then
      color = "green"
    elseif (levDif &gt;= -5) then
      color = "orange"
    else
      color = "red"
    end
    ui.variables.opponent_name = string.gsub(ui.variables.opponent_name, "(\$c%d+)", "")
    ui.variables.opponent_name = ui.fRemoveArticle(ui.variables.opponent_name)
    ui.variables.opponent_name = string.gsub(ui.variables.opponent_name, " ", "-")
    GUI.Opponent.Level:setFgColor(color)
    GUI.Opponent.Level:echo("&lt;center&gt;"..ui.variables.opponent_level)
    GUI.Opponent.Level:show()
    GUI.Opponent.Main.Health:setValue(hpPerc, 100,"&lt;p align=right&gt;"..hpPerc.."%  ")
    GUI.Opponent.Main.Health.front:echo(ui.variables.opponent_name)
    ui.fAssignTargetButton("o0", ui.variables.opponent_name)
    --uit
    --
    dif = GUI.Opponent.Main.Health.front:get_width() - dif
    if (dif &lt; 0) then
      GUI.Opponent.Main.Health.dif = Geyser.Label:new2({
        name = "GUI.Opponent.Main.Health.dif",
        x = GUI.Opponent.Main.Health.front:get_x() - GUI.Opponent.Main:get_x() + GUI.Opponent.Main.Health.front:get_width(),
        y = GUI.Opponent.Main.Health.front:get_y() - GUI.Opponent.Main:get_y(),
        width = -dif,
        height = GUI.Opponent.Main.Health.front:get_height(),
        message = [[- -]]
      }, GUI.Opponent.Main)
      GUI.Opponent.Main.Health.dif:setStyleSheet(GUI.CSS.GaugeBack..[[
        qproperty-alignment: 'AlignRight';
        border: 1px solid rgba(255, 0, 0, 0.8);
        background-color: rgba(255, 0, 0, 0.4);
      ]])
      GUI.Opponent.Main.Health.dif:setFontSize(5)
      ui.fIncrement_difTimer_o(2)
    elseif (dif &gt; 0) then
      GUI.Opponent.Main.Health.dif = Geyser.Label:new2({
        name = "GUI.Opponent.Main.Health.dif",
        x = GUI.Opponent.Main.Health.front:get_x() - GUI.Opponent.Main:get_x() + GUI.Opponent.Main.Health.front:get_width() - dif,
        y = GUI.Opponent.Main.Health.front:get_y() - GUI.Opponent.Main:get_y() + 2,
        width = dif-1,
        height = GUI.Opponent.Main.Health.front:get_height() - 4,
        message = [[++]]
      }, GUI.Opponent.Main)
      GUI.Opponent.Main.Health.dif:setStyleSheet(GUI.CSS.GaugeBack..[[
        qproperty-alignment: 'AlignRight';
        border: 1px solid rgba(0, 255, 0, 0.8);
        background-color: rgba(0, 255, 0, 0.4);
      ]])
      GUI.Opponent.Main.Health.dif:setFontSize(5)
      ui.fIncrement_difTimer_o(2)
    end

  else
    GUI.Opponent.Level:setFgColor(color)
    GUI.Opponent.Level:echo("")
    GUI.Opponent.Level:hide()
    GUI.Opponent.Main.Health:setValue(0, 100,"")
    GUI.Opponent.Main.Health.front:echo("")
    ui.fAssignTargetButton("o0", nil)
  end
  --
  -- Opponent Name on title
  local title = "* Nessuno *";
  if (ui.variables.opponent_name ~= "") then
    title = ui.variables.opponent_name;
  end
  -- Target on title
  if (ui.variables.target) and (ui.variables.target ~= "") then
    title = title.." (T:"..ui.variables.target..")"
  end
  GUI.Opponent:setTitle(title)
  table.save(ui.fileVariables, ui.variables)
end</script>
				<eventHandlerList />
			</Script>
			<Script isActive="yes" isFolder="no">
				<name>Path</name>
				<packageName></packageName>
				<script>--
function ui.fGetNextNumber(text, index)
  local number = ""
  index = tonumber(index or 1)
  while (index&lt;=text:len()) and (string.match(string.lower(text:sub(index, index)), "[0123456789]")) do
    number = number..string.lower(text:sub(index, index))
    index = index + 1
  end
  if (number == "") then
    number = "1"
  end
  number = tonumber(number)
  return number, index
end
--s
function ui.fSavePath(dir)
  --if (ui.path[ui.idxPath]) and (dir == ui.dirReverse[ui.path[ui.idxPath]]) then
  --  ui.idxPath = ui.idxPath - 1
  --elseif (ui.path[ui.idxPath+1]) and (dir == ui.path[ui.idxPath+1]) then
  --  ui.idxPath = ui.idxPath + 1
  --else
  if (ui.idxPath &lt; ui.maxPath) then
    ui.idxPath = ui.idxPath + 1
    ui.path[ui.idxPath] = dir
    ui.memPath = ui.idxPath
  else
    for i=1, ui.maxPath-1 do
      ui.path[i] = ui.path[i+1]
    end
    ui.path[ui.maxPath] = dir    
    ui.idxPath = ui.maxPath
  end
end
--</script>
				<eventHandlerList />
			</Script>
			<Script isActive="yes" isFolder="no">
				<name>Player (GMCP)</name>
				<packageName></packageName>
				<script>--
function ui.fIncrement_difTimer_p(time_left)
  if ui.difTimer then
    killTimer(ui.difTimer)
  end
  --
  if time_left &gt; 0 then
    time_left = time_left - 1
    ui.difTimer = tempTimer(1, function() ui.fIncrement_difTimer_p(time_left) end)
    GUI.Player.Health.dif:show()
  else
    GUI.Player.Health.dif:hide()
  end
end
--
function ui.fUpdatePlayer()
  ui.variables.ac             = gmcp.MSDP.AC or ui.variables.ac
  ui.variables.alignment      = gmcp.MSDP.ALIGNMENT or ui.variables.alignment
  ui.variables.experience     = gmcp.MSDP.EXPERIENCE or ui.variables.experience
  ui.variables.money          = gmcp.MSDP.MONEY or ui.variables.money
  ui.variables.character_name = gmcp.MSDP.CHARACTER_NAME or ui.variables.character_name
  ui.variables.health         = gmcp.MSDP.HEALTH or ui.variables.health
  ui.variables.health_max     = gmcp.MSDP.HEALTH_MAX or ui.variables.health_max
  ui.variables.level          = gmcp.MSDP.LEVEL or ui.variables.level
  ui.variables.mana           = gmcp.MSDP.MANA or ui.variables.mana
  ui.variables.mana_max       = gmcp.MSDP.MANA_MAX or ui.variables.mana_max
  ui.variables.movement       = gmcp.MSDP.MOVEMENT or ui.variables.movement
  ui.variables.movement_max   = gmcp.MSDP.MOVEMENT_MAX or ui.variables.movement_max
  ui.variables.character_name = gmcp.MSDP.CHARACTER_NAME or ui.variables.character_name
  --
  -- for debug
  if (ui.enDebug) then
    ui.variables.health         = math.random(0, 100)
    ui.variables.health_max     = 100
    ui.variables.level          = math.random(0, 60)
    ui.variables.mana           = math.random(0, 100)
    ui.variables.mana_max       = 100
    ui.variables.movement       = math.random(0, 100)
    ui.variables.movement_max   = 100
    ui.variables.character_name = "D3Bu4 M0D3"
  end
  --
  -- HP
  local hp = tonumber(ui.variables.health) or hp
  local hpMax = tonumber(ui.variables.health_max) or hpMAx
  local hpPerc = 0
  local dif = GUI.Player.Health.front:get_width()
  if hpMax ~= 0 then hpPerc = math.floor(100 * hp / hpMax) end
  ui.parameters.last_hp = ui.parameters.last_hp or 0;
  if (hp &lt; ui.parameters.last_hp) and (hpPerc &lt; 40) then
    playSoundFile(ui.pathSnd..[[hurt.wav]], 10)
  end
  ui.parameters.last_hp = hp
  --
  -- Mana
  local mana = tonumber(ui.variables.mana)
  local manaMax = tonumber(ui.variables.mana_max)
  local manaPerc = 0
  if manaMax ~= 0 then manaPerc = math.floor(100 * mana / manaMax) end
  ui.parameters.last_mana = ui.parameters.last_mana or 0;
  if (mana &lt; ui.parameters.last_mana) then
    playSoundFile(ui.pathSnd..[[cast.wav]], 10)
  end
  ui.parameters.last_mana = mana
  --
  -- Stamina
  local stamina = tonumber(ui.variables.movement)
  local staminaMax = tonumber(ui.variables.movement_max)
  local staminaPerc = 0
  if staminaMax ~= 0 then staminaPerc = math.floor(100 * stamina / staminaMax) end
  -- Redraw widget
  GUI.Player:setTitle(ui.variables.character_name)
  GUI.Player.Level:echo("&lt;center&gt;"..ui.variables.level)
  GUI.Exp:setValue(ui.variables.experience, 300000000)
  GUI.Player.Health:setValue(hpPerc, 100,"&lt;center&gt;"..hp.."/"..hpMax.." - "..hpPerc.."%")
  GUI.Player.Mana:setValue(manaPerc, 100,"&lt;center&gt;"..mana.."/"..manaMax.." - "..manaPerc.."%")
  GUI.Player.Stamina:setValue(staminaPerc, 100,"&lt;center&gt;"..stamina.."/"..staminaMax.." - "..staminaPerc.."%")
  -- Update variables
  table.save(ui.fileVariables, ui.variables)
  --
  if (ui.lastMoney) then
    if (ui.variables.money &lt; ui.lastMoney) then
      ui.fEcho2n("Il tuo portafoglio si allegerisce di &lt;gold&gt;"..(ui.lastMoney - ui.variables.money).."&lt;reset&gt; monete d'oro.\n")
    end 
    ui.lastMoney = ui.variables.money  
  else
    ui.lastMoney = ui.variables.money
  end
  --
  dif = GUI.Player.Health.front:get_width() - dif
  if (dif &lt; 0) then
    GUI.Player.Health.dif = Geyser.Label:new2({
      name = "GUI.Player.Health.dif",
      x = GUI.Player.Health.front:get_x() - GUI.Player.Box:get_x() + GUI.Player.Health.front:get_width(),
      y = GUI.Player.Health.front:get_y() - GUI.Player.Box:get_y(),
      width = -dif,
      height = GUI.Player.Health.front:get_height(),
      message = [[- -]]
    }, GUI.Player.Box)
    GUI.Player.Health.dif:setStyleSheet(GUI.CSS.GaugeBack..[[
      qproperty-alignment: 'AlignRight';
      border: 1px solid rgba(255, 0, 0, 0.8);
      background-color: rgba(255, 0, 0, 0.4);
    ]])
    ui.fIncrement_difTimer_p(2)
  elseif (dif &gt; 0) then
    GUI.Player.Health.dif = Geyser.Label:new2({
      name = "GUI.Player.Health.dif",
      x = GUI.Player.Health.front:get_x() - GUI.Player.Box:get_x() + GUI.Player.Health.front:get_width() - dif,
      y = GUI.Player.Health.front:get_y() - GUI.Player.Box:get_y() + 2,
      width = dif-1,
      height = GUI.Player.Health.front:get_height() - 4,
      message = [[++]]
    }, GUI.Player.Box)
    GUI.Player.Health.dif:setStyleSheet(GUI.CSS.GaugeBack..[[
      qproperty-alignment: 'AlignRight';
      border: 1px solid rgba(0, 255, 0, 0.8);
      background-color: rgba(0, 255, 0, 0.4);
    ]])
    ui.fIncrement_difTimer_p(2)
  end
  GUI.Player.Health.dif:setFontSize(5)
end</script>
				<eventHandlerList />
			</Script>
			<Script isActive="yes" isFolder="no">
				<name>Profiles</name>
				<packageName></packageName>
				<script>--
function ui.fGetProfileNameFormattedText(profile)
  return ui.cProfileName..profile.."&lt;reset&gt;"
end
--
-- Get saved profiles list
function ui.fGetProfiles()
  local lfs = require("lfs")
  local profiles = {}
  --
  if (lfs.chdir(ui.pathPrf)) then
    for profile in lfs.dir(ui.pathPrf) do
      if (profile~=".") and (profile~="..") and (lfs.chdir(ui.pathPrf..profile)) then
        profiles[#profiles+1] = profile
      end
    end
  end
  return profiles
end
--
function ui.fContainProfile(profiles, profile)
  for _, p in pairs(profiles) do
    if (p == profile) then
      return true
    end
  end
  return false;
end
--
-- List all aliases
function ui.fShowAllProfiles()
  local profiles = ui.fGetProfiles()
  local nProfiles = 0
  --
  cecho(ui.fTitle("Profili"))
  for profile in ui.fOrderedPairs(profiles) do
    nProfiles = nProfiles + 1
    cecho(ui.fGetNumberFormattedText(nProfiles).." "..ui.fGetProfileNameFormattedText(profiles[profile]).."\n")
  end
  --
  if (nProfiles&gt;0) then
    echo("\n")
  else
    cecho("Per maggiori info "..ui.fGetCommandFormattedText("ui.fHelp uiprofiles").."\n\n")
  end
end
--
function ui.fAddProfile(profile)
  local profiles = ui.fGetProfiles()
  if (ui.fContainProfile(profiles, profile)) then
    return true
  end
  return nil
end
--
function ui.fLoadProfile(profile)
  local profiles = ui.fGetProfiles()
  if (ui.fContainProfile(profiles, profile)) then
    return true
  end
  return nil
end
--
function ui.fMergeProfile(profile)
  local profiles = ui.fGetProfiles()
  if (ui.fContainProfile(profiles, profile)) then
    return true
  end
  return nil
end
--
function ui.fRemoveProfile(profile)
  local profiles = ui.fGetProfiles()
  if (ui.fContainProfile(profiles, profile)) then
    ui.fDeleteDirectory(ui.pathPrf..profile)
    return true
  end
  return nil
end
--
function ui.fRemoveAllProfiles()
  local profiles = ui.fGetProfiles()
  for profile in pairs(profiles) do
    ui.fDeleteDirectory(ui.pathPrf..profiles[profile])
  end
  return true
end
--
function ui.fSaveProfile(profile)
  local profiles = ui.fGetProfiles()
  if (ui.fContainProfile(profiles, profile)) then
    ui.fDeleteDirectory(ui.pathPrf..profile)
  end
  --
  require "lfs"
  return lfs.mkdir(ui.pathPrf..profile)
end</script>
				<eventHandlerList />
			</Script>
			<Script isActive="yes" isFolder="no">
				<name>Targets</name>
				<packageName></packageName>
				<script>--
function ui.fGetTargetChild(type, number)
  if (type == "g") then
    return GUI.Group.Main.Body[type..number];
  elseif (type == "o") then
    return GUI.Opponent.Main
  elseif (type == "t") then
    return GUI.TargetButtons.Main.Body[type..number]
  else
    return nil
  end
end
--
function ui.fGetTargetFormattedText(target)
  local str = ui.cTarget.."["..target.."]"
  if (ui.targets[target]) and (ui.targets[target].keybId) then
    str = str.." "..ui.fGetKeybFormattedText(ui.targets[target].keybind)
  end
  return str.."&lt;reset&gt;"
end
--
-- Refresh target button
function ui.fRefreshTargetButton(button)
  local type, number = ui.fExpandButton(button)
  local child = ui.fGetTargetChild(type, number)
  --
  if (child ~= nil) then
    button = type..number 
    if (ui.targets[button]) then
      local mod1 = ui.targets[button].mod1 or "";
      local mod2 = ui.targets[button].mod2 or "";
      local key = ui.targets[button].key or "";
      local result, keybind
      local target
      local CCS, bgColor
      -- Target
      if (ui.targets[button].target) and (ui.targets[button].target ~= "") then
        target = ui.targets[button].target
      else
        target = "'"..button.."'";
      end
      -- Keybind
      if (mod2 ~= "") then
        result, keybind = ui.fSetKeyb(ui.targets, button, [[ui.fExecuteTargetButton("]]..button..[[")]], mod2, mod1, key)
      elseif (mod1 ~= "") then
        result, keybind = ui.fSetKeyb(ui.targets, button, [[ui.fExecuteTargetButton("]]..button..[[")]], mod1, key)
      elseif (key ~= "") then
        result, keybind = ui.fSetKeyb(ui.targets, button, [[ui.fExecuteTargetButton("]]..button..[[")]], key)
      else
        result, keybind = ui.fSetKeyb(ui.targets, button, [[ui.fExecuteTargetButton("]]..button..[[")]])
      end
      if (result &lt;= 0) then
        ui.fRemoveKeyb(ui.targets[button])
      end
      -- Echo
      child.keybind:echo("&lt;center&gt;"..keybind)
      -- CCS
      if (type == "g") then
        CCS = GUI.CSS.Border3;
        bgColor = "150,150,0"
      elseif (type == "o") then
        CCS = GUI.CSS.Border3;
        bgColor = "150,0,0"
      elseif (type == "t") then
        GUI.TargetButtons.Main.Body[button]:echo("&lt;center&gt;"..target)
        CCS = GUI.CSS.Target;
        bgColor = "150,0,0"
      end
      --
      if (target == ui.variables["target"]) then
        child:setStyleSheet([[
          QLabel{
            ]]..CCS..[[
            background-color: rgba(]]..bgColor..[[,1);
          }
        ]])
      else
        child:setStyleSheet([[
          QLabel{
            ]]..CCS..[[
            background-color: rgba(]]..bgColor..[[,.4);
          }
          QLabel::hover{
            ]]..CCS..[[
            background-color: rgba(]]..bgColor..[[,1);
          }
        ]])
      end
      return true
    end
  end
  return false
end
-- 
-- Refresh all target button
function ui.fUpdateAllTargetButton()
  for i=0, 9 do
    if (i &gt;= 1) and (i &lt;= 4) then
      ui.fRefreshTargetButton("t"..i)
    end
    ui.fRefreshTargetButton("g"..i)
  end
  ui.fRefreshTargetButton("o0")
end
--
-- Refresh Target
function ui.fUpdateTarget()
  if (not ui.variables.target) or (ui.variables.target == "") then
    GUI.TargetButtons:setTitle("Target")
  else
    GUI.TargetButtons:setTitle("Target: "..ui.variables["target"])
  end
end
--
-- Assign Target button
function ui.fAssignTargetButton(button, value)
  local ret = 0;
  local type, number = ui.fExpandButton(button)
  if (type == "g") or (type == "o") or (type == "t") then
    button = type..number
    ui.targets[button] = ui.targets[button] or {}
    ui.targets[button].target = value
    ui.fUpdateAllTargetButton()
    ui.fUpdateTarget()
    ui.fSaveFileTargetButtons()
    return 1 -- Value assigned (can be nil)
  end
  return -1 -- Invaid button
end
--
-- Execute Target button
function ui.fExecuteTargetButton(button)
  local type, number = ui.fExpandButton(button)
  if (type == "g") or (type == "o") or (type == "t") then
    button = type..number
    if (ui.targets[button]) and (ui.targets[button].target) then
      if (ui.variables["target"] == ui.targets[button].target) then
        ui.variables["target"] = ""
        ui.fEcho2n(ui.fGetTargetFormattedText(button).." nessun "..ui.fGetVarNameFormattedText("target").." selezionato")
      else
        ui.variables["target"] = ui.targets[button].target
        ui.fEcho2n(ui.fGetTargetFormattedText(button).." "..ui.fGetVarNameFormattedText("target").." impostato su "..ui.fGetVarValueFormattedText(ui.variables.target).."&lt;reset&gt;.")
      end
      ui.fUpdateTarget()
    elseif (type == "g") then
      ui.fEcho2n("Nessun componente del gruppo associato a "..ui.fGetTargetFormattedText(button)..".")
    elseif (type == "o") then
      ui.fEcho2n("Nessun avversario ingaggiato associato a "..ui.fGetTargetFormattedText(button)..".")
    elseif (type == "t") then
      ui.fEcho2n(ui.fGetTargetFormattedText(button).." non configurato. Usare il comanto "..ui.fGetCommandFormattedText(button.." &lt;testo&gt;").." per configurare.")
    end
    -- Save @target
    table.save(ui.fileVariables, ui.variables)
    ui.fUpdateAllTargetButton()
  else
    ui.fEcho2n(ui.fGetTargetFormattedText(button).." pulsante non valido.")
  end
  ui.fUpdateOpponent()
end
--
-- Save buttons data from file
function ui.fSaveFileTargetButtons()
  local targetsDataToSave = {}
  for button in pairs(ui.targets) do
    targetsDataToSave[button] = {}
    targetsDataToSave[button].target = ui.targets[button].target
    targetsDataToSave[button].mod1 = ui.targets[button].mod1
    targetsDataToSave[button].mod2 = ui.targets[button].mod2
    targetsDataToSave[button].key = ui.targets[button].key
  end
  table.save(ui.fileTargets, targetsDataToSave)
end</script>
				<eventHandlerList />
			</Script>
			<Script isActive="yes" isFolder="no">
				<name>Tick</name>
				<packageName></packageName>
				<script>function ui.fIncrementTickTimer(time_left)
  if time_left + 1 &lt;= 75 then
    time_left = time_left + 1
  else
    if (ui.enDebug) then
      time_left = 70      
    else
      time_left = 1
    end
    ui.fTickUpdateAffects()
  end
  if ui.ticktimer then
    killTimer(ui.ticktimer)
  end
  ui.ticktimer = tempTimer(1, function() ui.fIncrementTickTimer(time_left) end)
  GUI.Tick:setValue(time_left, 75)
end
</script>
				<eventHandlerList />
			</Script>
			<Script isActive="yes" isFolder="no">
				<name>Variables</name>
				<packageName></packageName>
				<script>--
function ui.fGetVarNameFormattedText(varName)
  return ui.cVarID..ui.varID..ui.cVarName..varName.."&lt;reset&gt;"
end
--
function ui.fGetVarValueFormattedText(varValue)
  return ui.cVarCont..tostring(varValue)
end
--
function ui.fGetVarFormattedText(variable)
  if (ui.variables[variable]) then
    if (ui.variables[variable] == "") then
      return ui.fGetVarNameFormattedText(variable)
    end
    return ui.fGetVarValueFormattedText(ui.variables[variable])..ui.fGetVarNameFormattedText(variable)
  end
  return ""
end
--
function ui.fRemoveAllVariables()
  ui.variables = {}
  ui.variables = table.deepcopy(ui.pre_defined_variables)
end
--
function ui.fShowAllVar()
  local app = {}
  local numVar = 0
  local numPreVar = 0
  cecho(ui.fTitle("Variabili predefinite"))
  for variable in pairs(ui.variables) do
    local var = ui.fGetVarNameFormattedText(variable)
    if (ui.variables[variable]) and (ui.variables[variable]  ~= "") then
      var = var..ui.fGetOperatorFormattedText(" = ")..ui.fGetVarValueFormattedText(ui.variables[variable])
    end
    if (ui.pre_defined_variables[variable] == nil) then
      numVar = numVar + 1
      table.insert(app, ui.fGetNumberFormattedText(numVar).." "..var.."\n")
    else
      numPreVar = numPreVar + 1
      cecho(ui.fGetNumberFormattedText(numPreVar).." "..var.."\n")
    end
  end
  cecho(ui.fTitle("Variabili"))
  if (numVar&gt;0) then
    for data in pairs(app) do
      cecho(app[data])
    end
    echo("\n")
  else
    cecho("Per maggiori info "..ui.fGetCommandFormattedText("ui.fHelp uivariables").."\n\n")
  end
end</script>
				<eventHandlerList />
			</Script>
		</ScriptGroup>
		<ScriptGroup isActive="yes" isFolder="yes">
			<name>Graphic elements</name>
			<packageName></packageName>
			<script></script>
			<eventHandlerList />
			<Script isActive="yes" isFolder="no">
				<name>Buttons</name>
				<packageName></packageName>
				<script>function ui.fInitButtons()
  --
  -- Help button
  GUI.HelpButton = Geyser.Label:new2({
    name = "GUI.HelpButton",
    x = -50, y = 5,
    width = 30,
    height = 30,
  })
  GUI.HelpButton:setStyleSheet([[border-image: url("]]..ui.pathImg..[[helpButton.png")]]);
  GUI.HelpButton:setClickCallback("ui.fHelp", nil)
  --
  -- Options button
  function ui.fOptionsButtonCallback()
    if GUI.Options.hidden then
      GUI.Options:show()
      GUI.Options:resize(200, 300)
    else
      GUI.Options:hide()
    end 
  end
  GUI.OptionsButton = Geyser.Label:new2({
    name = "GUI.OptionsButton",
    x = -85, y = 5,
    width = 30,
    height = 30,
  })
  GUI.OptionsButton:setStyleSheet([[border-image: url("]]..ui.pathImg..[[helpButton.png")]]);
  GUI.OptionsButton:setClickCallback("ui.fOptionsButtonCallback", nil)
end</script>
				<eventHandlerList />
			</Script>
			<Script isActive="yes" isFolder="no">
				<name>Affects Widget</name>
				<packageName></packageName>
				<script>function ui.fInitAffectsWidget()
  --
  -- Alias buttons 
  GUI.Affect = Adjustable.Container:new2({
    name = "GUI.Affect",
    titleText ="Effetti",
    titleTxtColor = "orange",
    buttonsize = 12,
    buttonFontSize = 5,
    adjLabelstyle = GUI.CSS.AC, 
    buttonstyle = GUI.CSS.ACButtons,
  })
  --
  GUI.Affect.Main = Geyser.Label:new2({
    name = "GUI.Affect.Main",
    x = 0,
    y = 25,
    width = "100%",
    height = "100%-25",
  },GUI.Affect)
  GUI.Affect.Main:enableClickthrough()
  --
  -- Border
  ui.fAddBorder(GUI.Affect.Main, 2)
  --
  -- Affect icon
  local i
  for i=1, 20 do
    local col = (i-1) % 10;
    local row = (i&lt;=10)and(0)or(1)
    --
    GUI["AffectIcon"..i] = Geyser.Label:new2({
      name = "GUI.AffectIcon"..i,
      x = 32*col,
      y = 32*row,
      width = 30,
      height = 30,
    }, GUI.Affect.Main.Body)
    GUI["AffectIcon"..i]:setStyleSheet(GUI.CSS.Affect);
    --
    -- Icon
    GUI["AffectIcon"..i].icon = Geyser.Label:new2({
      name = "GUI.AffectIcon"..i..".icon",
      x = 4, y = 4,
      width = -4,
      height = -5,
    }, GUI["AffectIcon"..i])
    GUI["AffectIcon"..i].icon:setStyleSheet(GUI.CSS.AffectIcon)
    GUI["AffectIcon"..i].icon:enableClickthrough() -- for tooltip
    --
    -- Time
    GUI["AffectIcon"..i].time = Geyser.Label:new2({
      name = "GUI.AffectIcon"..i..".time",
      x = -20, y = -15,
      width = 30,
      height = 15,
    }, GUI["AffectIcon"..i])
    GUI["AffectIcon"..i].time:setStyleSheet([[
      background-color: rgba(0, 0, 0, 0);
    ]])
    --
    GUI["AffectIcon"..i]:hide()
  end
end</script>
				<eventHandlerList />
			</Script>
			<Script isActive="yes" isFolder="no">
				<name>Alias Buttons Widget</name>
				<packageName></packageName>
				<script>function ui.fInitAliasButtonsWidget()
  --
  -- Alias buttons 
  GUI.AliasButtons = Adjustable.Container:new2({
    name = "GUI.AliasButtons",
    titleText ="Pulsanti alias",
    titleTxtColor = "orange",
    buttonsize = 12,
    buttonFontSize = 5,
    adjLabelstyle = GUI.CSS.AC, 
    buttonstyle = GUI.CSS.ACButtons,
  })
  --
  --
  GUI.AliasButtons.Main = Geyser.Label:new2({
    name = "GUI.AliasButtons.Main",
    x = 0,
    y = 25,
    width = "100%",
    height = "100%-25",
  },GUI.AliasButtons)
  GUI.AliasButtons.Main:enableClickthrough()
  --
  -- Border
  ui.fAddBorder(GUI.AliasButtons.Main, 2)
  --
  -- Navigator box
  GUI.AliasButtons.Main.Body.Navigator = Geyser.Label:new2({
    name = "GUI.AliasButtons.Body.Main.Navigator",
    x = 0, 
    y = 0,
    width = 25,
    height = "100%",
    h_policy = Geyser.Fixed,
  },GUI.AliasButtons.Main.Body)
  --
  -- Up button
  GUI.AliasButtons.Main.Body.Navigator.Up = Geyser.Label:new2({
    name = "GUI.AliasButtons.Main.Body.Navigator.Up",
    x = 0, 
    y = 0,
    width = "100%",
    height = 25,
    v_policy = Geyser.Fixed,
  },GUI.AliasButtons.Main.Body.Navigator)
  GUI.AliasButtons.Main.Body.Navigator.Up:setStyleSheet([[border-image: url("]]..ui.pathImg..[[miniArrowUp.png")]]);
  GUI.AliasButtons.Main.Body.Navigator.Up:setClickCallback("ui.fIncraseButtonsPage")
  --
  -- Selected button page
  GUI.AliasButtons.Main.Body.Navigator.Page = Geyser.Label:new2({
    name = "GUI.AliasButtons.Main.Body.Navigator.Page",
    x = 0, 
    y = 25,
    width = 25,
    height = "100%-50",
  },GUI.AliasButtons.Main.Body.Navigator)
  GUI.AliasButtons.Main.Body.Navigator.Page:setColor(0, 0, 0, 0)
  --
  -- Down button
  GUI.AliasButtons.Main.Body.Navigator.Down = Geyser.Label:new2({
    name = "GUI.AliasButtons.Main.Body.Navigator.Down",
    x = 0, 
    y = "100%-25",
    width = "100%",
    height = 25,
    v_policy = Geyser.Fixed,
  },GUI.AliasButtons.Main.Body.Navigator)
  GUI.AliasButtons.Main.Body.Navigator.Down:setStyleSheet([[border-image: url("]]..ui.pathImg..[[miniArrowDown.png")]]);
  GUI.AliasButtons.Main.Body.Navigator.Down:setClickCallback("ui.fDecraseButtonsPage")
  --
  -- Alias Buttons Box
  GUI.AliasButtons.Main.Body.CButtons = GUI.CButtons or Geyser.Label:new({
    name = "GUI.AliasButtons.Main.Body.CButtons",
    x = 25, 
    y = 0,
    width = "100%-25",
    height = "100%",
  },GUI.AliasButtons.Main.Body)
  --
  -- Buttons
  for order=1,10 do
    local i = order % 10
    --
    -- Name
    GUI.AliasButtons.Main.Body.CButtons["Custom"..i] = Geyser.Label:new2({
      name = "GUI.AliasButtons.Main.Body.CButtons.Custom"..i,
      x = (10*i).."%", 
      y = 0,
      width = "10%",
      height = "100%",
    },GUI.AliasButtons.Main.Body.CButtons)
    GUI.AliasButtons.Main.Body.CButtons["Custom"..i]:setStyleSheet(GUI.CSS.AliasButtons);
    GUI.AliasButtons.Main.Body.CButtons["Custom"..i]:setClickCallback("ui.fClickAliasButton", i, nil)
    --
    -- Icon
    GUI.AliasButtons.Main.Body.CButtons["Custom"..i].icon = Geyser.Label:new2({
      name = "GUI.AliasButtons.Main.Body.CButtons.Custom"..i..".icon",
      x = 10, y = 10,
      width = -10,
      height = -10,
    }, GUI.AliasButtons.Main.Body.CButtons["Custom"..i])
    GUI.AliasButtons.Main.Body.CButtons["Custom"..i].icon:enableClickthrough()
    --
    -- Index
    GUI.AliasButtons.Main.Body.CButtons["Custom"..i].index = Geyser.Label:new2({
      name = "GUI.AliasButtons.Main.Body.CButtons.Custom"..i..".index",
      x = 0, y = 0,
      width = 25,
      height = 25,
      fontSize = 8,
    }, GUI.AliasButtons.Main.Body.CButtons["Custom"..i])
    GUI.AliasButtons.Main.Body.CButtons["Custom"..i].index:setStyleSheet([[border-image: url("]]..ui.pathImg..[[round.png") 0px stretch;]]);
    GUI.AliasButtons.Main.Body.CButtons["Custom"..i].index:enableClickthrough()
    --
    -- Keybid
    GUI.AliasButtons.Main.Body.CButtons["Custom"..i].keybind = Geyser.Label:new2({
      name = "GUI.AliasButtons.Main.Body.CButtons.Custom"..i..".keybind",
      x = 5, y = -15,
      width = -5,
      height = 15,
    }, GUI.AliasButtons.Main.Body.CButtons["Custom"..i])
    GUI.AliasButtons.Main.Body.CButtons["Custom"..i].keybind:setStyleSheet(GUI.CSS.Keybind);
    GUI.AliasButtons.Main.Body.CButtons["Custom"..i].keybind:enableClickthrough()
  end
end</script>
				<eventHandlerList />
			</Script>
			<Script isActive="yes" isFolder="no">
				<name>Equipment Widget</name>
				<packageName></packageName>
				<script>function ui.fInitEquipmentWidget()
  --
  -- Equip
  GUI.Equipment = Adjustable.Container:new2({
    name = "GUI.Equipment",
    titleText ="Equipaggiamento",
    titleTxtColor = "orange",
    buttonsize = 12,
    buttonFontSize = 5,
    adjLabelstyle = GUI.CSS.AC, 
    buttonstyle = GUI.CSS.ACButtons,
  })
  --
  GUI.Equipment.Main = Geyser.Label:new2({
    name = "GUI.Equipment.Main",
    x = 0,
    y = 25,
    width = "100%",
    height = "100%-25",
  },GUI.Equipment)
  GUI.Equipment.Main:enableClickthrough()
  --
  -- Border
  ui.fAddBorder(GUI.Equipment.Main, 1)
  --
  -- Body
  GUI.Equipment.Main.Body.Console = Geyser.MiniConsole:new2({
    name = 'GUI.Equipment.Main.Body.Console',
    x=0, y=0,
    width = "100%",
    height = "100%",
    autoWrap = true,
    scrollBar = false,
  }, GUI.Equipment.Main.Body)
  GUI.Equipment.Main.Body.Console:setColor(30,24,24)
  GUI.Equipment.Main.Body.Console:setBgColor(30,24,24)
end</script>
				<eventHandlerList />
			</Script>
			<Script isActive="yes" isFolder="no">
				<name>Group Widget</name>
				<packageName></packageName>
				<script>function ui.fInitGroupWidget()
  --
  -- Group Members
  GUI.Group = Adjustable.Container:new2({
    name = "GUI.Group",
    titleText ="Gruppo",
    titleTxtColor = "orange",
    buttonsize = 12,
    buttonFontSize = 5,
    adjLabelstyle = GUI.CSS.AC, 
    buttonstyle = GUI.CSS.ACButtons,
  })
  --
  GUI.Group.Main = Geyser.Label:new2({
    name = "GUI.Group.Main",
    x = 0,
    y = 25,
    width = "100%",
    height = "100%-25",
  },GUI.Group)
  GUI.Group.Main:enableClickthrough()
  --
  -- Border
  ui.fAddBorder(GUI.Group.Main, 2)
  --
  local i
  for i=1, 10 do
    local mod = i % 10
    --
    -- Member
    GUI.Group.Main.Body["g"..mod] = Geyser.Label:new2({
      name = "GUI.Group.Main.Body.g"..mod
    }, GUI.Group.Main.Body)
    GUI.Group.Main.Body["g"..mod]:setClickCallback("ui.fClickTarget", "g"..mod)
    --
    -- Member Health Gauges
    GUI.Group.Main.Body["g"..mod].Health = Geyser.Gauge:new2({
      name = "GUI.Group.Main.Body.g"..mod..".Health",
      x = 10,
      y = 7,
      width = -5,
      height = 20,
    }, GUI.Group.Main.Body["g"..mod])
    GUI.Group.Main.Body["g"..mod].Health:setValue(0, 100)
    GUI.Group.Main.Body["g"..mod].Health:enableClickthrough()
    --
    GUI.Group.Main.Body["g"..mod].Health.back:setStyleSheet(GUI.CSS.GaugeBack..[[
      background-color: rgba(150, 0, 0, 0.3);
    ]])
    GUI.Group.Main.Body["g"..mod].Health.back:enableClickthrough()
    --
    GUI.Group.Main.Body["g"..mod].Health.front:setStyleSheet(GUI.CSS.GaugeFront..[[
      background-color: QLinearGradient( x1: 0, y1: 0, x2: 0, y2: 1, stop: 0 #ee0000, stop: 0.65 #990000, stop: 1 #bb0000);
    ]])
    GUI.Group.Main.Body["g"..mod].Health.front:enableClickthrough()
    --
    -- Member Mana Gauges
    GUI.Group.Main.Body["g"..mod].Mana = Geyser.Gauge:new2({
      name = "GUI.Group.Main.Body.g"..mod..".Mana",
      x = 10,
      y = 25,
      width = -5,
      height = 7,
    }, GUI.Group.Main.Body["g"..mod])
    GUI.Group.Main.Body["g"..mod].Mana:setValue(0, 100)
    GUI.Group.Main.Body["g"..mod].Mana:enableClickthrough()
    --
    GUI.Group.Main.Body["g"..mod].Mana.back:setStyleSheet(GUI.CSS.GaugeBack..[[
      background-color: rgba(0, 0, 150, .3);
    ]])
    GUI.Group.Main.Body["g"..mod].Mana.back:enableClickthrough()
    --
    GUI.Group.Main.Body["g"..mod].Mana.front:setStyleSheet(GUI.CSS.GaugeFront..[[
      background-color: QLinearGradient( x1: 0, y1: 0, x2: 0, y2: 1, stop: 0 #0000ee, stop: 0.65 #000099, stop: 1 #0000bb);
    ]])
    GUI.Group.Main.Body["g"..mod].Mana.front:enableClickthrough()
    --
    -- Member Stamina Gauges
    GUI.Group.Main.Body["g"..mod].Stamina = Geyser.Gauge:new2({
      name = "GUI.g"..mod..".Stamina",
      x = 10,
      y = 30,
      width = -5,
      height = 7,
    }, GUI.Group.Main.Body["g"..mod])
    GUI.Group.Main.Body["g"..mod].Stamina:setValue(0, 100)
    GUI.Group.Main.Body["g"..mod].Stamina:enableClickthrough()
    --
    GUI.Group.Main.Body["g"..mod].Stamina.back:setStyleSheet(GUI.CSS.GaugeBack..[[
      background-color: rgba(0, 150, 0, .2);
    ]])
    GUI.Group.Main.Body["g"..mod].Stamina.back:enableClickthrough()
    --
    GUI.Group.Main.Body["g"..mod].Stamina.front:setStyleSheet(GUI.CSS.GaugeFront..[[
      background-color: QLinearGradient( x1: 0, y1: 0, x2: 0, y2: 1, stop: 0 #00aa00, stop: 0.65 #006600, stop: 1 #008800);
    ]])
    GUI.Group.Main.Body["g"..mod].Stamina.front:enableClickthrough()
    --
    -- Member gem
    GUI.Group.Main.Body["g"..mod].Gem = Geyser.Label:new2({
      name = "GUI.Group.Main.Body.g"..mod..".Gem",
      x = 0, y = 0,
      width = 30,
      height = 30,
    }, GUI.Group.Main.Body["g"..mod])
    GUI.Group.Main.Body["g"..mod].Gem:setStyleSheet([[
      border-image: url("]]..ui.pathImg..[[gemBlue.png") 0px stretch;
    ]]);
    GUI.Group.Main.Body["g"..mod].Gem:enableClickthrough()
    --
    -- Index
    GUI.Group.Main.Body["g"..mod].index = Geyser.Label:new2({
      name = "GUI.Group.Main.Body.g"..mod..".index",
      x = -20, 
      y = -20,
      width = 25,
      height = 25,
      fontSize = 6,
    }, GUI.Group.Main.Body["g"..mod])
    GUI.Group.Main.Body["g"..mod].index:echo("&lt;center&gt;g"..mod.."")
    GUI.Group.Main.Body["g"..mod].index:setStyleSheet([[border-image: url("]]..ui.pathImg..[[round.png") 0px stretch;]]);
    GUI.Group.Main.Body["g"..mod].index:enableClickthrough()
    --
    -- Keybid
    GUI.Group.Main.Body["g"..mod].keybind = Geyser.Label:new2({
      name = "GUI.Group.Main.Body.g"..mod..".keybind",
      x = 5, y = -10,
      width = -5,
      height = 15,
    }, GUI.Group.Main.Body["g"..mod])
    GUI.Group.Main.Body["g"..mod].keybind:setStyleSheet(GUI.CSS.Keybind);
    GUI.Group.Main.Body["g"..mod].keybind:echo("&lt;center&gt;keybind")
    GUI.Group.Main.Body["g"..mod].keybind:enableClickthrough()
  end
end</script>
				<eventHandlerList />
			</Script>
			<Script isActive="yes" isFolder="no">
				<name>Inventory Widget</name>
				<packageName></packageName>
				<script>function ui.fInitInventoryWidget()
  --
  -- Inventory
  GUI.Inventory = Adjustable.Container:new2({
    name = "GUI.Inventory",
    titleText ="Contenitore",
    titleTxtColor = "orange",
    buttonsize = 12,
    buttonFontSize = 5,
    adjLabelstyle = GUI.CSS.AC, 
    buttonstyle = GUI.CSS.ACButtons,
  })
  --
  GUI.Inventory.Main = Geyser.Label:new2({
    name = "GUI.Inventory.Main",
    x = 0,
    y = 25,
    width = "100%",
    height = "100%-25",
  },GUI.Inventory)
  GUI.Inventory.Main:enableClickthrough()
  --
  -- Border
  ui.fAddBorder(GUI.Inventory.Main, 1)
  --
  -- Body
  GUI.Inventory.Main.Body.Console = Geyser.MiniConsole:new2({
    name = 'GUI.Inventory.Main.Body.Console',
    x=0, y=0,
    width = "100%",
    height = "100%",
    autoWrap = true,
    scrollBar = false,
  }, GUI.Inventory.Main.Body)
  GUI.Inventory.Main.Body.Console:setColor(30,24,24)
  GUI.Inventory.Main.Body.Console:setBgColor(30,24,24)
end</script>
				<eventHandlerList />
			</Script>
			<Script isActive="yes" isFolder="no">
				<name>Map\Compass Widget</name>
				<packageName></packageName>
				<script>function ui.fInitMapCompassWidget()
  --
  -- Compass
  GUI.MapCompass = Adjustable.Container:new2({
    name = "GUI.MapCompass",
    titleText ="Mappa",
    titleTxtColor = "orange",
    buttonsize = 12,
    buttonFontSize = 5,
    adjLabelstyle = GUI.CSS.AC, 
    buttonstyle = GUI.CSS.ACButtons,
  })
  --
  GUI.MapCompass.Main = Geyser.Label:new2({
    name = "GUI.MapCompass.Main",
    x = 0,
    y = 25,
    width = "100%",
    height = "100%-25",
  },GUI.MapCompass)
  GUI.MapCompass.Main:enableClickthrough()
  --
  -- Border
  ui.fAddBorder(GUI.MapCompass.Main, 1)
  --
  -- Exits
  GUI.MapCompass.Main.Body.Exits = Geyser.MiniConsole:new2({ 
    name = 'GUI.MapCompass.Main.Body.Exits',
    x = 0, y = 0,
    width = "50%",
    height = "100%",
    scrollBar = false,
    fontSize = 10,
  }, GUI.MapCompass.Main.Body)
  GUI.MapCompass.Main.Body.Exits:setColor(30,24,24)
  GUI.MapCompass.Main.Body.Exits:setBgColor(30,24,24)
  --
  -- Other Exits
  GUI.MapCompass.Main.Body.OtherExits = Geyser.MiniConsole:new2({ 
    name = 'GUI.MapCompass.Main.Body.OtherExits',
    x = "50%", y = 0,
    width = "50%",
    height ="100%",
    scrollBar = false,
    fontSize = 10,
  }, GUI.MapCompass.Main.Body)
  GUI.MapCompass.Main.Body.OtherExits:setColor(30,24,24)
  GUI.MapCompass.Main.Body.OtherExits:setBgColor(30,24,24)
end</script>
				<eventHandlerList />
			</Script>
			<Script isActive="yes" isFolder="no">
				<name>Opponent Widget</name>
				<packageName></packageName>
				<script>function ui.fInitOpponentWidget()
  --
  -- Opponent
  GUI.Opponent = Adjustable.Container:new2({
    name = "GUI.Opponent",
    titleText = "Avversario",
    titleTxtColor = "orange",
    buttonsize = 12,
    buttonFontSize = 5,
    adjLabelstyle = GUI.CSS.AC, 
    buttonstyle = GUI.CSS.ACButtons,
  });
  --
  -- Opponent Level
  GUI.Opponent.Level = Geyser.Label:new2({
    name = "GUI.Opponent.Level",
    x = -60,
    y = 2,
    width = 25,
    height = 25,
    fontSize = 8,
  }, GUI.Opponent)
  GUI.Opponent.Level:setStyleSheet([[border-image: url("]]..ui.pathImg..[[round.png") 0px stretch;]]);
  GUI.Opponent.Level:enableClickthrough()
  --
  --
  GUI.Opponent.Main = Geyser.Label:new2({
    name = "GUI.Opponent.Main",
    x = 0,
    y = 25,
    width = "100%",
    height = "100%-25",
  }, GUI.Opponent)
  GUI.Opponent.Main:setStyleSheet(GUI.CSS.Border3..[[
    background-color: rgba(77, 0, 0);
  ]]);
  GUI.Opponent.Main:setClickCallback("ui.fExecuteTargetButton", "o0", nil)
  --
  -- Opponent Health Gauges
  GUI.Opponent.Main.Health = Geyser.Gauge:new2({
    name = "GUI.Opponent.Main.Health",
    x = 15,
    y = 14,
    width = -10,
    height = -11,
  },GUI.Opponent.Main)
  GUI.Opponent.Main.Health:setValue(0, 100)
  GUI.Opponent.Main.Health:enableClickthrough()
  --
  GUI.Opponent.Main.Health.back:setStyleSheet(GUI.CSS.GaugeBack..[[
    background-color: rgba(00, 0, 0, 0.3);
  ]]);
  GUI.Opponent.Main.Health.back:enableClickthrough()
  --
  GUI.Opponent.Main.Health.front:setStyleSheet(GUI.CSS.GaugeFront..[[
    background-color: QLinearGradient( x1: 0, y1: 0, x2: 0, y2: 1, stop: 0 #ee0000, stop: 0.65 #990000, stop: 1 #bb0000);
  ]])
  GUI.Opponent.Main.Health.front:enableClickthrough()
  --
  --
  GUI.Opponent.Main.Health.dif = Geyser.Label:new2({
    name = "GUI.Opponent.Main.Health.dif",
    x = 0,
    y = 0,
    width = "10",
    height = "10",
  }, GUI.Opponent.Main)
  GUI.Opponent.Main.Health.dif:enableClickthrough()
  --
  -- Opponent Gem
  GUI.Opponent.Main.Gem = Geyser.Label:new2({
    name = "GUI.Opponent.Main.Gem",
    x = 0, y = 0,
    width = 30,
    height = 30,
  }, GUI.Opponent.Main)
  GUI.Opponent.Main.Gem:setStyleSheet([[
    margin: 0px;
    border-image: url("]]..ui.pathImg..[[gemRed.png") 0px stretch;
  ]]);
  GUI.Opponent.Main.Gem:enableClickthrough()
  --
  -- Keybid
  GUI.Opponent.Main.keybind = Geyser.Label:new2({
    name = "GUI.Opponent.Main.keybind",
    x = 5, y = -15,
    width = -5,
    height = 15,
  }, GUI.Opponent.Main)
  GUI.Opponent.Main.keybind:setStyleSheet(GUI.CSS.Keybind);
  GUI.Opponent.Main.keybind:enableClickthrough()
  --
end</script>
				<eventHandlerList />
			</Script>
			<Script isActive="yes" isFolder="no">
				<name>Pivate Chat Widget</name>
				<packageName></packageName>
				<script>function ui.fInitPrivateChatWidget()
  --
  -- Private messages
  GUI.PrivateChat = Adjustable.Container:new2({
    name = "GUI.ACPrivate",
    titleText ="Canale privato",
    titleTxtColor = "orange",
    buttonsize = 12,
    buttonFontSize = 5,
    adjLabelstyle = GUI.CSS.AC, 
    buttonstyle = GUI.CSS.ACButtons,
  })
  --
  GUI.PrivateChat.Main = Geyser.Label:new2({
    name = "GUI.Private",
    x = 0,
    y = 25,
    width = "100%",
    height = "100%-25",
  },GUI.PrivateChat)
  GUI.PrivateChat.Main:enableClickthrough()
  --
  -- Border
  ui.fAddBorder(GUI.PrivateChat.Main, 1)
  --
  -- Body
  GUI.PrivateChat.Main.Body.Console = Geyser.MiniConsole:new2({
    name = 'GUI.PrivateChat.Main.Body.Console',
    x=0, y=0,
    width = "100%", 
    height = "100%",
    autoWrap = true,
    scrollBar = false,
  }, GUI.PrivateChat.Main.Body)
  GUI.PrivateChat.Main.Body.Console:setColor(30, 24, 24)
  GUI.PrivateChat.Main.Body.Console:setBgColor(30, 24, 24)
end</script>
				<eventHandlerList />
			</Script>
			<Script isActive="yes" isFolder="no">
				<name>Player Widget</name>
				<packageName></packageName>
				<script>function ui.fInitPlayerWidget()
  --
  -- Player 
  GUI.Player = Adjustable.Container:new2({
    name = "GUI.ACPlayer",
    titleText ="Player",
    titleTxtColor = "orange",
    buttonsize = 12,
    buttonFontSize = 5,
    adjLabelstyle = GUI.CSS.AC, 
    buttonstyle = GUI.CSS.ACButtons,
  })
  --
  GUI.Player.Box = Geyser.Label:new2({
    name = "GUI.Player",
    x = 0,
    y = 25,
    width = "100%",
    height = "100%-25",
  }, GUI.Player)
  GUI.Player.Box:setStyleSheet(GUI.CSS.Border3..[[
    background-color: rgba(30,24,24);
  ]]);
  GUI.Player.Box:enableClickthrough()
  --
  -- Player Health Gauges
  GUI.Player.Health = Geyser.Gauge:new2({
    name = "GUI.Player.Health",
    x = 8,
    y = 15,
    width = -5,
    height = "50%-15",
  },GUI.Player.Box)
  GUI.Player.Health:setValue(0, 100)
  --
  GUI.Player.Health.back:setStyleSheet(GUI.CSS.GaugeBack..[[
    background-color: rgba(150, 0, 0, 0.3);
  ]])
  --
  GUI.Player.Health.front:setStyleSheet(GUI.CSS.GaugeFront..[[
    background-color: QLinearGradient( x1: 0, y1: 0, x2: 0, y2: 1, stop: 0 #ee0000, stop: 0.65 #990000, stop: 1 #bb0000);
  ]])
  GUI.Player.Health.front:echo("Vita")
  --
  --
  GUI.Player.Health.dif = Geyser.Label:new2({
    name = "GUI.Player.Health.dif",
    x = 0,
    y = 0,
    width = "10",
    height = "10",
  }, GUI.Player.Box)
  --
  -- Tick
  GUI.Tick = Geyser.Gauge:new2({
    name = "GUI.Tick",
    x = 8,
    y = "50%-1",
    width = -5,
    height = 6,
  }, GUI.Player.Box)
  GUI.Tick:setValue(0, 75)
  --
  GUI.Tick.back:setStyleSheet(GUI.CSS.GaugeBack..[[
    background-color: rgba(255, 255, 255, 0.1);
  ]])
  --
  GUI.Tick.front:setStyleSheet(GUI.CSS.GaugeFront..[[
    background-color: grey;
  ]])
  --
  -- Player Mana Gauges
  GUI.Player.Mana = Geyser.Gauge:new2({
    name = "GUI.Player.Mana",
    x = 8,
    y = "50%+5",
    width = -5,
    height = "25%-5",
  },GUI.Player.Box)
  GUI.Player.Mana:setValue(0, 100)
  --
  GUI.Player.Mana.back:setStyleSheet(GUI.CSS.GaugeBack..[[
    background-color: rgba(0, 0, 150, .3);
  ]])
  --
  GUI.Player.Mana.front:setStyleSheet(GUI.CSS.GaugeFront..[[
    background-color: QLinearGradient( x1: 0, y1: 0, x2: 0, y2: 1, stop: 0 #0000ee, stop: 0.65 #000099, stop: 1 #0000bb);
  ]])
  GUI.Player.Mana.front:echo("Mana")
  --
  -- Player Stamina Gauges (used for moviment)
  GUI.Player.Stamina = Geyser.Gauge:new2({
    name = "GUI.Player.Stamina",
    x = 8,
    y = "75%",
    width = -5,
    height = "25%-5",
  },GUI.Player.Box)
  GUI.Player.Stamina:setValue(0, 100)
  --
  GUI.Player.Stamina.back:setStyleSheet(GUI.CSS.GaugeBack..[[
    background-color: rgba(0, 150, 0, .2);
  ]])
  --
  GUI.Player.Stamina.front:setStyleSheet(GUI.CSS.GaugeFront..[[
    background-color: QLinearGradient( x1: 0, y1: 0, x2: 0, y2: 1, stop: 0 #00aa00, stop: 0.65 #006600, stop: 1 #008800);
  ]])
  GUI.Player.Stamina.front:echo("Movimento")
  --
  -- Experience 
  GUI.Exp = Geyser.Gauge:new2({
    name = "GUI.Exp",
    x = 8, 
    y = 10,
    width = -5,
    height = 6,
  },GUI.Player.Box)
  GUI.Exp:setValue(0, 100)
  --
  GUI.Exp.front:echo("")
  --
  GUI.Exp.back:setStyleSheet(GUI.CSS.GaugeBack..[[
    background-color: rgba(255, 255, 255, 0.1);
  ]])
  --
  GUI.Exp.front:setStyleSheet(GUI.CSS.GaugeFront..[[
    background-color: purple;
  ]])
  --
  -- Player Gem
  GUI.Player.Gem = Geyser.Label:new2({
    name = "GUI.Player.Gem",
    x = 0,
    y = 0,
    width = 28,
    height = 28,
  }, GUI.Player.Box)
  GUI.Player.Gem:setStyleSheet([[
    margin: 0px;
    background-image: url("]]..ui.pathImg..[[gemEmpty.png");
  ]]);
  --
  -- Player Level
  GUI.Player.Level = Geyser.Label:new2({
    name = "GUI.Player.Level",
    x = -60,
    y = 2,
    width = 25,
    height = 25,
    fontSize = 8,
  }, GUI.Player)
  GUI.Player.Level:setStyleSheet([[border-image: url("]]..ui.pathImg..[[round.png") 0px stretch;]]);
end</script>
				<eventHandlerList />
			</Script>
			<Script isActive="yes" isFolder="no">
				<name>Public Chat Widget</name>
				<packageName></packageName>
				<script>function ui.fInitPublicChatWidget()
  --
  -- Public messages
  GUI.PublicChat = Adjustable.Container:new2({
    name = "GUI.PublicChat",
    titleText ="Canale pubblico",
    titleTxtColor = "orange",
    buttonsize = 12,
    buttonFontSize = 5,
    adjLabelstyle = GUI.CSS.AC, 
    buttonstyle = GUI.CSS.ACButtons,
  })
  --
  GUI.PublicChat.Main = Geyser.Label:new2({
    name = "GUI.Public",
    x = 0,
    y = 25,
    width = "100%",
    height = "100%-25",
  },GUI.PublicChat)
  GUI.PublicChat.Main:enableClickthrough()
  --
  -- Border
  ui.fAddBorder(GUI.PublicChat.Main, 1)
  --
  -- Body
  GUI.PublicChat.Main.Body.Console = Geyser.MiniConsole:new2({
    name = 'GUI.PublicChat.Main.Body.Console',
    x=0, y=0,
    width = "100%", 
    height = "100%",
    autoWrap = true,
    scrollBar = false,
  }, GUI.PublicChat.Main.Body)
  GUI.PublicChat.Main.Body.Console:setColor(30, 24, 24)
  GUI.PublicChat.Main.Body.Console:setBgColor(30, 24, 24)
end</script>
				<eventHandlerList />
			</Script>
			<Script isActive="yes" isFolder="no">
				<name>Target Buttons Widget</name>
				<packageName></packageName>
				<script>function ui.fInitTargetButtonsWidget()
  --
  -- Target
  GUI.TargetButtons = Adjustable.Container:new2({
    name = "GUI.TargetButtons",
    titleText ="Target",
    titleTxtColor = "orange",
    buttonsize = 12,
    buttonFontSize = 5,
    adjLabelstyle = GUI.CSS.AC, 
    buttonstyle = GUI.CSS.ACButtons,
  })
  --
  GUI.TargetButtons.Main = Geyser.Label:new2({
    name = "GUI.TargetButtons.Main",
    x = 0,
    y = 25,
    width = "100%",
    height = "100%-25",
  },GUI.TargetButtons)
  --
  -- Border
  ui.fAddBorder(GUI.TargetButtons.Main, 2)
  --
  -- Target buttons
  GUI.TargetButtons.Main.Body.t1 = Geyser.Label:new2({
    name = "GUI.TargetButtons.Main.Body.t1",
    x = 0,
    y = 0,
    width = "50%",
    height = "50%",
  },GUI.TargetButtons.Main.Body)
  --
  GUI.TargetButtons.Main.Body.t2 = Geyser.Label:new2({
    name = "GUI.TargetButtons.Main.Body.t2",
    x = "50%",
    y = 0,
    width = "50%",
    height = "50%",
  },GUI.TargetButtons.Main.Body)
  --
  GUI.TargetButtons.Main.Body.t3 = Geyser.Label:new2({
    name = "GUI.TargetButtons.Main.Body.t3",
    x = 0,
    y = "50%",
    width = "50%",
    height = "50%",
  },GUI.TargetButtons.Main.Body)
  --
  GUI.TargetButtons.Main.Body.t4 = Geyser.Label:new2({
    name = "GUI.TargetButtons.Main.Body.t4",
    x = "50%",
    y = "50%",
    width = "50%",
    height = "50%",
  },GUI.TargetButtons.Main.Body)
  --
  for i=1,4 do
    GUI.TargetButtons.Main.Body["t"..i]:setFontSize(10)
    GUI.TargetButtons.Main.Body["t"..i]:setFgColor("LightGoldenrod")
    GUI.TargetButtons.Main.Body["t"..i]:setClickCallback("ui.fExecuteTargetButton", "t"..i, nil)
    --
    -- Index
    GUI.TargetButtons.Main.Body["t"..i].index = Geyser.Label:new2({
      name = "GUI.TargetButtons.Main.Body.t"..i..".index",
      x = 0, y = 0,
      width = 25,
      height = 25,
      fontSize = 8,
    }, GUI.TargetButtons.Main.Body["t"..i])
    GUI.TargetButtons.Main.Body["t"..i].index:echo("&lt;center&gt;t"..i.."")
    GUI.TargetButtons.Main.Body["t"..i].index:setStyleSheet([[border-image: url("]]..ui.pathImg..[[round.png") 0px stretch;]]);
    GUI.TargetButtons.Main.Body["t"..i].index:enableClickthrough()
    --
    -- Keybid
    GUI.TargetButtons.Main.Body["t"..i].keybind = Geyser.Label:new2({
      name = "GUI.TargetButtons.Main.Body.t"..i..".keybind",
      x = 5, y = -15,
      width = -5,
      height = 15,
    }, GUI.TargetButtons.Main.Body["t"..i])
    GUI.TargetButtons.Main.Body["t"..i].keybind:setStyleSheet(GUI.CSS.Keybind);
    GUI.TargetButtons.Main.Body["t"..i].keybind:enableClickthrough()
  end
end</script>
				<eventHandlerList />
			</Script>
		</ScriptGroup>
		<Script isActive="yes" isFolder="no">
			<name>Init Structures</name>
			<packageName></packageName>
			<script>--
ui = ui or {}
ui.enDebug = false
ui.release = "1-220210"
ui.autoUpdate = true
ui.echo = "&lt;blue&gt;[  &lt;DodgerBlue&gt;UI  &lt;blue&gt;] "
--
-- Colors
ui.cAliasButton = "&lt;orange&gt;"
ui.cAliasName = "&lt;violet&gt;"
ui.cAliasOutput = "&lt;PaleGoldenrod&gt;"
ui.cCommand = "&lt;steel_blue&gt;"
ui.cError = "&lt;DarkOrange&gt;"
ui.cInput = "&lt;MediumSeaGreen&gt;" -- #
ui.cKeybind = "&lt;cyan&gt;"
ui.cLink = "&lt;blue&gt;"
ui.cOperator = "&lt;salmon&gt;"      -- » or «
ui.cProfileName = "&lt;green&gt;"
ui.cSeparator = "&lt;orange_red&gt;" -- ; or /
ui.cTarget = "&lt;orange&gt;"
ui.cText = "&lt;grey&gt;"
ui.cTitle = "&lt;white&gt;"
ui.cVarID = "&lt;steel_blue&gt;"
ui.cVarName = "&lt;DeepPink&gt;"
ui.cVarCont = "&lt;LightBlue&gt;"
--
ui.fDebug("[init] Structures")
--
-- Outpt file path
ui.pathPkg = getMudletHomeDir().."/"
ui.pathTpl = ui.pathPkg.."Lumen et Umbra UI/"
--
ui.pathIcn = ui.pathTpl.."icons/"
ui.pathImg = ui.pathTpl.."images/"
ui.pathPrf = ui.pathTpl.."profiles/"
ui.pathSnd = ui.pathTpl.."sounds/"
--
ui.fileNameAliases = "aliases.lua";
ui.fileNameHighlights = "highlights.lua";
ui.fileNameParameters = "parameters.lua";
ui.fileNameTargets = "targets.lua";
ui.fileNameVariables = "variables.lua";
--
ui.fileAliases = ui.pathTpl..ui.fileNameAliases;
ui.fileHighlights = ui.pathTpl..ui.fileNameHighlights;
ui.fileParameters = ui.pathTpl..ui.fileNameParameters;
ui.fileTargets = ui.pathTpl..ui.fileNameTargets;
ui.fileVariables = ui.pathTpl..ui.fileNameVariables;
--
ui.varID = "@"
--
-- Icons for affect 
ui.affects = {
  ["[CD] Nuovo Dungeon"]        = {icon = "skill_115.png", color = "blue", shortName = "CD Dung" },
  ["[CD] Nuova Missione"]       = {icon = "skill_115.png", color = "blue", shortName = "CD Miss" },  
  ["avvelena"]                  = {icon = nil,             color = "YellowGreen", shortName = "Vel" },
  ["chiaroveggenza"]            = {icon = nil,             color = "magenta", shortName = "Chiaro" },  
  ["colpo psichico"]            = {icon = nil,             color = "magenta", shortName = "Colpo PSI" },  
  ["forza psichica"]            = {icon = "skill_9.png",   color = "OrangeRed", shortName = "PSI Str" },
  ["individua il magico"]       = {icon = 'Skill_322.png', color = "DarkOrchid", shortName = "Ind. mag." },
  ["individua il male"]         = {icon = 'skill_72.png',  color = "DarkOrchid", shortName = "Ind. mal." },
  ["individua invisibile"]      = {icon = "Skill_312.png", color = "DarkOrchid", shortName = "Ind. inv." },
  ["levitazione"]               = {icon = "skill_156.png", color = "blue", shortName = "Lev" },
  ["nuotare (cooldown)"]        = {icon = "skill_110.png", color = "blue", shortName = "Swim" },
  ["percepisci vita"]           = {icon = "skill_44.png",  color = "DarkOrchid", shortName = "True Live" },
  ["primo soccorso"]            = {icon = nil,             color = "green", shortName = "First AID" },  
  ["santuario"]                 = {icon = "Skill_243.png", color = "white", shortName = "Sanc" },
  ["scarica di adrenalina"]     = {icon = "Skill_472.png", color = "yellow", shortName = "PSI Dro" },
  ["scopri le trappole"]        = {icon = "skill_166.png", color = "brown", shortName = "Det. trap" },
  ["scudo di fuoco"]            = {icon = "Skill_448.png", color = "firebrick", shortName = "PSI Fire" },
  ["scudo psichico"]            = {icon = "skill_168.png", color = "cyan", shortName = "PSI Shield" },
  ["vera vista"]                = {icon = "Skill_264.png", color = "DarkOrchid", shortName = "Vera Vista" },
}
--
-- Modifier for keybind
ui.keyb_modifier = {
  CTRL = mudlet.keymodifier.Control,
  ALT = mudlet.keymodifier.Alt,
}
--
-- Keys for keybind
ui.keyb_single = {
  ["0"] = mudlet.key["0"],
  ["1"] = mudlet.key["1"],
  ["2"] = mudlet.key["2"],
  ["3"] = mudlet.key["3"],
  ["4"] = mudlet.key["4"],
  ["5"] = mudlet.key["5"],
  ["6"] = mudlet.key["6"],
  ["7"] = mudlet.key["7"],
  ["8"] = mudlet.key["8"],
  ["9"] = mudlet.key["9"],
  A = mudlet.key.A,
  B = mudlet.key.B,
  C = mudlet.key.C,
  D = mudlet.key.D,
  E = mudlet.key.E,
  F = mudlet.key.F,
  G = mudlet.key.G,
  H = mudlet.key.H,
  I = mudlet.key.I,
  J = mudlet.key.J,
  K = mudlet.key.k,
  L = mudlet.key.L,
  M = mudlet.key.M,
  N = mudlet.key.N,
  O = mudlet.key.O,
  P = mudlet.key.P,
  Q = mudlet.key.Q,
  R = mudlet.key.R,
  S = mudlet.key.S,
  T = mudlet.key.T,
  U = mudlet.key.U,
  V = mudlet.key.V,
  W = mudlet.key.W,
  X = mudlet.key.X,
  Y = mudlet.key.Y,
  Z = mudlet.key.Z,
  F1  = mudlet.key.F1,
  F2  = mudlet.key.F2,
  F3  = mudlet.key.F3,
  F4  = mudlet.key.F4,
  F5  = mudlet.key.F5,
  F6  = mudlet.key.F6,
  F7  = mudlet.key.F7,
  F8  = mudlet.key.F8,
  F9  = mudlet.key.F9,
  F10 = mudlet.key.F10,
  F11 = mudlet.key.F11,
  F12 = mudlet.key.F12,
}
--
ui.dirCompress = {
  down  = "d",
  basso = "d",
  d     = "d",
  east  = "e",
  est   = "e",
  e     = "e",
  north = "n",
  nord  = "n",
  n     = "n",
  south = "s",
  sud   = "s",
  s     = "s",
  up    = "u",
  alto  = "u",
  u     = "u",
  west  = "w",
  ovest = "w",
  w     = "w",
}
--
ui.dirExpand = {
  d = "basso",
  e = "est",
  n = "nord",
  s = "sud",
  u = "alto",
  w = "ovest",
}
--
ui.dirTokenX = {
  d = "└",
  e = "│",
  n = "─",
  s = "─",
  u = "┐",
  w = "│",
}
--
ui.dirToken = {
  d = "⤦",
  e = "▷",
  n = "△",
  s = "▽",
  u = "⤤",
  w = "◁",
}
--
ui.dirTokenSecret = {
  d = "S",
  e = "S",
  n = "S",
  s = "S",
  u = "S",
  w = "S",
}
--
ui.dirTokenClose = {
  d = "□",
  e = "□",
  n = "□",
  s = "□",
  u = "□",
  w = "□",
}
--
ui.dirTokenFrom = {
  d = "◆",
  e = "◆",
  n = "◆",
  s = "◆",
  u = "◆",
  w = "◆",
}
--
ui.dirTokenColor = {
  d     = "&lt;255,255,255:30,24,24&gt;", -- white
  e     = "&lt;255,255,0:30,24,24&gt;",   -- yellow
  n     = "&lt;0,255,0:30,24,24&gt;",     -- green
  s     = "&lt;0,0,255:30,24,24&gt;",     -- blue
  u     = "&lt;0,255,255:30,24,24&gt;",   -- cyan
  w     = "&lt;255,0,255:30,24,24&gt;",   -- magenta
}
--
ui.dirReverse = {
  d     = "u",
  basso = "alto",
  e     = "w",
  est   = "ovest",
  n     = "s",
  nord  = "sud",
  s     = "n",
  sud   = "nord",
  u     = "d",
  alto  = "basso",
  w     = "e",
  ovest = "est",
}
--
ui.lastFromPrivate = ui.lastFromPrivate or ""
ui.lastFromPubblic = ui.lastFromPubblic or ""
--
ui.roomName = ui.roomName or ""
ui.roomType = ui.roomType or ""
--
ui.strExits = ui.strExits or ""
ui.exits = ui.exits or {}
ui.track = ui.track or ""
ui.position = ui.position or "centro"
--
-- Pre defined variables
ui.pre_defined_variables = {
  ac = 0,
  alignment = 0,
  character_name = "@character_name",
  experience = 0,
  health = 100,
  health_max = 100,
  level = 1,
  mana = 70,
  mana_max = 100,
  money = 0,
  movement = 30,
  movement_max = 100,
  opponent_health = 0,
  opponent_health_max = 100,
  opponent_level = 1,
  opponent_name = "",
  target = "",
}
--
-- Pre defined target buttons
ui.pre_defined_target_buttons = {
  g0 = { mod1 = "CTRL", mod2 = "", key = "F10" },
  g1 = { mod1 = "CTRL", mod2 = "", key = "F1" },
  g2 = { mod1 = "CTRL", mod2 = "", key = "F2" },
  g3 = { mod1 = "CTRL", mod2 = "", key = "F3" },
  g4 = { mod1 = "CTRL", mod2 = "", key = "F4" },
  g5 = { mod1 = "CTRL", mod2 = "", key = "F5" },
  g6 = { mod1 = "CTRL", mod2 = "", key = "F6" },
  g7 = { mod1 = "CTRL", mod2 = "", key = "F7" },
  g8 = { mod1 = "CTRL", mod2 = "", key = "F8" },
  g9 = { mod1 = "CTRL", mod2 = "", key = "F9" },
  o0 = { mod1 = "CTRL", mod2 = "", key = "0" },
  t1 = { mod1 = "CTRL", mod2 = "", key = "1" },
  t2 = { mod1 = "CTRL", mod2 = "", key = "2" },
  t3 = { mod1 = "CTRL", mod2 = "", key = "3" },
  t4 = { mod1 = "CTRL", mod2 = "", key = "4" },
}
--
-- Storico Path
ui.idxPath = 0;
ui.memPath = 0;
ui.maxPath = 50;
ui.path = {}
--
-- Group
ui.group = ui.group or {}
ui.totalMember = 0
--
-- Affects
ui.actAffects = ui.actAffects or {}
--
-- General
ui.pre_defined_parameters = {
  fsMapCompass = 6,
  fsEquipment = 6,
  fsInventory = 6,
  fsPrivateChat = 6,
  fsPublicChat = 6,
  page = "a"
}</script>
			<eventHandlerList />
		</Script>
		<Script isActive="yes" isFolder="no">
			<name>Init CSS</name>
			<packageName></packageName>
			<script>--
ui.fDebug("[init] CSS")
--
GUI = GUI or {}
GUI.CSS = GUI.CSS or {}
--
-- User Windos TAB
GUI.CSS.Tab = [[
.QWidget{
  background: rgba(30,24,24);
}
QDockWidget{
  font-family: 'IM Fell DW Pica', serif;
  font-size: 14px;
}
QDockWidget::title{ 
  border-style: outset;
  border-width: 2px;
  border-color: "#996600";
  border-top-left-radius: 10px;
  border-top-right-radius: 10px;
  background-color: #4d0000;
  margin-right: 1px;
  margin-left: 1px;
  text-align: center;
}
QDockWidget::title::hover{
  background-color: #b30000;
}
QDockWidget::close-button{
    subcontrol-position: top right;
    subcontrol-origin: margin;
    position: absolute;
    top: 0px; 
    right: 10px; 
    bottom: 0px;
    width: 15px;
}
QDockWidget::float-button {
    subcontrol-position: top left;
    subcontrol-origin: margin;
    position: absolute;
    top: 0px; 
    left: 10px; 
    bottom: 0px;
    width: 15px;
}
]]
--
-- Affect
GUI.CSS.Affect = [[
QLabel {
  border: 1px solid;
  border-radius: 14px;
  border-image: url("]]..ui.pathImg..[[round.png") 0px stretch;
  background-color: rgba(30, 24, 0);
}
]]
--
-- Affect Icon
GUI.CSS.AffectIcon = [[
  border: 0px solid;
  border-radius: 10px;
  qproperty-alignment: 'AlignVCenter | AlignCenter';
  qproperty-wordWrap: true;
]]
--
-- Target buttons
GUI.CSS.Target = [[
  margin: 5px;
  border-style: outset;
  border-width: 2px;
  border-color: "#aa8822";
  border-radius: 5px 10px;
  font-family: 'IM Fell DW Pica', serif;
  qproperty-wordWrap: true;
]]
--
-- Group target buttons
GUI.CSS.Border3 = [[
  margin: 0;
  border: 6px solid transparent;
  border-image: url("]]..ui.pathImg..[[playerBG.png") 6px stretch;
  background-color: rgba(30,24,24);
]]
--
-- Alias buttons
GUI.CSS.AliasButtons = [[
  border: 10px solid transparent;
  border-image: url("]]..ui.pathImg..[[buttonBorder.png") 10px stretch;
  margin: 5px;
]]
--
-- Buttons Icon
GUI.CSS.ButtonsIcon = [[
  background-color: rgba(0,0,0,0);
  font-family: 'IM Fell DW Pica', serif;
  font-size: 8px;
  qproperty-wordWrap: true;
]]
--
-- Gauge back
GUI.CSS.GaugeBack = [[
  border: none;
  border-radius: 5px;
  margin: 1px;
  font-size: 4;
]]
-- font-family: 'IM Fell DW Pica SC', serif;
--
-- Gauge front
GUI.CSS.GaugeFront = [[
  border-radius: 3px;
  margin:  2px 0px 2px 0px;
  font-size: 4;
]]
-- font-family: 'IM Fell DW Pica SC', serif;
--
-- Target Name
GUI.CSS.Name = [[
  background-color: rgba(0,0,0,.6);
  opacity: 50;
  border-color: black;
  border-width: 1px;
  border-radius: 5px;
  border-style: none;
  margin: 1px;
  font-family: 'IM Fell DW Pica SC', serif;
  qproperty-wordWrap: true;
]]
--
-- Keybind
GUI.CSS.Keybind = [[
  background-color: rgba(0, 0, 0, 0);
  font-size: 4;
]]
--  font-family: 'IM Fell DW Pica', serif;
GUI.CSS.AC = [[
  border: 2px solid rgb(90,72,72); 
  border-top-left-radius: 10px;
  border-top-right-radius: 10px;
  background-color: rgb(30,24,24);
]]
--
GUI.CSS.ACButtons = [[
  QLabel{
    border-radius: 5px;
    background-color: rgb(90,72,72);
  }
  QLabel::hover{
    background-color: rgb(180,144,144);}
]]</script>
			<eventHandlerList />
		</Script>
		<Script isActive="yes" isFolder="no">
			<name>Init Help</name>
			<packageName></packageName>
			<script>ui.fDebug("[init] Help")
--
ui.help = {}
--
ui.help.error = [[
Non esiste aiuto per questa parola
]]
--
ui.help.help = [[
&lt;title&gt;Lumen et Umbra UI Help&lt;/title&gt;
Lumen et Umbra UI comprende un insieme di componenti grafici, script, trigger,
etc, creati per personalizzare l'esperienza di gioco con il MUD Lumen et Umbra.
Usare il comando &lt;command&gt;uih[elp] &lt;comando&gt;&lt;/command&gt; per avere informazioni sugli argomenti:
Comandi:
  - &lt;command&gt;uia[liases]&lt;/command&gt;     - Aliases
  - &lt;command&gt;uib[uttons]&lt;/command&gt;     - Pulsanti per alias (a0..a9, b0..b9, c0..c9)
  - &lt;command&gt;uihi[ghlights]&lt;/command&gt;  - Highlights
  - &lt;command&gt;uik[eibind]&lt;/command&gt;     - Tasti rapidi per aliases e targets
  - &lt;command&gt;uip[rofiles]&lt;/command&gt;    - Profili
  - &lt;command&gt;uiv[ariables]&lt;/command&gt;   - Variabili
Altri argomenti:
  - &lt;command&gt;target&lt;/command&gt;          - Target (g0..g9, o0, t1..t4)
Altri comandi:
  - &lt;command&gt;uic[olors]&lt;/command&gt;      - Lista colori disponibili
  - &lt;command&gt;uisetf[ontsize]&lt;/command&gt; - Dimensione font delle finestre
  - &lt;command&gt;.&lt;/command&gt;/&lt;command&gt;..&lt;/command&gt;            - Walk e speedwalk
]]
--
ui.help.alias = [[
&lt;title&gt;Aliases&lt;/title&gt;
Gli aliases permettono di eseguire lunghi comandi digitando poche lettere. E'
possibile arricchire il comando associato all'alias utilizzando le variabili
create con il comando &lt;command&gt;uivariable&lt;/command&gt;. E' possibile associare 
più comandi ad un alias utilizzando gli appositi separatori.
&lt;white&gt;Configurazione:&lt;reset&gt;
  &lt;command&gt;uia[liases]&lt;/command&gt;                   Per visualizzare l'elenco degli aliases
  &lt;command&gt;uia[liases]&lt;/command&gt; &lt;aliasName&gt;&lt;alias&gt;&lt;/aliasName&gt;           Per visualizzare il singolo alias
  &lt;command&gt;uia[liases]&lt;/command&gt; &lt;aliasName&gt;&lt;alias&gt;&lt;/aliasName&gt; &lt;command&gt;&lt;comandi&gt;&lt;/command&gt; Per creare o modificare un alias
  &lt;command&gt;uia[liases]&lt;/command&gt; &lt;aliasName&gt;&lt;alias&gt;&lt;/aliasName&gt; &lt;command&gt;remove&lt;/command&gt;    Per eliminare un alias
  &lt;command&gt;uia[liases] remove_all&lt;/command&gt;        Per eliminare tutti gli aliases
&lt;white&gt;Utilizzo:&lt;reset&gt;
  &lt;aliasName&gt;&lt;alias&gt;&lt;/aliasName&gt; &lt;input&gt;[argomento]&lt;/input&gt;           Per eseguire l'alias
&lt;white&gt;Caratteri speciali:&lt;reset&gt; &lt;input&gt;#&lt;/input&gt; Parametro - ]]..ui.cVarID..ui.varID..[[&lt;reset&gt; Variabile - ]]..ui.cSeparator..[[;&lt;reset&gt; o ]]..ui.cSeparator..[[/&lt;reset&gt; = Divisore comandi
&lt;white&gt;Es. 1:&lt;reset&gt; &lt;command&gt;uia&lt;/command&gt; &lt;aliasName&gt;hl&lt;/aliasName&gt; &lt;aliasOutput&gt;cast 'heal'&lt;/aliasOutput&gt;       | &lt;white&gt;Es. 2:&lt;reset&gt; &lt;command&gt;uia&lt;/command&gt; &lt;aliasName&gt;bt&lt;/aliasName&gt; &lt;aliasOutput&gt;bash&lt;/aliasOutput&gt; &lt;varName&gt;target&lt;/varName&gt;   
  &lt;aliasName&gt;hl&lt;/aliasName&gt;        : &lt;aliasOutput&gt;cast 'heal'&lt;/aliasOutput&gt;       |   &lt;varName&gt;target&lt;/varName&gt; &lt;varValue&gt;Pluto&lt;/varValue&gt;
  &lt;aliasName&gt;hl&lt;/aliasName&gt; &lt;input&gt;Pippo&lt;/input&gt;  : &lt;aliasOutput&gt;cast 'heal'&lt;/aliasOutput&gt; &lt;input&gt;Pippo&lt;/input&gt; |   &lt;aliasName&gt;bt&lt;/aliasName&gt;          : &lt;aliasOutput&gt;bash&lt;/aliasOutput&gt; &lt;varValue&gt;Pluto&lt;/varValue&gt;
                                |   &lt;aliasName&gt;bt&lt;/aliasName&gt; &lt;input&gt;Pippo&lt;/input&gt;    : &lt;aliasOutput&gt;bash&lt;/aliasOutput&gt; &lt;input&gt;Pippo&lt;/input&gt;
-------------------------------- ----------------------------------
&lt;white&gt;Es. 3:&lt;reset&gt; &lt;command&gt;uia&lt;/command&gt; &lt;aliasName&gt;aa&lt;/aliasName&gt; &lt;varName&gt;action&lt;/varName&gt; &lt;varName&gt;target&lt;/varName&gt;   | &lt;white&gt;Es. 4:&lt;reset&gt; &lt;command&gt;uia&lt;/command&gt; &lt;aliasName&gt;dd&lt;/aliasName&gt; &lt;aliasOutput&gt;get&lt;/aliasOutput&gt; &lt;input&gt;#&lt;/input&gt; &lt;varName&gt;bag&lt;/varName&gt;]]..ui.cSeparator..[[;&lt;reset&gt;&lt;aliasOutput&gt;drink&lt;/aliasOutput&gt; &lt;input&gt;#&lt;/input&gt;]]..ui.cSeparator..[[;&lt;reset&gt;&lt;aliasOutput&gt;put&lt;/aliasOutput&gt; &lt;input&gt;#&lt;/input&gt; &lt;varName&gt;bag&lt;/varName&gt;
  &lt;varName&gt;action&lt;/varName&gt; &lt;varValue&gt;kick&lt;/varValue&gt;                  |   &lt;varName&gt;bag&lt;/varName&gt; &lt;varValue&gt;moltetasche&lt;/varValue&gt;
  &lt;varName&gt;target&lt;/varName&gt; &lt;varValue&gt;Pluto&lt;/varValue&gt;                 |   &lt;aliasName&gt;dd&lt;/aliasName&gt; &lt;input&gt;limonata&lt;/input&gt; : &lt;aliasOutput&gt;get&lt;/aliasOutput&gt; &lt;input&gt;limonata&lt;/input&gt; &lt;varValue&gt;moltetasche&lt;/varValue&gt;
  &lt;aliasName&gt;aa&lt;/aliasName&gt;        : &lt;varValue&gt;kick&lt;/varValue&gt; &lt;varValue&gt;Pluto&lt;/varValue&gt;        |               : &lt;aliasOutput&gt;drink&lt;/aliasOutput&gt; &lt;input&gt;limonata&lt;/input&gt;
  &lt;aliasName&gt;aa&lt;/aliasName&gt; &lt;input&gt;Pippo&lt;/input&gt;  : &lt;varValue&gt;kick&lt;/varValue&gt; &lt;input&gt;Pippo&lt;/input&gt;        |               : &lt;aliasOutput&gt;put&lt;/aliasOutput&gt; &lt;input&gt;limonata&lt;/input&gt; &lt;varValue&gt;moltetasche&lt;/varValue&gt;
]]
--
ui.help.button = [[
&lt;title&gt;Pulsanti per alias (a0..a9, b0..b9, c0..c9)&lt;/title&gt;
I pulsanti degli alias sono i pulsanti che posso essere personalizzati 
assonciandogli un alias. Sono identificati con una lettera (a, b oppure c) e un
numero (da 0 a 9) per un totale di 30 pulsanti configurabili (da a0 a c9).
&lt;white&gt;Configurazione:&lt;reset&gt;
  &lt;command&gt;uib[uttons]&lt;/command&gt;                  Per visualizzare l'elenco dei pulsanti configurati
  &lt;command&gt;uib[uttons]&lt;/command&gt; &lt;button&gt;         Per visualizzare il singolo pulsante
  &lt;command&gt;uib[uttons]&lt;/command&gt; &lt;button&gt; &lt;aliasName&gt;&lt;alias&gt;&lt;/aliasName&gt;  Per associare un alias al pusante
  &lt;command&gt;uib[uttons]&lt;/command&gt; &lt;button&gt; &lt;command&gt;remove&lt;/command&gt;   Per eliminare l'alias associato al pulsante
  &lt;command&gt;uib[uttons] remove_all&lt;/command&gt;       Per eliminare gli aliases associati a tutti i pulsanti
&lt;white&gt;Utilizzo:&lt;reset&gt;
  &lt;button&gt; o click             Per eseguire l'alias associato al pulsante
]]
--
ui.help.color = [[
&lt;title&gt;Colori&lt;/title&gt;
E' possibile visualizzare l'elenco dei colori che si possono utilizzare negli
uiHilights tramite il comando &lt;command&gt;uiColors&lt;/command&gt;.  
&lt;white&gt;Utilizzo:&lt;reset&gt;
  &lt;command&gt;uic[olors]&lt;/command&gt;    Per visualizzare l'elenco dei colori
]]
--
ui.help.fontsize = [[
&lt;title&gt;Impostare la dimensione del font delle finestre&lt;/title&gt;
E' possibile cambiare la dimensione del font di alcune finestre dell'UI.
&lt;white&gt;Utilizzo:&lt;reset&gt;
  &lt;command&gt;uisetf[ontsize] &lt;nome_finetra&gt; &lt;dimensione_font&gt;&lt;/command&gt;
I &lt;command&gt;&lt;nome_finetra&gt;&lt;/command&gt; disponibili sono: &lt;command&gt;contenitore&lt;/command&gt;, &lt;command&gt;equipaggiamento&lt;/command&gt;, &lt;command&gt;mappa&lt;/command&gt;, &lt;command&gt;privato&lt;/command&gt; o &lt;command&gt;pubblico&lt;/command&gt;.
Le &lt;command&gt;&lt;dimensione_font&gt;&lt;/command&gt; devono essere un valore compreso tra &lt;command&gt;1&lt;/command&gt; e &lt;command&gt;30&lt;/command&gt;.
]]
--
ui.help.highlight = [[
&lt;title&gt;Highlights&lt;/title&gt;
Gli Highlights permettono di evidenziare le parole e le frasi del mud 
cambiandone il colore. Questo può semplificare la visualizzazione di elementi 
importanti come, ad esempio, evidenziare la presenza di una &lt;red&gt;cassa&lt;reset&gt; nella 
descrizione di una stanza.
&lt;white&gt;Configurazione:&lt;reset&gt;
  &lt;command&gt;uihi[lights]&lt;/command&gt;                   Per visualizzare l'elenco degli highlights
  &lt;command&gt;uihi[lights]&lt;/command&gt; &lt;testo&gt;           Per visualizzare il colore del testo
  &lt;command&gt;uihi[lights]&lt;/command&gt; &lt;testo&gt; &lt;colore&gt;  Per associare un colore a un testo
  &lt;command&gt;uihi[lights]&lt;/command&gt; &lt;testo&gt; &lt;command&gt;remove&lt;/command&gt;    Per eliminare highlights associato al testo
  &lt;command&gt;uihi[lights] remove_all&lt;/command&gt;        Per eliminare gli aliases associati a tutti i pulsanti
Per un elenco completo dei colori disponibili, utilizzare il comando uicolors.
]]
--
ui.help.keybind = [[
&lt;title&gt;Tasti rapidi per aliases e target&lt;/title&gt;
E' possibile associare una combinazione di tasti a un alias o a un target con
il comando &lt;command&gt;uikeybind&lt;/command&gt;.
&lt;white&gt;Configurazione:&lt;reset&gt;
  &lt;command&gt;uik[eybind]&lt;/command&gt;                         Per visualizzare l'elenco dei tasti rapidi
  &lt;command&gt;uik[eybind]&lt;/command&gt; &lt;alias\target&gt;          Per visualizzare i tasti dell'alias\del target
  &lt;command&gt;uik[eybind]&lt;/command&gt; &lt;alias\target&gt; &lt;tasti&gt;  Per associare uun tasto all'alias\al target
  &lt;command&gt;uik[eybind]&lt;/command&gt; &lt;alias\target&gt; &lt;command&gt;remove&lt;/command&gt;   Per eliminare i tasti dell'alias\del target
  &lt;command&gt;uik[eybind] remove_all&lt;/command&gt;              Per eliminare tutti i tasti rapidi
I tasti utillizzabili sono i tasti funzione, i caratteri dell'alfabeto e i 
numeri, singolarmente oppure preceduti da CTRL, ALT o entrambi.
]]
--
ui.help.profile = [[
&lt;title&gt;Profili&lt;/title&gt;
Profili di configurazione.
&lt;white&gt;Configurazione:&lt;reset&gt;
  &lt;command&gt;uip[rofiles]&lt;/command&gt;                   Per visualizzare l'elenco dei disponibili
  &lt;command&gt;uip[rofiles] load&lt;/command&gt; &lt;profile&gt;    Per caricare un profile
  &lt;command&gt;uip[rofiles] merge&lt;/command&gt; &lt;profile&gt;   Per aggiungere i dati di un profilo (ignora i duplicati)
  &lt;command&gt;uip[rofiles] save&lt;/command&gt; &lt;profile&gt;    Per salvare i dati in uso su un profilo
  &lt;command&gt;uip[rofiles] remove&lt;/command&gt; &lt;profile&gt;  Per rimuovere un profilo
  &lt;command&gt;uip[rofiles] remove_all&lt;/command&gt;        Per eliminare tutti i profile
]]
--
ui.help.target = [[
&lt;title&gt;Target (g0..g9, o0, t1..t4)&lt;/title&gt;
La variable &lt;varName&gt;target&lt;/varName&gt; è una variabile predefinita dell'UI di Lumen et Umbra che è
possibile impostare in modi differenti. Oltre ad essere trattata come una 
variabile gestibile dal comando &lt;command&gt;uivariables&lt;/command&gt; è possibile impostarla utilizzando
o i 4 tasti target (t1, t2, t3 e t4), oppure cliccando sul riquadro del nemico
attualmente ingaggiato (o0) o ancora cliccando su uno dei componenti del gruppo
di gioco (g0 .. g9).
I tasti T1..T4 sono configurabili, mentre O0 e G0..G9 sono preimpostati in base
all'avversario ingaggiato e la composizione dale gruppo (l'ultima aggiornata 
con il comando &lt;white&gt;group&lt;reset&gt;.
&lt;white&gt;Configurazione:&lt;reset&gt;
  &lt;command&gt;t1..4&lt;/command&gt; &lt;valore&gt;        Per assegnare un valore a T1..T4
  &lt;command&gt;t1..4 remove&lt;/command&gt;          Per rimuovere il valore aassegnato a T1..T4
&lt;white&gt;Utilizzo:&lt;reset&gt;
  &lt;g0..9&gt; o click             Per assegnare a &lt;varName&gt;target&lt;/varName&gt; un componente del gruppo
  &lt;0o&gt; o click                Per assegnare a &lt;varName&gt;target&lt;/varName&gt; l'avversario ingaggiato
  &lt;t1..4&gt; o click             Per assegnare a &lt;varName&gt;target&lt;/varName&gt; il valore assegnato a t1..4
]]
--
ui.help.variable = [[
&lt;title&gt;Variabili&lt;/title&gt;
E' possibile definire delle variabili (retentive) da riutilizzare negli alias.
E' possibile richiamare una variabile all'interno di un alias facendo precedere
al nome della variabile il carattere speciale &lt;command&gt;@&lt;/command&gt;.
Alcune delle variabili sono già dichiarate (variabili predefinite), e vengno
utilizzate per gli elementi l'interfaccia.
Le variabili sono utlizzabili nel codice dei vostri script facendo accesso alla
tabella ui.variables[nomevariabile].
&lt;white&gt;Configurazione:&lt;reset&gt;
  &lt;command&gt;uiv[ariable]&lt;/command&gt;                        Per visualizzare l'elenco delle variabili
  &lt;command&gt;uiv[ariable]&lt;/command&gt; &lt;varName&gt;&lt;nome&gt;&lt;/varName&gt;                 Per visualizzare il valore di una variabile
  &lt;command&gt;uiv[ariable]&lt;/command&gt; &lt;varName&gt;&lt;nome&gt;&lt;/varName&gt; &lt;valore&gt;        Per creare o modificare una variabile
  &lt;command&gt;uiv[ariable]&lt;/command&gt; &lt;varName&gt;&lt;nome&gt;&lt;/varName&gt; &lt;command&gt;remove&lt;/command&gt;          Per rimuovere una variabile
  &lt;command&gt;uiv[ariable] remove_all&lt;/command&gt;             Per rimuovere tutte le variabili
]]
--
ui.help.walk = [[
&lt;title&gt;Walk, Speedwalk e Backwalk&lt;/title&gt;
Lumen et Umbra UI comprende uno strumento per la gestione dei movimenti del
personaggio. Tramite i comandi "&lt;command&gt;.&lt;/command&gt;" e "&lt;command&gt;..&lt;/command&gt;" è possibile percorrere lunghi
&lt;percorsi&gt; espressi, per esempio, nel formato "ee2w4suuu9n" oltre che 
ripercorrere i propri passi. 
&lt;white&gt;Utilizzo:&lt;reset&gt;
  &lt;command&gt;.&lt;/command&gt;&lt;percorso&gt;   Per eseguire il percorso specificato
  &lt;command&gt;..&lt;/command&gt;&lt;percorso&gt;  Per eseguire il percorso specificato all'indietro
  &lt;command&gt;.&lt;/command&gt;             Per ripercorere i propri passi (massimo 50 locazioni)
  &lt;command&gt;..&lt;/command&gt;            Per ripercorere i propri passi all'indietro (massimo 50 locazioni)
&lt;white&gt;Attenzione:&lt;reset&gt;
- Vengono memorizzate le direzioni inviate anche se il movimento nella locazione
non dovesse avvenire a causa di un ostacolo.
- Funziona solo con i comandi "d", "e", "n", "s", "u" e "w". 
- Non funziona con il comando "enter".
- Non funziona con il comando "run".
]]</script>
			<eventHandlerList />
		</Script>
		<Script isActive="yes" isFolder="no">
			<name>Init Widgets</name>
			<packageName></packageName>
			<script>--
-- GMCP
gmcp = gmcp or {}
gmcp.MSDP = gmcp.MSDP or {}
--
-- Load parameters
ui.fDebug("[init] Load 'Parameters' from file")
ui.parameters = ui.parameters or {}
if (io.exists(ui.fileParameters)) then
  table.load(ui.fileParameters, ui.parameters)
end
ui.parameters = table.update(ui.pre_defined_parameters, ui.parameters)
table.save(ui.fileParameters, ui.parameters)
--
-- Load variables
ui.fDebug("[init] Load 'Variables' from file")
ui.variables = ui.variables or {}
if (io.exists(ui.fileVariables)) then
  table.load(ui.fileVariables, ui.variables)
end
ui.variables = table.update(ui.pre_defined_variables, ui.variables)
table.save(ui.fileVariables, ui.variables)
ui.variables.opponent_health     = ""
ui.variables.opponent_health_max = ""
ui.variables.opponent_level      = ""
ui.variables.opponent_name       = ""
--
-- Load targets
ui.fDebug("[init] Load 'Targets' from file")
ui.targets = ui.targets or {}
if (io.exists(ui.fileTargets)) then
  table.load(ui.fileTargets, ui.targets)
else
  -- Update only if file targets not esist otherwise it would reassign any removed keys
  ui.targets = table.update(ui.pre_defined_target_buttons, ui.targets)
end
table.save(ui.fileTargets, ui.targets)
--
-- Load Aliases
ui.fDebug("[init] Load 'Aliases' from file")
ui.fReadFileAliases()
--
-- Load Highlights
ui.fDebug("[init] Load 'Highlights' from file")
ui.fReadFileHighlights()
--
-- Opponent
ui.fDebug("[init] Opponent")
ui.fInitOpponentWidget()
--
-- Group
ui.fDebug("[init] Group")
ui.fInitGroupWidget()
--
-- Target Buttons
ui.fDebug("[init] Target Buttons")
ui.fInitTargetButtonsWidget()
--
--  Opponent and Groups are also targets. Widgets needed before updating
ui.fUpdateAllTargetButton()
ui.fUpdateTarget()
ui.fUpdateOpponent()
ui.fUpdateGroup() 
--
-- Player
ui.fDebug("[init] Player")
ui.fInitPlayerWidget()
ui.fUpdatePlayer()
--
-- Alias Button
ui.fDebug("[init] Alias Buttons")
ui.fInitAliasButtonsWidget()
ui.fUpdateAllAliasButton()
--
-- Affects
ui.fDebug("[init] Affects")
ui.fInitAffectsWidget()
ui.fUpdateAffects()
--
-- Map/Compass
ui.fDebug("[init] Map/Compass")
ui.fInitMapCompassWidget()
ui.fUpdateMap()
--
-- Inventory
ui.fDebug("[init] Inventory")
ui.fInitInventoryWidget()
GUI.Inventory.Main.Body.Console:setFontSize(ui.parameters.fsInventory)
--
-- Equipment
ui.fDebug("[init] Equipment")
ui.fInitEquipmentWidget()
GUI.Equipment.Main.Body.Console:setFontSize(ui.parameters.fsEquipment)
--
-- Public
ui.fDebug("[init] Public Chat")
ui.fInitPublicChatWidget()
GUI.PublicChat.Main.Body.Console:setFontSize(ui.parameters.fsPublicChat)
--
-- Private
ui.fDebug("[init] Private Chat")
ui.fInitPrivateChatWidget()
GUI.PrivateChat.Main.Body.Console:setFontSize(ui.parameters.fsPrivateChat)
--
-- GMCP
ui.fDebug("[init] setMergeTables()")
setMergeTables("MSDP")
--
-- Events
ui.fDebug("[init] Register events")
registerAnonymousEventHandler("gmcp.MSDP","ui.fUpdateOpponent")
registerAnonymousEventHandler("gmcp.MSDP","ui.fUpdatePlayer")
--
-- Debug
if (ui.enDebug) then
  -- Tick simulation
  ui.fIncrementTickTimer(75)
end
--
ui.fDebug("[init] ... end UI init!")
--
ui.fEchon("&lt;orange&gt; - Lumen et Umbra UI v"..ui.release.." -&lt;white&gt; "..ui.fGetCommandFormattedText("uih[elp]").."&lt;white&gt; per iniziare.")</script>
			<eventHandlerList />
		</Script>
		<Script isActive="no" isFolder="no">
			<name>Note</name>
			<packageName></packageName>
			<script>--[[
ver [...in corso...]
------------
- Aggiunto @Target sul titolo della finestra Opponent
- Aggiunto evidenza grafica sulla quantità di hp persi o recuperati
- Aggiunto ora per ogni messaggio rivecuto nelle finestre dei messaggi
- Aggiunto ordinamento Alias per nome
- Aggiunto ordinamento Keybind per tasti di scelta rapida
- Aggiunto ordinamento effetti per durata
- Aggiunto protezione su stack overflow negli alias (profondità ricorsiva settata a 20 livelli di chiamate)
- Aggiunto comando uiR[eply] per rispondere velocemente all'ultimo messaggo privato ricevuto
- Aggiunto uscite speciali e specchi di Astral all'elenco delle uscite nella finestra Map/Compasss
- Aggiunto visualizzazione del percorso memorizzato nella finestra Map/Compass
- Aggiunto visualizzazione delle posizioni nella finestra Map/Compass
- Corretto bug minori
- Corretto bug sulla cancellazione delle finestre all'apertura dello script (dovuto al nome delle label che compongono il bordo)
- Corretto dimensione delle icone degli effetti
- Corretto help di uiSetFontSize
- Corretto script di esecuzione degli alias
- Corretto tooltip sulle icone degli effetti
- Corretto trigger equipment e loot (non funzionavano con la visiualizzazione della rarità degli oggetti spenta) 
- Corretto trigger specchi di Astral (alcune descrizione di specchi non facevano partire il trig) 
- Corretto visualizzazione dei messaggi contenenti caratteri speciali nelle finestre dei messaggi
- Corretto visualizzazzione dell'elenco degli alias con evidenza di Alias, Variabili, Testo, etc
- Corretto visualizzazione della direzione del track nella finestra Map/Compasss
- Corretta definizione dei componenti Geyser per ottimizzazione memoria (annidiati correttamente)
- Migliorato gestione keybind
- Migliorato visualizzazione degli effetti
- Migliorato visualizzazione dei bottoni alias
- Migliorato visualizzazione della finestra gruppo
- Sostituito costruttore dei componenti Geyser da new() a new2()
- Sostituito nomi funzioni appartenenti all'UI (aggiunta desinenza "ui.f")
- Sostituite UserWindows con AdjustableContainer
--
In Corso:
- Gestione profili
--
ver 1.220210
------------
- cadidate release
--
ver 0.3b
--------
- Rimossa gestione dei tab\frame ereditata da CS.
- Rimossa gestine CCS ereditata da CS.
- Implementata gestione frame con Geyser.UserWindow.
- Sistemato il problema del riavvio obbligatorio di mudlet dopo l'installazione del pack 
- Nuova getione dell'ui.fHelp
--
ver 0.2b
--------
Alias buttons:
- I custom buttons sono diventati alias buttons
--
Comandi:
- Aggiunti comandi uiResizeL(h, w) e uiResizeR(h, w) per ridimensionare (o nascondere) le barre laterali
- Aggiunto comndo uiRepair per riparare automaticamente tutto l'equipaggiamento danneggiato
--
Interfaccia:
- Rivista procedura di inizializzazione (presenta ancora alcune discrepanze)
- Trasformati i box player, opponent, compass e group in widget che è possibile spostare, ridimensionare e nascondere
- Snellita gestione Affects
--
Target buttons (g0..g9)
- I componenti del gruppo sono diventati target selezionabili
--
Target buttons (o0)
- Il widget dell'avversario è diventato un target selezionabile
--
uiAlias:
- Nuova gestione con struttura semplificata
- Aggiunta la possibilità di eseguire tramite UiAlias, un altro uiAlias o un alias definito in Mudlet.
  Possibilità di esecuzione di codice lua chiamando la funzione lua() nel pattern dell'uiAlias 
  Attenzione: può creare ricorsione incontrollata (stack overwlow)
- Aggiunta la possibilità di associare una combinazione di tasti all'uiAlias
--
uiHighlights:
- Nuova gestione con struttura semplificata
- Definizione per nome (invece che per numero)
- Riconoscimento per parola intera
- Riconoscimento non più sensibili alle maiuscole\minuscole
--
uiKeybind:
- Nuova gestione: keibind associati a target e alias
--
uiSpeedWalk
- Memorizza lo storico della strada percorsa e permette di ripercorrela indeitro con il comando "..", e poi dinuovo in avanti con il comendo "."
--
ver 0.1b
--------
- primo rilascio
]]</script>
			<eventHandlerList />
		</Script>
	</ScriptPackage>
	<KeyPackage>
		<KeyGroup isActive="yes" isFolder="yes">
			<name>Keypad</name>
			<packageName></packageName>
			<script></script>
			<command></command>
			<keyCode>-1</keyCode>
			<keyModifier>0</keyModifier>
			<KeyGroup isActive="yes" isFolder="yes">
				<name>Movement (keypad)</name>
				<packageName></packageName>
				<script></script>
				<command></command>
				<keyCode>-1</keyCode>
				<keyModifier>0</keyModifier>
				<Key isActive="yes" isFolder="no">
					<name>keypad 2 (south)</name>
					<packageName></packageName>
					<script></script>
					<command>s</command>
					<keyCode>50</keyCode>
					<keyModifier>536870912</keyModifier>
				</Key>
				<Key isActive="yes" isFolder="no">
					<name>keypad 4 (west)</name>
					<packageName></packageName>
					<script></script>
					<command>w</command>
					<keyCode>52</keyCode>
					<keyModifier>536870912</keyModifier>
				</Key>
				<Key isActive="yes" isFolder="no">
					<name>keypad 3 (down)</name>
					<packageName></packageName>
					<script></script>
					<command>d</command>
					<keyCode>49</keyCode>
					<keyModifier>536870912</keyModifier>
				</Key>
				<Key isActive="yes" isFolder="no">
					<name>keypad 6 (east)</name>
					<packageName></packageName>
					<script></script>
					<command>e</command>
					<keyCode>54</keyCode>
					<keyModifier>536870912</keyModifier>
				</Key>
				<Key isActive="yes" isFolder="no">
					<name>keypad 8 (north)</name>
					<packageName></packageName>
					<script></script>
					<command>n</command>
					<keyCode>56</keyCode>
					<keyModifier>536870912</keyModifier>
				</Key>
				<Key isActive="yes" isFolder="no">
					<name>keypad 9 (up)</name>
					<packageName></packageName>
					<script></script>
					<command>u</command>
					<keyCode>57</keyCode>
					<keyModifier>536870912</keyModifier>
				</Key>
			</KeyGroup>
		</KeyGroup>
	</KeyPackage>
	<VariablePackage>
		<HiddenVariables />
	</VariablePackage>
</MudletPackage>
